<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>elgong&#39;s Home.</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.elgong.top/"/>
  <updated>2019-01-24T07:14:02.377Z</updated>
  <id>http://www.elgong.top/</id>
  
  <author>
    <name>elgong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Network in Network</title>
    <link href="http://www.elgong.top/2019/01/24/Network-in-Network/"/>
    <id>http://www.elgong.top/2019/01/24/Network-in-Network/</id>
    <published>2019-01-24T07:08:27.000Z</published>
    <updated>2019-01-24T07:14:02.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Network-in-network-（NIN）"><a href="#Network-in-network-（NIN）" class="headerlink" title="Network in network （NIN）"></a>Network in network （NIN）</h1><p><code>2014年</code> 论文地址：  <a href="https://arxiv.org/abs/1312.4400" title="论文地址" target="_blank" rel="noopener">https://arxiv.org/abs/1312.4400</a></p><h2 id="论文核心"><a href="#论文核心" class="headerlink" title="论文核心"></a>论文核心</h2><p>NIN特点: </p><ul><li><p>微型网络: </p><ul><li>增强模型在感受野（receptive field）内对局部区域的辨别能力;  </li></ul></li></ul><ul><li>GAP全局平均池化: <ul><li>强化了特征图与分类的对应关系;</li><li>GAP本身是结构化的正则化器，能避免整体结构的过拟合；</li></ul></li></ul><blockquote><p>　　卷积层使用线性滤波器（卷积核）来扫描输入，后面接一个非线性激活函数。而卷积核是广义线性模型（generalized linear model ）GLM，抽象程度低（该特征对同一概念的变体是不变的）,用更有效的 <code>非线性函数逼近器</code> 代替 <code>GLM</code> 可以增强局部模型的抽象能力。当样本的隐含概念（latent concept）线性可分时，GLM可以达到很好的抽象程度，例如：这些概念的变体都在GLM分割平面的同一边，而 &lt;font color=red 传统的CNN就默认了这个假设——认为隐含概念（latent concept）是线性可分的。 然而，同一概念的数据通常是非线性流形的（nonlinear manifold），捕捉这些概念的表达通常都是输入的高维非线性函数。在NIN中，GLM用“微型网络”结构替代，该结构是一个<code>非线性函数逼近器</code>。  </p><p>　　本文作者选择多层感知器实例化微型网络，该感知器是一个通用函数逼近器，也是一个通过反向传播训练的神经网络。</p></blockquote><p><img src="/2019/01/24/Network-in-Network/nerworkInNetwork1.png" alt="logo"><br>该图是 单独的 <code>mlpconv 层</code></p><ul><li>这里有没有尝试过其他微型网络结构？？？？（可创新吗）</li><li><h2 id="NIN-网络结构"><a href="#NIN-网络结构" class="headerlink" title="NIN 网络结构"></a>NIN 网络结构</h2><img src="/2019/01/24/Network-in-Network/nerworkInNetwork2.png" alt="logo"></li></ul><p>　　NIN 的整体结构是一系列 <code>mlpconve层</code> 的堆叠，最上层接一个 <code>GAP层</code> 和 <code>分类层</code>。 <code>mlpconv层</code> 间的子层可以被相加，像CNN和maxout网络一样。上图展示了一个包含三个mlpconv层的NIN。每个mlpconv层，包含一个三层的感知器，NIN和微型网络的层数都是灵活的，可以根据具体任务微调。</p><p>　　这里没有采用传统CNN的 <code>全连接层</code> 进行分类，而是直接通过 <code>全局平均池化层（GAP）</code>输出最后一个 <code>mlpconv层特征图</code>的空间平均值作为类别的置信度值，然后将得到的向量输入 <code>softmax层</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Network-in-network-（NIN）&quot;&gt;&lt;a href=&quot;#Network-in-network-（NIN）&quot; class=&quot;headerlink&quot; title=&quot;Network in network （NIN）&quot;&gt;&lt;/a&gt;Network in net
      
    
    </summary>
    
      <category term="计算机视觉论文阅读" scheme="http://www.elgong.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="深度学习论文" scheme="http://www.elgong.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>C++梳理笔记</title>
    <link href="http://www.elgong.top/2019/01/20/C-%E6%A2%B3%E7%90%86%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.elgong.top/2019/01/20/C-梳理笔记/</id>
    <published>2019-01-20T12:30:39.000Z</published>
    <updated>2019-01-24T05:11:28.465Z</updated>
    
    <content type="html"><![CDATA[<font color="red"><big>测试内容</big></font><p><del>删除线</del></p><p><a href="http://zhuzhuyule.xyz" target="_blank" rel="noopener">链接</a></p><p><img src="/2019/01/20/C-梳理笔记/test.jpg" alt="logo"></p><h1 id="C-学习笔记"><a href="#C-学习笔记" class="headerlink" title="C++学习笔记"></a>C++学习笔记</h1><h2 id="类型转换："><a href="#类型转换：" class="headerlink" title="类型转换："></a><strong>类型转换：</strong></h2><ol><li><p>隐式转换： 低类型转换为高类型</p><pre><code>浮点数（直接舍掉小数，不四舍五入） + 整数</code></pre></li><li><p>显式转换：</p><pre><code>int **(**z**) = (**int**)** z **= static_cast\&lt;**int**\&gt; (**z**)**</code></pre></li></ol><p>。。。</p><h3 id="数据的输入和输出：信息的流动"><a href="#数据的输入和输出：信息的流动" class="headerlink" title="数据的输入和输出：信息的流动"></a><strong>数据的输入和输出：信息的流动</strong></h3><ol><li><p>输入：</p></li><li><p>输出：</p></li><li><p>流类库的操纵符：</p></li></ol><h3 id="程序控制："><a href="#程序控制：" class="headerlink" title="程序控制："></a><strong>程序控制：</strong></h3><pre><code>if, while, for, do-while , break, continue, { switch,case,default } ;</code></pre><ol><li><p>do-while:</p><pre><code>do 语句      // 先执行一次while(表达式)；</code></pre></li><li><p>for的范围，遍历容器：</p></li></ol><h3 id="自定义类型："><a href="#自定义类型：" class="headerlink" title="自定义类型："></a><strong>自定义类型：</strong></h3><ul><li>类型别名： </li></ul><ol><li><p>typedef double Area, V;</p></li><li><p>using Area = double</p></li></ol><ul><li>枚举类型： 有限的个数</li></ul><p>　　　　不限定作用域： enum 类型名 { 变量值列表}</p><p>　　　　限定作用域：</p><p>　　　注：枚举元素是常量，不能赋值</p><p>　　　　　枚举元素有默认值，默认0,1,2,3,4，声明时可以另外指定</p><p>　　　　　可以进行关系运算</p><ul><li><p>auto类型 和decltyoe类型</p><pre><code>decltype( float( i )) j = 2;   // j值是2，类型是float;auto m = 2.5;  // m 为float;</code></pre></li><li><p>结构体( C语言中的)： struct</p><pre><code>struct MyTimeStruct{   //定义 结构体类型    unsigned int year,mouth,day,hour,min,sec;};</code></pre></li></ul><h2 id="函数：-可重用的功能模块（定义和调用）"><a href="#函数：-可重用的功能模块（定义和调用）" class="headerlink" title="函数： 可重用的功能模块（定义和调用）"></a><strong>函数： 可重用的功能模块（定义和调用）</strong></h2><h3 id="函数定义："><a href="#函数定义：" class="headerlink" title="函数定义："></a><strong>函数定义：</strong></h3><p>　　形参不占用空间，调用时分配；</p><h3 id="函数调用："><a href="#函数调用：" class="headerlink" title="函数调用："></a><strong>函数调用：</strong></h3><p>　　调用前要函数声明： int sum<strong>(</strong> int a<strong>,</strong> int b<strong>);</strong></p><p>　　1. 函数的嵌套调用：</p><p>　　2. 函数的递归调用： 直接或者间接调用自身</p><p>计算n!</p><pre><code>unsigned int fac( unsigned int n){    if (n == 0) return 1;    return fac( n - 1) * n;}</code></pre><p>汉诺塔</p><pre><code>分析：1.    A 上的n-1个盘子移动到B上（借助C）;2.    A上剩下的盘子移动到C上；3.    B上的n-1个盘子移动到C上（借助A）void move(char src, char obj){    cout &lt;&lt; src &lt;&lt; &quot;---&gt;&gt;&gt;&quot; &lt;&lt; obj &lt;&lt; endl;}void hanoi(int n, char src, char medium, char obj){    if(n == 1)        move(src, obj);    else{        hanoi(n-1, src, obj, medium);        move(src, obj);        hanoi(n-1, medium, src, obj);    }}</code></pre><h3 id="函数的参数："><a href="#函数的参数：" class="headerlink" title="函数的参数："></a><strong>函数的参数：</strong></h3><ol><li><p>形参不占用空间，调用时分配；</p></li><li><p>计算结果返回多个（利用引用）</p></li><li><p>多个参数时，从后开始传</p></li></ol><h3 id="引用类型（-amp-）：-必须初始化，该类型不可改变，是其他变量的别名"><a href="#引用类型（-amp-）：-必须初始化，该类型不可改变，是其他变量的别名" class="headerlink" title="引用类型（&amp;）： 必须初始化，该类型不可改变，是其他变量的别名"></a><strong>引用类型（&amp;）：</strong> 必须初始化，该类型不可改变，是其他变量的别名</h3><pre><code>int i, j;int &amp; ri = i;  // 定义int引用类型变量 ri, 初始化为i的引用</code></pre><h3 id="含有可变参数的函数：（两种方法）"><a href="#含有可变参数的函数：（两种方法）" class="headerlink" title="含有可变参数的函数：（两种方法）"></a><strong>含有可变参数的函数：（两种方法）</strong></h3><ol><li><p>所有实参类型相同：<code>initializer_list&lt;int&gt; li; //类模板, 都是常量</code></p></li><li><p>具体看第九章</p></li><li><p>类型不同：</p></li></ol><h3 id="内联函数（inline）：-用函数体内的语句，替换函数调用表达式，编译时完成，类似-define"><a href="#内联函数（inline）：-用函数体内的语句，替换函数调用表达式，编译时完成，类似-define" class="headerlink" title="内联函数（inline）： 用函数体内的语句，替换函数调用表达式，编译时完成，类似 #define"></a><strong>内联函数（inline）： </strong>用函数体内的语句，替换函数调用表达式，编译时完成，类似 #define</h3><p>声明： <code>inline int calArea(int a){  }</code></p><p>要求： 1. 不能有循环，switch语句 2. 定义在调用之前 3. 不能有异常接口声明</p><h3 id="constexpr-函数：（常量表达式函数）"><a href="#constexpr-函数：（常量表达式函数）" class="headerlink" title="constexpr 函数：（常量表达式函数）"></a>constexpr 函数：（常量表达式函数）</h3><h3 id="带默认参数的函数："><a href="#带默认参数的函数：" class="headerlink" title="带默认参数的函数："></a><strong>带默认参数的函数：</strong></h3><pre><code>int getVa(int length, int weight = 2)</code></pre><h3 id="函数的重载：（C-多态性的重要机制，编译过程中实现）"><a href="#函数的重载：（C-多态性的重要机制，编译过程中实现）" class="headerlink" title="函数的重载：（C++多态性的重要机制，编译过程中实现）"></a><strong>函数的重载：</strong>（C++多态性的重要机制，编译过程中实现）</h3><p>函数体同名，参数类型不同/参数个数不同</p><pre><code>int add(int x, int y);float add(float x, float y);float add(float x, float y, float z);</code></pre><h3 id="C-系统函数："><a href="#C-系统函数：" class="headerlink" title="C++系统函数："></a><strong>C++系统函数：</strong></h3><pre><code>#include &lt;cmath&gt;    |_    |_#include &lt;cstdlib&gt;    |_    |_#include &lt;cstdio&gt;    |_    |_#include &lt;ctime&gt;    |_    |_</code></pre><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a><strong>类和对象</strong></h2><p>类：构建对象的蓝图，</p><p>对象：由类创建，含有数据和方法</p><p>封装：对数据和操作数据的方法的组合绑定</p><p>继承：在已有类基础上，形成新的类</p><p>多态：</p><p>构造函数：定义对象时，通过构造函数初始化</p><p>析构函数：删除对象时，通过析构函数释放资源</p><h3 id="类和对象的定义："><a href="#类和对象的定义：" class="headerlink" title=" 类和对象的定义："></a><strong> 类和对象的定义：</strong></h3><p>定义类：</p><pre><code>class {  //类名称     public:        // 公有成员,外部接口    private:        // 私有成员    protected:        int hour = 0; // 类内初始化        // 保护型成员}</code></pre><p>注意：不指定类型，默认为私有；</p><h3 id="成员函数："><a href="#成员函数：" class="headerlink" title="成员函数："></a><strong>成员函数：</strong></h3><pre><code>|_ 内联成员函数： 类内声明或者inline关键字|_类外实现：void 类名称::成员函数名称（）{ }</code></pre><h3 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a><strong>构造函数：</strong></h3><ul><li><p>在创建对象时，自动调用来初始化数据</p></li><li><p>与类名相同</p></li><li><p>构造函数有初始化列表</p></li><li><p>格式 类名（string s, lei i）：s(初始值)，i(初始值){ }；</p></li></ul><h3 id="委托构造函数：一个构造函数-通过另一个构造函数-初始化"><a href="#委托构造函数：一个构造函数-通过另一个构造函数-初始化" class="headerlink" title="委托构造函数：一个构造函数 通过另一个构造函数 初始化"></a><strong>委托构造函数：</strong>一个构造函数 通过另一个构造函数 初始化</h3><h3 id="复制构造函数："><a href="#复制构造函数：" class="headerlink" title="复制构造函数："></a><strong>复制构造函数：</strong></h3><p>用途：</p><ul><li><p>用存在的对象 去初始化新对象 （通过引用旧的对象）</p></li><li><p>函数f的形参是类的对象，调用f时，将用实参对象初始化形参对象</p></li><li><p>函数g的返回值是类的对象，用return的对象来在主调函数中初始化一个无名对象</p></li></ul><h3 id="析构函数：生存期结束，删除清理工作，不能有return，不能有参数"><a href="#析构函数：生存期结束，删除清理工作，不能有return，不能有参数" class="headerlink" title="析构函数：生存期结束，删除清理工作，不能有return，不能有参数"></a><strong>析构函数：</strong>生存期结束，删除清理工作，不能有return，不能有参数</h3><pre><code>class 类名{public:    类名（形参）； // 构造函数    类名（const 类名&amp; 旧对象名）；  // 复制构造函数 =delete是不生成    ~ 类名（）；}</code></pre><blockquote><p>  注：未声明时，编译器自己生成一个默认的</p></blockquote><h3 id="前向引用声明：两个类相互引用时，某个类在引用之前就声明"><a href="#前向引用声明：两个类相互引用时，某个类在引用之前就声明" class="headerlink" title="前向引用声明：两个类相互引用时，某个类在引用之前就声明"></a><strong>前向引用声明：</strong>两个类相互引用时，某个类在引用之前就声明</h3><pre><code>class A;  //前向引用声明，只是一个标识符，不是万能的class B{public:    void A(B b);}class A{public：    void B（A a）;}</code></pre><h3 id="结构体：特殊的类，默认是公有的，可以有函数成员"><a href="#结构体：特殊的类，默认是公有的，可以有函数成员" class="headerlink" title="结构体：特殊的类，默认是公有的，可以有函数成员"></a><strong>结构体：</strong>特殊的类，默认是公有的，可以有函数成员</h3><pre><code>//公有成员    int a;protected:    int b;private:    int c;};</code></pre><h3 id="联合体："><a href="#联合体：" class="headerlink" title="联合体："></a><strong>联合体：</strong></h3><p>目的：存储空间的共用，成员不能同时有效，比如某人语文课成绩，只有一种可能；</p><pre><code>union Mark{ // 成绩的联合体， 只有一个成立    char grade;  //等级类的成绩    bool pass;  // 是否通过的成绩int percent;  //百分制成绩  }</code></pre><h3 id="枚举类："><a href="#枚举类：" class="headerlink" title="枚举类："></a><strong>枚举类：</strong></h3><p>enum class 枚举类型名： 底层类型（int）<strong>{</strong> 枚举列表 <strong>};</strong></p><pre><code>//默认 int</code></pre><p>优势：</p><ul><li><p>强制作用域 –必须在枚举类 枚举类型名：：枚举值，不同枚举类可以有同名值了</p></li><li><p>转换限制 –枚举对象不能与整型 隐式转换</p></li><li><p>底层类型 –可以指定</p></li></ul><h2 id="数据共享和保护："><a href="#数据共享和保护：" class="headerlink" title="数据共享和保护："></a><strong>数据共享和保护：</strong></h2><h3 id="作用域分类："><a href="#作用域分类：" class="headerlink" title="作用域分类："></a><strong>作用域分类：</strong></h3><p>函数原型作用域：</p><ul><li>形参的范围在（）内，所以不需要名字也行，int area( int );</li></ul><p>局部作用域</p><ul><li><p>函数{ }内</p></li><li><p>if、for、while { }内</p></li></ul><p>类作用域： 类外访问类的成员</p><ul><li><p>静态成员：通过 对象名.成员名 访问</p></li><li><p>非静态成员：</p></li><li><p>文件作用域</p></li><li><p>命名空间作用域： 10章</p></li></ul><h3 id="对象的生存期："><a href="#对象的生存期：" class="headerlink" title="对象的生存期："></a><strong>对象的生存期：</strong></h3><p>静态生存期： 整个程序结束后消失</p><ul><li>函数内的静态对象， 用static ，全局寿命，只局部可见</li></ul><p>动态生存期：</p><ul><li><p>离开作用域后消失</p></li><li><p>下次进函数重新生成对象</p></li></ul><h3 id="类的静态数据成员："><a href="#类的静态数据成员：" class="headerlink" title="类的静态数据成员："></a><strong>类的静态数据成员：</strong></h3><ul><li><p>static 声明</p></li><li><p>为该类所有对象共享，具有静态生存期</p></li><li><p>必须在类外定义和初始化，类内声明，用：：指明所属于的类</p></li></ul><p>比如记录 类产生了多少对象；opencv中的Mat对象好像用到了？？？？</p><pre><code>class base{       public :              static   int   _num;//声明   };   int  base::_num=0;  //真正定义  </code></pre><h3 id="类的友元："><a href="#类的友元：" class="headerlink" title="类的友元："></a><strong>类的友元：</strong></h3><ul><li><p>破坏数据封装和数据隐藏的机制</p></li><li><p>尽量不用</p></li></ul><h3 id="友元函数："><a href="#友元函数：" class="headerlink" title=" 友元函数："></a><strong> 友元函数：</strong></h3><ul><li><p>类声明中由关键字 friend 修饰说明的非成员函数</p></li><li><p>可以在其函数体内访问对象的private,protected成员</p></li><li><p>但必须通过对象名：：访问，函数参数为类的引用</p></li><li><h3 id="友元类："><a href="#友元类：" class="headerlink" title=" 友元类："></a><strong> 友元类：</strong></h3><pre><code>class A{    friend B;  public:    void display(){        count &lt;&lt; x &lt;&lt; enld;    }  private:    int x;}class B{  public:    void set(int i);    void display();  private:    A a;}void B::set(int i){    a.x = i;   // B类中改变 A类私有值}void B::display(){    a.display()}</code></pre></li></ul><h3 id="共享数据的保护："><a href="#共享数据的保护：" class="headerlink" title="共享数据的保护："></a><strong>共享数据的保护：</strong></h3><p>#<strong>常类型：</strong>const</p><p>常对象：必须初始化，不可更新</p><pre><code>class A{}A const a; // a是常对象</code></pre><p>常成员：(不可以放在构造函数体内复制，可以在初始化列表中)</p><pre><code>A：：A(int i):a(i){ }</code></pre><ul><li><p>常数据成员：const修饰的</p></li><li><p>静态常数据成员： static const int b;</p></li><li><p>常函数成员（用来处理常对象的函数）</p><ul><li><p>不更新对象的数据成员</p></li><li><p>声明和实现都带const</p></li></ul></li></ul><pre><code>class A{    void f（int a）const;}void A::f(int a) const{  }; // f是常对象函数, 处理常对象</code></pre><ul><li>常引用：不可更新</li></ul><p>　　　引用是双向传递的，避免修改原值的方法就是常引用；</p><pre><code>const A&amp; a;</code></pre><ul><li><p>常数组：</p></li><li><p>常指针：</p></li></ul><h3 id="多文件结构和预编译命令："><a href="#多文件结构和预编译命令：" class="headerlink" title="多文件结构和预编译命令："></a><strong>多文件结构和预编译命令：</strong></h3><ul><li><p>.h 系统使用</p></li><li><p>.hpp 个人使用(类的声明,函数的声明)</p></li><li><p>.cpp (类的实现，函数的实现)</p><p> <img src="/2019/01/20/C-梳理笔记/f5d645ed218d5fa3e753f771b72310fc.png" alt=""></p></li></ul><h3 id="外部变量："><a href="#外部变量：" class="headerlink" title="外部变量："></a><strong>外部变量：</strong></h3><p>文件作用域中定义的变量默认是外部变量，其他文件使用前，extern声明</p><p>将变量和函数限制在编译单元内：namespcae:</p><pre><code>namespace{ //匿名的命名空间，外部不可调用任何东西    int i;    void fun(){        i++;    }}</code></pre><h3 id="预编译命令："><a href="#预编译命令：" class="headerlink" title="预编译命令："></a><strong>预编译命令：</strong></h3><pre><code>#include&lt; &gt;  标准方式搜索，从系统目录include#include”” 先当前目录搜索，没有再标准搜索#define #undef 删除有#define的宏#if 表达式  // 条件编译指令---#else---#endif #ifndef 标识符---#else  ---#endif</code></pre><h2 id="数组，指针与字符串："><a href="#数组，指针与字符串：" class="headerlink" title="数组，指针与字符串："></a><strong>数组，指针与字符串：</strong></h2><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a><strong>数组：</strong></h3><p>定义： <code>int arr**[**m**][**n**]**…;</code></p><p>　　注：二维数组中 arr[1] 第二行首地址</p><h3 id="数组作为函数参数："><a href="#数组作为函数参数：" class="headerlink" title="数组作为函数参数："></a><strong>数组作为函数参数：</strong></h3><p>　　数组名做参数： 形参，实参都是数组名，传入的是地址</p><h3 id="对象数组："><a href="#对象数组：" class="headerlink" title="对象数组："></a><strong>对象数组：</strong></h3><p>　　定义：类名 数组名[对象元素个数]</p><p>　　访问：数组名[下标].成员名</p><h3 id="基于范围的for循环：c-11-自动遍历整个容器"><a href="#基于范围的for循环：c-11-自动遍历整个容器" class="headerlink" title="基于范围的for循环：c++11,自动遍历整个容器"></a><strong>基于范围的for循环：</strong>c++11,自动遍历整个容器</h3><pre><code>for( auto x : 容器){ } for( auto &amp;x : 容器){ }</code></pre><p>注意：</p><ul><li><p>auto &amp;x是元素引用，auto x是元素的副本</p></li><li><p>auto推导出的类型是容器中的值类型</p></li><li><p>：冒号后的表达式只执行一次</p></li></ul><h3 id="指针："><a href="#指针：" class="headerlink" title="指针："></a><strong>指针：</strong></h3><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义：</strong></h3><pre><code>static int i;static int * p = &amp;I;</code></pre><h3 id="指针的初始化和赋值："><a href="#指针的初始化和赋值：" class="headerlink" title="指针的初始化和赋值："></a><strong>指针的初始化和赋值：</strong></h3><h3 id="指针的算术运算，关系运算："><a href="#指针的算术运算，关系运算：" class="headerlink" title="指针的算术运算，关系运算："></a><strong>指针的算术运算，关系运算：</strong></h3><h3 id="指针数组："><a href="#指针数组：" class="headerlink" title="指针数组："></a><strong>指针数组：</strong></h3><pre><code>类名  *p[2];</code></pre><h3 id="指向数组的指针："><a href="#指向数组的指针：" class="headerlink" title="指向数组的指针："></a><strong>指向数组的指针：</strong></h3><pre><code>int **p; 指向二维数组的指针</code></pre><h3 id="指针与函数："><a href="#指针与函数：" class="headerlink" title="指针与函数："></a><strong>指针与函数：</strong></h3><ul><li><p>指针做参数：大批量数据提高效率</p></li><li><p>指针类型的函数：返回类型是指针</p><pre><code>int * function(int i){return 全局或者静态的 }；// 不能返回非静态局部变量</code></pre></li><li><p>指向函数的指针：实现函数回调的功能</p></li></ul><blockquote><p>  定义： 数据类型 (*f)(参数表);</p></blockquote><blockquote><p>  数据类型：返回值</p></blockquote><ul><li>对象指针：</li></ul><blockquote><p>  定义： 类名 *对象指针名 = &amp; 对象；</p></blockquote><blockquote><p>  访问对象： 对象指针名->成员名</p></blockquote><p>（*对象指针名）.成员名</p><ul><li><p>this 指针：成员函数的一个隐士参数，初始化为对象的地址，不可改变</p></li><li><p>隐含于类的每个非静态成员函数中</p></li><li><p>指出成员函数所操作的当前的对象</p></li><li><p>*this 是当前对象地址</p></li></ul><h3 id="动态内存分配："><a href="#动态内存分配：" class="headerlink" title="动态内存分配："></a><strong>动态内存分配：</strong></h3><p>new<strong> 类型名 </strong>(<strong>初始化列表</strong>) // 返回首字节地址</p><p>delete 指针p //p一直在，删除的只是p指向的对象申请的空间</p><p>动态数组：<br>new 类型名[数组长度]</p><p>delete[] 数组首地址p指针</p><h3 id="智能指针：C-11"><a href="#智能指针：C-11" class="headerlink" title="智能指针：C++11"></a><strong>智能指针：</strong>C++11</h3><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><strong>内存管理</strong></h3><ul><li><p>unique_ptr:</p><ul><li>不允许多个指针共享资源，标准库中move可以转移指针，但原来指针会失效</li></ul></li><li><p>shared_ptr:</p><ul><li>多指针共享</li></ul></li><li><p>weak_ptr:</p><ul><li>可复制共享</li></ul></li></ul><blockquote><p>  Vector对象：类模板</p></blockquote><p>优势：</p><ul><li><p>封装任何形式的动态数组，自动创建，删除</p></li><li><p>下标越界检查</p></li></ul><p>定义： vector &lt;元素类型&gt; object（长度）</p><ul><li><p><code>object.begin()  object.end()  object.size()</code></p></li><li><p>auto 遍历vector <code>for(auto e: object);</code></p></li></ul><h3 id="对象的复制和移动："><a href="#对象的复制和移动：" class="headerlink" title="对象的复制和移动："></a><strong>对象的复制和移动：</strong></h3><ul><li><p>浅层复制和深层复制：复制对象用到复制构造函数，默认的复制构造只传递了指针，两个变量指向同一块内存，释放其中一个，再释放第二个会出错；</p><ul><li><p>浅层：实现对象间数据一一对应的复制，但两个对象指向同一内存</p></li><li><p>深层：当对象成员是指针类型，应该对指针所指对象进行复制。</p></li></ul></li></ul><blockquote><p>  类名<strong>::</strong>类名<strong>(</strong>const 类名<strong>&amp;</strong> v<strong>){</strong></p></blockquote><blockquote><p>  size <strong>=</strong> v<strong>.</strong>size<strong>;</strong></p></blockquote><blockquote><p>  data_ptr <strong>= new</strong> Ponit<strong>[</strong>size<strong>];</strong></p></blockquote><blockquote><p>  <strong>for(</strong>int i<strong>=</strong>0<strong>;</strong> i <strong>\&lt;</strong> size<strong>; ++</strong>i<strong>){</strong></p></blockquote><blockquote><p>  data_ptr<strong>[</strong>i<strong>] =</strong> v<strong>.</strong>data_ptr<strong>[</strong>i<strong>];</strong></p></blockquote><blockquote><p>  <strong>}</strong></p></blockquote><blockquote><p>  <strong>}</strong></p></blockquote><ul><li><p>移动构造：C++11,省去了构造和删除临时对象的过程</p><p><img src="/2019/01/20/C-梳理笔记/8c3092d99bcdba78edeb2d8123270ffe.png" alt=""></p></li></ul><blockquote><p>  class_name<strong>(</strong>class_name <strong>&amp;&amp;</strong>old<strong>)::</strong>xptr<strong>(</strong>old<strong>.</strong>xptr<strong>){</strong></p></blockquote><blockquote><p>  n<strong>.</strong>xptr <strong>= NULL;</strong> // 原来的指针清空</p></blockquote><blockquote><p>  <strong>}</strong></p></blockquote><h3 id="C风格字符串：字符数组"><a href="#C风格字符串：字符数组" class="headerlink" title="C风格字符串：字符数组"></a><strong>C风格字符串：</strong>字符数组</h3><h3 id="string类："><a href="#string类：" class="headerlink" title="string类："></a><strong>string类：</strong></h3><p>常用构造函数：</p><ul><li><p>string(); //默认构造，长度为0</p><ul><li>string s1<strong>;</strong></li></ul></li><li><p>string(const char *s) //指针s所指向的字符串常量初始化该对象</p><pre><code>string s2 = “abc”;string(const string &amp;rhs) //复制构造函数string s3 = s2;</code></pre></li></ul><p>访问：下标访问</p><p>整行字符串的输入： cin 被空格隔开</p><p>getline(cin,s2); //包含#include\&lt;string></p><p>getline(cin,s2,’,’);</p><h2 id="继承和派生：-充分利用原有的"><a href="#继承和派生：-充分利用原有的" class="headerlink" title="继承和派生： 充分利用原有的"></a><strong>继承和派生：</strong> 充分利用原有的</h2><p>继承：保持已有类的特征来构造新类</p><p>派生：在已有类基础上新增自己的特性</p><p>基类：父类</p><p>派生类：子类</p><p>直接基类和间接基类</p><p>单继承：</p><pre><code>class 派生类名：继承方式 基类名{  //继承方式，    成员声明；//新增成员的声明}</code></pre><p>多继承：</p><pre><code>class 派生类名：继承方式1 基类1，继承方式2 基类2{    成员声明；}</code></pre><h3 id="继承的方式："><a href="#继承的方式：" class="headerlink" title="继承的方式："></a><strong>继承的方式：</strong></h3><p>控制：派生类对基类成员的访问权限</p><ul><li>公有继承 public</li></ul><blockquote><p>  基类中的pubilc和protected访问属性在派生类中不变</p></blockquote><blockquote><p>  基类的pravate不可被对象直接访问</p></blockquote><ul><li><p>私有继承 ：内部可以访问基类的公有和保护成员，但是其对象不再可以访问</p></li><li><p>保护继承 ：基类的公有和保护，到这都成了保护成员，类内可以访问，但对象不能</p></li></ul><p>派生类的构成：</p><ul><li><p>吸收基类成员</p></li><li><p>改造基类成员</p><ul><li>增加同名成员，基类成员被覆盖（重新定义继承的成员函数必须用虚函数）</li></ul></li><li><p>添加新成员</p></li></ul><h3 id="类型转换：-1"><a href="#类型转换：-1" class="headerlink" title="类型转换："></a><strong>类型转换：</strong></h3><p>基类和派生类之间：</p><p>派生类的对象可以隐含转换为基类对象；</p><p>派生类的对象可以初始化基类的引用；</p><p>派生类的指针可以隐含转换为基类的指针；</p><h3 id="派生类的构造函数："><a href="#派生类的构造函数：" class="headerlink" title="派生类的构造函数："></a><strong>派生类的构造函数：</strong></h3><p>默认情况下，基类的构造函数不被继承，派生类需要自己构造</p><p>c++11，using语句继承基类构造函数</p><h3 id="派生类的复制构造函数："><a href="#派生类的复制构造函数：" class="headerlink" title="派生类的复制构造函数："></a><strong>派生类的复制构造函数：</strong></h3><h3 id="派生类的析构函数："><a href="#派生类的析构函数：" class="headerlink" title="派生类的析构函数："></a><strong>派生类的析构函数：</strong></h3><h3 id="虚基类："><a href="#虚基类：" class="headerlink" title="虚基类："></a><strong>虚基类：</strong></h3><h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a><strong>多态性</strong></h2><h3 id="运算符重载："><a href="#运算符重载：" class="headerlink" title="运算符重载："></a><strong>运算符重载：</strong></h3><pre><code>//双目运算符函数类型 operator 运算符（参数）  {    // 参数个数 = 原操作数个数 - 1}//前置单目运算符，返回引用所以可以当左值函数类型 &amp; operator ++（无参数）  {    return * this;}//后置单目运算符，函数类型 operator ++（参数为int类型）  {    old = *this;    ++(*this);  //调用的前置    return old;}</code></pre><ul><li>重载为非成员函数：</li></ul><ol><li><p>列出所有操作数</p></li><li><p>至少有一个自定义类型参数</p></li><li><p>后置单目运算，参数要增加int,但不用写形参名</p></li><li><p>要操作某类对象的私有成员，则可声明为该类的友元函数</p></li></ol><h3 id="虚函数：virtual改造基类成员，实现动态绑定；必须是非静态成员"><a href="#虚函数：virtual改造基类成员，实现动态绑定；必须是非静态成员" class="headerlink" title="虚函数：virtual改造基类成员，实现动态绑定；必须是非静态成员"></a><strong>虚函数：</strong>virtual改造基类成员，实现动态绑定；必须是非静态成员</h3><blockquote><p>  原理：编译时先不确定和哪个类的成员对应，在程序运行时刻，再对应；</p></blockquote><pre><code>#include &lt;iostream&gt;using namespace std;class Base1{public:    virtual void display() const; //虚函数，不要用内联};void Base1::display() const{    cout &lt;&lt; &quot;Base1 &quot; &lt;&lt; endl;}class Base2:public Base1{public:    virtual void display() const;}void Base2::display() const{    cout &lt;&lt; &quot;Base2&quot; &lt;&lt; endl;}</code></pre><h3 id="虚析构函数：打算通过基类指针调用某一个对象的析构函数（执行delete）"><a href="#虚析构函数：打算通过基类指针调用某一个对象的析构函数（执行delete）" class="headerlink" title="虚析构函数：打算通过基类指针调用某一个对象的析构函数（执行delete）"></a><strong>虚析构函数：</strong>打算通过基类指针调用某一个对象的析构函数（执行delete）</h3><h3 id="虚表和动态绑定："><a href="#虚表和动态绑定：" class="headerlink" title="虚表和动态绑定："></a><strong>虚表和动态绑定：</strong></h3><blockquote><p>  虚表：</p></blockquote><ul><li><p>每个多态类都有虚表；</p></li><li><p>存放各个数函数的入口地址；</p></li><li><p>每个对象有指向当前类的虚表的指针（虚指针vptr）；</p></li></ul><blockquote><p>  动态绑定：</p></blockquote><ul><li>构造函数为对象的虚指针赋值</li></ul><h3 id="抽象类：含有纯虚函数的类-不能直接定义对象"><a href="#抽象类：含有纯虚函数的类-不能直接定义对象" class="headerlink" title="抽象类：含有纯虚函数的类,不能直接定义对象"></a><strong>抽象类：</strong>含有纯虚函数的类,不能直接定义对象</h3><blockquote><p>  纯虚函数：</p></blockquote><blockquote><p>  基类中声明的虚函数，在基类中没有定义具体的操作，要求在派生类中根据实际需求完</p></blockquote><blockquote><p>  成自己的版本：</p></blockquote><pre><code>virtual 函数类型 函数名**(**参数名**) =** 0**;**</code></pre><h3 id="override-和-final-C-11"><a href="#override-和-final-C-11" class="headerlink" title="override 和 final :C++11"></a><strong>override 和 final :</strong>C++11</h3><p>override声明的函数，必须在基类中找到原型；</p><p>final 不允许继承或者覆盖；</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a><strong>模板</strong></h2><h3 id="函数魔板：整数和浮点数求绝对值，需要多次重载函数，但是用函数模板，只需要设计通用功能；"><a href="#函数魔板：整数和浮点数求绝对值，需要多次重载函数，但是用函数模板，只需要设计通用功能；" class="headerlink" title="函数魔板：整数和浮点数求绝对值，需要多次重载函数，但是用函数模板，只需要设计通用功能；"></a><strong>函数魔板：</strong>整数和浮点数求绝对值，需要多次重载函数，但是用函数模板，只需要设计通用功能；</h3><p>template\&lt;模板参数表> // 类型：class或者typename 常量：</p><p>函数定义</p><pre><code>template&lt;typename T&gt;T abs(T x){    return x&lt;0?-x:x;}</code></pre><h3 id="类模板："><a href="#类模板：" class="headerlink" title="类模板："></a><strong>类模板：</strong></h3><pre><code>template&lt;模板参数表&gt;class 类名{    类成员声明;}//类成员定义template &lt;模板参数表&gt;类型名  类名&lt;模板参数标识符列表&gt; :: 函数名(参数表){}</code></pre><h3 id="线性群体：按位置顺序有序排列"><a href="#线性群体：按位置顺序有序排列" class="headerlink" title="线性群体：按位置顺序有序排列"></a><strong>线性群体：</strong>按位置顺序有序排列</h3><p>直接访问：</p><p>数组类模板：</p><p>索引访问：</p><p>顺序访问：</p><p>链表类和结点类模板：</p><p>单链表：每个结点包括数据和指针，只有一个指向后续结点的称为单链表；</p><p><img src="/2019/01/20/C-梳理笔记/9167a427f849e864c5d630d0c0bc3163.png" alt=""></p><p>单链表结点类模板：</p><pre><code>template &lt;class T&gt;class Node{    private:        Node&lt;T&gt; *next;    public:        T data;         Node(const T&amp;item,Node&lt;T&gt;* next = 0);  //构造函数    void insertAfter(Node&lt;T&gt; *p); //插入    Node&lt;T&gt; *deleteAfter();  //删除    Node&lt;T&gt; *nextNode() const; }template &lt;class T&gt;void Node&lt;T&gt;::insertAfter(Node&lt;T&gt; *p){  // *p是要插入的结点// p节点的指针指向当前节点的后续结点    p-&gt;next = next; // next是原链表待插入位置的结点的指针    next = p;  }template &lt;class T&gt;Node&lt;T&gt; *deleteAfter(){    Node&lt;T&gt; * tempPtr = next;    if (next == NULL)  //判断是否是删除最后的元素        return 0;    next = tempPtr = next;    return tempPtr;}</code></pre><blockquote><p>  插入：</p></blockquote><p><img src="/2019/01/20/C-梳理笔记/85d072d9c8a8366378b00b9af8ca4920.png" alt=""></p><blockquote><p>  头插法：可以当队列</p></blockquote><blockquote><p>  尾插法：栈</p></blockquote><blockquote><p>  删除：</p></blockquote><p><img src="/2019/01/20/C-梳理笔记/ffdd5c0226d2a3f9a7833379eb0ebf90.png" alt=""></p><p>待查询：</p><p>explicit关键字</p><p>构造函数 explicit可以抑制内置类型隐式转换</p><h2 id="泛型设计"><a href="#泛型设计" class="headerlink" title="泛型设计"></a><strong>泛型设计</strong></h2><p>基本概念：</p><p>编写不依赖具体数据类型的程序，通用的；</p><p>STL简介：(Standard Template Library)</p><p>C++ string类库入门：</p><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(){    // 构造函数：    string str1 = &quot;Yesterday&quot;;    string str2(&quot;Today&quot;);    string str3(&quot;Hello&quot;,2); //取c风格字符串 长度为 2 作为初值，即&quot;He&quot;    string str4(str1, 6); // 始于位置6开始的字符串，即&quot;day&quot;    string str5(str1,6,1); // 始于6，长度1，即&quot;d&quot;    string str6(1,&apos;a&apos;); //6个&apos;a&apos;    // 赋值，交换    str1.assign(&quot;hahahaha&quot;); //重新赋值    swap(str1,str2); //交换两个字符串内容 str1=&quot;Today&quot; str2=&quot;hahahaha&quot;    // 追加    str1 += &quot; we&quot;; // += 可追加 string对象，字符串，字符    str1.append(&quot; ar&quot;); // append 可追加 string对象，字符串    str1.push_back(&apos;e&apos;); //push_back 只能追加字符 str1 = &quot;Today we are&quot;    // 插入    str1.insert(0,&quot; family&quot;); //str1 = &quot;Today we are family&quot;    // 删除    str1.erase(2,1); //第2个位置开始， len = 1 个字符    str1.clear(); //删除全部    // 访问字符串    string s = &quot;asdfgh&quot;;    cout &lt;&lt; s[1]; // &apos;s&apos;    cout &lt;&lt; s.at(2); // &apos;d&apos;    // 查找    int position = s.find(&apos;f&apos;,0); // 从0开始查找第一次出现‘f’的坐标    // 替换    s.replace(s.find(&apos;f&apos;),3,&quot;ZZZ&quot;); //替换find的位置处    3个字符串为 “ZZZ”    // 分割    getchar();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font color=&quot;red&quot;&gt;&lt;big&gt;测试内容&lt;/big&gt;&lt;/font&gt;


&lt;p&gt;&lt;del&gt;删除线&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://zhuzhuyule.xyz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接&lt;/a&gt;&lt;/p
      
    
    </summary>
    
      <category term="C++" scheme="http://www.elgong.top/categories/C/"/>
    
    
      <category term="C++" scheme="http://www.elgong.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>333</title>
    <link href="http://www.elgong.top/2019/01/18/333/"/>
    <id>http://www.elgong.top/2019/01/18/333/</id>
    <published>2019-01-18T07:25:41.000Z</published>
    <updated>2019-01-18T07:25:52.646Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/01/18/333/test.jpg" alt="logo"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2019/01/18/333/test.jpg&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图片测试！</title>
    <link href="http://www.elgong.top/2019/01/18/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95%EF%BC%81/"/>
    <id>http://www.elgong.top/2019/01/18/图片测试！/</id>
    <published>2019-01-18T07:11:41.000Z</published>
    <updated>2019-01-18T07:17:20.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="测试图片"><a href="#测试图片" class="headerlink" title="测试图片"></a>测试图片</h1><p><img src="/2019/01/18/图片测试！/test.jpg" alt="logo"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;测试图片&quot;&gt;&lt;a href=&quot;#测试图片&quot; class=&quot;headerlink&quot; title=&quot;测试图片&quot;&gt;&lt;/a&gt;测试图片&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/01/18/图片测试！/test.jpg&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="闲聊" scheme="http://www.elgong.top/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="http://www.elgong.top/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>欢迎来我的小屋！</title>
    <link href="http://www.elgong.top/2019/01/18/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E6%88%91%E7%9A%84%E5%B0%8F%E5%B1%8B%EF%BC%81/"/>
    <id>http://www.elgong.top/2019/01/18/欢迎来我的小屋！/</id>
    <published>2019-01-18T06:54:22.000Z</published>
    <updated>2019-01-18T06:57:47.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈哈"><a href="#哈哈" class="headerlink" title="哈哈"></a>哈哈</h1><h2 id="试试效果"><a href="#试试效果" class="headerlink" title="试试效果"></a>试试效果</h2><blockquote><p>一直想建一个自己的网站</p></blockquote><pre><code>现在先试试这个</code></pre><ul><li></li></ul><ol><li>aa</li><li>bb</li><li>cc</li><li>dd</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哈哈&quot;&gt;&lt;a href=&quot;#哈哈&quot; class=&quot;headerlink&quot; title=&quot;哈哈&quot;&gt;&lt;/a&gt;哈哈&lt;/h1&gt;&lt;h2 id=&quot;试试效果&quot;&gt;&lt;a href=&quot;#试试效果&quot; class=&quot;headerlink&quot; title=&quot;试试效果&quot;&gt;&lt;/a&gt;试试效果&lt;/h
      
    
    </summary>
    
      <category term="闲聊" scheme="http://www.elgong.top/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="http://www.elgong.top/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
</feed>
