<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>elgong&#39;s Home.</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.elgong.top/"/>
  <updated>2019-07-25T01:55:50.668Z</updated>
  <id>http://www.elgong.top/</id>
  
  <author>
    <name>elgong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pandas-行列操作</title>
    <link href="http://www.elgong.top/2019/07/25/pandas-%E8%A1%8C%E5%88%97%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.elgong.top/2019/07/25/pandas-行列操作/</id>
    <published>2019-07-24T23:01:01.000Z</published>
    <updated>2019-07-25T01:55:50.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pandas-行列操作"><a href="#pandas-行列操作" class="headerlink" title="pandas-行列操作"></a>pandas-行列操作</h1><blockquote><p>对于一种数据结构,最基本的操作就应该是增删改查了。</p></blockquote><h2 id="1-行列选择"><a href="#1-行列选择" class="headerlink" title="1. 行列选择"></a>1. 行列选择</h2><p>行选择和列选择有许多方法，很容易记混，常用的要记住。</p><h3 id="行选择"><a href="#行选择" class="headerlink" title="行选择"></a>行选择</h3><ul><li><p>切片  <code>df[a:b]</code></p></li><li><p>索引</p><p><code>df.iloc[a:b]</code></p><p><code>df.iloc[a:b][&#39;Price&#39;]</code></p></li><li><p>指定位置</p><p><code>df.loc[a:b]</code></p></li><li><p>按照条件查找</p><p><code>df[( df[&quot;row2&quot;] == 1) &amp; (df[&quot;row2&quot;] == &quot;null&quot;)]</code></p><p><code>df.loc[( df[&quot;row2&quot;] == 1) &amp; (df[&quot;row2&quot;] == &quot;null&quot;)]</code></p></li></ul><h3 id="列选择"><a href="#列选择" class="headerlink" title="列选择"></a>列选择</h3><ul><li><p>通过列标签选择单列</p><p>  <code>df[&quot;price&quot;]</code></p></li><li><p>通过列标签选择多列</p><p> <code>fprice&quot;, &quot;time&quot;]]</code></p></li><li><p>通过列索引,选择前3列</p><p><code>df.iloc[:, :3]</code> </p></li></ul><h3 id="行列选择"><a href="#行列选择" class="headerlink" title="行列选择"></a>行列选择</h3><p>  <code>df.loc[1:3,[&quot;price&quot;]]</code></p><p>  <code>df.iloc[a:b][&#39;Price&#39;]</code></p><h2 id="2-行的增删改查"><a href="#2-行的增删改查" class="headerlink" title="2. 行的增删改查"></a>2. 行的增删改查</h2><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><blockquote><p>单列</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 末尾增加</span><br><span class="line">   df[&quot;new col&quot;] = None</span><br><span class="line">   </span><br><span class="line">// 指定位置增加，在2列后</span><br><span class="line">   df.insert(2,&apos;city&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>多列</p></blockquote><p>   <code>pd.concat([df, pd.DataFrame(columns=[&quot;C&quot;,&quot;D&quot;])])</code></p><blockquote><p>单行（待验证）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// loc 添加</span><br><span class="line">  df.loc[‘5‘] = [3, 3, 3, 3]</span><br><span class="line">    </span><br><span class="line">// set_value 添加</span><br><span class="line">  df.set_value(‘5‘, df.columns, [3,3,3,3], takeable=False)</span><br></pre></td></tr></table></figure><blockquote><p>多行</p></blockquote><p>多行相当于合并两张表了,可以参考(merge,concat)<a href="https://note.youdao.com/" target="_blank" rel="noopener">方法</a>。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><blockquote><p>列</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// del 方法</span><br><span class="line">   def df[&quot;col_name&quot;]</span><br><span class="line"></span><br><span class="line">//根据列名 drop 方法</span><br><span class="line">   df.drop([&quot;b&quot;, &quot;c&quot;], axis=1,inplace = True)</span><br><span class="line">axis = 1 列</span><br><span class="line">axis = 0 行</span><br><span class="line"></span><br><span class="line">// 根据列号 drop 方法</span><br><span class="line">   df.drop(df.columns[[1,2]], axis=1, inplace=True)</span><br></pre></td></tr></table></figure><blockquote><p>行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 根据索引 删除行</span><br><span class="line">   df = df.drop([1, 2])</span><br><span class="line"></span><br><span class="line">// 根据value 删除行</span><br><span class="line">   df = df[~df[&quot;col&quot;].isin(5,9)</span><br></pre></td></tr></table></figure><h3 id="修改与查找"><a href="#修改与查找" class="headerlink" title="修改与查找"></a>修改与查找</h3><blockquote><p>单值修改和查找时, 参考选择行列方法。</p><p>多值查找时，</p></blockquote><h4 id="按条件查找"><a href="#按条件查找" class="headerlink" title="按条件查找"></a>按条件查找</h4><p> <code>df_train[( df_train[&quot;row&quot;] == 1) &amp;( == &quot;null&quot;)]</code></p><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><blockquote><p>单个替换，inplace = True 覆盖源文件</p></blockquote><p>  <code>df.replace(to_replace, value, inplace = True)</code></p><blockquote><p>多值替换—-字典</p></blockquote><p>  <code>df.replace({&quot;A&quot;:&quot;B&quot;,  29:100})</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pandas-行列操作&quot;&gt;&lt;a href=&quot;#pandas-行列操作&quot; class=&quot;headerlink&quot; title=&quot;pandas-行列操作&quot;&gt;&lt;/a&gt;pandas-行列操作&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;对于一种数据结构,最基本的操作就应该是增删
      
    
    </summary>
    
      <category term="pandas系列教程" scheme="http://www.elgong.top/categories/pandas%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="pandas" scheme="http://www.elgong.top/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>pandas-数据结构</title>
    <link href="http://www.elgong.top/2019/07/22/pandas-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://www.elgong.top/2019/07/22/pandas-数据结构/</id>
    <published>2019-07-22T01:01:01.000Z</published>
    <updated>2019-07-25T01:56:34.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pandas-数据结构"><a href="#pandas-数据结构" class="headerlink" title="pandas 数据结构"></a>pandas 数据结构</h1><blockquote><p>pandas 基本操作都很简单，只是在刚开始学习的过程中，容易忘掉一些API，导致完成一些操作时，总会想着翻翻手册，这一系列博客，是对这些方法进行了梳理，可作为入门学习的参考材料。平时经常翻阅。</p></blockquote><p>“index” (axis=0, default), “columns” (axis=1)</p><h2 id="1-Series"><a href="#1-Series" class="headerlink" title="1. Series"></a>1. Series</h2><blockquote><p>Series 是一个带有 名称 和索引的一维数组。</p></blockquote><h3 id="创建seriex"><a href="#创建seriex" class="headerlink" title="创建seriex"></a>创建seriex</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// Series 数组生成，指定数据类型</span><br><span class="line">In:   </span><br><span class="line">    user_age = pd.Series(data=[18, 30, 25, 40], dtype=float)</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">        0    18</span><br><span class="line">        1    30</span><br><span class="line">        2    25</span><br><span class="line">        3    40</span><br><span class="line">        dtype: int64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 增加索引 index</span><br><span class="line">In:   </span><br><span class="line">    user_age.index = [&quot;Tom&quot;, &quot;Bob&quot;, &quot;Mary&quot;, &quot;James&quot;]</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">    Tom      18</span><br><span class="line">    Bob      30</span><br><span class="line">    Mary     25</span><br><span class="line">    James    40</span><br><span class="line">    dtype: int64</span><br><span class="line">    </span><br><span class="line">// 表头</span><br><span class="line">In:</span><br><span class="line">    user_age.index.name(&quot;name&quot;)</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">    name</span><br><span class="line">    Tom      18</span><br><span class="line">    Bob      30</span><br><span class="line">    Mary     25</span><br><span class="line">    James    40</span><br><span class="line">    dtype: int64</span><br></pre></td></tr></table></figure><h3 id="像字典一样使用series"><a href="#像字典一样使用series" class="headerlink" title="像字典一样使用series"></a>像字典一样使用series</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// index 当键值</span><br><span class="line">In: </span><br><span class="line">    user_age[&quot;Tom&quot;]</span><br><span class="line">    user_age.get(&quot;Tom&quot;)</span><br><span class="line"></span><br><span class="line">// 切片-列</span><br><span class="line">In:</span><br><span class="line">    user_age[2:3]</span><br><span class="line">    </span><br><span class="line">// 按条件查找</span><br><span class="line">In:</span><br><span class="line">    user_age[user_age &gt; 30]</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">    name</span><br><span class="line">    James    40.0</span><br><span class="line">    Name: user_age_info, dtype: float64</span><br></pre></td></tr></table></figure><h3 id="像向量一样使用series"><a href="#像向量一样使用series" class="headerlink" title="像向量一样使用series"></a>像向量一样使用series</h3><blockquote><p>可以传递给np方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 整列加减</span><br><span class="line">In:</span><br><span class="line">    user_age + 1</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">    name</span><br><span class="line">    Tom      19.0</span><br><span class="line">    Bob      31.0</span><br><span class="line">    Mary     26.0</span><br><span class="line">    James    41.0</span><br><span class="line">    Name: user_age_info, dtype: float64</span><br></pre></td></tr></table></figure><h2 id="2-DataFrame"><a href="#2-DataFrame" class="headerlink" title="2. DataFrame"></a>2. DataFrame</h2><blockquote><p>DataFrame 是一个带有 名称 和索引的二维数组，像一张Excel表格。</p></blockquote><h3 id="创建DataFrame"><a href="#创建DataFrame" class="headerlink" title="创建DataFrame"></a>创建DataFrame</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// DataFrame 根据字典生成</span><br><span class="line"></span><br><span class="line">In:</span><br><span class="line">    index = pd.Index(data=[&quot;Tom&quot;, &quot;Bob&quot;, &quot;Mary&quot;, &quot;James&quot;], name=&quot;name&quot;)</span><br><span class="line">    </span><br><span class="line">    data = &#123;</span><br><span class="line">        &quot;age&quot;: [18, 30, 40],</span><br><span class="line">        &quot;city&quot;: [&quot;BeiJing&quot;, &quot;ShangHai&quot;, &quot;HangZhou&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    user_info = pd.DataFrame(data=data, index=index)</span><br><span class="line">    user_info</span><br><span class="line"></span><br><span class="line">Out:</span><br><span class="line">    </span><br><span class="line">// DataFrame 根据二维列表生成</span><br><span class="line">In:</span><br><span class="line">    data = [[18, &quot;BeiJing&quot;], </span><br><span class="line">            [30, &quot;ShangHai&quot;], </span><br><span class="line">            [25, &quot;GuangZhou&quot;], </span><br><span class="line">            [40, &quot;ShenZhen&quot;]]</span><br><span class="line">    columns = [&quot;age&quot;, &quot;city&quot;]</span><br><span class="line">    </span><br><span class="line">    user_info = pd.DataFrame(data=data, index=index, columns=columns)</span><br><span class="line">    user_info</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pandas-数据结构&quot;&gt;&lt;a href=&quot;#pandas-数据结构&quot; class=&quot;headerlink&quot; title=&quot;pandas 数据结构&quot;&gt;&lt;/a&gt;pandas 数据结构&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;pandas 基本操作都很简单，只是在刚开
      
    
    </summary>
    
      <category term="pandas系列教程" scheme="http://www.elgong.top/categories/pandas%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="pandas" scheme="http://www.elgong.top/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>评价指标 ROC与AUC</title>
    <link href="http://www.elgong.top/2019/07/20/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87-ROC%E4%B8%8EAUC/"/>
    <id>http://www.elgong.top/2019/07/20/评价指标-ROC与AUC/</id>
    <published>2019-07-20T07:10:00.000Z</published>
    <updated>2019-07-20T07:20:57.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="非均衡分类问题"><a href="#非均衡分类问题" class="headerlink" title="非均衡分类问题"></a>非均衡分类问题</h2><blockquote><p>非均衡分类问题指的是每个类别的错误代价不同。</p><p>比如疾病检测中,有病患者诊断健康的代价，要比健康人诊断成有病（可能性）造成的影响更为严重。</p><p>对于常用的预测模型，通常是有预测的概率值，我们找到一个合适的截断点作为正负类别的界限。显然再不同的任务下，截断点选择是不同的。我们使用Precison 和Recall的新度量指标来针对特定任务下选择合适的截断值。</p></blockquote><div class="table-container"><table><thead><tr><th>真实标签</th><th>预测为正</th><th>预测为反</th></tr></thead><tbody><tr><td>正例</td><td>TP</td><td>FN</td></tr><tr><td>反例</td><td>FP</td><td>TN</td></tr></tbody></table></div><ul><li>Precison(查准率)：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P = TP/(TP+FP)</span><br></pre></td></tr></table></figure><ul><li>Recall(召回率)：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R = TP/(TP+FN)</span><br></pre></td></tr></table></figure><blockquote><p>当正负样本不不均衡,人为修改测试集中的正负比例时, P-R曲线波动很大，但是ROC曲线变化很小。</p></blockquote><h2 id="ROC-曲线"><a href="#ROC-曲线" class="headerlink" title="ROC 曲线"></a>ROC 曲线</h2><blockquote><p>可以研究学习器的泛化性能。</p><h2 id="加图"><a href="#加图" class="headerlink" title="加图"></a>加图</h2><ul><li>横坐标：真阳率，正例被正确预测的概率</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FPR = FP/(TN+FP)</span><br></pre></td></tr></table></figure><ul><li>纵坐标：假阳率，负例被预测错误的概率<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TPR = TP/(TP+FN)</span><br></pre></td></tr></table></figure></li></ul><p><strong>==理解四点一线==</strong>：</p><ul><li>(0, 0):  FP = TP = 0, 所有样本预测为负</li><li>(1, 1):  FP = TP = 1, 所有样本预测为正</li><li>(1, 0):  FP = 1, TP = 0, 所有正样本预测为负</li><li>(0, 1):  FP = 0, TP = 1, 完美预测</li><li>对角线：随机猜测的值。</li></ul><h2 id="AUC值"><a href="#AUC值" class="headerlink" title="AUC值"></a>AUC值</h2><p>AUC(Area under Curve) 被定义为ROC曲线的下侧面积。一般在(0.5~1)之间。</p><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><ol><li><p>几何角度</p><blockquote><p>直接计算曲线下的面积，梯形</p></blockquote></li><li><p>概率角度</p><blockquote><p>任取一对正负样本对，正样本score大于负样本score的概率</p></blockquote></li></ol><h3 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h3><p><a href="http://zhuzhuyule.xyz" target="_blank" rel="noopener">链接</a></p><p><img src="/2019/07/20/评价指标-ROC与AUC/test.jpg" alt="logo"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;非均衡分类问题&quot;&gt;&lt;a href=&quot;#非均衡分类问题&quot; class=&quot;headerlink&quot; title=&quot;非均衡分类问题&quot;&gt;&lt;/a&gt;非均衡分类问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;非均衡分类问题指的是每个类别的错误代价不同。&lt;/p&gt;
&lt;p&gt;比如疾病检测中
      
    
    </summary>
    
      <category term="西瓜书笔记" scheme="http://www.elgong.top/categories/%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ROC" scheme="http://www.elgong.top/tags/ROC/"/>
    
  </entry>
  
  <entry>
    <title>集成学习-Adaboost</title>
    <link href="http://www.elgong.top/2019/06/25/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0-Adaboost/"/>
    <id>http://www.elgong.top/2019/06/25/集成学习-Adaboost/</id>
    <published>2019-06-25T10:57:01.000Z</published>
    <updated>2019-07-12T12:50:21.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Adaboost-算法原理及推导"><a href="#Adaboost-算法原理及推导" class="headerlink" title="Adaboost 算法原理及推导"></a>Adaboost 算法原理及推导</h1><blockquote><p>Adaboost 是Boosting算法的代表。Boosting可将许多弱学习器组合达到强学习器的效果。其主要的流程是：</p><ol><li>先训练一个基学习器；</li><li>根据基学习器的表现，改变样本的分布，使得错误分类的样本得到更多的关注；</li><li>改变分布后的样本再训练新的基学习器，如此迭代；</li><li>加权组合这些基学习器。</li></ol></blockquote><h2 id="一、Adaboost算法原理"><a href="#一、Adaboost算法原理" class="headerlink" title="一、Adaboost算法原理"></a>一、Adaboost算法原理</h2><blockquote><p>“Adaptive Boosting”（自适应增强）</p></blockquote><p>Adaboost算法中，每个样本有对应的权重D,每个基分类器也有对应的权重α，然后是下边的三步骤：</p><pre><code>Step1：初始化训练集的权重；</code></pre><blockquote><p>如果有N个样本，则每一个训练样本最开始时都被赋予相同的权重：1/N。</p></blockquote><pre><code>迭代：Step2： 改变样本分布，训练基学习器；</code></pre><blockquote><p>错分的样本权重D会增加；准确率高的分类器的权重α会更大；</p></blockquote><pre><code>Step3: 加权组合弱学习器。</code></pre><h2 id="二、Adaboost算法推导"><a href="#二、Adaboost算法推导" class="headerlink" title="二、Adaboost算法推导"></a>二、Adaboost算法推导</h2><p>给定训练集</p><script type="math/tex; mode=display">T=\{(x 1, y 1),(x 2, y 2) \ldots(\mathrm{xN}, y \mathrm{N})\}</script><p>其中，</p><script type="math/tex; mode=display">y_{i} \in\{-1,1\}</script><p>步骤1：初始化训练集的权重D。每个训练样本的初始权重w相同，均为1/N,</p><script type="math/tex; mode=display">D_{1}=\left(w_{11}, w_{12} \cdots w_{1 i} \cdots, w_{1 N}\right)</script><script type="math/tex; mode=display">w_{1 i}=\frac{1}{N}, i=1,2, \cdots, N</script><p>步骤2：训练基学习器，改变训练样本分布，迭代训练新的学习器。<br>用m=1,2…M 代表迭代的轮数，每轮产生的学习器为</p><script type="math/tex; mode=display">h_{m}(x)$$,- 计算学习器$$h_{m}(x) 在训练数据集上的分类错误率E_{t}（误差的权值和）：$$E_{t}=P\left(G_{m}(x) \neq y_{i}\right)</script><script type="math/tex; mode=display">=\sum_{i=1}^{N} w_{m i} I\left(G_{m}\left(x_{i}\right) \neq y_{i}\right)</script><ul><li>计算学习器<script type="math/tex">h_{m}(x)</script>的权重α：</li></ul><script type="math/tex; mode=display">\alpha_{m}=\frac{1}{2} \ln \frac{\left(1-E_{m}\right)}{E_{m}}</script><ul><li>更新训练集样本权重。</li></ul><script type="math/tex; mode=display">D_{m+1}=\left(w_{m+1,1}, w_{m+1,2} \cdots w_{m+1, i} \cdots, w_{m+1, N}\right)</script><script type="math/tex; mode=display">w_{m+1, i}=\frac{w_{m i}}{Z_{m}} \exp \left(-\alpha_{m} y_{i} G_{m}\left(x_{i}\right)\right), i=1,2, \cdots, N</script><ul><li>迭代训练学习器</li></ul><p>步骤3：加权组合弱学习器。</p><script type="math/tex; mode=display">f(x)=\sum_{m=1}^{M} \alpha_{m} h_{m}(x)</script><script type="math/tex; mode=display">H(x)=\operatorname{sign}(f(x))=\operatorname{sign}\left(\sum_{m=1}^{M} \alpha_{m} h_{m}(x)\right)</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Adaboost-算法原理及推导&quot;&gt;&lt;a href=&quot;#Adaboost-算法原理及推导&quot; class=&quot;headerlink&quot; title=&quot;Adaboost 算法原理及推导&quot;&gt;&lt;/a&gt;Adaboost 算法原理及推导&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;A
      
    
    </summary>
    
      <category term="西瓜书笔记" scheme="http://www.elgong.top/categories/%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="集成学习" scheme="http://www.elgong.top/tags/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>逻辑回归</title>
    <link href="http://www.elgong.top/2019/04/27/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <id>http://www.elgong.top/2019/04/27/逻辑回归/</id>
    <published>2019-04-27T05:01:43.000Z</published>
    <updated>2019-07-26T04:54:54.888Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>逻辑回归就是西瓜书里的对数几率回归，名为回归，实际则是分类算法。其实质是利用线性回归模型的预测结果来逼近真实标记的对数几率。</p><p>一句话概括就是:</p><font color="red"> 逻辑回归假设数据服从 **伯努利分布** ,通过 **极大化似然函数** 的方法，运用 **梯度下降** 来求解参数，来达到将数据二分类的目的。</font></blockquote><h2 id="线性模型如何处理二分类问题？"><a href="#线性模型如何处理二分类问题？" class="headerlink" title="线性模型如何处理二分类问题？"></a>线性模型如何处理二分类问题？</h2><blockquote><p>在处理二分类任务时，我们希望模型能预测样本属于某类别的概率[0, 1]，或者直接输出类别的标签{0, 1}。 线性模型不能直接来完成这项任务，因为其输出是一个实际值，范围也不一定在0~1之间，无法体现我们所想要的概率或者标签。</p></blockquote><script type="math/tex; mode=display">y=\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}+b</script><p>因此，我们需要找到一种能把线性模型输出映射到 <strong>概率</strong> 或者 <strong>标签</strong> 的方法；</p><ul><li><p>如何转化为标签？</p><p>  单位阶跃函数</p></li><li><p>如何转化为概率？</p><p>  sigmoid函数 (二分类): 将无穷范围的值限制在(0, 1)之间</p><p>  softmax函数（多分类）: 所有类别概率和为1</p></li></ul><p><img src="/2019/04/27/逻辑回归/sigmoid.png" alt="logo"></p><p>由于单位阶跃函数存在跳跃点，在跳跃点不可导，想选择梯度下降法来优化时，只能选择sigmoid函数了。</p><h2 id="逻辑回归模型"><a href="#逻辑回归模型" class="headerlink" title="逻辑回归模型"></a>逻辑回归模型</h2><blockquote><p>逻辑回归就是这样的一个过程：面对一个分类问题，建立代价函数，然后通过优化方<br>法迭代求解出最优的模型参数，然后测试验证我们这个求解的模型的好坏。</p></blockquote><h3 id="逻辑回归的优缺点"><a href="#逻辑回归的优缺点" class="headerlink" title="逻辑回归的优缺点"></a>逻辑回归的优缺点</h3><ul><li><p>优点 </p><ul><li><p>速度快，适合二分类问题</p></li><li><p>简单易于理解，直接看到各个特征的权重</p></li><li><p>能容易地更新模型吸收新的数据</p></li></ul></li></ul><ul><li><p>缺点</p><ul><li>对数据和场景的适应能力有局限性，不如决策树算法适应性那么强</li></ul></li></ul><h3 id="逻辑回归的用途"><a href="#逻辑回归的用途" class="headerlink" title="逻辑回归的用途"></a>逻辑回归的用途</h3><ul><li><strong>寻找主要影响因素</strong>：  通过学习到的权重值，得到不同因素对结果的影响力大小</li></ul><ul><li><strong>预测</strong>：  预测事件发生的概率</li></ul><h3 id="建模常规步骤"><a href="#建模常规步骤" class="headerlink" title="建模常规步骤"></a>建模常规步骤</h3><ul><li>寻找 <code>h 函数</code>（预测函数）</li></ul><ul><li>构造 <code>J 函数</code> (损失函数)</li></ul><ul><li>利用梯度下降等方法最小化  <code>J 函数</code>，并求取参数</li></ul><h3 id="LR基本模型"><a href="#LR基本模型" class="headerlink" title="LR基本模型"></a>LR基本模型</h3><p>以下就是逻辑回归的基本模型：</p><script type="math/tex; mode=display">y=\frac{1}{1+e^{-z}}</script><script type="math/tex; mode=display">z=w^{\top} x+b</script><p>取倒数</p><script type="math/tex; mode=display">\frac{1}{y}=1+e^{-z}</script><p>取对数</p><script type="math/tex; mode=display">\ln \left(\frac{1}{y}-1\right)=-z</script><script type="math/tex; mode=display">\ln \frac{y}{1-y}=\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}+b</script><p>ln(y/(1-y)) 就是对数几率</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>线性模型常用的目标函数 <code>均方误差</code> 用在逻辑回归模型是非凸函数，非凸函数通过梯度下降法容易陷入局部最小值，因此需要想办法找到代价函数，且代价函数为凸函数。</p><h3 id="极大似然法定义代价函数"><a href="#极大似然法定义代价函数" class="headerlink" title="极大似然法定义代价函数"></a>极大似然法定义代价函数</h3><p>这里通过极大似然估计的方法来定义目标函数：</p><blockquote><p><strong>极大似然估计</strong>： 这里想了很久才算有点理解，之前就一直卡在这里。。极大似然估计就是可以利用已知数据来推测出产生这些数据的最可能的环境条件。</p><p>举个栗子，当我们扔硬币时，出现的可能性有两个，要么正面朝上（事件A），要么反面朝上(事件B)，假设出现某事件的可能性只与硬币的 <code>质量分布θ</code> 有关系，假设我们做了n组实验（A出现m次），这样能得到两种情况的概率 P(A), P(B),我们要推测出 <code>质量分布θ</code> 是多少，也就是 <code>参数估计</code> ,即 <code>质量分布θ</code> 是多少时，才最可能出现当前实验的结果。抛硬币的事件服从二项分布，那么给定了一组实验的情况下，似然函数是(似然函数与概率值相等)：</p><script type="math/tex; mode=display">L\left(\theta ; x_{1}, \ldots, x_{n}\right)=f\left(x_{1}, \ldots, x_{n} ; \theta\right)=\prod_{i=1}^{n} P\left(X=x_{i}\right)=\theta^{m}(1-\theta)^{n-m}</script></blockquote><p>假设一个数据集<code>Cn</code>,标签<code>y∈{0,1}</code>，预测值<code>Θ</code>,模型参数为<code>w</code>则似然函数可以写作:</p><script type="math/tex; mode=display">P\left( \theta _{\left( x_i \right)}|w \right) =\prod_{n=1}^N{\theta}_{xi}^{yi}\cdot \left( 1-\theta _{\left( x_i \right)} \right) ^{1-y_i}</script><p>取对数简化运算:</p><script type="math/tex; mode=display">\mathrm{L}(\mathrm{w}, \mathrm{b})=\sum_{i=1}^{N}\left[y_{i} \log \left(\emptyset\left(x_{i}\right)\right)+\left(1-y_{i}\right) \log \left(1-\emptyset\left(x_{i}\right)\right)\right]</script><p>实际代价函数的样子:</p><script type="math/tex; mode=display">\mathrm{J}(\mathrm{w}, \mathrm{b})=-\frac{1}{N} \mathrm{L}(\mathrm{w}, \mathrm{b})=-\frac{1}{N} \sum_{i=1}^{N}\left[y_{i} \log \left(\emptyset\left(x_{i}\right)\right)+\left(1-y_{i}\right) \log \left(1-\emptyset\left(x_{i}\right)\right)\right]</script><p>取对数之后的公式很符合理想的代价函数，当实际标签与预测结果相同，则代价为0，而相反时，会随着差值越大，损失越大。</p><p>因为</p><script type="math/tex; mode=display">\operatorname{logit}(\mathrm{p})=\log \frac{p}{1-p}</script><script type="math/tex; mode=display">\log \frac{P(Y=1 | X)}{1-P(Y=1 | X)}=w \cdot x+b</script><p>带入后继续化简</p><script type="math/tex; mode=display">\mathrm{L}(\mathrm{w}, \mathrm{b})=\sum_{i=1}^{N}\left[y_{i}\left(\mathrm{w} \cdot x_{i}+\mathrm{b}\right)-\log \left(1+e^{\mathrm{w} \cdot x_{i}+b}\right)\right]</script><h3 id="直观解释"><a href="#直观解释" class="headerlink" title="直观解释"></a>直观解释</h3><p>直观上理解，代价函数就是分类错误的惩罚，那么当y=1时，prediction 越小时，损失应越大；y=0时prediction 越大时，损失应越小。</p><script type="math/tex; mode=display">\operatorname{cost}=\left\{\begin{aligned}-\log (\hat{p}), & \text { if } y=1 \\-\log (1-\hat{p}), & \text { if } y=0 \end{aligned}\right.</script><h2 id="通过梯度下降来最小化代价函数"><a href="#通过梯度下降来最小化代价函数" class="headerlink" title="通过梯度下降来最小化代价函数"></a>通过梯度下降来最小化代价函数</h2><p>因为我们找到的代价函数是凸函数，所以可以尝试用梯度下降来找到合适的参数w，b：</p><script type="math/tex; mode=display">\mathrm{w} :=\mathrm{w}-\alpha \frac{\partial J(w, b)}{\partial w}</script><script type="math/tex; mode=display">\mathrm{b} :=\mathrm{b}-\alpha \frac{\partial J(w, b)}{\partial b}</script><p>偏导求解过程：</p><p>对w求偏导</p><script type="math/tex; mode=display">\frac{\partial J(w, b)}{\partial w}=-\frac{1}{N} \sum_{i=1}^{N}\left[y_{i} \frac{1}{\partial\left(x_{i}\right)}-\left(1-y_{i}\right) \frac{1}{1-\emptyset\left(x_{i}\right)}\right] \frac{\partial \emptyset\left(x_{i}\right)}{\partial w}</script><script type="math/tex; mode=display">=-\frac{1}{N} \sum_{i=1}^{N}\left[y_{i} \frac{1}{\emptyset\left(x_{i}\right)}-\left(1-y_{i}\right) \frac{1}{1-\emptyset\left(x_{i}\right)}\right] \sigma\left(x_{i}\right)\left(1-\emptyset\left(x_{i}\right)\right) \cdot x_{i}</script><script type="math/tex; mode=display">=-\frac{1}{N} \Sigma_{i=1}^{N}\left(y_{i}-\emptyset\left(x_{i}\right)\right) \cdot x_{i^{*}}</script><p>对b求偏导</p><script type="math/tex; mode=display">\frac{\partial J(w, b)}{\partial b}=-\frac{1}{N} \sum_{i=1}^{N}\left[y_{i} \frac{1}{\emptyset\left(x_{i}\right)}-\left(1-y_{i}\right) \frac{1}{1-\emptyset\left(x_{i}\right)}\right] \frac{\partial \emptyset\left(x_{i}\right)}{\partial b}</script><script type="math/tex; mode=display">=-\frac{1}{N} \sum_{i=1}^{N}\left[y_{i} \frac{1}{\emptyset\left(x_{i}\right)}-\left(1-y_{i}\right) \frac{1}{1-\emptyset\left(x_{i}\right)}\right] \wp\left(x_{i}\right)\left(1-\emptyset\left(x_{i}\right)\right)</script><script type="math/tex; mode=display">=-\frac{1}{N} \Sigma_{i=1}^{N}\left(y_{i}-\emptyset\left(x_{i}\right)\right)</script><p>带入公式后，得到最终推导的结果：</p><script type="math/tex; mode=display">\mathrm{w} :=\mathrm{w}+\alpha \frac{1}{N} \sum_{i=1}^{N}\left(y_{i}-\emptyset\left(x_{i}\right)\right) \cdot x_{i}</script><script type="math/tex; mode=display">\mathrm{b} :=\mathrm{b}+\alpha \frac{1}{N} \sum_{i=1}^{N}\left(y_{i}-\emptyset\left(x_{i}\right)\right)</script><font color="red"> 通过以上公式可以看出，逻辑回归的梯度与 `sigmoid` 本身无关，只与 `y` 和`x`和 `w` 有关系。</font><h2 id="进一步提高泛化能力"><a href="#进一步提高泛化能力" class="headerlink" title="进一步提高泛化能力"></a>进一步提高泛化能力</h2><blockquote><p>影响模型泛化能力的主因素是 <code>过拟合</code>, 过拟合问题比较容易理解，这里就不贴图了。下面分析一下产生过拟合的原因和解决办法。</p></blockquote><h3 id="过拟合产生的原因有哪些？"><a href="#过拟合产生的原因有哪些？" class="headerlink" title="过拟合产生的原因有哪些？"></a>过拟合产生的原因有哪些？</h3><p><strong>过多的特征</strong></p><h3 id="怎么解决过拟合？"><a href="#怎么解决过拟合？" class="headerlink" title="怎么解决过拟合？"></a>怎么解决过拟合？</h3><ol><li><p>减少特征数量</p><p> 减少特征数量会导致部分信息丢失。</p></li><li><p>正则化</p><p> 保留所有的特征，并且减小参数的大小。</p></li></ol><h3 id="正则化方法"><a href="#正则化方法" class="headerlink" title="正则化方法"></a>正则化方法</h3><p><strong>在代价函数上增加一个惩罚项</strong>，<font color="red">惩罚项应该是模型复杂度的单调递增函数，模型越复杂，惩罚项越大。 </font></p><p>回归问题中，取<strong>平方损失</strong>（L2 范数），或者L1范数</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2 m} \sum_{i=1}^{n}\left(\mathrm{h}_{\theta}\left(\mathrm{x}_{i}\right)-y_{i}\right)^{2}+\lambda \sum_{j=1}^{n} \theta_{j}^{2}</script><p>这里的lambda 系数：</p><p> 如果它的值很大，说明对模型的复杂度惩罚大，对拟合数据的损失惩罚小，这样它就不会过分拟合数据，在训练数据上的偏差较大，在未知数据上的方差较小，但是可能出现欠拟合的现象；</p><p> 如果它的值很小，说明比较注重对训练数据的拟合，在训练数据上的偏差会小，但是可能会导致过拟合。</p><p>加入正则化后的参数更新：</p><script type="math/tex; mode=display">\theta_{j} :=\theta_{j}-\frac{\alpha}{m} \sum_{i=1}^{m}\left(h_{\theta}\left(x_{i}\right)-y_{i}\right) x_{i}^{j}-\frac{\lambda}{m} \theta_{j}</script><h2 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h2><p>空</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://irwenqiang.iteye.com/blog/1552680&quot;该部分参考这里&quot;" target="_blank" rel="noopener">极大似然估计</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;逻辑回归就是西瓜书里的对数几率回归，名为回归，实际则是分类算法。其实质是利用线性回归模型的预测结果来逼近真实标记的对数几率。&lt;/p&gt;
&lt;p&gt;一句话概括就是:&lt;/p&gt;
&lt;font color=&quot;red&quot;&gt; 
逻辑回归假设数据服从 **伯努利分布** 
      
    
    </summary>
    
      <category term="机器学习方法" scheme="http://www.elgong.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="逻辑回归" scheme="http://www.elgong.top/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>决策树-1基本概念</title>
    <link href="http://www.elgong.top/2019/04/20/%E5%86%B3%E7%AD%96%E6%A0%91-1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://www.elgong.top/2019/04/20/决策树-1基本概念/</id>
    <published>2019-04-20T10:09:10.000Z</published>
    <updated>2019-07-27T13:09:13.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="决策树1-基本概念"><a href="#决策树1-基本概念" class="headerlink" title="决策树1- 基本概念"></a>决策树1- 基本概念</h1><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p><img src="/2019/04/20/决策树-1基本概念/tree.png" alt="logo"></p><p>上图来自西瓜书，是决策树的一种树形。生成决策树的过程，不断的<strong>根据样本的属性( 样本的某个特 )划分样本子集</strong>。每个结点选择当前最优的属性作为划分依据，将样本集合不断的划分成更小的子集合，直到子集合中样本类别一致时或者没有可以划分的属性值时，则停止划分，标记为叶结点(叶节点代表一个类别)。</p><p>简单的介绍一下决策树的组成元素:</p><ol><li>根节点:  所有的训练样本</li><li>内部节点:   对应某一个划分属性</li><li>叶节点：   对应某一种决策结果</li><li>判定测试序列：   某个样本在节点中传递的路径</li></ol><p>所有节点都包含着不同数量的样本。</p><blockquote><p>以上是分类树的例子，决策树也可以用作回归任务，如CART算法。决策树是GBDT,Xgboost等更高级结构的基础，所以尽量要掌握决策树的原理。</p></blockquote><h2 id="决策树算法的基本流程"><a href="#决策树算法的基本流程" class="headerlink" title="决策树算法的基本流程"></a>决策树算法的基本流程</h2><p>假设有一个数据集，其中的每个样本有多种特征，每个特征有不同的取值。通过这个数据集来生成一个决策树的一般流程可以归纳为:</p><ul><li>特征选择</li></ul><blockquote><p>特征选择就是决策树分叉时，依据新节点的”纯度”，选择最优的划分属性;</p></blockquote><ul><li>决策树生成</li></ul><blockquote><p>树不断的分叉，直到样本的属性用光，或者树的深度达到了预定值，则结束分叉;</p></blockquote><ul><li>剪枝</li></ul><blockquote><p>如果一直树杈分下去，一定能够使得所有的样本都正确的归类，但这样会产生对训练集的过拟合，泛化能力变差，可以通过剪枝操作来改善泛化能力。</p></blockquote><p>通过这三步，就可以生成一颗决策树了。下面来学习一下具体怎么进行特征的选择和剪枝。</p><h2 id="如何选择最优的划分属性"><a href="#如何选择最优的划分属性" class="headerlink" title="如何选择最优的划分属性?"></a>如何选择最优的划分属性?</h2><blockquote><p>决策树不断分叉的原因，是尽可能的让不同类别的样本划分到不同的节点，同类别的样本划分到同一个节点。而选择最优的划分属性（特征）的过程，相当于是遍历计算出所有特征的结果，找到能使分叉后子集合最 “纯” 的特征，就是最优的划分属性了。<br>所以，该如何定义 “纯” ，需要借助信息论中 “信息熵” 的概念了。</p></blockquote><p><strong>熵</strong> :  表示随机变量不确定性的度量,也就是混乱程度的一种度量。</p><p>假定数据集 <code>D</code> 中第 <code>K</code> 类样本所占的比例为 <script type="math/tex">p_{k}</script>,则信息熵定义为:</p><script type="math/tex; mode=display">\operatorname{Ent}(D)=-\sum_{k=1}^{N} p_{k} \log _{2} p_{k}</script><p>数据集包含的<font color="#FF0000">类别越少时越纯，<code>Ent(D)</code>也越小。</font> </p><h3 id="法1-信息增益"><a href="#法1-信息增益" class="headerlink" title="法1: 信息增益"></a>法1: 信息增益</h3><p>==ID3算法用到信息增益==</p><blockquote><p>直白的讲就是决策树分叉前的信息熵减去分叉后的信息熵。</p><p>信息增益最大的特征就是最佳划分属性。</p></blockquote><p>假定分叉前样本集 <code>D</code> 中的特征 <code>a</code> 有 <code>V</code>个可能的取值 <script type="math/tex">\left\{a^{1}, a^{2}, \ldots, a^{V}\right\}</script> ,当选择 <code>a</code> 做划分属性时，会分<code>V</code>个节点，每个节点上的子样本集合为 <script type="math/tex">D^{v}</script>,同时为不同节点赋权重(按照样本的比例)，于是信息增益为: </p><script type="math/tex; mode=display">\operatorname{Gain}(D, a)=\operatorname{Ent}(D)-\sum_{v=1}^{V} \frac{\left|D^{v}\right|}{|D|} \operatorname{Ent}\left(D^{v}\right)</script><p>减数部分也叫<font color="#FF0000"> 条件熵 </font></p><font color="#FF0000">缺点:</font> 分叉时偏好取值较多的属性。<font color="#FF0000">原因分析:</font><ol><li>取值多的特征，样本更分散，所有得到的新节点”纯度” 趋于更高，熵更低，而划分前的增益不变的情况下，该特征增益更大。</li><li>比如，当特征的可能取值数量正好等于样本数量，那条件熵几乎为0，该特征一定会被选择。</li></ol><h3 id="法2-信息增益率"><a href="#法2-信息增益率" class="headerlink" title="法2: 信息增益率"></a>法2: 信息增益率</h3><p>==C4.5算法用到信息增率==</p><blockquote><p>相当于在法1基础上，增加了惩罚系数，可取值越多，系数越大。</p></blockquote><script type="math/tex; mode=display">Gain\_ratio\left( D,a \right) =\frac{Gain\left( D,a \right)}{IV\left( a \right)}</script><script type="math/tex; mode=display">\mathrm{IV}(a)=-\sum_{v=1}^{V} \frac{\left|D^{v}\right|}{|D|} \log _{2} \frac{\left|D^{v}\right|}{|D|}</script><p><code>IV(a)</code> 是属性 <code>a</code> 的 “固有值”，内部属性。</p><p><font color="#FF0000">缺点:</font> 分叉时偏好取值较少的属性。</p><h3 id="法3：基尼指数"><a href="#法3：基尼指数" class="headerlink" title="法3：基尼指数"></a>法3：基尼指数</h3><p>==CART决策树算法用到基尼指数==</p><blockquote><p>反应从节点样本集合中随机抽取两个样本，类别不一致的概率。</p></blockquote><p>基尼值的定义:</p><script type="math/tex; mode=display">\operatorname{Gini}(D)=\sum_{k=1}^{|\mathcal{Y}|} \sum_{k^{\prime} \neq k} p_{k} p_{k^{\prime}}</script><script type="math/tex; mode=display">=\sum_{k=1}^{|y|} p_{k}\left(1-P_{k}\right)</script><script type="math/tex; mode=display">=1-\sum_{k=1}^{|\mathcal{Y}|} p_{k}^{2}</script><p>基尼指数的定义：</p><script type="math/tex; mode=display">Gini\_index\left( D,a \right) =\sum_{v=1}^V{\frac{\left| D^v \right|}{|D|}}\text{operatorname}Gini\left( D^v \right)</script><p>三种决策树模型：</p><div class="table-container"><table><thead><tr><th>算法</th><th>特征选择标准</th></tr></thead><tbody><tr><td>ID3</td><td>信息增益</td></tr><tr><td>C4.5</td><td>信息增益率</td></tr><tr><td>CART</td><td>基尼指数</td></tr></tbody></table></div><h2 id="对抗过拟合-—-剪枝处理"><a href="#对抗过拟合-—-剪枝处理" class="headerlink" title="对抗过拟合 — 剪枝处理"></a>对抗过拟合 — 剪枝处理</h2><blockquote><p>分支太多，容易过拟合，泛化能力变差。所以要适当剪枝，常用方法是<strong>预剪枝</strong>和<strong>后剪枝</strong></p></blockquote><h3 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h3><ol><li>预剪枝是在决策树生成的过程中，对每个结点在划分前先估计，根据划分前后验证集的精度，来决定是否划分；</li></ol><ol><li>只能估计当前结点可划分性，不能预测到未来节点划分的必要性，是贪心算法；</li></ol><ol><li>容易造成欠拟合。</li></ol><h3 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h3><ol><li>先生成完整的树，再从叶结点往回计算，根据验证集精度是否提升决定是否剪枝；</li></ol><ol><li>泛化能力往往优于预剪枝，欠拟合风险小；</li></ol><ol><li>时间开销大。</li></ol><h2 id="属性为连续值时？"><a href="#属性为连续值时？" class="headerlink" title="属性为连续值时？"></a>属性为连续值时？</h2><blockquote><p>C4.5 算法采用二分法将连续值离散化</p><p>与离散属性不同，连续的属性可以在后代节点中再次使用</p></blockquote><h2 id="当数据中含有缺失值时？"><a href="#当数据中含有缺失值时？" class="headerlink" title="当数据中含有缺失值时？"></a>当数据中含有缺失值时？</h2><p>处理方法：</p><p>通过无缺失数据计算出三个参数：</p><ol><li>无缺失样本占总样本比例 </li><li>无缺失样中 <code>K类别</code> 占比 <code>pk</code></li><li>无缺失样本中 <code>v 属性</code>样本占比 <code>rv</code></li></ol><p>对单样本增加一个权值 <code>Wx</code>, 无缺失样本的<code>Wx = 1</code>，  有缺失样本的<code>Wx = rv*Wx</code>。</p><p>在计算分支时，<strong>同一样本以不同的概率划分到不同的子节点中</strong></p><ul><li>当样本的属性已知：则把该样本划分进对应的子节点，权值=1；</li></ul><ul><li>当样本的该属性缺失：则把该样本同时划入所有的子节点，样本权值需要更新为`Wx = rv*Wx。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;决策树1-基本概念&quot;&gt;&lt;a href=&quot;#决策树1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;决策树1- 基本概念&quot;&gt;&lt;/a&gt;决策树1- 基本概念&lt;/h1&gt;&lt;h2 id=&quot;决策树&quot;&gt;&lt;a href=&quot;#决策树&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="机器学习方法" scheme="http://www.elgong.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="决策树" scheme="http://www.elgong.top/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机类加载机制</title>
    <link href="http://www.elgong.top/2019/04/14/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.elgong.top/2019/04/14/虚拟机类加载机制/</id>
    <published>2019-04-14T06:11:58.000Z</published>
    <updated>2019-07-12T12:50:21.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><blockquote><p>绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来。</p></blockquote><ul><li>静态绑定</li></ul><blockquote><p>前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现java当中的方法只有<code>final，static，private和构造方法</code> 是前期绑定的。</p></blockquote><ul><li>动态绑定</li></ul><blockquote><p>运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。</p></blockquote><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：<strong>加载、验证、准备、解析、初始化、使用和卸载</strong> 七个阶段，前五个阶段属于类加载的过程。这是开始顺序，每个阶段可能交错。</p><h3 id="step1：加载"><a href="#step1：加载" class="headerlink" title="step1：加载"></a>step1：加载</h3><h4 id="加载阶段，虚拟机完成的任务："><a href="#加载阶段，虚拟机完成的任务：" class="headerlink" title="加载阶段，虚拟机完成的任务："></a>加载阶段，虚拟机完成的任务：</h4><ul><li>通过一个类的全限定名来获取起定义的二进制字节流。</li></ul><blockquote><p>二进制字节流来源： Class文件，Jar包、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等；</p></blockquote><ul><li>将该字节流的静态存储结构转换为方法区的运行时数据结构。</li></ul><ul><li>在Java堆中声称一个代表这个类的 java.lang.Class对象，作为对方法区中这些对象的入口。</li></ul><h4 id="三种主要的类加载器？"><a href="#三种主要的类加载器？" class="headerlink" title="三种主要的类加载器？"></a>三种主要的类加载器？</h4><blockquote><p> 类加载机制采用了委托模式。 类加载器与类本身一同确定这个类在Java 虚拟机中的唯一性。</p></blockquote><ol><li>启动类加载器 <em>Bootstrap ClassLoader</em></li></ol><blockquote><p>该加载器由C++实现，不属于类，负责加载 <code>/JDK/JRE/lib/rt.jar</code>，主要加载 JVM 工作需要的类；</p></blockquote><ol><li>扩展类加载器 <em>Extension ClassLoader</em><blockquote><p>Bootstrp loader 加载 ExtClassLoader,<br> 该加载器由sun.misc.Launcher$ExtClassLoader 实现，它负责加载`/JDK\JRE\lib\ext目录中的类，自己的类打包jar放入也可以；</p></blockquote></li><li><p>应用程序类加载器 <em>Application ClassLoader</em></p><blockquote><p>Bootstrp loader加载完ExtClassLoader后，就会加载AppClassLoader,并且将AppClassLoader的父加载器指定为 ExtClassLoader， 负责加载classpath所指定的位置的类。</p></blockquote></li><li><p>自定义类加载器</p></li></ol><blockquote><p>如果要自定义类加载器，需要继承 <code>应用程序类加载器</code></p></blockquote><h4 id="三者如何协调工作？"><a href="#三者如何协调工作？" class="headerlink" title="三者如何协调工作？"></a>三者如何协调工作？</h4><p>类加载机制采用了委托模式。启动类加载器加载其他类加载器，当需要加载类时，<strong>优先父类加载器工作</strong>。</p><blockquote><p>  双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p></blockquote><h3 id="step2：验证"><a href="#step2：验证" class="headerlink" title="step2：验证"></a>step2：验证</h3><h4 id="验证的目的？"><a href="#验证的目的？" class="headerlink" title="验证的目的？"></a>验证的目的？</h4><p>保证<code>class 文件</code>的字节流符号JVM 虚拟机的要求，不危害虚拟机自身安全。虽然 Java 源码编译不会产生如数组越界之类的错误，但<code>class 文件</code>可以被编辑。</p><h4 id="都需要哪些验证？"><a href="#都需要哪些验证？" class="headerlink" title="都需要哪些验证？"></a>都需要哪些验证？</h4><ul><li>文件格式验证</li></ul><blockquote><p><strong>验证字节流是否符合 <code>class文件规范</code></strong>（如开头是否为魔数<code>0xCAFEBABE</code>， 主次版本号是否可以被当前虚拟机处理等）</p></blockquote><ul><li>元数据验证</li></ul><blockquote><p><strong> 验证字节码描述的信息是否符合Java 语言规范</strong>（如类的继承实现是否符合语法规范）</p><ul><li>字节码验证</li></ul><p>该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</p></blockquote><ul><li>符号引用验证</li></ul><blockquote><p>发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。</p></blockquote><h3 id="step3：-准备"><a href="#step3：-准备" class="headerlink" title="step3： 准备"></a>step3： 准备</h3><p> 准备阶段是正式为<strong>类变量</strong>（静态变量）分配内存并设置类变量初始值的阶段，<strong>这些内存都将在方法区中分配</strong>。注意的是：</p><ol><li>只为类变量分配内存；</li></ol><ol><li>static 类变量初始值为默认初始值，而不是程序中的值；</li></ol><pre><code>public static int value = 3；  // 实际初始值为0</code></pre><ol><li><p>同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值；</p><p> public static final int value = 3；  // 实际初始值为3</p></li></ol><h3 id="step4：-解析"><a href="#step4：-解析" class="headerlink" title="step4： 解析"></a>step4： 解析</h3><blockquote><p>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。</p><p> 解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。</p></blockquote><h3 id="step5：-初始化"><a href="#step5：-初始化" class="headerlink" title="step5： 初始化"></a>step5： 初始化</h3><blockquote><p>真正开始执行类中定义的Java程序代码,初始化阶段是执行类构造器<clinit>()方法的过程。</clinit></p></blockquote><p>类构造器 <code>&lt;clinit&gt;()</code> 执行规则：</p><ol><li>按照在源文件中出现的顺序收集<code>类变量</code> 和 <code>静态语句块 static{ }</code>;</li><li>静态语句块中只能访问定义在之前的变量，而在块后定义的变量只能被赋值，但不能被访问；</li><li>优先构造父类；</li><li>父类中的 <code>静态语句块 static{ }</code> 优先于子类中的变量赋值操作；</li><li>不是必须的，当类或者接口中没有静态语句块或者没有变量赋值，则可以不生成<code>&lt;clinit&gt;()</code>；</li></ol><h2 id="双亲委派被破坏-3种情况下"><a href="#双亲委派被破坏-3种情况下" class="headerlink" title="双亲委派被破坏 3种情况下"></a>双亲委派被破坏 3种情况下</h2><ul><li>第一次： JDK1.2之前还没有双亲委派，但是有用户自定义类加载器（通过<code>loadClass（）</code>加载），为了兼容老版本，设计者添加了 <code>protected findClass()</code>，直接调用用户<code>loadClass（）</code>方法；</li></ul><ul><li><p>第二次：原则上 <strong>越基础的类由越上层的加载器进行加载</strong>,但是有些情况下基础类需要调用用户的代码。如<strong>JNDI, JDBC，JCE,JAXB，JBI</strong>,这时候引入了<code>线程上下文加载器</code>；</p></li><li><p>第三次：“代码热替换”和“模块热部署”出现，希望程序中的功能模块像键盘鼠标一样直接更换，而不是重启。<strong>OSGi</strong> 是这个标准化模块，具体还没看。。。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;虚拟机类加载机制&quot;&gt;&lt;a href=&quot;#虚拟机类加载机制&quot; class=&quot;headerlink&quot; title=&quot;虚拟机类加载机制&quot;&gt;&lt;/a&gt;虚拟机类加载机制&lt;/h1&gt;&lt;h2 id=&quot;绑定&quot;&gt;&lt;a href=&quot;#绑定&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="深入理解Java 虚拟机" scheme="http://www.elgong.top/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="Java类加载机制" scheme="http://www.elgong.top/tags/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>华为软挑2019</title>
    <link href="http://www.elgong.top/2019/04/01/%E5%8D%8E%E4%B8%BA%E8%BD%AF%E6%8C%91/"/>
    <id>http://www.elgong.top/2019/04/01/华为软挑/</id>
    <published>2019-04-01T10:19:34.000Z</published>
    <updated>2019-07-12T12:50:21.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参加软挑的一些感悟"><a href="#参加软挑的一些感悟" class="headerlink" title="参加软挑的一些感悟"></a>参加软挑的一些感悟</h1><h2 id="写在前边的话"><a href="#写在前边的话" class="headerlink" title="写在前边的话"></a>写在前边的话</h2><p>　　</p><blockquote><p>我本科一直在做嵌入式相关的项目,这是第一次参加软件类的竞赛,不得不说过程确实很刺激,最后止步杭厦赛区50强也很是遗憾,明明很接近,最后输在了代码效率上,本地成绩很好的 <code>python代码</code> ,上传测评运行时间超限（官测环境比本地性能好，普遍情况是用时远超本地，其中华为云主机集体宕机半小时，很多人测过的最优代码，最后再上传就超时了<a href="https://bbs.huaweicloud.com/forum/thread-16237-1-1.html" target="_blank" rel="noopener">https://bbs.huaweicloud.com/forum/thread-16237-1-1.html</a>）。超限原因主要两点，一是自己在实现调度器时的代码臃肿，二是正式赛数据量大增。但进入32强的不少组并没有实现调度器，完全 <code>随机时间发车+单车路径最优规划</code> , 感觉很(￣_,￣ )。这比赛不实现调度器，意义少了一半，再用上这种偷鸡方法，没觉出来还有啥意义。唉，菜鸡就是菜鸡。总之，这次经历对我还是有不少积极的影响的，下面就总结一下吧。</p></blockquote><h2 id="题目解读"><a href="#题目解读" class="headerlink" title="题目解读"></a>题目解读</h2><p>本次比赛主要做的是 <code>动态路网下多车辆调度问题</code>, <font color="red"><big>参赛者合理安排数万车辆在合理时间从出发点到达各自的目的地，程序上传至官方服务器，运行后得出 <strong>所有车辆出发时间和规划的路径</strong> ，将在官方调度器中进行调度，完成车辆调度用时即为最终成绩。</big></font>具体是比赛任务书中花了很大篇幅讲了官方调度器的规则，并且论坛前期几乎天天在更新规则补充，最终完全准确实现的队伍只见过一个，其他很对队伍是很接近，但总有差别。我们自己实现的调度器，调度时间完全对的上，但是所有车辆调度总时间总是差了一些。分析原因有以下两点:   </p><ol><li>我们实现的调度规则还有与官方一些差异；（但是我们实现的和部分队伍对比的结果完全一致，但和官网就有差异，猜测可能有些规则官方描述的有些差异，或者某细节被我们忽略了）</li><li>python 即使版本相同，但是在不同机器上结果确实有差异，这个也被官方证实了<a href="https://bbs.huaweicloud.com/forum/thread-15889-1-1.html" target="_blank" rel="noopener">https://bbs.huaweicloud.com/forum/thread-15889-1-1.html</a>。</li></ol><p>总体上参考任务书，下面只简单梳理一下思路（这里默认已经熟悉了任务书）：</p><p>下面先附上官方伪代码</p><pre><code>    for(/* 按时间片处理 */) {       foreach(roads) {            /* 调整所有道路上在道路上的车辆，让道路上车辆前进，只要不出路口且可以到达终止状态的车辆             * 分别标记出来等待的车辆（要出路口的车辆，或者因为要出路口的车辆阻挡而不能前进的车辆）             * 和终止状态的车辆（在该车道内可以经过这一次调度可以行驶其最大可行驶距离的车辆）*/            driveAllCarJustOnRoadToEndState(allChannle);/* 对所有车道进行调整 */            /* driveAllCarJustOnRoadToEndState该处理内的算法与性能自行考虑 */       }        while(/* all car in road run into end state */){            /* driveAllWaitCar() */            foreach(crosses){                foreach(roads){                    while(/* wait car on the road */){                        Direction dir = getDirection();                        Car car = getCarFromRoad(road, dir);                        if (conflict）{                            break;                        }            channle = car.getChannel();            /* 这里只指因下一道路有等待车辆阻挡而导致该车辆无法进入的情况 */            /* 其他情况均返回true,比如下一车道满无法进入（全是终态），或才是下一车道限速不能进入，该车辆停留在其当前车道最前方 */            /* 该车辆也是移动至其所在车道最前方，只有有车辆由等待变以终止，就对其车道后续车辆状态进行调整 */            if(!car.moveToNextRoad()) {                break;            }            /* driveAllCarJustOnRoadToEndState该处理内的算法与性能自行考虑 */            driveAllCarJustOnRoadToEndState(channel);                }            }          }        }        /* 车库中的车辆上路行驶 */        driveCarInGarage();    }</code></pre><ul><li>要调度的车辆分两种：<font color="red"><big>路上的车和要上路的车</big></font></li></ul><ul><li>每个时间片<font color="red">先处理路上车，在处理上路车</font></li></ul><ul><li>路上的车处理步骤： <font color="red"><big>step1标记状态， step2 移动车辆 </big></font></li></ul><ul><li>车的状态：每个时间片（一个时间片指的是所有车辆一次调度完成）路上车辆有三种状态，未调度过的车是    <code>无状态</code>， 调度过但是由于阻挡或者其他原因不能移动的车标记为 <code>等待状态</code>， 调度过并且完成移动的车标记为 <code>终态</code>。</li></ul><ul><li>step1: 怎样标记状态？</li></ul><pre><code>- 这个时间片车辆最大行驶速度能超过该道路长度（超过了但不一定就能进入下一条道路），直接标记为`等待状态`- 这个时间片车辆最大行驶速度不能超过该道路长度，但是前方有车辆挡住自己将要走的路，直接标记为`等待状态`- 这个时间片车辆最大行驶速度不能超过该道路长度，并且前方没车辆挡住自己，**移动该车**，直接标记为`终止状态`</code></pre><ul><li><p>step2: 按什么顺序调度车辆？</p><ul><li>路上的车：<ul><li>处理次序：<ul><li>按照ID升序反复遍历<strong>路口</strong>，直到所有车辆变成终态</li><li>对每个路口，按照ID升序遍历朝向这个路口的<strong>道路</strong>（也反复遍历，直到所有车进入终止状态，或者被阻挡无法移动）</li><li>每个道路上有多条线，按照<strong>优先级顺序</strong>处理车辆，只有第一优先级车辆完成调度，才能调度优先级低的车。</li><li>不过马路而被标记等待的车，不受优先级限制，阻挡车辆离开，这种车立马跟上</li></ul></li></ul></li><li>上路的车：<ul><li>上路车按照ID升序处理</li><li>规划的时间因为前方无空位而未上路的车，顺延到下一时刻优先上路，即不参与下一时刻车辆ID升序发车。</li></ul></li></ul></li></ul><ul><li>哪些车参与<strong>优先级</strong>的排序？</li></ul><pre><code>要过马路的车和车速超过当前道路剩余长度，但是根据任务书10-5条，不能进入下一道路的车都参与优先级排序。</code></pre><p>大概就这些了，其他更细微的只能遇到才想起来了。</p><h2 id="思路总结"><a href="#思路总结" class="headerlink" title="思路总结"></a>思路总结</h2><blockquote><p>这里只总结一下初赛的思路。</p></blockquote><p>这个比赛就是合理安排车辆调度，以最短时间让所有车都到达终点。所以要找到合适的方法让车辆快速充满道路而不至于 <code>锁死</code>,<code>锁死</code>也是赛题的最难点。 道路上流动的车越多，越容易出现锁死情况；道路上流动的车越少，最终调度时间就越长。所以优化的目标变成了<font color="red"><big>保证不死锁的情况下，让更多的车在道路上流动起来</big></font>。</p><h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>死锁指的是，某个时间片道路上的车辆由于循环等待（形成了环形等待情况），导致无法再进一步调度任何车辆，导致调度失败，成绩为0。<strong>体现在调度器里</strong>，就是step2 反复调度路口时，等待状态的车辆数量不再减少，即锁死了。</p><h3 id="怎么避免死锁？"><a href="#怎么避免死锁？" class="headerlink" title="怎么避免死锁？"></a>怎么避免死锁？</h3><p>唯一可以避免的方法是完全实现调度器，和官方调度器一致，就可以准确判断到锁死，并且在规划道路时动态规划新路，解开环形等待的死亡链。可惜大家完全模拟出来调度器的几乎没有（据我一直水群了解到的情况看，是这样，不排除潜水大佬真的实现了）。<br>所以呢，大部分人都是想尽办法的尽量减少锁死，无法完全避免，下面会举例几种方法。</p><h3 id="有不完全正确调度器的解决方案"><a href="#有不完全正确调度器的解决方案" class="headerlink" title="有不完全正确调度器的解决方案"></a>有不完全正确调度器的解决方案</h3><ol><li><p>单车最优路径静态规划 + 遇锁死时对部分车动态规划</p><blockquote><p>如果调度器不太一致时，就当某道路调度同一车辆多次，就给这个车强制规划新路径。</p></blockquote></li><li><p>单车最优路径静态规划 + 遇锁死时把锁死车辆从路上删除，未来重新发车</p></li><li><p>分批次发车 + 每个批次单独规划路径 + 动态路阻 + 锁死车辆动态规划</p><blockquote><p>这个是效果比较好的一种方法，练习赛后期成绩能进入前15名的方法。动态路阻指的是道路情况拥堵，这里选择了几个因素：</p><p>动态路阻 = 这个批次经过该道路车辆数量<em>a + abs(道路限速 - 车速)</em>b + （1 - 道路中路线数/最大线数）*c</p><p>路阻每个批次都清除一次，这样在调度器不准确的情况下很大程度上抑制了死锁的发生，当时采用这种方法之后，每个批次发车量明显可以提高很多。这里a，b，c是需要调节的参数。</p></blockquote></li></ol><h3 id="没有调度器的解决方案"><a href="#没有调度器的解决方案" class="headerlink" title="没有调度器的解决方案"></a>没有调度器的解决方案</h3><p>如果没实现调度器，也有一些不错的方法，但是不算偷鸡。这里把路网当成计算机的网络，网络的带宽就是道路的线数，我们想让网络传输最大量的数据，但是网络本身承载能力有限制，我们要找到均衡流量的方法，让网络上流动的流量尽可能的均衡，这样再找到合适的参数，即网络最适合的承载车辆数目，保证网络流量不超过这个限制，也可以减少死锁的情况。即 <strong>分批次发车 + 每个批次单独规划路径 + 动态路阻</strong></p><h3 id="还有一种不太有意义的方法"><a href="#还有一种不太有意义的方法" class="headerlink" title="还有一种不太有意义的方法"></a>还有一种不太有意义的方法</h3><p>这种也被很多人叫做偷鸡方法，就是 <strong>单车路径最优规划 + 随机时间发车</strong>，然后就是调调调。这种方法优势是答案生成快，可以反复调无数次。而实现调度器的同学，基本半小时才能调一次参数，因为模拟调度的过程比较费时间，又加上动态路径规划，时间代价大大提高。</p><h3 id="对单车的寻路算法"><a href="#对单车的寻路算法" class="headerlink" title="对单车的寻路算法"></a>对单车的寻路算法</h3><p>想当然的觉得地图是平面的，因为官方给的任务书全是平面图，并且每个路口对应的四个街道都是有方向的，所以对路口直接建立了坐标系，有了每个点的方位坐标信息，也就很自然的选择了A*算法。结果没想到，最后正式赛当天出现的地图是这。。。样。。。的。。。，出现了高空立交桥，这还算直行吗。开始不知道地图变了样子，结果递归建坐标系的部分爆了bug，改了半天，卒了。后来看到群里可视化后的效果是下图，吐血了，赶紧换了Dijkstra算法。这两个算法有时间再总结。</p><p><img src="/2019/04/01/华为软挑/huawei.jpg" alt="logo"></p><h2 id="我们组的结果"><a href="#我们组的结果" class="headerlink" title="我们组的结果"></a>我们组的结果</h2><p>结果就是止步初赛了，调度器 + 动态规划 + 动态路阻 + 。。。+ python 真是很费时间，本地要15分钟勉强出结果，服务器上直接超时。 放弃了调度器和动态规划， 只用了动态路阻，最后所剩时间不多了，只调了几次参数就到时间了。 </p><h2 id="比赛的经验与教训"><a href="#比赛的经验与教训" class="headerlink" title="比赛的经验与教训"></a>比赛的经验与教训</h2><ol><li>比赛运行环境一定要保证和官方一致，不然结果会出现不一致。</li><li>如果还是这种复杂规则的情况，不要再选择python，速度确实有问题，代码能力差的人体现的更明显~、~、</li><li>好好理解题目在行动。</li></ol><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>结果有点惨淡，但是这段时间确实收获了很多，也多亏了两位队友的倾力相助，以及师兄的思路指导。郭同学为团队提供了大部分算法上的思路和代码；丁同学从开始比赛到最后一天，也一直在和我讨论着调度以及算法，纠正了我很多错误的理解，比赛的日子也是近段时间来最开心的日子，期待大家下一次的合作。画江湖之绿皮车将要回归。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参加软挑的一些感悟&quot;&gt;&lt;a href=&quot;#参加软挑的一些感悟&quot; class=&quot;headerlink&quot; title=&quot;参加软挑的一些感悟&quot;&gt;&lt;/a&gt;参加软挑的一些感悟&lt;/h1&gt;&lt;h2 id=&quot;写在前边的话&quot;&gt;&lt;a href=&quot;#写在前边的话&quot; class=&quot;head
      
    
    </summary>
    
      <category term="竞赛" scheme="http://www.elgong.top/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="华为软挑初赛" scheme="http://www.elgong.top/tags/%E5%8D%8E%E4%B8%BA%E8%BD%AF%E6%8C%91%E5%88%9D%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Deep Residual Learning for Image Recognition</title>
    <link href="http://www.elgong.top/2019/01/25/Deep-Residual-Learning-for-Image-Recognition/"/>
    <id>http://www.elgong.top/2019/01/25/Deep-Residual-Learning-for-Image-Recognition/</id>
    <published>2019-01-25T14:19:29.000Z</published>
    <updated>2019-07-12T12:50:21.698Z</updated>
    
    <content type="html"><![CDATA[<p><code>2015年</code> 论文地址：  <a href="https://arxiv.org/pdf/1512.03385.pdf&quot;论文地址&quot;" target="_blank" rel="noopener">https://arxiv.org/pdf/1512.03385.pdf</a></p><h2 id="通常情况下"><a href="#通常情况下" class="headerlink" title="通常情况下"></a>通常情况下</h2><ol><li>神经网络层越深，特征的抽象程度越高，模型的表达能力越强，语义信息越丰富；</li><li>同时，网络越深，<code>退化问题</code> 越难解决;</li></ol><h2 id="退化问题是网络加深的障碍"><a href="#退化问题是网络加深的障碍" class="headerlink" title="退化问题是网络加深的障碍"></a>退化问题是网络加深的障碍</h2><p>　　简单的增加深度，会导致 <code>梯度弥散</code> 或者 <code>梯度爆炸</code> ,可以通过标准初始化和中间层正则化（batchNorm）解决；但是随着继续增加深度，训练集准确率饱和，甚至下降（<code>退化问题</code>，不属于过拟合）。</p><p><img src="/2019/01/25/Deep-Residual-Learning-for-Image-Recognition/resnet1.png" alt="logo"></p><p>　　神经网络就像一个｀Function Set｀，网络是输入 x 到输出 out 的映射关系 F，<code>out = F(x)</code> ，所以网络层越深，这个 <code>Set</code> 包含的函数越复杂，那能够拟合的情况就更多（意思是解决的问题就更多），上图是作者在<code>CIFAR-10</code> 数据集上的对比实验，56层网络是在20层网络上的重复叠加（最差也应该是前22层的恒等映射），但是较深网络训练集的误差却比浅层网络的误差更大。这不是过拟合了，过深网络出现了 <code>退化问题</code>。</p><h2 id="本文效果（很大程度上解决了退化问题）："><a href="#本文效果（很大程度上解决了退化问题）：" class="headerlink" title="本文效果（很大程度上解决了退化问题）："></a>本文效果（很大程度上解决了退化问题）：</h2><ol><li>作者在ImageNet上实验了一个152层的残差网络，比VGG深8倍，取得了3.57%的错误率。</li><li>作者通过一系列实验证明了表示的深度（即网络的深度）对很多视觉识别任务都至关重要。仅仅由于使用了非常深的网络，作者就在COCO目标检测数据集上获得了28%的相对提升。</li></ol><h2 id="本文怎么解决退化问题？"><a href="#本文怎么解决退化问题？" class="headerlink" title="本文怎么解决退化问题？"></a>本文怎么解决退化问题？</h2><h3 id="Resnet-结构分析"><a href="#Resnet-结构分析" class="headerlink" title="Resnet 结构分析"></a>Resnet 结构分析</h3><h4 id="ResNet-短连接块"><a href="#ResNet-短连接块" class="headerlink" title="ResNet 短连接块"></a>ResNet 短连接块</h4><p><img src="/2019/01/25/Deep-Residual-Learning-for-Image-Recognition/resnet2.png" alt="logo"><br>作者在《Identity Mapping in Deep Residual Networks 》一文中，推导了为什么短连接更容易训练，也提出了新的短连接块结构。</p><h4 id="为什么-ResNet-build-block-更容易训练？"><a href="#为什么-ResNet-build-block-更容易训练？" class="headerlink" title="为什么 ResNet build block 更容易训练？"></a>为什么 ResNet build block 更容易训练？</h4><h5 id="前向传播中帮助网络中一些层更容易实现恒等映射："><a href="#前向传播中帮助网络中一些层更容易实现恒等映射：" class="headerlink" title="前向传播中帮助网络中一些层更容易实现恒等映射："></a>前向传播中帮助网络中一些层更容易实现恒等映射：</h5><p>　　<strong><em>出现了第一幅图的退化问题，这里假设深层网络的后边层都变成了<font color="red">恒等映射 </font>，那网络就退化成了浅层网络</em></strong>（因为网络很深，所以其中肯定包括了多余的层，这些层会形成<font color="red">恒等映射 </font>关系），原来的直接多个层堆叠的非线性层去直接学习<font color="red"> 恒等映射 </font>优化起来复杂，而加了上图的 <code>短连接</code>块之后，学习<font color="red"> 恒等映射 </font>变容易了。</p><h5 id="反向传播中"><a href="#反向传播中" class="headerlink" title="反向传播中"></a>反向传播中</h5><blockquote><p>　　因为网络中存在<code>恒等映射的短连接通道</code>，假设不加residual模块的输出为h(x)。x=10,h(x)=11,h(x)简化为线性运算Wh​, Wh明显为1.1，加了redidual模块后，F(x)=1, H(x)=F(x)+x=11，F也简化为线性运算,对应的WF为0.1。当标签中的真实值为12，反向传播的损失为1，而对于F中的参数和h中参数回传的损失实际上是一样大的而且梯度都是x的值，但是对于F的参数就从0.1到1.1扩大了十倍多，而h的参数是从1.1到2.1扩大不到2倍，因此redidual模块会明显减小模块中参数的值从而让网络中的参数对反向传导的损失值有更敏感的响应能力，虽然根本上没有解决回传的损失小得问题，但是却让参数减小，相对而言增加了回传损失的效果，也产生了一定的正则化作用。<br><a href="https://blog.csdn.net/weixin_43624538/article/details/85049699?from=timeline&amp;isappinstalled=0&quot;该部分参考这里&quot;" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43624538/article/details/85049699?from=timeline&amp;isappinstalled=0</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;2015年&lt;/code&gt; 论文地址：  &lt;a href=&quot;https://arxiv.org/pdf/1512.03385.pdf&amp;quot;论文地址&amp;quot;&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://arxiv.org
      
    
    </summary>
    
      <category term="计算机视觉论文阅读" scheme="http://www.elgong.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="深度学习论文" scheme="http://www.elgong.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Network in Network</title>
    <link href="http://www.elgong.top/2019/01/24/Network-in-Network/"/>
    <id>http://www.elgong.top/2019/01/24/Network-in-Network/</id>
    <published>2019-01-24T07:08:27.000Z</published>
    <updated>2019-07-12T12:50:21.698Z</updated>
    
    <content type="html"><![CDATA[<p><code>2014年</code> 论文地址：  <a href="https://arxiv.org/abs/1312.4400" title="论文地址" target="_blank" rel="noopener">https://arxiv.org/abs/1312.4400</a></p><h2 id="论文核心"><a href="#论文核心" class="headerlink" title="论文核心"></a>论文核心</h2><p>NIN特点: </p><ul><li>微型网络: <ul><li>增强模型在感受野（receptive field）内对局部区域的辨别能力;  </li></ul></li></ul><ul><li>GAP全局平均池化: <ul><li>强化了特征图与分类的对应关系;</li><li>GAP本身是结构化的正则化器，能避免整体结构的过拟合；</li></ul></li></ul><blockquote><p>　　卷积层使用线性滤波器（卷积核）来扫描输入，后面接一个非线性激活函数。而卷积核是广义线性模型（generalized linear model ）GLM，抽象程度低（该特征对同一概念的变体是不变的）,用更有效的 <code>非线性函数逼近器</code> 代替 <code>GLM</code> 可以增强局部模型的抽象能力。当样本的隐含概念（latent concept）线性可分时，GLM可以达到很好的抽象程度，例如：这些概念的变体都在GLM分割平面的同一边，而<font color="red">传统的CNN就默认了这个假设——认为隐含概念（latent concept）是线性可分的</font>。然而，同一概念的数据通常是非线性流形的（nonlinear manifold），捕捉这些概念的表达通常都是输入的高维非线性函数。在NIN中，GLM用“微型网络”结构替代，该结构是一个<code>非线性函数逼近器</code>。  </p><p>　　本文作者选择多层感知器实例化微型网络，该感知器是一个通用函数逼近器，也是一个通过反向传播训练的神经网络。</p></blockquote><p><img src="/2019/01/24/Network-in-Network/nerworkInNetwork1.png" alt="logo"><br>该图是 单独的 <code>mlpconv 层</code>。<br>这里有没有尝试过其他微型网络结构？？？？（可创新吗）</p><ul><li><h2 id="NIN-网络结构"><a href="#NIN-网络结构" class="headerlink" title="NIN 网络结构"></a>NIN 网络结构</h2><img src="/2019/01/24/Network-in-Network/nerworkInNetwork2.png" alt="logo"></li></ul><p>　　NIN 的整体结构是一系列 <code>mlpconve层</code> 的堆叠，最上层接一个 <code>GAP层</code> 和 <code>分类层</code>。 <code>mlpconv层</code> 间的子层可以被相加，像CNN和maxout网络一样。上图展示了一个包含三个mlpconv层的NIN。每个mlpconv层，包含一个三层的感知器，NIN和微型网络的层数都是灵活的，可以根据具体任务微调。</p><p>　　这里没有采用传统CNN的 <code>全连接层</code> 进行分类，而是直接通过 <code>全局平均池化层（GAP）</code>输出最后一个 <code>mlpconv层特征图</code>的空间平均值作为类别的置信度值，然后将得到的向量输入 <code>softmax层</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;2014年&lt;/code&gt; 论文地址：  &lt;a href=&quot;https://arxiv.org/abs/1312.4400&quot; title=&quot;论文地址&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://arxiv.org/abs/131
      
    
    </summary>
    
      <category term="计算机视觉论文阅读" scheme="http://www.elgong.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="深度学习论文" scheme="http://www.elgong.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>C++梳理笔记</title>
    <link href="http://www.elgong.top/2019/01/20/C-%E6%A2%B3%E7%90%86%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.elgong.top/2019/01/20/C-梳理笔记/</id>
    <published>2019-01-20T12:30:39.000Z</published>
    <updated>2019-07-12T12:50:21.698Z</updated>
    
    <content type="html"><![CDATA[<font color="red"><big>测试内容</big></font><p><del>删除线</del></p><p><a href="http://zhuzhuyule.xyz" target="_blank" rel="noopener">链接</a></p><p><img src="/2019/01/20/C-梳理笔记/test.jpg" alt="logo"></p><h1 id="C-学习笔记"><a href="#C-学习笔记" class="headerlink" title="C++学习笔记"></a>C++学习笔记</h1><h2 id="类型转换："><a href="#类型转换：" class="headerlink" title="类型转换："></a><strong>类型转换：</strong></h2><ol><li><p>隐式转换： 低类型转换为高类型</p><pre><code>浮点数（直接舍掉小数，不四舍五入） + 整数</code></pre></li><li><p>显式转换：</p><pre><code> int **(**z**) = (**int**)** z **= static_cast\&lt;**int**\&gt; (**z**)**</code></pre></li></ol><p>。。。</p><h3 id="数据的输入和输出：信息的流动"><a href="#数据的输入和输出：信息的流动" class="headerlink" title="数据的输入和输出：信息的流动"></a><strong>数据的输入和输出：信息的流动</strong></h3><ol><li><p>输入：</p></li><li><p>输出：</p></li><li><p>流类库的操纵符：</p></li></ol><h3 id="程序控制："><a href="#程序控制：" class="headerlink" title="程序控制："></a><strong>程序控制：</strong></h3><pre><code>    if, while, for, do-while , break, continue, { switch,case,default } ;</code></pre><ol><li><p>do-while:</p><pre><code> do 语句      // 先执行一次 while(表达式)；</code></pre></li><li><p>for的范围，遍历容器：</p></li></ol><h3 id="自定义类型："><a href="#自定义类型：" class="headerlink" title="自定义类型："></a><strong>自定义类型：</strong></h3><ul><li>类型别名： </li></ul><ol><li><p>typedef double Area, V;</p></li><li><p>using Area = double</p></li></ol><ul><li>枚举类型： 有限的个数</li></ul><p>　　　　不限定作用域： enum 类型名 { 变量值列表}</p><p>　　　　限定作用域：</p><p>　　　注：枚举元素是常量，不能赋值</p><p>　　　　　枚举元素有默认值，默认0,1,2,3,4，声明时可以另外指定</p><p>　　　　　可以进行关系运算</p><ul><li><p>auto类型 和decltyoe类型</p><pre><code>      decltype( float( i )) j = 2;   // j值是2，类型是float;      auto m = 2.5;  // m 为float;</code></pre></li><li><p>结构体( C语言中的)： struct</p><pre><code>      struct MyTimeStruct{   //定义 结构体类型          unsigned int year,mouth,day,hour,min,sec;      };</code></pre></li></ul><h2 id="函数：-可重用的功能模块（定义和调用）"><a href="#函数：-可重用的功能模块（定义和调用）" class="headerlink" title="函数： 可重用的功能模块（定义和调用）"></a><strong>函数： 可重用的功能模块（定义和调用）</strong></h2><h3 id="函数定义："><a href="#函数定义：" class="headerlink" title="函数定义："></a><strong>函数定义：</strong></h3><p>　　形参不占用空间，调用时分配；</p><h3 id="函数调用："><a href="#函数调用：" class="headerlink" title="函数调用："></a><strong>函数调用：</strong></h3><p>　　调用前要函数声明： int sum<strong>(</strong> int a<strong>,</strong> int b<strong>);</strong></p><p>　　1. 函数的嵌套调用：</p><p>　　2. 函数的递归调用： 直接或者间接调用自身</p><p>计算n!</p><pre><code>    unsigned int fac( unsigned int n){        if (n == 0) return 1;        return fac( n - 1) * n;    }</code></pre><p>汉诺塔</p><pre><code>    分析：    1.    A 上的n-1个盘子移动到B上（借助C）;    2.    A上剩下的盘子移动到C上；    3.    B上的n-1个盘子移动到C上（借助A）    void move(char src, char obj)    {        cout &lt;&lt; src &lt;&lt; &quot;---&gt;&gt;&gt;&quot; &lt;&lt; obj &lt;&lt; endl;    }    void hanoi(int n, char src, char medium, char obj)    {        if(n == 1)            move(src, obj);        else{            hanoi(n-1, src, obj, medium);            move(src, obj);            hanoi(n-1, medium, src, obj);        }    }</code></pre><h3 id="函数的参数："><a href="#函数的参数：" class="headerlink" title="函数的参数："></a><strong>函数的参数：</strong></h3><ol><li><p>形参不占用空间，调用时分配；</p></li><li><p>计算结果返回多个（利用引用）</p></li><li><p>多个参数时，从后开始传</p></li></ol><h3 id="引用类型（-amp-）：-必须初始化，该类型不可改变，是其他变量的别名"><a href="#引用类型（-amp-）：-必须初始化，该类型不可改变，是其他变量的别名" class="headerlink" title="引用类型（&amp;）： 必须初始化，该类型不可改变，是其他变量的别名"></a><strong>引用类型（&amp;）：</strong> 必须初始化，该类型不可改变，是其他变量的别名</h3><pre><code>    int i, j;    int &amp; ri = i;  // 定义int引用类型变量 ri, 初始化为i的引用</code></pre><h3 id="含有可变参数的函数：（两种方法）"><a href="#含有可变参数的函数：（两种方法）" class="headerlink" title="含有可变参数的函数：（两种方法）"></a><strong>含有可变参数的函数：（两种方法）</strong></h3><ol><li><p>所有实参类型相同：<code>initializer_list&lt;int&gt; li; //类模板, 都是常量</code></p></li><li><p>具体看第九章</p></li><li><p>类型不同：</p></li></ol><h3 id="内联函数（inline）：-用函数体内的语句，替换函数调用表达式，编译时完成，类似-define"><a href="#内联函数（inline）：-用函数体内的语句，替换函数调用表达式，编译时完成，类似-define" class="headerlink" title="内联函数（inline）： 用函数体内的语句，替换函数调用表达式，编译时完成，类似 #define"></a><strong>内联函数（inline）： </strong>用函数体内的语句，替换函数调用表达式，编译时完成，类似 #define</h3><p>声明： <code>inline int calArea(int a){  }</code></p><p>要求： 1. 不能有循环，switch语句 2. 定义在调用之前 3. 不能有异常接口声明</p><h3 id="constexpr-函数：（常量表达式函数）"><a href="#constexpr-函数：（常量表达式函数）" class="headerlink" title="constexpr 函数：（常量表达式函数）"></a>constexpr 函数：（常量表达式函数）</h3><h3 id="带默认参数的函数："><a href="#带默认参数的函数：" class="headerlink" title="带默认参数的函数："></a><strong>带默认参数的函数：</strong></h3><pre><code>    int getVa(int length, int weight = 2)</code></pre><h3 id="函数的重载：（C-多态性的重要机制，编译过程中实现）"><a href="#函数的重载：（C-多态性的重要机制，编译过程中实现）" class="headerlink" title="函数的重载：（C++多态性的重要机制，编译过程中实现）"></a><strong>函数的重载：</strong>（C++多态性的重要机制，编译过程中实现）</h3><p>函数体同名，参数类型不同/参数个数不同</p><pre><code>    int add(int x, int y);    float add(float x, float y);    float add(float x, float y, float z);</code></pre><h3 id="C-系统函数："><a href="#C-系统函数：" class="headerlink" title="C++系统函数："></a><strong>C++系统函数：</strong></h3><pre><code>    #include &lt;cmath&gt;        |_        |_    #include &lt;cstdlib&gt;        |_        |_    #include &lt;cstdio&gt;        |_        |_    #include &lt;ctime&gt;        |_        |_</code></pre><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a><strong>类和对象</strong></h2><p>类：构建对象的蓝图，</p><p>对象：由类创建，含有数据和方法</p><p>封装：对数据和操作数据的方法的组合绑定</p><p>继承：在已有类基础上，形成新的类</p><p>多态：</p><p>构造函数：定义对象时，通过构造函数初始化</p><p>析构函数：删除对象时，通过析构函数释放资源</p><h3 id="类和对象的定义："><a href="#类和对象的定义：" class="headerlink" title=" 类和对象的定义："></a><strong> 类和对象的定义：</strong></h3><p>定义类：</p><pre><code>    class {  //类名称         public:            // 公有成员,外部接口        private:            // 私有成员        protected:            int hour = 0; // 类内初始化            // 保护型成员    }</code></pre><p>注意：不指定类型，默认为私有；</p><h3 id="成员函数："><a href="#成员函数：" class="headerlink" title="成员函数："></a><strong>成员函数：</strong></h3><pre><code>    |_ 内联成员函数： 类内声明或者inline关键字    |_类外实现：void 类名称::成员函数名称（）{ }</code></pre><h3 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a><strong>构造函数：</strong></h3><ul><li><p>在创建对象时，自动调用来初始化数据</p></li><li><p>与类名相同</p></li><li><p>构造函数有初始化列表</p></li><li><p>格式 类名（string s, lei i）：s(初始值)，i(初始值){ }；</p></li></ul><h3 id="委托构造函数：一个构造函数-通过另一个构造函数-初始化"><a href="#委托构造函数：一个构造函数-通过另一个构造函数-初始化" class="headerlink" title="委托构造函数：一个构造函数 通过另一个构造函数 初始化"></a><strong>委托构造函数：</strong>一个构造函数 通过另一个构造函数 初始化</h3><h3 id="复制构造函数："><a href="#复制构造函数：" class="headerlink" title="复制构造函数："></a><strong>复制构造函数：</strong></h3><p>用途：</p><ul><li><p>用存在的对象 去初始化新对象 （通过引用旧的对象）</p></li><li><p>函数f的形参是类的对象，调用f时，将用实参对象初始化形参对象</p></li><li><p>函数g的返回值是类的对象，用return的对象来在主调函数中初始化一个无名对象</p></li></ul><h3 id="析构函数：生存期结束，删除清理工作，不能有return，不能有参数"><a href="#析构函数：生存期结束，删除清理工作，不能有return，不能有参数" class="headerlink" title="析构函数：生存期结束，删除清理工作，不能有return，不能有参数"></a><strong>析构函数：</strong>生存期结束，删除清理工作，不能有return，不能有参数</h3><pre><code>    class 类名{    public:        类名（形参）； // 构造函数        类名（const 类名&amp; 旧对象名）；  // 复制构造函数 =delete是不生成        ~ 类名（）；    }</code></pre><blockquote><p>  注：未声明时，编译器自己生成一个默认的</p></blockquote><h3 id="前向引用声明：两个类相互引用时，某个类在引用之前就声明"><a href="#前向引用声明：两个类相互引用时，某个类在引用之前就声明" class="headerlink" title="前向引用声明：两个类相互引用时，某个类在引用之前就声明"></a><strong>前向引用声明：</strong>两个类相互引用时，某个类在引用之前就声明</h3><pre><code>    class A;  //前向引用声明，只是一个标识符，不是万能的    class B{    public:        void A(B b);    }    class A{    public：        void B（A a）;    }</code></pre><h3 id="结构体：特殊的类，默认是公有的，可以有函数成员"><a href="#结构体：特殊的类，默认是公有的，可以有函数成员" class="headerlink" title="结构体：特殊的类，默认是公有的，可以有函数成员"></a><strong>结构体：</strong>特殊的类，默认是公有的，可以有函数成员</h3><pre><code>    //公有成员        int a;    protected:        int b;    private:        int c;    };</code></pre><h3 id="联合体："><a href="#联合体：" class="headerlink" title="联合体："></a><strong>联合体：</strong></h3><p>目的：存储空间的共用，成员不能同时有效，比如某人语文课成绩，只有一种可能；</p><pre><code>    union Mark{ // 成绩的联合体， 只有一个成立        char grade;  //等级类的成绩        bool pass;  // 是否通过的成绩    int percent;  //百分制成绩  }</code></pre><h3 id="枚举类："><a href="#枚举类：" class="headerlink" title="枚举类："></a><strong>枚举类：</strong></h3><p>enum class 枚举类型名： 底层类型（int）<strong>{</strong> 枚举列表 <strong>};</strong></p><pre><code>//默认 int</code></pre><p>优势：</p><ul><li><p>强制作用域 —必须在枚举类 枚举类型名：：枚举值，不同枚举类可以有同名值了</p></li><li><p>转换限制 —枚举对象不能与整型 隐式转换</p></li><li><p>底层类型 —可以指定</p></li></ul><h2 id="数据共享和保护："><a href="#数据共享和保护：" class="headerlink" title="数据共享和保护："></a><strong>数据共享和保护：</strong></h2><h3 id="作用域分类："><a href="#作用域分类：" class="headerlink" title="作用域分类："></a><strong>作用域分类：</strong></h3><p>函数原型作用域：</p><ul><li>形参的范围在（）内，所以不需要名字也行，int area( int );</li></ul><p>局部作用域</p><ul><li><p>函数{ }内</p></li><li><p>if、for、while { }内</p></li></ul><p>类作用域： 类外访问类的成员</p><ul><li><p>静态成员：通过 对象名.成员名 访问</p></li><li><p>非静态成员：</p></li><li><p>文件作用域</p></li><li><p>命名空间作用域： 10章</p></li></ul><h3 id="对象的生存期："><a href="#对象的生存期：" class="headerlink" title="对象的生存期："></a><strong>对象的生存期：</strong></h3><p>静态生存期： 整个程序结束后消失</p><ul><li>函数内的静态对象， 用static ，全局寿命，只局部可见</li></ul><p>动态生存期：</p><ul><li><p>离开作用域后消失</p></li><li><p>下次进函数重新生成对象</p></li></ul><h3 id="类的静态数据成员："><a href="#类的静态数据成员：" class="headerlink" title="类的静态数据成员："></a><strong>类的静态数据成员：</strong></h3><ul><li><p>static 声明</p></li><li><p>为该类所有对象共享，具有静态生存期</p></li><li><p>必须在类外定义和初始化，类内声明，用：：指明所属于的类</p></li></ul><p>比如记录 类产生了多少对象；opencv中的Mat对象好像用到了？？？？</p><pre><code>    class base{           public :                  static   int   _num;//声明       };       int  base::_num=0;  //真正定义  </code></pre><h3 id="类的友元："><a href="#类的友元：" class="headerlink" title="类的友元："></a><strong>类的友元：</strong></h3><ul><li><p>破坏数据封装和数据隐藏的机制</p></li><li><p>尽量不用</p></li></ul><h3 id="友元函数："><a href="#友元函数：" class="headerlink" title=" 友元函数："></a><strong> 友元函数：</strong></h3><ul><li><p>类声明中由关键字 friend 修饰说明的非成员函数</p></li><li><p>可以在其函数体内访问对象的private,protected成员</p></li><li><p>但必须通过对象名：：访问，函数参数为类的引用</p></li><li><h3 id="友元类："><a href="#友元类：" class="headerlink" title=" 友元类："></a><strong> 友元类：</strong></h3><pre><code>class A{    friend B;  public:    void display(){        count &lt;&lt; x &lt;&lt; enld;    }  private:    int x;}class B{  public:    void set(int i);    void display();  private:    A a;}void B::set(int i){    a.x = i;   // B类中改变 A类私有值}void B::display(){    a.display()}</code></pre></li></ul><h3 id="共享数据的保护："><a href="#共享数据的保护：" class="headerlink" title="共享数据的保护："></a><strong>共享数据的保护：</strong></h3><h1 id="常类型：const"><a href="#常类型：const" class="headerlink" title="常类型：const"></a><strong>常类型：</strong>const</h1><p>常对象：必须初始化，不可更新</p><pre><code>    class A{    }    A const a; // a是常对象</code></pre><p>常成员：(不可以放在构造函数体内复制，可以在初始化列表中)</p><pre><code>    A：：A(int i):a(i){ }</code></pre><ul><li><p>常数据成员：const修饰的</p></li><li><p>静态常数据成员： static const int b;</p></li><li><p>常函数成员（用来处理常对象的函数）</p><ul><li><p>不更新对象的数据成员</p></li><li><p>声明和实现都带const</p></li></ul></li></ul><pre><code>        class A{            void f（int a）const;        }        void A::f(int a) const{          }; // f是常对象函数, 处理常对象</code></pre><ul><li>常引用：不可更新</li></ul><p>　　　引用是双向传递的，避免修改原值的方法就是常引用；</p><pre><code>     const A&amp; a;</code></pre><ul><li><p>常数组：</p></li><li><p>常指针：</p></li></ul><h3 id="多文件结构和预编译命令："><a href="#多文件结构和预编译命令：" class="headerlink" title="多文件结构和预编译命令："></a><strong>多文件结构和预编译命令：</strong></h3><ul><li><p>.h 系统使用</p></li><li><p>.hpp 个人使用(类的声明,函数的声明)</p></li><li><p>.cpp (类的实现，函数的实现)</p><p> <img src="/2019/01/20/C-梳理笔记/f5d645ed218d5fa3e753f771b72310fc.png" alt=""></p></li></ul><h3 id="外部变量："><a href="#外部变量：" class="headerlink" title="外部变量："></a><strong>外部变量：</strong></h3><p>文件作用域中定义的变量默认是外部变量，其他文件使用前，extern声明</p><p>将变量和函数限制在编译单元内：namespcae:</p><pre><code>    namespace{ //匿名的命名空间，外部不可调用任何东西        int i;        void fun(){            i++;        }    }</code></pre><h3 id="预编译命令："><a href="#预编译命令：" class="headerlink" title="预编译命令："></a><strong>预编译命令：</strong></h3><pre><code>    #include&lt; &gt;  标准方式搜索，从系统目录include    #include”” 先当前目录搜索，没有再标准搜索    #define     #undef 删除有#define的宏    #if 表达式  // 条件编译指令    ---    #else    ---    #endif     #ifndef 标识符    ---    #else      ---    #endif</code></pre><h2 id="数组，指针与字符串："><a href="#数组，指针与字符串：" class="headerlink" title="数组，指针与字符串："></a><strong>数组，指针与字符串：</strong></h2><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a><strong>数组：</strong></h3><p>定义： <code>int arr**[**m**][**n**]**…;</code></p><p>　　注：二维数组中 arr[1] 第二行首地址</p><h3 id="数组作为函数参数："><a href="#数组作为函数参数：" class="headerlink" title="数组作为函数参数："></a><strong>数组作为函数参数：</strong></h3><p>　　数组名做参数： 形参，实参都是数组名，传入的是地址</p><h3 id="对象数组："><a href="#对象数组：" class="headerlink" title="对象数组："></a><strong>对象数组：</strong></h3><p>　　定义：类名 数组名[对象元素个数]</p><p>　　访问：数组名[下标].成员名</p><h3 id="基于范围的for循环：c-11-自动遍历整个容器"><a href="#基于范围的for循环：c-11-自动遍历整个容器" class="headerlink" title="基于范围的for循环：c++11,自动遍历整个容器"></a><strong>基于范围的for循环：</strong>c++11,自动遍历整个容器</h3><pre><code>  for( auto x : 容器){ } for( auto &amp;x : 容器){ }</code></pre><p>注意：</p><ul><li><p>auto &amp;x是元素引用，auto x是元素的副本</p></li><li><p>auto推导出的类型是容器中的值类型</p></li><li><p>：冒号后的表达式只执行一次</p></li></ul><h3 id="指针："><a href="#指针：" class="headerlink" title="指针："></a><strong>指针：</strong></h3><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义：</strong></h3><pre><code>    static int i;    static int * p = &amp;I;</code></pre><h3 id="指针的初始化和赋值："><a href="#指针的初始化和赋值：" class="headerlink" title="指针的初始化和赋值："></a><strong>指针的初始化和赋值：</strong></h3><h3 id="指针的算术运算，关系运算："><a href="#指针的算术运算，关系运算：" class="headerlink" title="指针的算术运算，关系运算："></a><strong>指针的算术运算，关系运算：</strong></h3><h3 id="指针数组："><a href="#指针数组：" class="headerlink" title="指针数组："></a><strong>指针数组：</strong></h3><pre><code>    类名  *p[2];</code></pre><h3 id="指向数组的指针："><a href="#指向数组的指针：" class="headerlink" title="指向数组的指针："></a><strong>指向数组的指针：</strong></h3><pre><code>    int **p; 指向二维数组的指针</code></pre><h3 id="指针与函数："><a href="#指针与函数：" class="headerlink" title="指针与函数："></a><strong>指针与函数：</strong></h3><ul><li><p>指针做参数：大批量数据提高效率</p></li><li><p>指针类型的函数：返回类型是指针</p><pre><code>  int * function(int i){return 全局或者静态的 }；// 不能返回非静态局部变量</code></pre></li><li><p>指向函数的指针：实现函数回调的功能</p></li></ul><blockquote><p>  定义： 数据类型 (*f)(参数表);</p><p>  数据类型：返回值</p></blockquote><ul><li>对象指针：</li></ul><blockquote><p>  定义： 类名 *对象指针名 = &amp; 对象；</p><p>  访问对象： 对象指针名->成员名</p></blockquote><p>（*对象指针名）.成员名</p><ul><li><p>this 指针：成员函数的一个隐士参数，初始化为对象的地址，不可改变</p></li><li><p>隐含于类的每个非静态成员函数中</p></li><li><p>指出成员函数所操作的当前的对象</p></li><li><p>*this 是当前对象地址</p></li></ul><h3 id="动态内存分配："><a href="#动态内存分配：" class="headerlink" title="动态内存分配："></a><strong>动态内存分配：</strong></h3><p>new<strong> 类型名 </strong>(<strong>初始化列表</strong>) // 返回首字节地址</p><p>delete 指针p //p一直在，删除的只是p指向的对象申请的空间</p><p>动态数组：<br>new 类型名[数组长度]</p><p>delete[] 数组首地址p指针</p><h3 id="智能指针：C-11"><a href="#智能指针：C-11" class="headerlink" title="智能指针：C++11"></a><strong>智能指针：</strong>C++11</h3><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><strong>内存管理</strong></h3><ul><li><p>unique_ptr:</p><ul><li>不允许多个指针共享资源，标准库中move可以转移指针，但原来指针会失效</li></ul></li><li><p>shared_ptr:</p><ul><li>多指针共享</li></ul></li><li><p>weak_ptr:</p><ul><li>可复制共享</li></ul></li></ul><blockquote><p>  Vector对象：类模板</p></blockquote><p>优势：</p><ul><li><p>封装任何形式的动态数组，自动创建，删除</p></li><li><p>下标越界检查</p></li></ul><p>定义： vector &lt;元素类型&gt; object（长度）</p><ul><li><p><code>object.begin()  object.end()  object.size()</code></p></li><li><p>auto 遍历vector <code>for(auto e: object);</code></p></li></ul><h3 id="对象的复制和移动："><a href="#对象的复制和移动：" class="headerlink" title="对象的复制和移动："></a><strong>对象的复制和移动：</strong></h3><ul><li><p>浅层复制和深层复制：复制对象用到复制构造函数，默认的复制构造只传递了指针，两个变量指向同一块内存，释放其中一个，再释放第二个会出错；</p><ul><li><p>浅层：实现对象间数据一一对应的复制，但两个对象指向同一内存</p></li><li><p>深层：当对象成员是指针类型，应该对指针所指对象进行复制。</p></li></ul></li></ul><blockquote><p>  类名<strong>::</strong>类名<strong>(</strong>const 类名<strong>&amp;</strong> v<strong>){</strong></p><p>  size <strong>=</strong> v<strong>.</strong>size<strong>;</strong></p><p>  data_ptr <strong>= new</strong> Ponit<strong>[</strong>size<strong>];</strong></p><p>  <strong>for(</strong>int i<strong>=</strong>0<strong>;</strong> i <strong>\&lt;</strong> size<strong>; ++</strong>i<strong>){</strong></p><p>  data_ptr<strong>[</strong>i<strong>] =</strong> v<strong>.</strong>data_ptr<strong>[</strong>i<strong>];</strong></p><p>  <strong>}</strong></p><p>  <strong>}</strong></p></blockquote><ul><li><p>移动构造：C++11,省去了构造和删除临时对象的过程</p><p><img src="/2019/01/20/C-梳理笔记/8c3092d99bcdba78edeb2d8123270ffe.png" alt=""></p></li></ul><blockquote><p>  class_name<strong>(</strong>class_name <strong>&amp;&amp;</strong>old<strong>)::</strong>xptr<strong>(</strong>old<strong>.</strong>xptr<strong>){</strong></p><p>  n<strong>.</strong>xptr <strong>= NULL;</strong> // 原来的指针清空</p><p>  <strong>}</strong></p></blockquote><h3 id="C风格字符串：字符数组"><a href="#C风格字符串：字符数组" class="headerlink" title="C风格字符串：字符数组"></a><strong>C风格字符串：</strong>字符数组</h3><h3 id="string类："><a href="#string类：" class="headerlink" title="string类："></a><strong>string类：</strong></h3><p>常用构造函数：</p><ul><li><p>string(); //默认构造，长度为0</p><ul><li>string s1<strong>;</strong></li></ul></li><li><p>string(const char *s) //指针s所指向的字符串常量初始化该对象</p><pre><code>string s2 = “abc”;string(const string &amp;rhs) //复制构造函数string s3 = s2;</code></pre></li></ul><p>访问：下标访问</p><p>整行字符串的输入： cin 被空格隔开</p><p>getline(cin,s2); //包含#include\<string\></string\></p><p>getline(cin,s2,’,’);</p><h2 id="继承和派生：-充分利用原有的"><a href="#继承和派生：-充分利用原有的" class="headerlink" title="继承和派生： 充分利用原有的"></a><strong>继承和派生：</strong> 充分利用原有的</h2><p>继承：保持已有类的特征来构造新类</p><p>派生：在已有类基础上新增自己的特性</p><p>基类：父类</p><p>派生类：子类</p><p>直接基类和间接基类</p><p>单继承：</p><pre><code>class 派生类名：继承方式 基类名{  //继承方式，    成员声明；//新增成员的声明}</code></pre><p>多继承：</p><pre><code>class 派生类名：继承方式1 基类1，继承方式2 基类2{    成员声明；}</code></pre><h3 id="继承的方式："><a href="#继承的方式：" class="headerlink" title="继承的方式："></a><strong>继承的方式：</strong></h3><p>控制：派生类对基类成员的访问权限</p><ul><li>公有继承 public</li></ul><blockquote><p>  基类中的pubilc和protected访问属性在派生类中不变</p><p>  基类的pravate不可被对象直接访问</p></blockquote><ul><li><p>私有继承 ：内部可以访问基类的公有和保护成员，但是其对象不再可以访问</p></li><li><p>保护继承 ：基类的公有和保护，到这都成了保护成员，类内可以访问，但对象不能</p></li></ul><p>派生类的构成：</p><ul><li><p>吸收基类成员</p></li><li><p>改造基类成员</p><ul><li>增加同名成员，基类成员被覆盖（重新定义继承的成员函数必须用虚函数）</li></ul></li><li><p>添加新成员</p></li></ul><h3 id="类型转换：-1"><a href="#类型转换：-1" class="headerlink" title="类型转换："></a><strong>类型转换：</strong></h3><p>基类和派生类之间：</p><p>派生类的对象可以隐含转换为基类对象；</p><p>派生类的对象可以初始化基类的引用；</p><p>派生类的指针可以隐含转换为基类的指针；</p><h3 id="派生类的构造函数："><a href="#派生类的构造函数：" class="headerlink" title="派生类的构造函数："></a><strong>派生类的构造函数：</strong></h3><p>默认情况下，基类的构造函数不被继承，派生类需要自己构造</p><p>c++11，using语句继承基类构造函数</p><h3 id="派生类的复制构造函数："><a href="#派生类的复制构造函数：" class="headerlink" title="派生类的复制构造函数："></a><strong>派生类的复制构造函数：</strong></h3><h3 id="派生类的析构函数："><a href="#派生类的析构函数：" class="headerlink" title="派生类的析构函数："></a><strong>派生类的析构函数：</strong></h3><h3 id="虚基类："><a href="#虚基类：" class="headerlink" title="虚基类："></a><strong>虚基类：</strong></h3><h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a><strong>多态性</strong></h2><h3 id="运算符重载："><a href="#运算符重载：" class="headerlink" title="运算符重载："></a><strong>运算符重载：</strong></h3><pre><code>//双目运算符函数类型 operator 运算符（参数）  {    // 参数个数 = 原操作数个数 - 1}//前置单目运算符，返回引用所以可以当左值函数类型 &amp; operator ++（无参数）  {    return * this;}//后置单目运算符，函数类型 operator ++（参数为int类型）  {    old = *this;    ++(*this);  //调用的前置    return old;}</code></pre><ul><li>重载为非成员函数：</li></ul><ol><li><p>列出所有操作数</p></li><li><p>至少有一个自定义类型参数</p></li><li><p>后置单目运算，参数要增加int,但不用写形参名</p></li><li><p>要操作某类对象的私有成员，则可声明为该类的友元函数</p></li></ol><h3 id="虚函数：virtual改造基类成员，实现动态绑定；必须是非静态成员"><a href="#虚函数：virtual改造基类成员，实现动态绑定；必须是非静态成员" class="headerlink" title="虚函数：virtual改造基类成员，实现动态绑定；必须是非静态成员"></a><strong>虚函数：</strong>virtual改造基类成员，实现动态绑定；必须是非静态成员</h3><blockquote><p>  原理：编译时先不确定和哪个类的成员对应，在程序运行时刻，再对应；</p></blockquote><pre><code>#include &lt;iostream&gt;using namespace std;class Base1{public:    virtual void display() const; //虚函数，不要用内联};void Base1::display() const{    cout &lt;&lt; &quot;Base1 &quot; &lt;&lt; endl;}class Base2:public Base1{public:    virtual void display() const;}void Base2::display() const{    cout &lt;&lt; &quot;Base2&quot; &lt;&lt; endl;}</code></pre><h3 id="虚析构函数：打算通过基类指针调用某一个对象的析构函数（执行delete）"><a href="#虚析构函数：打算通过基类指针调用某一个对象的析构函数（执行delete）" class="headerlink" title="虚析构函数：打算通过基类指针调用某一个对象的析构函数（执行delete）"></a><strong>虚析构函数：</strong>打算通过基类指针调用某一个对象的析构函数（执行delete）</h3><h3 id="虚表和动态绑定："><a href="#虚表和动态绑定：" class="headerlink" title="虚表和动态绑定："></a><strong>虚表和动态绑定：</strong></h3><blockquote><p>  虚表：</p></blockquote><ul><li><p>每个多态类都有虚表；</p></li><li><p>存放各个数函数的入口地址；</p></li><li><p>每个对象有指向当前类的虚表的指针（虚指针vptr）；</p></li></ul><blockquote><p>  动态绑定：</p></blockquote><ul><li>构造函数为对象的虚指针赋值</li></ul><h3 id="抽象类：含有纯虚函数的类-不能直接定义对象"><a href="#抽象类：含有纯虚函数的类-不能直接定义对象" class="headerlink" title="抽象类：含有纯虚函数的类,不能直接定义对象"></a><strong>抽象类：</strong>含有纯虚函数的类,不能直接定义对象</h3><blockquote><p>  纯虚函数：</p><p>  基类中声明的虚函数，在基类中没有定义具体的操作，要求在派生类中根据实际需求完</p><p>  成自己的版本：</p></blockquote><pre><code>virtual 函数类型 函数名**(**参数名**) =** 0**;**</code></pre><h3 id="override-和-final-C-11"><a href="#override-和-final-C-11" class="headerlink" title="override 和 final :C++11"></a><strong>override 和 final :</strong>C++11</h3><p>override声明的函数，必须在基类中找到原型；</p><p>final 不允许继承或者覆盖；</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a><strong>模板</strong></h2><h3 id="函数魔板：整数和浮点数求绝对值，需要多次重载函数，但是用函数模板，只需要设计通用功能；"><a href="#函数魔板：整数和浮点数求绝对值，需要多次重载函数，但是用函数模板，只需要设计通用功能；" class="headerlink" title="函数魔板：整数和浮点数求绝对值，需要多次重载函数，但是用函数模板，只需要设计通用功能；"></a><strong>函数魔板：</strong>整数和浮点数求绝对值，需要多次重载函数，但是用函数模板，只需要设计通用功能；</h3><p>template\&lt;模板参数表> // 类型：class或者typename 常量：</p><p>函数定义</p><pre><code>template&lt;typename T&gt;T abs(T x){    return x&lt;0?-x:x;}</code></pre><h3 id="类模板："><a href="#类模板：" class="headerlink" title="类模板："></a><strong>类模板：</strong></h3><pre><code>template&lt;模板参数表&gt;class 类名{    类成员声明;}//类成员定义template &lt;模板参数表&gt;类型名  类名&lt;模板参数标识符列表&gt; :: 函数名(参数表){}</code></pre><h3 id="线性群体：按位置顺序有序排列"><a href="#线性群体：按位置顺序有序排列" class="headerlink" title="线性群体：按位置顺序有序排列"></a><strong>线性群体：</strong>按位置顺序有序排列</h3><p>直接访问：</p><p>数组类模板：</p><p>索引访问：</p><p>顺序访问：</p><p>链表类和结点类模板：</p><p>单链表：每个结点包括数据和指针，只有一个指向后续结点的称为单链表；</p><p><img src="/2019/01/20/C-梳理笔记/9167a427f849e864c5d630d0c0bc3163.png" alt=""></p><p>单链表结点类模板：</p><pre><code>template &lt;class T&gt;class Node{    private:        Node&lt;T&gt; *next;    public:        T data;         Node(const T&amp;item,Node&lt;T&gt;* next = 0);  //构造函数    void insertAfter(Node&lt;T&gt; *p); //插入    Node&lt;T&gt; *deleteAfter();  //删除    Node&lt;T&gt; *nextNode() const; }template &lt;class T&gt;void Node&lt;T&gt;::insertAfter(Node&lt;T&gt; *p){  // *p是要插入的结点// p节点的指针指向当前节点的后续结点    p-&gt;next = next; // next是原链表待插入位置的结点的指针    next = p;  }template &lt;class T&gt;Node&lt;T&gt; *deleteAfter(){    Node&lt;T&gt; * tempPtr = next;    if (next == NULL)  //判断是否是删除最后的元素        return 0;    next = tempPtr = next;    return tempPtr;}</code></pre><blockquote><p>  插入：</p></blockquote><p><img src="/2019/01/20/C-梳理笔记/85d072d9c8a8366378b00b9af8ca4920.png" alt=""></p><blockquote><p>  头插法：可以当队列</p><p>  尾插法：栈</p><p>  删除：</p></blockquote><p><img src="/2019/01/20/C-梳理笔记/ffdd5c0226d2a3f9a7833379eb0ebf90.png" alt=""></p><p>待查询：</p><p>explicit关键字</p><p>构造函数 explicit可以抑制内置类型隐式转换</p><h2 id="泛型设计"><a href="#泛型设计" class="headerlink" title="泛型设计"></a><strong>泛型设计</strong></h2><p>基本概念：</p><p>编写不依赖具体数据类型的程序，通用的；</p><p>STL简介：(Standard Template Library)</p><p>C++ string类库入门：</p><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(){    // 构造函数：    string str1 = &quot;Yesterday&quot;;    string str2(&quot;Today&quot;);    string str3(&quot;Hello&quot;,2); //取c风格字符串 长度为 2 作为初值，即&quot;He&quot;    string str4(str1, 6); // 始于位置6开始的字符串，即&quot;day&quot;    string str5(str1,6,1); // 始于6，长度1，即&quot;d&quot;    string str6(1,&#39;a&#39;); //6个&#39;a&#39;    // 赋值，交换    str1.assign(&quot;hahahaha&quot;); //重新赋值    swap(str1,str2); //交换两个字符串内容 str1=&quot;Today&quot; str2=&quot;hahahaha&quot;    // 追加    str1 += &quot; we&quot;; // += 可追加 string对象，字符串，字符    str1.append(&quot; ar&quot;); // append 可追加 string对象，字符串    str1.push_back(&#39;e&#39;); //push_back 只能追加字符 str1 = &quot;Today we are&quot;    // 插入    str1.insert(0,&quot; family&quot;); //str1 = &quot;Today we are family&quot;    // 删除    str1.erase(2,1); //第2个位置开始， len = 1 个字符    str1.clear(); //删除全部    // 访问字符串    string s = &quot;asdfgh&quot;;    cout &lt;&lt; s[1]; // &#39;s&#39;    cout &lt;&lt; s.at(2); // &#39;d&#39;    // 查找    int position = s.find(&#39;f&#39;,0); // 从0开始查找第一次出现‘f’的坐标    // 替换    s.replace(s.find(&#39;f&#39;),3,&quot;ZZZ&quot;); //替换find的位置处    3个字符串为 “ZZZ”    // 分割    getchar();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font color=&quot;red&quot;&gt;&lt;big&gt;测试内容&lt;/big&gt;&lt;/font&gt;


&lt;p&gt;&lt;del&gt;删除线&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://zhuzhuyule.xyz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接&lt;/a&gt;&lt;/p
      
    
    </summary>
    
      <category term="C++" scheme="http://www.elgong.top/categories/C/"/>
    
    
      <category term="C++" scheme="http://www.elgong.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>欢迎来我的小屋！</title>
    <link href="http://www.elgong.top/2019/01/18/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E6%88%91%E7%9A%84%E5%B0%8F%E5%B1%8B%EF%BC%81/"/>
    <id>http://www.elgong.top/2019/01/18/欢迎来我的小屋！/</id>
    <published>2019-01-18T06:54:22.000Z</published>
    <updated>2019-07-12T12:50:21.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈哈"><a href="#哈哈" class="headerlink" title="哈哈"></a>哈哈</h1><h2 id="试试效果"><a href="#试试效果" class="headerlink" title="试试效果"></a>试试效果</h2><blockquote><p>一直想建一个自己的网站</p></blockquote><pre><code>现在先试试这个</code></pre><ul><li></li></ul><ol><li>aa</li><li>bb</li><li>cc</li><li>dd</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哈哈&quot;&gt;&lt;a href=&quot;#哈哈&quot; class=&quot;headerlink&quot; title=&quot;哈哈&quot;&gt;&lt;/a&gt;哈哈&lt;/h1&gt;&lt;h2 id=&quot;试试效果&quot;&gt;&lt;a href=&quot;#试试效果&quot; class=&quot;headerlink&quot; title=&quot;试试效果&quot;&gt;&lt;/a&gt;试试效果&lt;/h
      
    
    </summary>
    
      <category term="闲聊" scheme="http://www.elgong.top/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="http://www.elgong.top/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
</feed>
