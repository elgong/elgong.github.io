<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>elgong&#39;s Home.</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.elgong.top/"/>
  <updated>2020-07-04T04:37:50.880Z</updated>
  <id>http://www.elgong.top/</id>
  
  <author>
    <name>elgong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql 笔记</title>
    <link href="http://www.elgong.top/2020/07/04/mysql-%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.elgong.top/2020/07/04/mysql-笔记/</id>
    <published>2020-07-04T04:37:17.000Z</published>
    <updated>2020-07-04T04:37:50.880Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><a href="http://note.youdao.com/noteshare?id=c98cc599b42b416ea2bd0aec7fd11fff&amp;sub=833E6D40B97E4F2F98EFD56C010FE4C7" target="_blank" rel="noopener">JDBC 使用</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=71dd174ad72a6cca26ae011637d4a705&amp;sub=E3BE9112006D4380953846BA1E446964" target="_blank" rel="noopener">mysql必知必会</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=4d74a6536781f195ffb428a0aa74fabe&amp;sub=9A407FE68AB54120B18950BEE5500BAF" target="_blank" rel="noopener">数据库-三大范式</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=78c16d370ba2bf4d06fd1d253072d582&amp;sub=6B15DEFDC24B4353A5820B68A5FB2C05" target="_blank" rel="noopener">数据库ER图基础</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=f0c534778c8fde528be10f4ffdb2c03b&amp;sub=336222838CDC4F249C1210E24D3701AD" target="_blank" rel="noopener">mysql必知必会1-DDL数据定义语言</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=360395368205af6b9cd43b67c17200af&amp;sub=3BAEE4ACEA0F4FC2A40AB4DC39965766" target="_blank" rel="noopener">mysql必知必会2-DML数据操作语句</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=3a8535b5bdf8fbe6b46b85a8f6ab707e&amp;sub=0C9D47245F604624A95E1982D45157F2" target="_blank" rel="noopener">mysql必知必会3-TCL事务控制语言</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=5a66c81500067c3bafc11fb31cc56cd6&amp;sub=6ADA92683A36438EB254D18AE729A6FA" target="_blank" rel="noopener">mysql必知必会4-数据类型和约束</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=8b1f73787548684951c21dea07576331&amp;sub=E95C55AAF40F4378B7A14176911B4B81" target="_blank" rel="noopener">mysql必知必会5-视图</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=d71e1773bdfb453b885ec8280980823e&amp;sub=B0AFAE28DCC94DF09AE25F420927921E" target="_blank" rel="noopener">mysql必知必会6-变量，存储过程，函数….</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=71dd174ad72a6cca26ae011637d4a705&amp;sub=E3BE9112006D4380953846BA1E446964" target="_blank" rel="noopener">mysql必知必会7</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=003c0cce526f2a71945614993d250377&amp;sub=56317DB968F04FE3BCC0D482D083C877" target="_blank" rel="noopener">索引优化1-索引的概念 </a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=a527e1fa83cc6b429814c2f8710b891c&amp;sub=9B9BDA5A138144B5A5A5E5C4BE6CE1D1" target="_blank" rel="noopener">索引优化2-Mysql索引的底层实现 </a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=f35d29b727ca3a228bfad4aac0a9e9e6&amp;sub=53F88FCDB69547E895DAD25A7D402035" target="_blank" rel="noopener">索引优化3- explain 查看执行计划 </a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=a83b6505ac7dbb6b3c69afd1860b8ccb&amp;sub=C419B2D7DA254E589E0F449A60544A1C" target="_blank" rel="noopener">Sql语句优化-查询截取分析 </a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=f8935a502a43186c1c821ad33ccc2c6d&amp;sub=5D286DE5F8304B8BA7290255DBF15C0C" target="_blank" rel="noopener">mysql-数据库锁的机制和原理 </a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://note.youdao.com/noteshare?id=c98cc599b42b416ea2bd0aec7fd11fff&amp;amp;sub=833E6D40B97E4F2F98EFD56C010FE4C7&quot; target=&quot;
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.elgong.top/categories/mysql/"/>
    
    
      <category term="索引" scheme="http://www.elgong.top/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络知识</title>
    <link href="http://www.elgong.top/2020/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    <id>http://www.elgong.top/2020/07/04/计算机网络知识/</id>
    <published>2020-07-04T04:35:59.000Z</published>
    <updated>2020-07-04T04:36:39.272Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><a href="http://note.youdao.com/noteshare?id=92e3adba9198d367e976bcc3f772d149&amp;sub=7F7B0D8B9F3E4D7996815384809C35EA" target="_blank" rel="noopener">互联网协议入门1-模型分层</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=8c41ad2717d4deee47f83841e49d755b&amp;sub=C0C042EE387F4A0096F427CE6F391887" target="_blank" rel="noopener">互联网协议入门2-访问网页的过程</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=e7f3f660c5df2335b7eccb7be89ce514&amp;sub=A775AFCC161A4388859120A340BDC6CB" target="_blank" rel="noopener">互联网协议入门3-TCP协议详细内容</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=71031b3ed61c6e8bd302a8577f6c396f&amp;sub=0F5DF1F408844E7184F3A6BB5F868F89" target="_blank" rel="noopener">互联网协议入门4-Http协议（应用层)</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://note.youdao.com/noteshare?id=92e3adba9198d367e976bcc3f772d149&amp;amp;sub=7F7B0D8B9F3E4D7996815384809C35EA&quot; target=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据分析-pandas包</title>
    <link href="http://www.elgong.top/2020/07/04/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-pandas%E5%8C%85/"/>
    <id>http://www.elgong.top/2020/07/04/数据分析-pandas包/</id>
    <published>2020-07-04T04:34:32.000Z</published>
    <updated>2020-07-04T04:35:28.300Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="http://note.youdao.com/noteshare?id=f191fc11a263f303532d40c02c1f2161&amp;sub=3F6F9858E4DA4B7A9245F66557B15AB4" target="_blank" rel="noopener">pandas</a></li><li><a href="http://note.youdao.com/noteshare?id=64c2febf14a2e0f96bcbc868375500b9&amp;sub=0B21232330E442118F68ADFB44DECA6E" target="_blank" rel="noopener">pandas-1数据结构</a></li><li><a href="http://note.youdao.com/noteshare?id=7b8a86d71c5321171292fa000666efc8&amp;sub=A1102303D97F4E2D836A588F4882C5E2" target="_blank" rel="noopener">pandas-2索引和选择数据</a></li><li><a href="http://note.youdao.com/noteshare?id=02c6e6a9916d2f600153fa5402395c29&amp;sub=0CF2D73FB22140A29F3838CF6EF299B9" target="_blank" rel="noopener">pandas-分层和多级索引</a></li><li><a href="http://note.youdao.com/noteshare?id=b8d6c15c3d603261cee9b6771732c5a5&amp;sub=WEB9f17e5d4ecb0520c9c27c8145f3450dc" target="_blank" rel="noopener">pandas-4分组与聚合</a></li><li><a href="http://note.youdao.com/noteshare?id=57496ba2051b12d778ac17612d871354&amp;sub=62AE7AB578AF4B3A9D630676179C8CA0" target="_blank" rel="noopener">pandas-5缺失值处理</a></li><li><a href="http://note.youdao.com/noteshare?id=f16646b876ddb2c5ec482e316ca881dd&amp;sub=8024BDCE94B4455FA20514234C7233C0" target="_blank" rel="noopener">pandas-6重复值处理</a></li><li><a href="http://note.youdao.com/noteshare?id=5210591266c5f2472eab6bdb0e1adc7e&amp;sub=7B85239BB0C74343830F3EBBC34F43A0" target="_blank" rel="noopener">pandas-7时间处理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://note.youdao.com/noteshare?id=f191fc11a263f303532d40c02c1f2161&amp;amp;sub=3F6F9858E4DA4B7A9245F66557B15AB4&quot; target=&quot;_bl
      
    
    </summary>
    
      <category term="数据分析" scheme="http://www.elgong.top/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="pandas" scheme="http://www.elgong.top/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>快速幂运算</title>
    <link href="http://www.elgong.top/2020/07/04/%E5%BF%AB%E9%80%9F%E5%B9%82%E8%BF%90%E7%AE%97/"/>
    <id>http://www.elgong.top/2020/07/04/快速幂运算/</id>
    <published>2020-07-04T04:31:43.000Z</published>
    <updated>2020-07-04T04:36:49.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先贴有道云笔记，未来整理。。"><a href="#先贴有道云笔记，未来整理。。" class="headerlink" title="先贴有道云笔记，未来整理。。"></a>先贴有道云笔记，未来整理。。</h2><p><a href="http://note.youdao.com/noteshare?id=4d602eda6d51d1f1a656694951e218ba&amp;sub=F32C820CFFE44712A988E55C186BD8E3" target="_blank" rel="noopener">快速幂运算</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;先贴有道云笔记，未来整理。。&quot;&gt;&lt;a href=&quot;#先贴有道云笔记，未来整理。。&quot; class=&quot;headerlink&quot; title=&quot;先贴有道云笔记，未来整理。。&quot;&gt;&lt;/a&gt;先贴有道云笔记，未来整理。。&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://note.y
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://www.elgong.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="快速幂运算" scheme="http://www.elgong.top/tags/%E5%BF%AB%E9%80%9F%E5%B9%82%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>计算根号N</title>
    <link href="http://www.elgong.top/2020/07/04/%E8%AE%A1%E7%AE%97%E6%A0%B9%E5%8F%B7N/"/>
    <id>http://www.elgong.top/2020/07/04/计算根号N/</id>
    <published>2020-07-04T04:10:33.000Z</published>
    <updated>2020-07-04T04:32:03.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以下是有道云笔记，有时间再整理成md"><a href="#以下是有道云笔记，有时间再整理成md" class="headerlink" title="以下是有道云笔记，有时间再整理成md"></a>以下是有道云笔记，有时间再整理成md</h2><p><a href="http://note.youdao.com/noteshare?id=1f4c84db61ceb66dcebabe0bc167b5e6&amp;sub=FCBCB5CEC9214D0AB928BDE0968C8947" target="_blank" rel="noopener">计算根号N- （折半法+牛顿迭代法)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;以下是有道云笔记，有时间再整理成md&quot;&gt;&lt;a href=&quot;#以下是有道云笔记，有时间再整理成md&quot; class=&quot;headerlink&quot; title=&quot;以下是有道云笔记，有时间再整理成md&quot;&gt;&lt;/a&gt;以下是有道云笔记，有时间再整理成md&lt;/h2&gt;&lt;p&gt;&lt;a hre
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://www.elgong.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="牛顿迭代" scheme="http://www.elgong.top/tags/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>protobuf 使用指南-golang版</title>
    <link href="http://www.elgong.top/2020/06/22/protobuf-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-golang%E7%89%88/"/>
    <id>http://www.elgong.top/2020/06/22/protobuf-使用指南-golang版/</id>
    <published>2020-06-22T14:24:57.000Z</published>
    <updated>2020-06-22T14:29:36.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="protobuf-使用指南-golang版本"><a href="#protobuf-使用指南-golang版本" class="headerlink" title="protobuf 使用指南-golang版本"></a>protobuf 使用指南-golang版本</h1><p>protobuf 是谷歌开源的序列化框架，广泛应用于各种rpc，微服务等等场景。</p><ul><li><p><a href="https://developers.google.com/protocol-buffers/docs/proto3?hl=zh-cn#generating" target="_blank" rel="noopener">英文手册</a></p></li><li><p><a href="https://colobu.com/2017/03/16/Protobuf3-language-guide/" target="_blank" rel="noopener">中文翻译</a></p></li><li><a href="https://segmentfault.com/a/1190000020338411" target="_blank" rel="noopener">其他参考</a></li></ul><p>[TOC]</p><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p><a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">发布地址</a></p><p><strong>0. 需要提前安装好go</strong></p><p><strong>1. 下载并编译源码包</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 下载包</span><br><span class="line">wget https://github.com/protocolbuffers/protobuf/releases/download/v3.12.3/protobuf-all-3.12.3.tar.gz</span><br><span class="line"></span><br><span class="line">// 解压</span><br><span class="line">tar -zxvf protobuf-all-3.12.3.tar.gz</span><br><span class="line"></span><br><span class="line">cd protobuf-3.12.3/</span><br><span class="line"></span><br><span class="line">./autogen.sh</span><br><span class="line"></span><br><span class="line">// 指定安装的位置</span><br><span class="line">./configure --prefix=/usr/local/protobuf</span><br><span class="line"></span><br><span class="line">// -j8 多核心加速编译</span><br><span class="line">make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">// 如果权限不够，则</span><br><span class="line">// sudo make -j8 &amp;&amp; sudo make install</span><br><span class="line"></span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure></p><p><strong>2. 执行完以上步骤，protoc可执行脚本在 /usr/local/protobuf 中, 可以创建软连接，这样也可以同时解决多版本的protobuf 共存问题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 明确一下：</span><br><span class="line">//    新安装的protobuf 可执行脚本目录在protobuf-3.12.3/bin/protoc</span><br><span class="line">//    而我们需要在 /usr/local/bin 创建它的一个软连接</span><br><span class="line">// 格式：  ln -s  源脚本  新创建的软连接名字</span><br><span class="line"></span><br><span class="line">sudo ln -s /usr/local/protobuf/bin/protoc     protoc3.12</span><br></pre></td></tr></table></figure><p><strong>3. 安装go插件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 先指定GOPATH</span><br><span class="line">// 设置wei当前路径</span><br><span class="line">export GOPATH=`pwd`</span><br><span class="line"></span><br><span class="line">// 下载安装go 插件</span><br><span class="line">go get github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure><p><strong>4. 创建工程</strong></p><p><strong>工程结构</strong>：</p><ul><li>bin</li><li>pkg</li><li>src<ul><li>myproto<ul><li>data.pb.go</li></ul></li><li>main.go</li></ul></li><li>data.proto<br><strong>具体步骤</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1. 创建工程文件夹</span><br><span class="line">mkdir  protobuf_learn</span><br><span class="line"></span><br><span class="line">// 2. 初始化模块</span><br><span class="line">go mod init protobuf_learn</span><br><span class="line"></span><br><span class="line">// 3. 创建 main.go</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 4. 执行 go build</span><br><span class="line">go build</span><br><span class="line"></span><br><span class="line">// 5. 创建自定义包 myproto</span><br><span class="line">mkdir  -p src/myproto</span><br></pre></td></tr></table></figure></li></ul><h2 id="定义消息类型"><a href="#定义消息类型" class="headerlink" title="定义消息类型"></a>定义消息类型</h2><p><strong>创建data.proto文件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">  string query = 1;</span><br><span class="line">  int32 page_number = 2;</span><br><span class="line">  int32 result_per_page = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="生成访问类"><a href="#生成访问类" class="headerlink" title="生成访问类"></a>生成访问类</h2><p><strong>执行命令</strong></p><p><strong>格式</strong>：<br>protoc  —proto_path=【.proto文件】 —java_out=【java输出路径】 —go_path=【go输出路径】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 提前创建好myproto</span><br><span class="line">protoc3.12  data.proto --go_out=./src/myproto</span><br></pre></td></tr></table></figure></p><h2 id="使用访问类"><a href="#使用访问类" class="headerlink" title="使用访问类"></a>使用访问类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &quot;github.com/golang/protobuf/proto&quot;</span><br><span class="line"></span><br><span class="line">// 编码 不是 Marshaler</span><br><span class="line">proto.Marshal(obj)</span><br><span class="line"></span><br><span class="line">// 解码</span><br><span class="line">proto.Unmarshal(data, raw)</span><br></pre></td></tr></table></figure><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">obj := &amp;myproto.SearchRequest&#123;</span><br><span class="line">Query: &quot;name&quot;,</span><br><span class="line">PageNumber:1,</span><br><span class="line">ResultPerPage: 2,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;protobuf 编码&quot;)</span><br><span class="line">data, err := proto.Marshal(obj)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;err&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(data)</span><br></pre></td></tr></table></figure><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(&quot;protobuf 解码&quot;)</span><br><span class="line"></span><br><span class="line">raw := &amp;myproto.SearchRequest&#123;&#125;</span><br><span class="line"></span><br><span class="line">err = proto.Unmarshal(data, raw)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;err&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(raw)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;protobuf-使用指南-golang版本&quot;&gt;&lt;a href=&quot;#protobuf-使用指南-golang版本&quot; class=&quot;headerlink&quot; title=&quot;protobuf 使用指南-golang版本&quot;&gt;&lt;/a&gt;protobuf 使用指南-golang
      
    
    </summary>
    
      <category term="序列化" scheme="http://www.elgong.top/categories/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    
      <category term="protobuf" scheme="http://www.elgong.top/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>redis学习-复制</title>
    <link href="http://www.elgong.top/2020/06/09/redis%E5%AD%A6%E4%B9%A0-%E5%A4%8D%E5%88%B6/"/>
    <id>http://www.elgong.top/2020/06/09/redis学习-复制/</id>
    <published>2020-06-09T13:57:30.442Z</published>
    <updated>2020-06-09T14:02:08.812Z</updated>
    
    <content type="html"><![CDATA[<p>[toc] </p><h1 id="Redis6-复制（由主到从）"><a href="#Redis6-复制（由主到从）" class="headerlink" title="Redis6-复制（由主到从）"></a>Redis6-复制（由主到从）</h1><blockquote><p>当存在主从多个节点时，才会出现复制，且复制的方向只能由主节点流向从节点</p></blockquote><p>[toc]</p><h2 id="一、-redis-集群的拓扑结构"><a href="#一、-redis-集群的拓扑结构" class="headerlink" title="一、 redis 集群的拓扑结构"></a>一、 redis 集群的拓扑结构</h2><h3 id="主备结构-一主一从"><a href="#主备结构-一主一从" class="headerlink" title="主备结构-一主一从"></a>主备结构-一主一从</h3><ul><li>可以只在从节点开启 AOF</li></ul><h3 id="读写分类结构-一主多从"><a href="#读写分类结构-一主多从" class="headerlink" title="读写分类结构-一主多从"></a>读写分类结构-一主多从</h3><blockquote><p>慢查询可以 使用从节点，防止主节点的阻塞，提高并发性</p></blockquote><h3 id="解决网络负载过重-树状主从结构"><a href="#解决网络负载过重-树状主从结构" class="headerlink" title="解决网络负载过重-树状主从结构"></a>解决网络负载过重-树状主从结构</h3><blockquote><p>一主多从，主节点的网络负载很大，利用多级结构可以减少主节点的网络负载</p></blockquote><h2 id="二、-复制涉及的环节"><a href="#二、-复制涉及的环节" class="headerlink" title="二、 复制涉及的环节"></a>二、 复制涉及的环节</h2><h3 id="建立复制"><a href="#建立复制" class="headerlink" title="建立复制"></a>建立复制</h3><p><strong>复制流的方向</strong>：只能从主节点流向从节点</p><p><strong>配置</strong>： 只能从节点配置！</p><ul><li>配置文件中添加 <code>slaveof masterHost masterPort</code></li><li>redis 启动命令后加入 <code>--slaveof masterHost masterPort</code></li><li>直接执行该命令</li></ul><p><strong>查看复制的状态</strong>：<code>info replication</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line">    # Replication</span><br><span class="line">    role:master</span><br><span class="line">    connected_slaves:0</span><br><span class="line">    master_replid:923b3aeddad7f8966ea67a788dd7098fe8e99fca</span><br><span class="line">    master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">    master_repl_offset:14</span><br><span class="line">    second_repl_offset:-1</span><br><span class="line">    repl_backlog_active:1</span><br><span class="line">    repl_backlog_size:1048576</span><br><span class="line">    repl_backlog_first_byte_offset:1</span><br><span class="line">    repl_backlog_histlen:14</span><br></pre></td></tr></table></figure></p><h3 id="断开复制"><a href="#断开复制" class="headerlink" title="断开复制"></a>断开复制</h3><p><strong>直接断开复制关系，从节点自动升级为主节点</strong><br><code>slaveof no one</code></p><h3 id="切换复制源"><a href="#切换复制源" class="headerlink" title="切换复制源"></a>切换复制源</h3><blockquote><p>注意切换后，会先清空之前的缓存，然后重新复制<br><code>slaveof masterHost masterPort</code></p></blockquote><h3 id="复制的时间间隔粒度？"><a href="#复制的时间间隔粒度？" class="headerlink" title="复制的时间间隔粒度？"></a>复制的时间间隔粒度？</h3><p>控制参数 <code>repl-disable-tcp-nodelay</code> 默认关闭</p><ul><li>关闭时：主节点有新数据产生，会及时发送给从节点</li><li>开启时：固定时间间隔发送给从节点，linux一般默认40ms</li></ul><h2 id="三、复制的具体流程-6步"><a href="#三、复制的具体流程-6步" class="headerlink" title="三、复制的具体流程 (6步)"></a>三、复制的具体流程 (6步)</h2><ol><li>从节点 执行 <code>slaveof host master</code> <ul><li>指令后，从节点保存主节点的信息（ip + port）</li><li>信息可以通过 <code>info replication</code> 获取</li></ul></li><li>从节点与主节点建立 socket 连接         <ul><li>从节点开启定时任务来维护复制的逻辑</li><li>连接不上，会断开重新连接</li></ul></li><li>从节点 主动通信，发送 <code>ping</code></li><li>需要 权限验证， <code>auth password</code> <ul><li>requirepass是配置在主节点的，masterauth是配置在从节点</li><li>具体在 redis.conf 中配置</li></ul></li><li><p>主从同步数据（全量复制和部分复制）</p></li><li><p>修改命令的持续写入从节点</p></li></ol><blockquote><p>全量复制一般只在第一次复制，剩下的就是每次复制执行的命令</p></blockquote><p>下面详细讲述全量复制的过程：</p><h3 id="psync指令-完成数据同步（包括全量和部分）"><a href="#psync指令-完成数据同步（包括全量和部分）" class="headerlink" title="psync指令 完成数据同步（包括全量和部分）"></a>psync指令 完成数据同步（包括全量和部分）</h3><p><strong>格式</strong>：<br><code>psync {runId}{offset}</code></p><p><strong>runId</strong>:  主节点运行 id， 重启后会自动改变</p><p><strong>offset</strong>: 从节点已经复试的数据偏移量，第一次默认为 -1</p><h4 id="全量复制的流程"><a href="#全量复制的流程" class="headerlink" title="全量复制的流程"></a>全量复制的流程</h4><ol><li>从节点发送 <code>psync</code> 进行同步， 无法得知主节点运行id，所以发送 <code>psync-1</code> </li><li>主节点 发现<code>psync-1</code>,判定需要全量复制，返回 运行id 和 offset</li><li>从节点保存 运行id 和 offset</li><li>主节点执行 <code>bgsave</code>, 将产生的 <code>RDB</code> 文件发送到从节点</li><li>同时主节点仍在处理命令，将命令写入了 缓冲区，再次把缓冲区的命令发送给 从节点（注意可能出现的缓冲区溢出，当写入超过1mb）</li></ol><h4 id="部分复制的流程"><a href="#部分复制的流程" class="headerlink" title="部分复制的流程"></a>部分复制的流程</h4><blockquote><p>针对网络异常导致的命令丢失等，做出了优化，避免使用全量复制来解决少量数据的问题</p></blockquote><ol><li>主从节点之间出现网络中断，并且超 <code>repl-timeout</code> 设定的时间，主节点可以得知断开了，写入命令都存在缓冲区</li><li>当主从连接恢复，由于从节点保存了 主节点的id 和复制偏移值，直接作为 <code>psync</code>参数继续传递</li></ol><h2 id="四、心跳检测"><a href="#四、心跳检测" class="headerlink" title="四、心跳检测"></a>四、心跳检测</h2><blockquote><p>主从节点连接后，会维护一个长连接，互相发送心跳命令</p></blockquote><p><strong>主节点</strong>：</p><ul><li>每10s发送一次 <code>ping</code>, 来检测从节点的状态</li><li>参数 <code>repl-ping-slave-period</code> 可以设置时间间隔</li></ul><p><strong>从节点</strong>：</p><ul><li>每1s 发送一次 <code>replconf ack{offset}</code></li><li>上报自身已经复制到的偏移量</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc] &lt;/p&gt;
&lt;h1 id=&quot;Redis6-复制（由主到从）&quot;&gt;&lt;a href=&quot;#Redis6-复制（由主到从）&quot; class=&quot;headerlink&quot; title=&quot;Redis6-复制（由主到从）&quot;&gt;&lt;/a&gt;Redis6-复制（由主到从）&lt;/h1&gt;&lt;blockq
      
    
    </summary>
    
      <category term="缓存中间件" scheme="http://www.elgong.top/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="redis" scheme="http://www.elgong.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis-持久化</title>
    <link href="http://www.elgong.top/2020/06/01/redis-%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://www.elgong.top/2020/06/01/redis-持久化/</id>
    <published>2020-05-31T16:16:27.000Z</published>
    <updated>2020-06-07T13:44:57.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h1><p>[toc]</p><p>Redis 是基于内存的k-v服务，内存在断电时无法保存数据，因此需要做数据的备份操作。</p><p>Redis 有两种备份方式：</p><ul><li>内存快照的持久化保存 RDB<ul><li>适合全量复制，容灾备份，每日周期性定时执行（间隔6小时） </li><li>压缩后的二进制文件，恢复速度快</li><li>耗时长，无法做到实时备份</li></ul></li><li>记录修改操作日志的持久化保存 AOF<ul><li>实时备份（1s 一次）</li></ul></li></ul><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><blockquote><p>内存快照的二进制压缩格式</p></blockquote><h3 id="RDB-备份流程"><a href="#RDB-备份流程" class="headerlink" title="RDB 备份流程"></a>RDB 备份流程</h3><p><img src="https://note.youdao.com/yws/public/resource/e035e0d66921bedda6618e6b77e6a985/xmlnote/7FD7F9AB88734CB0A9E0227F16C4BB2E/31348" alt="image"> </p><ol><li>执行<code>bgsave</code> 命令，判断RDF 或 AOF子进程是否在运行，如果存在则直接退出；</li><li>主进程<code>fork</code> 产生子进程，子进程用来执行备份操作（<strong>会阻塞主进程</strong>）；</li><li>子进程根据父进程生成的临时快照文件来创建 RDB 文件，替换旧 RDB 文件；</li><li>子进程发送完成信号给父进程，父进程会统计相关信息；</li></ol><blockquote><p>linux 进程中的 fork :<br>fork函数得到的子进程从父进程的继承了整个进程的地址空间，包括：进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设置、进程优先级、进程组号、当前工作目录、根目录、资源限制、控制终端等。</p><p>fork 不会拷贝父进程的物理空间，会共用</p></blockquote><h3 id="RDB-什么情况下会被触发？"><a href="#RDB-什么情况下会被触发？" class="headerlink" title="RDB 什么情况下会被触发？"></a>RDB 什么情况下会被触发？</h3><p>触发 RDB 备份 主要是两个命令： <code>save</code> 和 <code>bgsave</code></p><ul><li>save:<ul><li>主线程去执行 RDB 备份，所以无法响应请求；</li></ul></li><li>bgsave:<ul><li>子进程去执行备份，只在fork 阶段产生阻塞；</li></ul></li></ul><p>所以，我们只需要知道 <code>bgsave</code> 什么时候触发调用就行。</p><ul><li>配置<code>save m n</code> ：即 m 秒内数据集被修改了n次，则触发<code>bgsave</code> </li><li>从节点的全量复制：主节点会将<code>RDB</code>文件传递到从节点</li><li><code>debug reload</code> 时</li><li>执行 <code>shutdown</code>时</li><li>从节点需要全量复制时？？？</li></ul><p><strong>AOF 默认是关闭的，但优先级高于 RDB</strong></p><h3 id="相关的指令"><a href="#相关的指令" class="headerlink" title="相关的指令"></a>相关的指令</h3><h4 id="运行期指定-RDB-文件保存地址"><a href="#运行期指定-RDB-文件保存地址" class="headerlink" title="运行期指定 RDB 文件保存地址"></a>运行期指定 RDB 文件保存地址</h4><p><code>config set dir {newDir}</code></p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>append only file</p><blockquote><p>日志记录修改操作，可以实时记录备份 </p></blockquote><h3 id="AOF-备份流程"><a href="#AOF-备份流程" class="headerlink" title="AOF 备份流程"></a>AOF 备份流程</h3><p><img src="https://note.youdao.com/yws/public/resource/e035e0d66921bedda6618e6b77e6a985/xmlnote/2C252F2CBCCD410F8E742C301F097554/31383" alt="image"></p><ol><li>写入命令会追加到 aof_buf 缓冲区中;</li><li>根据对应的策略 写入到硬盘；</li><li>当文件过于大时，会重写 AOF 文件;</li><li>重启优先加载 AOF 文件;</li></ol><h4 id="AOF-备份-1-命令写入"><a href="#AOF-备份-1-命令写入" class="headerlink" title="AOF 备份-1.命令写入"></a>AOF 备份-1.命令写入</h4><ul><li><p>先写入缓存区，然后再备份到硬盘中；</p></li><li><p>直接写入文本协议格式</p></li></ul><h4 id="AOF-备份-2-文件同步策略"><a href="#AOF-备份-2-文件同步策略" class="headerlink" title="AOF 备份-2.文件同步策略"></a>AOF 备份-2.文件同步策略</h4><p>同步策略： 配置 <code>appendfsync</code> 参数</p><ul><li>always</li><li>everysec （默认配置， 1s 执行一次写入）</li><li>no</li></ul><h4 id="AOF-备份-3-重写机制"><a href="#AOF-备份-3-重写机制" class="headerlink" title="AOF 备份-3.重写机制"></a>AOF 备份-3.重写机制</h4><p>重写的主要点：</p><ul><li>被删除的无效数据不需要在写入</li><li>过期数据不需要在写入</li><li>多条命令可以合并</li></ul><p><strong>手动触发重写命令</strong>： <code>bgrewriteaof</code></p><h4 id="AOF-备份-4-重启加载"><a href="#AOF-备份-4-重启加载" class="headerlink" title="AOF 备份-4. 重启加载"></a>AOF 备份-4. 重启加载</h4><p>比 RDB 优先级别高</p><h3 id="如何配置相关参数？"><a href="#如何配置相关参数？" class="headerlink" title="如何配置相关参数？"></a>如何配置相关参数？</h3><ol><li>开启 AOF功能<br> 配置 <code>appendonly yes</code></li></ol><h3 id="AOF-什么情况下会被触发？"><a href="#AOF-什么情况下会被触发？" class="headerlink" title="AOF 什么情况下会被触发？"></a>AOF 什么情况下会被触发？</h3><p>根据备份策略，一般是定时触发</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis-持久化&quot;&gt;&lt;a href=&quot;#Redis-持久化&quot; class=&quot;headerlink&quot; title=&quot;Redis 持久化&quot;&gt;&lt;/a&gt;Redis 持久化&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;Redis 是基于内存的k-v服务，内存在断电时无法保存数
      
    
    </summary>
    
      <category term="缓存中间件" scheme="http://www.elgong.top/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="redis" scheme="http://www.elgong.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis学习-Jedis 使用</title>
    <link href="http://www.elgong.top/2020/05/16/redis%E5%AD%A6%E4%B9%A0-Jedis-%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.elgong.top/2020/05/16/redis学习-Jedis-使用/</id>
    <published>2020-05-15T16:17:58.000Z</published>
    <updated>2020-05-15T16:26:59.337Z</updated>
    
    <content type="html"><![CDATA[<p>[toc] </p><p>[toc]</p><blockquote><p>本系列文章整理摘抄自<redis 开发与运维=""></redis></p></blockquote><h1 id="客户端怎么和-Redis-服务器连接？"><a href="#客户端怎么和-Redis-服务器连接？" class="headerlink" title="客户端怎么和 Redis 服务器连接？"></a>客户端怎么和 Redis 服务器连接？</h1><p>客户端和 Redis 服务器的通信是 建立在 TCP 连接的基础上的。</p><p>并且 Redis 制定了 RESP 序列化协议，是一个简单地通信约定。</p><h2 id="Resp序列化协议"><a href="#Resp序列化协议" class="headerlink" title="Resp序列化协议"></a>Resp序列化协议</h2><p><code>*&lt;参数数量&gt;\r\n$&lt;参数1的字节数量&gt;\r\n&lt;参数1&gt;\r\n$&lt;参数2的字节数量&gt;\r\n&lt;参数2&gt;\r\n</code></p><p>来给可视化一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*&lt;参数数量&gt;\r\n</span><br><span class="line">$&lt;参数1的字节数量&gt;\r\n</span><br><span class="line">&lt;参数1&gt;\r\n</span><br><span class="line">$&lt;参数2的字节数量&gt;\r\n</span><br><span class="line">&lt;参数2&gt;\r\n</span><br></pre></td></tr></table></figure></p><p>其他可以参考该书章节。</p><h1 id="Jedis-连接池的使用"><a href="#Jedis-连接池的使用" class="headerlink" title="Jedis 连接池的使用"></a>Jedis 连接池的使用</h1><p>简单的API 介绍</p><p><strong>获取 jedis连接</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line"></span><br><span class="line">Jedis jedis = null;</span><br><span class="line">try &#123;</span><br><span class="line">    jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line">    </span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    logger.error(e.getMessage(),e);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    if (jedis != null) &#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//  String</span><br><span class="line">jedis.set(&quot;key&quot;, &quot;value&quot;);</span><br><span class="line">jedis.get(&quot;key&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//  hset -字典</span><br><span class="line">jedis.set(&quot;hash&quot;, &quot;key1&quot;, &quot;value1&quot;);</span><br><span class="line">jedis.set(&quot;hash&quot;, &quot;key2&quot;, &quot;value2&quot;);</span><br><span class="line">jedis.get(&quot;key1&quot;)</span><br><span class="line"></span><br><span class="line">//  list -列表</span><br><span class="line">jedis.rpush(&quot;mylist&quot;, &quot;1&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// set -集合</span><br><span class="line">jedis.sadd(&quot;set&quot;, &quot;aaa&quot;);</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure><h2 id="springboot-环境下的使用"><a href="#springboot-环境下的使用" class="headerlink" title="springboot 环境下的使用"></a>springboot 环境下的使用</h2><h3 id="1-maven-依赖"><a href="#1-maven-依赖" class="headerlink" title="1. maven 依赖"></a>1. maven 依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.4.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.14&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h3><p><strong>配置类 -&gt; 从 application.preperties 读取配置项，并且配置</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;redis&quot;)</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line">  // 私有属性 </span><br><span class="line">    </span><br><span class="line">  // 配置项</span><br><span class="line">  get... set...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>poolFactory 工厂类创建 pool</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RedisPoolFactory &#123;</span><br><span class="line"></span><br><span class="line">    // 注入配置项</span><br><span class="line">    @Autowired</span><br><span class="line">    RedisConfig redisConfig;</span><br><span class="line"></span><br><span class="line">    // Bean注解 ： 根据方法创建对象，类型是JedisPool</span><br><span class="line">    @Bean</span><br><span class="line">    public JedisPool JedisPoolFactory()&#123;</span><br><span class="line"></span><br><span class="line">        JedisPoolConfig poolConfig = new JedisPoolConfig();</span><br><span class="line">        </span><br><span class="line">        // 各种配置</span><br><span class="line">        poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle());</span><br><span class="line">        poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal());</span><br><span class="line">        poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxTotal()*1000);</span><br><span class="line"></span><br><span class="line">        JedisPool jedisPool = new JedisPool(poolConfig, redisConfig.getHost(),                                      redisConfig.getPort(),                                                  redisConfig.getTimeout()*1000,                                          redisConfig.getPassword(), 0);</span><br><span class="line"></span><br><span class="line">        return jedisPool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Redis 服务类 开始封装各种服务</strong></p><p>当然，也要为服务模块化，比如 <code>RedisUserService</code>, <code>RedisMiaoshaService</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line"> public class RedisService &#123;</span><br><span class="line">    // 注入，@Bean 产生的jedisPool</span><br><span class="line">    @Autowired</span><br><span class="line">    JedisPool jedisPool;</span><br><span class="line">    </span><br><span class="line">    public &lt;T&gt; boolean set(IProfixForKey prefix, String key, T value)&#123;</span><br><span class="line"></span><br><span class="line">        Jedis resource = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            // 拿到连接</span><br><span class="line">            resource = jedisPool.getResource();</span><br><span class="line">            </span><br><span class="line">            // 封装一下key, 加上特点的头信息，例如： dbName:tableName:id</span><br><span class="line">            String strValue = beanToString(value);</span><br><span class="line">    </span><br><span class="line">            // 生成key</span><br><span class="line">            String realKey = prefix.getPrefix() + key;</span><br><span class="line">    </span><br><span class="line">            if (strValue == null || strValue.length() &lt;= 0)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 设置</span><br><span class="line">            resource.set(realKey, strValue);</span><br><span class="line">    </span><br><span class="line">            return true;</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            returnToPool(resource);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="非-spring-环境下的使用"><a href="#非-spring-环境下的使用" class="headerlink" title="非 spring 环境下的使用"></a>非 spring 环境下的使用</h2><p>举个例子，不知道合不合适。</p><p><strong>单例模式 来创建 JedisPool</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class JedisFactory &#123;</span><br><span class="line"></span><br><span class="line">    private volatile  static JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    private volatile static JedisPoolConfig poolConfig;</span><br><span class="line">    private volatile static String ip;</span><br><span class="line">    private volatile static int port;</span><br><span class="line">    private volatile static int timeout;</span><br><span class="line">    private volatile static String password;</span><br><span class="line">    private volatile static int database;</span><br><span class="line"></span><br><span class="line">    private JedisFactory() &#123;</span><br><span class="line"></span><br><span class="line">        //JedisPoolConfig poolConfig, String ip, int port, int timeout, String password, int database</span><br><span class="line">        /* apache common-pool 工具</span><br><span class="line">        *</span><br><span class="line">        * JedisPoolConfig</span><br><span class="line">        * */</span><br><span class="line">        this.jedisPool = new JedisPool(poolConfig, ip, port, timeout , password, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static JedisPool getJedisPool()&#123;</span><br><span class="line"></span><br><span class="line">        if (jedisPool == null)&#123;</span><br><span class="line"></span><br><span class="line">            synchronized (JedisFactory.class)&#123;</span><br><span class="line"></span><br><span class="line">                if (jedisPool == null)&#123;</span><br><span class="line">                    jedisPool = new JedisPool(JedisFactory.poolConfig, JedisFactory.ip, JedisFactory.port,</span><br><span class="line">                                              JedisFactory.timeout,  JedisFactory.password, JedisFactory.database);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setJedisPoolConfig(JedisPoolConfig poolConfig, String ip, int port, int timeout, String password, int database)&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot; 配置jedis 参数...&quot;);</span><br><span class="line">        JedisFactory.poolConfig = poolConfig;</span><br><span class="line">        JedisFactory.ip = ip;</span><br><span class="line">        JedisFactory.port = port;</span><br><span class="line">        JedisFactory.timeout = timeout * 1000;</span><br><span class="line">        JedisFactory.password = password;</span><br><span class="line">        JedisFactory.database = database;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>JedisService</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package top.elgong.jedis;</span><br><span class="line"></span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line">import redis.clients.jedis.JedisPool;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">*</span><br><span class="line">*   解决redis 用到的</span><br><span class="line">* */</span><br><span class="line">public class JedisService &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     */</span><br><span class="line">    public void set(String key, String value)&#123;</span><br><span class="line">        Jedis resource = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            JedisPool jedisPool = JedisFactory.getJedisPool();</span><br><span class="line"></span><br><span class="line">            resource = jedisPool.getResource();</span><br><span class="line"></span><br><span class="line">            resource.set(key, value);</span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line"></span><br><span class="line">            // 送回连接池中</span><br><span class="line">            if (resource != null)&#123;</span><br><span class="line">                resource.close();  // close 就是送回池子</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    *</span><br><span class="line">    * */</span><br><span class="line">    public String get(String key)&#123;</span><br><span class="line">        Jedis resource = null;</span><br><span class="line">        String ret = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            JedisPool jedisPool = JedisFactory.getJedisPool();</span><br><span class="line">            resource = jedisPool.getResource();</span><br><span class="line"></span><br><span class="line">            ret = resource.get(key);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            // 送回连接池中</span><br><span class="line">            if (resource != null)&#123;</span><br><span class="line">                resource.close();  // close 就是送回池子</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package top.elgong.jedis;</span><br><span class="line"></span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line">import redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static JedisService jedisService = new JedisService();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        JedisPoolConfig poolConfig = new JedisPoolConfig();</span><br><span class="line">        String ip = &quot;121.41.111.45&quot;;</span><br><span class="line">        int port = 6379;</span><br><span class="line">        int timeout = 300;</span><br><span class="line">        String password = &quot;Gelqq666%&quot;;</span><br><span class="line">        int database = 0;</span><br><span class="line"></span><br><span class="line">        JedisFactory.setJedisPoolConfig(poolConfig, ip, port, timeout, password, database);</span><br><span class="line"></span><br><span class="line">        jedisService.set(&quot;leetcode-java:jedis:test:key1&quot;, &quot;haha-&quot; + LocalDateTime.now().toString());</span><br><span class="line"></span><br><span class="line">        String s = jedisService.get(&quot;leetcode-java:jedis:test:key1&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Jedis-Pipline-的使用"><a href="#Jedis-Pipline-的使用" class="headerlink" title="Jedis Pipline 的使用"></a>Jedis Pipline 的使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = new Jedis(&quot;127.0.0.1&quot;);</span><br><span class="line"></span><br><span class="line">// 1)生成pipeline对象</span><br><span class="line">Pipeline pipeline = jedis.pipelined();</span><br><span class="line"></span><br><span class="line">// 2)pipeline执行命令， 注意此时命令并未真正执行</span><br><span class="line">for (String key : keys) &#123;</span><br><span class="line">    pipeline.del(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3)执行命令</span><br><span class="line">pipeline.sync();</span><br></pre></td></tr></table></figure><h1 id="Jedis-Lua-脚本"><a href="#Jedis-Lua-脚本" class="headerlink" title="Jedis Lua 脚本"></a>Jedis Lua 脚本</h1><p>待补充。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc] &lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列文章整理摘抄自&lt;redis 开发与运维=&quot;&quot;&gt;&lt;/redis&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;客户端怎么和-Redis-服务器连接？&quot;&gt;&lt;a href=&quot;#客户端怎么
      
    
    </summary>
    
      <category term="缓存中间件" scheme="http://www.elgong.top/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="redis" scheme="http://www.elgong.top/tags/redis/"/>
    
      <category term="jedis" scheme="http://www.elgong.top/tags/jedis/"/>
    
  </entry>
  
  <entry>
    <title>redis学习-缓存设计中要提前考虑的事情</title>
    <link href="http://www.elgong.top/2020/05/16/redis%E5%AD%A6%E4%B9%A0-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%AD%E8%A6%81%E6%8F%90%E5%89%8D%E8%80%83%E8%99%91%E7%9A%84%E4%BA%8B%E6%83%85/"/>
    <id>http://www.elgong.top/2020/05/16/redis学习-缓存设计中要提前考虑的事情/</id>
    <published>2020-05-15T16:16:33.000Z</published>
    <updated>2020-05-15T16:26:27.077Z</updated>
    
    <content type="html"><![CDATA[<p>[toc] </p><p>[toc]</p><blockquote><p>本系列文章整理摘抄自<redis 开发与运维=""></redis></p><h1 id="缓存设计前需要权衡成本和收益"><a href="#缓存设计前需要权衡成本和收益" class="headerlink" title="缓存设计前需要权衡成本和收益"></a>缓存设计前需要权衡成本和收益</h1></blockquote><h2 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h2><ul><li><strong>加速读写</strong></li><li><strong>降低后端负载</strong></li></ul><h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><ul><li><strong>数据不一致性</strong><ul><li>缓存层和存储层数据势必会有不一致的时间，需要考虑如何避免对业务造成的影响。 </li></ul></li><li><strong>代码维护成本</strong><ul><li>redis 和 mysql 两方代码都要考虑。</li></ul></li></ul><h1 id="缓存如何更新？"><a href="#缓存如何更新？" class="headerlink" title="缓存如何更新？"></a>缓存如何更新？</h1><p>基于内存的缓存不可能将所有的数据都做缓存，一般针对的都是<strong>热点数据</strong>。热点数据具有时效性，过了一定时间将成为<strong>非热点数据</strong>。</p><p>所以，缓存数据通常具有生命时长，到达指定的时间后，将被更新或者删除。</p><p>熟悉缓存的常用更新策略，才能针对业务场景做出合理的选择。</p><h2 id="更新策略1：-LRU-LFU-FIFO-算法"><a href="#更新策略1：-LRU-LFU-FIFO-算法" class="headerlink" title="更新策略1： LRU/LFU/FIFO 算法"></a>更新策略1： LRU/LFU/FIFO 算法</h2><p>通常缓存量超过了预设的最大值时，将会采取以上策略，具体由 <code>maxmemory-policy</code> 参数指定。</p><p><strong>一致性最差。</strong></p><h2 id="更新策略2-超时剔除"><a href="#更新策略2-超时剔除" class="headerlink" title="更新策略2: 超时剔除"></a>更新策略2: 超时剔除</h2><p>通过给缓存数据设置过期时间，让其在过期时间后自动删除，例如Redis提供的<code>expire</code>命令。 </p><p><strong>一致性取决于时间窗口。</strong></p><h2 id="更新策略3-主动更新"><a href="#更新策略3-主动更新" class="headerlink" title="更新策略3: 主动更新"></a>更新策略3: 主动更新</h2><p>当堆数据一致性要求高时，在更新存储层数据后，需要立即更新缓存中的数据。</p><p><strong>一致性最好。</strong></p><h2 id="最佳实践方案"><a href="#最佳实践方案" class="headerlink" title="最佳实践方案"></a>最佳实践方案</h2><h3 id="低一致性业务"><a href="#低一致性业务" class="headerlink" title="低一致性业务"></a>低一致性业务</h3><p>配置最大内存 + 淘汰策略</p><h3 id="高一致性业务"><a href="#高一致性业务" class="headerlink" title="高一致性业务"></a>高一致性业务</h3><p>超时剔除 + 主动更新</p><h1 id="缓存的粒度如何选？"><a href="#缓存的粒度如何选？" class="headerlink" title="缓存的粒度如何选？"></a>缓存的粒度如何选？</h1><p>对于缓存数据库的内容时，要考虑缓存全部字段，或者部分字段。</p><ul><li>全部字段：<ul><li>全部缓存占用空间过大</li><li>并不是所有字段都用的到</li></ul></li><li>部分字段：<ul><li>未来可能用到新字段 </li></ul></li></ul><h1 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h1><p>在系统刚上线，直接将数据加载进缓存系统，提前准备。</p><h1 id="缓存穿透问题（针对无效查询）"><a href="#缓存穿透问题（针对无效查询）" class="headerlink" title="缓存穿透问题（针对无效查询）"></a>缓存穿透问题（针对无效查询）</h1><h2 id="概念描述"><a href="#概念描述" class="headerlink" title="概念描述"></a>概念描述</h2><p>缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不命中。</p><h2 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h2><ul><li>问题1：业务代码或者数据出现问题</li><li>问题2：恶意攻击，爬虫造成的大量空命中</li></ul><h2 id="造成的影响"><a href="#造成的影响" class="headerlink" title="造成的影响"></a>造成的影响</h2><p>如果出现大量的缓存穿透，会对后端的数据库产生大流量的冲击，严重可使得数据库服务宕机。</p><h2 id="通用解决方案"><a href="#通用解决方案" class="headerlink" title="通用解决方案"></a>通用解决方案</h2><h3 id="问题如何发现？"><a href="#问题如何发现？" class="headerlink" title="问题如何发现？"></a>问题如何发现？</h3><p>统计<strong>总调用数、 缓存层命中数、 存储层命中数</strong>，如果发现大量存储层空命中， 可能就是出现了缓存穿透问题。</p><h3 id="问题如何预防？"><a href="#问题如何预防？" class="headerlink" title="问题如何预防？"></a>问题如何预防？</h3><h4 id="问题1的解决-缓存空对象-设置短过期时间"><a href="#问题1的解决-缓存空对象-设置短过期时间" class="headerlink" title="问题1的解决. 缓存空对象 + 设置短过期时间"></a>问题1的解决. 缓存空对象 + 设置短过期时间</h4><p>实时性高。</p><p>存储层不命中后，仍然将空对象保留到缓存层中，之后再访问这个数据将会从缓存中获取，这样就保护了后端数据源。 </p><h4 id="问题2的解决-布隆过滤器拦截（缓存层之前对存在的key做保存）"><a href="#问题2的解决-布隆过滤器拦截（缓存层之前对存在的key做保存）" class="headerlink" title="问题2的解决. 布隆过滤器拦截（缓存层之前对存在的key做保存）"></a>问题2的解决. 布隆过滤器拦截（缓存层之前对存在的key做保存）</h4><p>实时性差。</p><p>访问缓存层和存储层之前，将存在的key用布隆过滤器提前保存起来， 做第一层拦截</p><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><h2 id="概念描述-1"><a href="#概念描述-1" class="headerlink" title="概念描述"></a>概念描述</h2><p>发生大规模的缓存失效的情况，或者缓存层宕机，大量流量冲入存储层。</p><h2 id="产生的原因-1"><a href="#产生的原因-1" class="headerlink" title="产生的原因"></a>产生的原因</h2><p>缓存服务由于各种原因失效了。</p><h2 id="造成的影响-1"><a href="#造成的影响-1" class="headerlink" title="造成的影响"></a>造成的影响</h2><p>数据库服务宕机。</p><h2 id="通用解决方案-1"><a href="#通用解决方案-1" class="headerlink" title="通用解决方案"></a>通用解决方案</h2><h3 id="提前的规划：-保证缓存服务的高可用。"><a href="#提前的规划：-保证缓存服务的高可用。" class="headerlink" title="提前的规划： 保证缓存服务的高可用。"></a>提前的规划： 保证缓存服务的高可用。</h3><p>主从 + 哨兵， 集群。<br>Redis Sentinel和RedisCluster都实现了高可用</p><h3 id="出现雪崩时的处理：隔离组件做限流和降级处理"><a href="#出现雪崩时的处理：隔离组件做限流和降级处理" class="headerlink" title="出现雪崩时的处理：隔离组件做限流和降级处理"></a>出现雪崩时的处理：隔离组件做限流和降级处理</h3><ul><li>ehcache本地缓存 + Hystrix限流并降级,避免MySQL被搞死。</li><li>加锁排队（并发量不高的情况下）</li></ul><p><strong>Hystrix限流并降级的流程</strong></p><p>海量的用户请求出现：</p><ul><li>首先通过限流组件Hystrix限流（只有预定的请求进入存储层）</li><li>对于未通过的流量，直接导到 预定的降级处理方案，比如友好的提示等待。</li></ul><h3 id="3-提前排演测试"><a href="#3-提前排演测试" class="headerlink" title="3. 提前排演测试"></a>3. 提前排演测试</h3><h1 id="缓存击-针对失效数据-热点数据高并发访问时，失效来不及重建"><a href="#缓存击-针对失效数据-热点数据高并发访问时，失效来不及重建" class="headerlink" title="缓存击(针对失效数据)-热点数据高并发访问时，失效来不及重建"></a>缓存击(针对失效数据)-热点数据高并发访问时，失效来不及重建</h1><h2 id="概念描述-2"><a href="#概念描述-2" class="headerlink" title="概念描述"></a>概念描述</h2><p>当热点数据并发访问量非常大，由于之前设置了过期时间，失效后难以短时间重建。</p><p>比如： 热点的娱乐新闻。</p><h2 id="产生的原因-2"><a href="#产生的原因-2" class="headerlink" title="产生的原因"></a>产生的原因</h2><p>缓存服务由于各种原因失效了。</p><h2 id="造成的影响-2"><a href="#造成的影响-2" class="headerlink" title="造成的影响"></a>造成的影响</h2><p>数据库服务宕机。</p><h2 id="通用解决方案-2"><a href="#通用解决方案-2" class="headerlink" title="通用解决方案"></a>通用解决方案</h2><h3 id="1-限制重建的线程数-互斥锁"><a href="#1-限制重建的线程数-互斥锁" class="headerlink" title="1. 限制重建的线程数 - 互斥锁"></a>1. 限制重建的线程数 - 互斥锁</h3><p>并不是所有的线程都需要去重建，第一个遇到的线程重建，其他线程等待即可。</p><h4 id="互斥锁的实现1：通过setnx-和-expire命令实现"><a href="#互斥锁的实现1：通过setnx-和-expire命令实现" class="headerlink" title="互斥锁的实现1：通过setnx 和 expire命令实现"></a>互斥锁的实现1：通过setnx 和 expire命令实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">String get(String key) &#123;</span><br><span class="line">    // 从Redis中获取数据</span><br><span class="line">    String value = redis.get(key);</span><br><span class="line">    // 如果value为空， 则开始重构缓存</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        // 只允许一个线程重构缓存， 使用nx， 并设置过期时间ex</span><br><span class="line">        String mutexKey = &quot;mutext:key:&quot; + key;</span><br><span class="line">        if (redis.set(mutexKey, &quot;1&quot;, &quot;ex 180&quot;, &quot;nx&quot;)) &#123;</span><br><span class="line">            // 从数据源获取数据</span><br><span class="line">            value = db.get(key);</span><br><span class="line">            // 回写Redis， 并设置过期时间</span><br><span class="line">            redis.setex(key, timeout, value);</span><br><span class="line">            // 删除key_mutex</span><br><span class="line">            redis.delete(mutexKey);</span><br><span class="line">        &#125;/</span><br><span class="line">        / 其他线程休息50毫秒后重试</span><br><span class="line">        else &#123;</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">            get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="互斥锁的实现2：通过watch和Redis的事务命令实现"><a href="#互斥锁的实现2：通过watch和Redis的事务命令实现" class="headerlink" title="互斥锁的实现2：通过watch和Redis的事务命令实现"></a>互斥锁的实现2：通过watch和Redis的事务命令实现</h4><h3 id="2-永不过期"><a href="#2-永不过期" class="headerlink" title="2. 永不过期"></a>2. 永不过期</h3><p>但是会出现数据不一致的情况。</p><h3 id="3-错峰失效"><a href="#3-错峰失效" class="headerlink" title="3. 错峰失效"></a>3. 错峰失效</h3><p>不要让热点数据集中失效，而是一批一批，分时间段的失效</p><h3 id="4-失效后sleep-rand-这样不会所有请求都去立刻查db"><a href="#4-失效后sleep-rand-这样不会所有请求都去立刻查db" class="headerlink" title="4. 失效后sleep(rand()) 这样不会所有请求都去立刻查db"></a>4. 失效后sleep(rand()) 这样不会所有请求都去立刻查db</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc] &lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列文章整理摘抄自&lt;redis 开发与运维=&quot;&quot;&gt;&lt;/redis&gt;&lt;/p&gt;
&lt;h1 id=&quot;缓存设计前需要权衡成本和收益&quot;&gt;&lt;a href=&quot;#缓存设计前需要权衡成本和收益&quot; class=&quot;h
      
    
    </summary>
    
      <category term="缓存中间件" scheme="http://www.elgong.top/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="redis" scheme="http://www.elgong.top/tags/redis/"/>
    
      <category term="缓存雪崩" scheme="http://www.elgong.top/tags/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/"/>
    
      <category term="缓存穿透" scheme="http://www.elgong.top/tags/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/"/>
    
      <category term="缓存击穿" scheme="http://www.elgong.top/tags/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/"/>
    
  </entry>
  
  <entry>
    <title>redis学习-常用API</title>
    <link href="http://www.elgong.top/2020/05/16/redis%E5%AD%A6%E4%B9%A0-%E5%B8%B8%E7%94%A8API/"/>
    <id>http://www.elgong.top/2020/05/16/redis学习-常用API/</id>
    <published>2020-05-15T16:15:05.000Z</published>
    <updated>2020-05-15T16:15:53.124Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><blockquote><p>本系列文章整理摘抄自<redis 开发与运维=""></redis></p><h1 id="全局命令"><a href="#全局命令" class="headerlink" title="全局命令"></a>全局命令</h1></blockquote><h2 id="1-查看所有键-keys"><a href="#1-查看所有键-keys" class="headerlink" title="1. 查看所有键 keys"></a>1. 查看所有键 <strong>keys</strong></h2><p>遍历所有的键，时间复杂度O(n), 线上禁止使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys *</span><br></pre></td></tr></table></figure></p><h2 id="2-键总数-dbsize"><a href="#2-键总数-dbsize" class="headerlink" title="2. 键总数 dbsize"></a>2. 键总数 <strong>dbsize</strong></h2><p>该指令直接获取Redis 内置的键总数变量， 时间复杂度 O(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbsize</span><br></pre></td></tr></table></figure></p><h2 id="3-键是否存在-exist"><a href="#3-键是否存在-exist" class="headerlink" title="3. 键是否存在 exist"></a>3. 键是否存在 <strong>exist</strong></h2><p>存在返回1， 不存在返回0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exist key</span><br></pre></td></tr></table></figure></p><h2 id="4-删除键-del"><a href="#4-删除键-del" class="headerlink" title="4. 删除键 del"></a>4. 删除键 <strong>del</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key1  key2  key3</span><br></pre></td></tr></table></figure><h2 id="5-设置键过期-expire"><a href="#5-设置键过期-expire" class="headerlink" title="5. 设置键过期 expire"></a>5. 设置键过期 <strong>expire</strong></h2><p>成功返回1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// expire key seconds</span><br><span class="line">set key helloword</span><br><span class="line">expire key 10</span><br></pre></td></tr></table></figure></p><h2 id="6-查询键过期-ttl"><a href="#6-查询键过期-ttl" class="headerlink" title="6. 查询键过期 ttl"></a>6. 查询键过期 <strong>ttl</strong></h2><ul><li>返回 &gt;0 : 剩余的过期时间</li><li>返回 -1 : 键没设置过期时间</li><li>返回 -2 ：键不存在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ttl key</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-键的类型-type"><a href="#7-键的类型-type" class="headerlink" title="7. 键的类型  type"></a>7. 键的类型  <strong>type</strong></h2><p>若键不存在，返回 none<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure></p><h1 id="5种常用的数据类型"><a href="#5种常用的数据类型" class="headerlink" title="5种常用的数据类型"></a>5种常用的数据类型</h1><p>Redis 是字典服务器，其中键都是字符串类型，并且数据结构也都是在字符串类型上构建的。</p><p>而字符串类型的底层实现值可以为字符串，整数，浮点数，二进制。</p><p>字符串类型最大不能超过 512MB.</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="1-设置值-set、setex、setnx、set-xx"><a href="#1-设置值-set、setex、setnx、set-xx" class="headerlink" title="1. 设置值 set、setex、setnx、set .. xx"></a>1. 设置值 set、setex、setnx、set .. xx</h4><p>==set 命令的参数：==</p><ul><li>ex seconds: 秒过期</li><li>px milliseconds ： 毫秒过期</li><li>nx ：键必须不存在 （失败返回 0）</li><li>xx ：键必须存在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// set key value [ex seconds] [px milliseconds] [nx | xx]</span><br><span class="line"></span><br><span class="line">set hello world ex 60</span><br></pre></td></tr></table></figure></li></ul><p>==设置时间:==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setex key seconds value</span><br></pre></td></tr></table></figure><p>==设置不存在的key==</p><font color="red" size="5">setnx 可以作为分布式锁的一种实现方案</font><ul><li>失败： 返回 0</li><li>成功： 返回 1<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx key value</span><br></pre></td></tr></table></figure></li></ul><p>==设置存在的key==</p><ul><li>失败： 返回 nil</li><li>成功： 返回 ok<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value xx</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-获取值-get"><a href="#2-获取值-get" class="headerlink" title="2. 获取值 get"></a>2. 获取值 get</h4><p>==获取键值==</p><ul><li>不存在： 返回 nil</li><li>存在：   返回值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-批量设置值-mset"><a href="#3-批量设置值-mset" class="headerlink" title="3. 批量设置值 mset"></a>3. 批量设置值 mset</h4><font color="red" size="3">批量操作可以减少网络资源的浪费</font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key1 value1   key2 value2    key3 value3</span><br></pre></td></tr></table></figure>#### 4. 批量获取值 mget如果有空的， 该空值返回 nil<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget key1  key2  key3</span><br></pre></td></tr></table></figure>#### 5. 计数操作 incr、decr、incrby(自增指定值)、decrby(自减指定值)<font color="red" size="3">redis 的计数不是cas, 因为是单线程，不会出现冲突</font>- 不存在：  自动创建并返回1- 存在：    返回增后的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 自增</span><br><span class="line">//incr key</span><br></pre></td></tr></table></figure>### 不常用命令#### 1. 追加值 append <font color="red" size="3">可以对incr 的整数或者其他类型追加，因为它们都是string类型</font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// append key  value</span><br></pre></td></tr></table></figure><h4 id="2-字符串的长度-strlen"><a href="#2-字符串的长度-strlen" class="headerlink" title="2. 字符串的长度 strlen"></a>2. 字符串的长度 strlen</h4><ul><li>不存在：   返回 0 </li><li>存在：     返回字符串长度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// strlen key</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-设置并且返回原值-getset"><a href="#3-设置并且返回原值-getset" class="headerlink" title="3. 设置并且返回原值  getset"></a>3. 设置并且返回原值  getset</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// getset key value</span><br></pre></td></tr></table></figure><h4 id="4-设置指定位置的字符"><a href="#4-设置指定位置的字符" class="headerlink" title="4. 设置指定位置的字符"></a>4. 设置指定位置的字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// setrange key offset value</span><br></pre></td></tr></table></figure><h4 id="5-获取部分字符串"><a href="#5-获取部分字符串" class="headerlink" title="5. 获取部分字符串"></a>5. 获取部分字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// getrange key start end</span><br></pre></td></tr></table></figure><h3 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h3><p>字符串类型内部有3 种编码，</p><ul><li>int :    8字节</li><li>embstr ：&lt;= 39 字节的字符串</li><li>raw ：   &gt; 39 字节的字符串</li></ul><p>查看类型的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object  encoding key1</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1. 缓存"></a>1. 缓存</h4><font color="red" size="3">加速读写并减轻后端数据库的压力</font><p>推荐的key 定义规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 业务名：对象名：id：[属性]</span><br><span class="line"></span><br><span class="line">miaosha:item:itemId:price</span><br></pre></td></tr></table></figure><h4 id="2-计数"><a href="#2-计数" class="headerlink" title="2. 计数"></a>2. 计数</h4><p>实现业务上的快速技术、查询缓存，能够异步的写入数据库，减少数据库的访问压力。</p><h4 id="3-session-共享"><a href="#3-session-共享" class="headerlink" title="3. session 共享"></a>3. session 共享</h4><p>web 服务通常由多台服务器协同提供用户访问的服务，而用户登陆后的登陆信息如何保存？</p><p>借助 Redis 缓存将 用户session 集中管理，当用户登陆和查询时，在 Redis 服务器更新或者查询即可。</p><h4 id="4-限速"><a href="#4-限速" class="headerlink" title="4. 限速"></a>4. 限速</h4><p>比如限制单位时间内验证码的次数。</p><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="1-设置值-hset-amp-hsetnx-不存在才设置"><a href="#1-设置值-hset-amp-hsetnx-不存在才设置" class="headerlink" title="1. 设置值 hset &amp; hsetnx (不存在才设置)"></a>1. 设置值 hset &amp; hsetnx (不存在才设置)</h4><p><strong>hset:</strong></p><ul><li>成功： 返回 1</li><li>失败： 返回 0 </li></ul><p><strong>hsetnx</strong></p><ul><li>成功：</li><li>失败：<br><font color="red" size="3"> 待验证</font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// hashkey : value</span><br><span class="line">hset key hashKey value</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-获取值-hget"><a href="#2-获取值-hget" class="headerlink" title="2. 获取值 hget"></a>2. 获取值 hget</h4><p>不存在： 返回nil<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hget key</span><br></pre></td></tr></table></figure></p><h4 id="3-删除值-hdel-key-field"><a href="#3-删除值-hdel-key-field" class="headerlink" title="3. 删除值 hdel key field"></a>3. 删除值 hdel key field</h4><ul><li>删除成功：返回 1</li><li>删除失败：返回 0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// hset  mykey key1 value1</span><br><span class="line">// hset  mykey key2 value2</span><br><span class="line"></span><br><span class="line">hdel  mykey  key1</span><br><span class="line">// 删除后再查询会返回 nil</span><br></pre></td></tr></table></figure><h4 id="4-计算field-个数-hlen"><a href="#4-计算field-个数-hlen" class="headerlink" title="4. 计算field 个数 hlen"></a>4. 计算field 个数 hlen</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen mykey</span><br></pre></td></tr></table></figure><h4 id="5-批量设置或者获取-hmset-amp-hmget"><a href="#5-批量设置或者获取-hmset-amp-hmget" class="headerlink" title="5. 批量设置或者获取 hmset &amp; hmget"></a>5. 批量设置或者获取 hmset &amp; hmget</h4><p><strong>hmset</strong> </p><ul><li>成功返回 OK</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hmset  mykey key3 value3  key4 value 4</span><br><span class="line"></span><br><span class="line">// 批量获取返回</span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br></pre></td></tr></table></figure><h4 id="6-判断field-是否存在-hexists"><a href="#6-判断field-是否存在-hexists" class="headerlink" title="6. 判断field 是否存在 hexists"></a>6. 判断field 是否存在 hexists</h4><ul><li>存在： 返回 1</li><li>不存在： 返回 0<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexists  mykey key3</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-获取所有的field-hkeys"><a href="#7-获取所有的field-hkeys" class="headerlink" title="7. 获取所有的field, hkeys"></a>7. 获取所有的field, hkeys</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hkeys mykey</span><br><span class="line"></span><br><span class="line">// 返回</span><br><span class="line"></span><br><span class="line">1) &quot;key2&quot;</span><br><span class="line">2) &quot;key1&quot;</span><br><span class="line">3) &quot;key3&quot;</span><br><span class="line">4) &quot;key4&quot;</span><br><span class="line">5) &quot;key5&quot;</span><br></pre></td></tr></table></figure><h4 id="8-获取所有的value，-hvals-mykey"><a href="#8-获取所有的value，-hvals-mykey" class="headerlink" title="8. 获取所有的value， hvals mykey"></a>8. 获取所有的value， hvals mykey</h4><h4 id="9-获取-k-v-：-hgetall-mykey"><a href="#9-获取-k-v-：-hgetall-mykey" class="headerlink" title="9. 获取 k - v ： hgetall mykey"></a>9. 获取 k - v ： hgetall mykey</h4><font color="red" size="3">值太多时，会引起阻塞，线上可以 hscan  和 hmget</font><h4 id="10-values-的自增-hincrby-hincrbyfloat"><a href="#10-values-的自增-hincrby-hincrbyfloat" class="headerlink" title="10. values 的自增  hincrby hincrbyfloat"></a>10. values 的自增  hincrby hincrbyfloat</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hincrby</span><br></pre></td></tr></table></figure><h4 id="11-计算value的字符串长度（需要Redis3-2以上）-hstrlen"><a href="#11-计算value的字符串长度（需要Redis3-2以上）-hstrlen" class="headerlink" title="11. 计算value的字符串长度（需要Redis3.2以上） hstrlen"></a>11. 计算value的字符串长度（需要Redis3.2以上） hstrlen</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hstrlen mykey key1</span><br></pre></td></tr></table></figure><h3 id="内部编码-1"><a href="#内部编码-1" class="headerlink" title="内部编码"></a>内部编码</h3><p>哈希类型内部编码主要有两种：</p><ul><li>ziplist （更省内存）（数量小于512且value 小于64字节时，默认使用）</li><li>hashtable  读写时间复杂度 O(1)</li></ul><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="利用-hash-存储-数据库中的整行字段"><a href="#利用-hash-存储-数据库中的整行字段" class="headerlink" title="利用 hash 存储 数据库中的整行字段"></a>利用 hash 存储 数据库中的整行字段</h4><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul><li>列表用来储存多个有序的字符串。</li><li>可以当队列和堆栈使用</li></ul><h3 id="主要的操作："><a href="#主要的操作：" class="headerlink" title="主要的操作："></a>主要的操作：</h3><ul><li>添加 <code>rpush &amp; lpush</code>,  <code>linsert</code></li><li>删除 <code>lpop &amp; rpop</code>, <code>lrem</code>, <code>ltrim</code></li><li>查找 <code>lrange</code>,   <code>lindex</code>, <code>llen</code></li><li>修改  <code>lset</code></li><li>阻塞 <code>blpop &amp; brpop</code></li></ul><h4 id="1-添加-lpush-amp-rpush-linsert"><a href="#1-添加-lpush-amp-rpush-linsert" class="headerlink" title="1. 添加 lpush &amp; rpush, linsert"></a>1. 添加 lpush &amp; rpush, linsert</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 左，右插入</span><br><span class="line">lpush elgong.list  1</span><br><span class="line"></span><br><span class="line">rpush elgong.lsit  2</span><br><span class="line"></span><br><span class="line">// 指定位置插入</span><br><span class="line">linsert  elgong.list  after| before  location  value</span><br></pre></td></tr></table></figure><h4 id="2-删除-rpop-amp-lpop-lrem"><a href="#2-删除-rpop-amp-lpop-lrem" class="headerlink" title="2. 删除 rpop &amp; lpop, lrem"></a>2. 删除 rpop &amp; lpop, lrem</h4><p><strong>lrem</strong> 删除指定元素<br><code>lrem elgong.list  count  value</code></p><ul><li>value 为被删除的值</li><li>count &gt; 0:  从左往右删除 count 个</li><li>count = 0:  全部删除</li><li>count &lt; 0： 从右往左删除 count 个</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpop elgong.list</span><br><span class="line">lpop elgong.list</span><br><span class="line"></span><br><span class="line">// 删除指定的元素</span><br></pre></td></tr></table></figure><h4 id="3-查找-lrange-，-lindex，-llen"><a href="#3-查找-lrange-，-lindex，-llen" class="headerlink" title="3. 查找 lrange ， lindex， llen"></a>3. 查找 lrange ， lindex， llen</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取从左到右 所有元素</span><br><span class="line">lrange elgong.list 0  -1</span><br><span class="line"></span><br><span class="line">// 指定范围查找</span><br><span class="line">lrange elgong.list  start  end</span><br><span class="line"></span><br><span class="line">// 获取指定下标的元素, 索引为2</span><br><span class="line">lindex  elgong.list 2</span><br></pre></td></tr></table></figure><h4 id="4-修改-lset"><a href="#4-修改-lset" class="headerlink" title="4. 修改 lset"></a>4. 修改 lset</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lset key index newValue</span><br></pre></td></tr></table></figure><h4 id="5-阻塞-blpop-amp-brpop"><a href="#5-阻塞-blpop-amp-brpop" class="headerlink" title="5. 阻塞 blpop &amp; brpop"></a>5. 阻塞 blpop &amp; brpop</h4><p>有参数 timeout，</p><p>如果timeout = 0， 一直阻塞<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 等到list有值时再返回</span><br><span class="line">blpop elgong.list  0</span><br><span class="line"></span><br><span class="line">// 阻塞最长3s</span><br><span class="line">blpop elgong.list  3</span><br></pre></td></tr></table></figure></p><h3 id="内部编码-2"><a href="#内部编码-2" class="headerlink" title="内部编码"></a>内部编码</h3><ul><li>ziplist （长度小于512， 单值 小于64 字节时默认采用）</li><li>linkedlist</li></ul><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="1-消息队列"><a href="#1-消息队列" class="headerlink" title="1. 消息队列"></a>1. 消息队列</h4><p>通过阻塞可以实现生产者消费者模式。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="内部编码-3"><a href="#内部编码-3" class="headerlink" title="内部编码"></a>内部编码</h3><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><h3 id="不常用命令"><a href="#不常用命令" class="headerlink" title="不常用命令"></a>不常用命令</h3><h3 id="内部编码-4"><a href="#内部编码-4" class="headerlink" title="内部编码"></a>内部编码</h3><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><h1 id="键的管理"><a href="#键的管理" class="headerlink" title="键的管理"></a>键的管理</h1><p>常用的指令入 del, exists, expire, type, object.</p><h2 id="6-键的重命名-rename"><a href="#6-键的重命名-rename" class="headerlink" title="6. 键的重命名 rename"></a>6. 键的重命名 rename</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename elgong.list  newlist</span><br></pre></td></tr></table></figure><h2 id="7-随机返回一个键-randomKey"><a href="#7-随机返回一个键-randomKey" class="headerlink" title="7. 随机返回一个键 randomKey"></a>7. 随机返回一个键 randomKey</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randomKey</span><br></pre></td></tr></table></figure><h2 id="8-键过期时间"><a href="#8-键过期时间" class="headerlink" title="8. 键过期时间"></a>8. 键过期时间</h2><h2 id="9-键的遍历"><a href="#9-键的遍历" class="headerlink" title="9. 键的遍历"></a>9. 键的遍历</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 匹配</span><br><span class="line">keys [j,r]edis</span><br><span class="line">// 输出： jedis 和 redis 中存在的</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列文章整理摘抄自&lt;redis 开发与运维=&quot;&quot;&gt;&lt;/redis&gt;&lt;/p&gt;
&lt;h1 id=&quot;全局命令&quot;&gt;&lt;a href=&quot;#全局命令&quot; class=&quot;headerlink&quot; title=&quot;全局命令&quot;&gt;&lt;/a&gt;全局命令&lt;/
      
    
    </summary>
    
      <category term="缓存中间件" scheme="http://www.elgong.top/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="redis" scheme="http://www.elgong.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Bloom Filter 布隆过滤器</title>
    <link href="http://www.elgong.top/2020/05/16/Bloom-Filter-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://www.elgong.top/2020/05/16/Bloom-Filter-布隆过滤器/</id>
    <published>2020-05-15T16:12:25.000Z</published>
    <updated>2020-05-15T16:14:14.913Z</updated>
    
    <content type="html"><![CDATA[<p>[toc] </p><p>[toc]</p><p><a href="https://github.com/google/guava" target="_blank" rel="noopener">谷歌开源的Guava的布隆过滤器</a></p><h1 id="布隆过滤器是什么？"><a href="#布隆过滤器是什么？" class="headerlink" title="布隆过滤器是什么？"></a>布隆过滤器是什么？</h1><p>布隆过滤器由很长的<strong>二进制向量</strong>和一系列<strong>随机映射函数</strong>组成。</p><p>布隆过滤器可以用于检索一个元素是否在一个集合中。</p><p>它能给出的答案是： ==<strong>一定不存在 /可能存在</strong>==</p><h1 id="布隆过滤器的应用场景？"><a href="#布隆过滤器的应用场景？" class="headerlink" title="布隆过滤器的应用场景？"></a>布隆过滤器的应用场景？</h1><ul><li><strong>提升磁盘查询未命中的效率</strong><ul><li>通过bloom filter 过滤掉一定不存在的数据查询，减少访问磁盘和网络的次数。</li></ul></li><li><strong>redis限流-缓存击穿问题</strong><ul><li>redis 缓存前加一层布隆过滤器，应对缓存击穿问题 </li></ul></li><li><strong>海量网页黑名单</strong></li><li><strong>爬虫网址判重系统</strong></li></ul><h1 id="布隆过滤器的优缺点"><a href="#布隆过滤器的优缺点" class="headerlink" title="布隆过滤器的优缺点?"></a>布隆过滤器的优缺点?</h1><ul><li><strong>优点</strong>：<ul><li>布隆过滤器存储空间和插入/查询时间都是常数 O（k）</li><li>随机映射函数间独立，可以并行计算</li></ul></li><li><strong>缺点</strong>：<ul><li>随着存入的元素数量增加，误算率随之增加。</li><li>无法删除，因为不能确定元素是否真的在bitmap中。</li></ul></li></ul><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>布隆过滤器是一个很长的二进制向量，配合K 个随机映射函数，主要的操作是两个：<br><strong>插入</strong>和<strong>查找</strong></p><p><strong>插入时</strong>： 元素通过k 个随机映射函数，得到 k 个索引， 将二进制向量中的对应位置 置1</p><p><strong>查找时</strong>： 元素通过k 个随机映射函数，得到 k 个索引，查看对应位置是否全为1， 如果有0则一定不存在。</p><h2 id="怎么选择-参数？"><a href="#怎么选择-参数？" class="headerlink" title="怎么选择 参数？"></a>怎么选择 参数？</h2><p>假设输入元素的个数为 n，二进制向量的长度为m（也就是布隆过滤器大小），所容忍的误判率p和随机映射函数的个数k。计算公式如下：（小数向上取整）</p><p><img src="/2020/05/16/Bloom-Filter-布隆过滤器/F6AD6F9EB403400A8E5208E3422A2EBF" alt="image"></p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import java.util.BitSet;</span><br><span class="line"></span><br><span class="line">public class MyBloomFilter &#123;</span><br><span class="line">    //2&lt;&lt;25表示32亿个比特位</span><br><span class="line">    private static final int DEFAULT_SIZE= 2&lt;&lt; 25;</span><br><span class="line">    private  static  final int[] seeds=new int[]&#123;3,5,7,11,13,19,23,37&#125;;</span><br><span class="line">   </span><br><span class="line">    //这么大存储在BitSet</span><br><span class="line">    private BitSet bits=new BitSet(DEFAULT_SIZE);</span><br><span class="line">    private SimpleHash[] func=new SimpleHash[seeds.length];</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       </span><br><span class="line">        //可疑网站</span><br><span class="line">        String value=&quot;www.baidu.com&quot;;</span><br><span class="line">        MyBloomFilter filter=new MyBloomFilter();</span><br><span class="line">      </span><br><span class="line">        //加入之前判断一下</span><br><span class="line">        System.out.println(filter.contains(value));</span><br><span class="line">        filter.add(value);</span><br><span class="line">      </span><br><span class="line">        //加入之后判断一下</span><br><span class="line">        System.out.println(filter.contains(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //构造函数</span><br><span class="line">    public MyBloomFilter()&#123;</span><br><span class="line">        for(int i=0;i&lt;seeds.length;i++)&#123;</span><br><span class="line">            func[i]=new SimpleHash(DEFAULT_SIZE,seeds[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加网站</span><br><span class="line">    public void add(String value)&#123;</span><br><span class="line">        for (SimpleHash f : func) &#123;</span><br><span class="line">            bits.set(f.hash(value),true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断可疑网站是否存在</span><br><span class="line">    public boolean contains(String value)&#123;</span><br><span class="line">        if(value==null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean ret=true;</span><br><span class="line">        for (SimpleHash f : func) &#123;</span><br><span class="line">            ret=ret&amp;&amp;bits.get(f.hash(value));</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class SimpleHash &#123;</span><br><span class="line">        private int cap;</span><br><span class="line">        private int seed;</span><br><span class="line">        public SimpleHash(int cap,int seed)&#123;</span><br><span class="line">            this.cap=cap;</span><br><span class="line">            this.seed=seed;</span><br><span class="line">        &#125;</span><br><span class="line">        public int hash(String value)&#123;</span><br><span class="line">            int result=0;</span><br><span class="line">            int len=value.length();</span><br><span class="line">            for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">                result=seed*result+value.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">            return (cap-1)&amp;result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc] &lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/google/guava&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;谷歌开源的Guava的布隆过滤器&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;布隆过滤
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://www.elgong.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="布隆过滤器" scheme="http://www.elgong.top/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>redis学习-redis的价值</title>
    <link href="http://www.elgong.top/2020/05/12/redis%E5%AD%A6%E4%B9%A0-redis%E7%9A%84%E4%BB%B7%E5%80%BC/"/>
    <id>http://www.elgong.top/2020/05/12/redis学习-redis的价值/</id>
    <published>2020-05-11T16:06:27.000Z</published>
    <updated>2020-06-14T11:03:00.368Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><blockquote><p>本系列文章整理摘抄自<redis 开发与运维=""></redis></p><h1 id="Redis-是什么？"><a href="#Redis-是什么？" class="headerlink" title="Redis 是什么？"></a>Redis 是什么？</h1></blockquote><p>Redis 是一种 基于键值对的 <code>NOSQL</code> 内存数据库, 具有丰富的数据类型和基于内存的快速读写能力,单线程命令处理机制。</p><p>Redis 的值类型有多种：</p><ul><li>string</li><li>hash</li><li>list</li><li>set</li><li>zset (有序集合)</li><li>Bitmaps (位图)</li><li>HyperLogLog</li><li>GEO  (地理信息定位)</li></ul><p>Redis 提供了一下的附加功能：</p><ul><li>键的有效期</li><li>发布订阅</li><li>事务</li><li>Pipeline 流水线</li><li>Lua脚本</li><li>可持久化（RDB 和 AOF 两种策略）</li></ul><h1 id="Redis-有哪些特点？"><a href="#Redis-有哪些特点？" class="headerlink" title="Redis 有哪些特点？"></a>Redis 有哪些特点？</h1><p>Redis 有5大重要的特征：</p><ul><li><strong>读写速度快</strong>（读写速度可达10万/秒）<ul><li>基于内存</li><li>C 语言实现</li><li>单线程架构（IO多路模型），省却了线程间调度</li></ul></li><li><strong>基于键值对的字典服务器</strong></li><li><strong>可持久化</strong></li><li><strong>主从复制</strong></li><li><strong>高可用 &amp; 分布式</strong><ul><li>持久化</li><li>复制</li><li>哨兵</li><li>集群</li></ul></li></ul><h1 id="Redis-应用场景有哪些？"><a href="#Redis-应用场景有哪些？" class="headerlink" title="Redis 应用场景有哪些？"></a>Redis 应用场景有哪些？</h1><ul><li>缓存</li><li>排行榜系统(提供列表和有序集合)</li><li>计数器 （网站播放数，电商浏览数）</li><li>社交网络（点赞，粉丝，共同爱好，推送，下拉刷新）</li><li>消息队列</li><li>session 共享</li><li>限制访问的次数</li></ul><h1 id="为什么选择单线程？"><a href="#为什么选择单线程？" class="headerlink" title="为什么选择单线程？"></a>为什么选择单线程？</h1><p>官方的解释：</p><p>我们知道，运算和处理速度上，CPU &gt;&gt;&gt; 内存 &gt;&gt;&gt; 硬盘和网络。</p><ul><li>原因1：<strong>单线程内存读写速度优于多线程的并发切换消耗</strong></li></ul><p>CPU并不是Redis的瓶颈，因为通常Redis要么受内存限制，要么受网络限制，而多线程的线程调度消耗的资源要比在内存读取数据大得多，所以选择了单线程 + IO 多路复用模型。</p><ul><li>原因2：<strong>数据的一致性</strong></li></ul><p>单线程的操作，一定是线程安全的，并且避免了使用锁同步等。</p><font color="red" size="4">为了最大程度地利用CPU，可以在同一服务器上启动多个Redis实例，并为每个实例绑定一个CPU.  (Linux 通过 `taskset -c 1,2,3 /etc/init.d/mysql start`)</font><h1 id="Redis-的不足之处？"><a href="#Redis-的不足之处？" class="headerlink" title="Redis 的不足之处？"></a>Redis 的不足之处？</h1><p>数据有冷热之分，热点数据可以放在Redis 中，加速读写，减少对后端数据库的访问压力。</p><p>但是过于冷的数据，会浪费内存空间。</p><h1 id="与同类型的技术的横向对比？"><a href="#与同类型的技术的横向对比？" class="headerlink" title="与同类型的技术的横向对比？"></a>与同类型的技术的横向对比？</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列文章整理摘抄自&lt;redis 开发与运维=&quot;&quot;&gt;&lt;/redis&gt;&lt;/p&gt;
&lt;h1 id=&quot;Redis-是什么？&quot;&gt;&lt;a href=&quot;#Redis-是什么？&quot; class=&quot;headerlink&quot; title=&quot;Redi
      
    
    </summary>
    
      <category term="缓存中间件" scheme="http://www.elgong.top/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="redis" scheme="http://www.elgong.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>将博客搬至CSDN</title>
    <link href="http://www.elgong.top/2020/04/22/%E5%B0%86%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%87%B3CSDN/"/>
    <id>http://www.elgong.top/2020/04/22/将博客搬至CSDN/</id>
    <published>2020-04-22T04:21:03.000Z</published>
    <updated>2020-04-22T04:22:27.029Z</updated>
    
    <content type="html"><![CDATA[<p>本文为满足将博客内容搬迁至csdn 的审核要求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文为满足将博客内容搬迁至csdn 的审核要求。&lt;/p&gt;

      
    
    </summary>
    
      <category term="闲聊" scheme="http://www.elgong.top/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="http://www.elgong.top/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>Java 向上转型&amp;向下转型</title>
    <link href="http://www.elgong.top/2020/04/22/Java-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B/"/>
    <id>http://www.elgong.top/2020/04/22/Java-向上转型-向下转型/</id>
    <published>2020-04-22T03:53:28.000Z</published>
    <updated>2020-04-22T03:57:29.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="向上转型和向下转型"><a href="#向上转型和向下转型" class="headerlink" title="向上转型和向下转型"></a>向上转型和向下转型</h1><ul><li><strong>向上转型：</strong>  父类引用 指向子类对象<ul><li>调用效果： 父类的属性  +    <font color="red"><big>父类的方法（未被子类重写）+ 子类的方法 （重写了父类）</big></font></li></ul></li><li><strong>向下转型：</strong><ul><li>调用效果：子类的属性  +  子类的方法 </li></ul></li></ul><p>例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.elgong.cast;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Father.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 静态类变量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> staticInt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String staticStr = <span class="string">"father static str"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 实例变量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Int = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span>  String Str = <span class="string">"father str"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  会被子类覆盖的方法  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"被子类覆盖的方法 :say "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  不被子类覆盖的方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOnlyFather</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"未被子类覆盖的方法 : sayOnlyFather"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 私有方法默认为  fianl， 不可被继承， 也不参与转型 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" father sleep"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.elgong.cast;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Son.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 子类的 变量区 */</span></span><br><span class="line">    <span class="comment">/* 静态变量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> staticInt = <span class="number">111</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String staticStr = <span class="string">"son static str"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 实例变量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Int = <span class="number">222</span>;</span><br><span class="line">    <span class="keyword">public</span>  String Str = <span class="string">"son  str"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 子类独有的变量 */</span></span><br><span class="line">    <span class="keyword">public</span> String strOnlySon = <span class="string">"str Only Son"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类重写的方法：say"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类独有的方法： son sleep : "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.elgong.cast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" 向上转型：  "</span>);</span><br><span class="line">        <span class="comment">/* 向上转型 */</span></span><br><span class="line">        Father f = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line">        System.out.println(f.Int);  <span class="comment">// 打印 2</span></span><br><span class="line">        System.out.println(f.Str);  <span class="comment">// 打印 father  str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        f.say();  <span class="comment">// 打印 son say :</span></span><br><span class="line">        f.sayOnlyFather();  <span class="comment">// 打印   father say 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 向下转型 */</span></span><br><span class="line">        System.out.println(<span class="string">" 向下转型：  "</span>);</span><br><span class="line">        Son s = (Son)f;</span><br><span class="line"></span><br><span class="line">        System.out.println(s.Int);  <span class="comment">// 打印   222</span></span><br><span class="line">        System.out.println(s.Str);  <span class="comment">// 打印   son  str</span></span><br><span class="line">        System.out.println(s.strOnlySon);   <span class="comment">// 打印   strOnlySon</span></span><br><span class="line"></span><br><span class="line">        s.say();  <span class="comment">// 打印  son say : </span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;向上转型和向下转型&quot;&gt;&lt;a href=&quot;#向上转型和向下转型&quot; class=&quot;headerlink&quot; title=&quot;向上转型和向下转型&quot;&gt;&lt;/a&gt;向上转型和向下转型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;向上转型：&lt;/strong&gt;  父类引用 指向子类对象&lt;
      
    
    </summary>
    
      <category term="Java多态" scheme="http://www.elgong.top/categories/Java%E5%A4%9A%E6%80%81/"/>
    
    
      <category term="向上转型&amp;向下转型" scheme="http://www.elgong.top/tags/%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>蓄水池抽样算法</title>
    <link href="http://www.elgong.top/2020/04/19/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95/"/>
    <id>http://www.elgong.top/2020/04/19/蓄水池抽样算法/</id>
    <published>2020-04-19T09:18:21.000Z</published>
    <updated>2020-04-21T01:52:30.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、预备知识"><a href="#一、预备知识" class="headerlink" title="一、预备知识"></a>一、预备知识</h1><p>Java 随机数生成的方法：</p><p><code>java.util.Random</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Main.java </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定随机种子，默认以时间为种子</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random(<span class="number">2048</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成 0 ~ 99 之间的整数</span></span><br><span class="line">        System.out.println( random.nextInt(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成 0 ~ 1.0 之间的小数</span></span><br><span class="line">        System.out.println( random.nextDouble());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成 布尔</span></span><br><span class="line">        System.out.println( random.nextBoolean());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、海量数据随机采样K个的需求"><a href="#二、海量数据随机采样K个的需求" class="headerlink" title="二、海量数据随机采样K个的需求"></a>二、海量数据随机采样K个的需求</h1><p>从固定区间内随机采样数据十分简单，直接调用 <code>random.nextInt()</code> 就可以。</p><p><strong>但如果是长度未知的海量数据流呢？该如何实现等概率采样？</strong></p><p>​        答：蓄水池采样算法就是一种解决方案。</p><h1 id="三、实现原理（从未知长度的海量数据随机采样K个元素）"><a href="#三、实现原理（从未知长度的海量数据随机采样K个元素）" class="headerlink" title="三、实现原理（从未知长度的海量数据随机采样K个元素）"></a>三、实现原理（从未知长度的海量数据随机采样K个元素）</h1><h2 id="3-1-举例说明：从未知流中随机选择一个元素-K-1-的实现方法"><a href="#3-1-举例说明：从未知流中随机选择一个元素-K-1-的实现方法" class="headerlink" title="3.1 举例说明：从未知流中随机选择一个元素(K = 1)的实现方法"></a>3.1 <strong>举例说明：从未知流中随机选择一个元素(K = 1)的实现方法</strong></h2><ul><li><strong>当数据流中只有一个数据</strong>：<ul><li>直接返回该数据</li></ul></li><li><strong>当数据流中有两个数据</strong>：<ul><li>D0，D1 中随机选择一个。 概率均为 1/2</li></ul></li><li><strong>当数据流中有三个数据</strong><ul><li>Step1 : 处理 D0, D1 时 先保留一个，概率分别为 1/2</li><li>Step2 :处理 D3 时, 1/3 的概率保留D3, 1 - 1/3 的概率保留 Step1 中的结果</li></ul></li><li><strong>递推下去</strong>      </li></ul><h2 id="3-2-解析：假设流的长度只有3"><a href="#3-2-解析：假设流的长度只有3" class="headerlink" title="3.2 解析：假设流的长度只有3"></a>3.2 <strong>解析：假设流的长度只有3</strong></h2><p>数据 D1 被采样概率：（1/2）<em> (2/3) = 1/3<br>数据 D2 被采样概率：（1/2）</em>(2/3) = 1/3<br>数据 D3 被采样概率：  1/3</p><h2 id="3-3-算法描述"><a href="#3-3-算法描述" class="headerlink" title="3.3 算法描述"></a>3.3 算法描述</h2><ul><li>先选取数据流中的前k个元素，保存在池子pool中；</li><li>从第j（k + 1 &lt;= j &lt;= n）个元素开始<ul><li>每次先以概率 p = k/j选择是否让第j个元素留下；<ul><li>若j被选中，则从A中随机选择一个元素并用该元素j替换它</li><li>否则直接淘汰该元素；</li></ul></li></ul></li><li>重复步骤2直到结束，最后集合A中剩下的就是保证随机抽取的k个元素。</li></ul><h1 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private int[] sampling(int K) &#123;</span><br><span class="line">    int[] pool = new int[K];</span><br><span class="line">    </span><br><span class="line">    // 前 K 个元素直接放入数组中</span><br><span class="line">    for (int i = 0; i &lt; K; i++) &#123; </span><br><span class="line">        pool[i] = stream[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = K; i &lt; N; i++) &#123; // K + 1 个元素开始进行概率采样</span><br><span class="line">        int r = random.nextInt(i + 1);</span><br><span class="line">        // 这里其实就是k/j的体现</span><br><span class="line">        if (r &lt; K) &#123;</span><br><span class="line">            pool[r] = stream[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、leetcode-题目："><a href="#五、leetcode-题目：" class="headerlink" title="五、leetcode 题目："></a>五、leetcode 题目：</h1><p><a href="https://leetcode-cn.com/problems/random-pick-index/" target="_blank" rel="noopener">T1. 随机数索引</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 蓄水池算法：</span></span><br><span class="line"><span class="comment">    只对重复值采用蓄水池算法</span></span><br><span class="line"><span class="comment">    出现次数     概率</span></span><br><span class="line"><span class="comment">    1            1</span></span><br><span class="line"><span class="comment">    2            1/2</span></span><br><span class="line"><span class="comment">    3            1/3</span></span><br><span class="line"><span class="comment">    4            1/4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = getIndex(nums, target);</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 统计出现的次数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (target == nums[i])&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (index == -<span class="number">1</span>)&#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> r = random.nextInt(count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>)&#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/linked-list-random-node/" target="_blank" rel="noopener">T2. 链表中随机选择节点</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@param</span> head The linked list's head.</span></span><br><span class="line"><span class="comment">        Note that the head is guaranteed to be not null, so it contains at least one node. */</span></span><br><span class="line">    <span class="keyword">private</span> ListNode head;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns a random node's value. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        ListNode now = head;</span><br><span class="line">        <span class="keyword">int</span> ret = -<span class="number">1</span>;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (now != <span class="keyword">null</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ret == -<span class="number">1</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                ret = now.val;</span><br><span class="line">                now = now.next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> rm = random.nextInt(count );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rm == <span class="number">0</span>)&#123;</span><br><span class="line">                ret =  now.val;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            now = now.next;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、预备知识&quot;&gt;&lt;a href=&quot;#一、预备知识&quot; class=&quot;headerlink&quot; title=&quot;一、预备知识&quot;&gt;&lt;/a&gt;一、预备知识&lt;/h1&gt;&lt;p&gt;Java 随机数生成的方法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java.util.Random&lt;/code&gt;&lt;/p
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://www.elgong.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="蓄水池抽样算法 海量数据随机采样" scheme="http://www.elgong.top/tags/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%9A%8F%E6%9C%BA%E9%87%87%E6%A0%B7/"/>
    
  </entry>
  
  <entry>
    <title>mysql-必知必会7-综合内容</title>
    <link href="http://www.elgong.top/2020/04/11/mysql-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A7-%E7%BB%BC%E5%90%88%E5%86%85%E5%AE%B9/"/>
    <id>http://www.elgong.top/2020/04/11/mysql-必知必会7-综合内容/</id>
    <published>2020-04-11T03:35:36.000Z</published>
    <updated>2020-04-11T04:08:35.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、关系型数据库Mysql"><a href="#一、关系型数据库Mysql" class="headerlink" title="一、关系型数据库Mysql"></a><strong>一、关系型数据库Mysql</strong></h1><p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。</p><ul><li><strong>数据库:</strong> 数据库是一些关联表的集合。.</li><li><strong>数据表:</strong> 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li><li><strong>列:</strong> 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。</li><li><strong>行：</strong>一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</li><li><strong>冗余</strong>：存储两倍数据，冗余可以使系统速度更快。</li><li><strong>主键</strong>：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li><li><strong>外键：</strong>外键用于关联两个表。</li><li><strong>复合键</strong>：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li><li><strong>索引：</strong>使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li><li><p><strong>参照完整性:</strong> 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性</p></li><li><p><strong>主键: 表示特定行.</strong></p><ul><li>主键不能重复</li><li>每行必有主键,且不能为 NULL</li></ul></li><li><p><strong>外键:</strong>  product 只存产品信息, 和供应商ID,  vendors 存供应商的信息(主键是ID),则vendors的主键就是product的外键.</p></li></ul><p>MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。</p><h1 id="二、-安装与删"><a href="#二、-安装与删" class="headerlink" title="二、 安装与删"></a><strong>二、 安装与删</strong></h1><ul><li><p>删除mysql</p><p><code>sudo apt purge mysql-* sudo apt autoremove</code></p></li><li><p>安装mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server </span><br><span class="line">sudo apt install mysql-client </span><br><span class="line">sudo apt install libmysqlclient-dev `</span><br></pre></td></tr></table></figure></li></ul><p><strong>数据库规范：</strong></p><ul><li>关键字大写，表名，列名小写</li><li>索引从1开始</li><li>每条命令用分号隔开</li><li><p>注释</p></li><li><p>单行注释   #</p></li><li>单行注释  — 注释文</li><li>多行注释  /<em> </em>/</li></ul><font color="red"><big>索引从1开始！</big></font><h1 id="三、常用命令"><a href="#三、常用命令" class="headerlink" title="三、常用命令"></a><strong>三、常用命令</strong></h1><h2 id="指令执行顺序："><a href="#指令执行顺序：" class="headerlink" title="指令执行顺序："></a><strong>指令执行顺序：</strong></h2><p><strong>SELECT  FROM  WHERE   GROUP BY  HAVING  ORDER BY LIMIT.</strong></p>   <font color="red"><big>开始 **->** FROM子句 **->** WHERE子句 **->** GROUP BY子句 **->** HAVING子句 **->** ORDER BY子句 **->** SELECT子句 **->** LIMIT子句 **->** 最终结果 </big></font>    <font color="red"><big>每个步骤都会为下一个步骤生成一个虚拟表</big></font><h2 id="1-登陆系统-选择数据库"><a href="#1-登陆系统-选择数据库" class="headerlink" title="1. 登陆系统, 选择数据库"></a><strong>1. 登陆系统, 选择数据库</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql -u 用户名 -p 密码</span><br><span class="line">mysql -h localhost -P 3306 -p</span><br><span class="line"></span><br><span class="line"># 查看所有数据库列表</span><br><span class="line">SHOW DATABSASES;</span><br><span class="line"># 查看选择的数据库中的表的列表</span><br><span class="line">SHOW TABLES;</span><br><span class="line"># 查看表中的列有哪些</span><br><span class="line">SHOW COLUMNS FROM 表名;  ||  DESCRIBE 表名;</span><br><span class="line"></span><br><span class="line"># 选择库</span><br><span class="line">USE 数据库的名字;</span><br><span class="line"></span><br><span class="line"># 查看表结构</span><br><span class="line">DESC 表名;</span><br></pre></td></tr></table></figure><h2 id="2-基础查询——检索-SELECT-DISTINCT"><a href="#2-基础查询——检索-SELECT-DISTINCT" class="headerlink" title="2 基础查询——检索 SELECT + DISTINCT"></a><strong>2 基础查询——检索 SELECT + DISTINCT</strong></h2><p>SELECT 子句 固定的顺序:</p><p><strong>SELECT  FROM  WHERE （原始表有的字段）  GROUP BY  HAVING  （分组后有的字段）ORDER BY LIMIT.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 选择多个字段 `着重号`当字段名与关键字冲突，用它可以避免冲突</span><br><span class="line">SELECT id, `name`, price FROM 表名; </span><br><span class="line"></span><br><span class="line"># 起别名 AS, 可以省略SELECT salary &quot;Month Salary&quot; from employees;</span><br><span class="line">SELECT salary AS &quot;Month Salary&quot; from employees;</span><br><span class="line"></span><br><span class="line"># 字符串拼接 concat</span><br><span class="line"># 特别注意+：  </span><br><span class="line"># 1+9=10  两个数值型做加法</span><br><span class="line"># &apos;12&apos;+ 3 = 15 字符转整数，再加 </span><br><span class="line"># &apos;job&apos;+2 = 2  转换失败，则字符串变0</span><br><span class="line"># null+任何值 = null</span><br><span class="line">SELECT concat(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) , price FROM 表名; </span><br><span class="line"></span><br><span class="line"># 检索所有字段</span><br><span class="line">SELECT * FROM 表名;</span><br><span class="line"></span><br><span class="line"># 字段去重  DISTINCT</span><br><span class="line">SELECT DISTINCT id FROM 表名;   # 不能应用于多列</span><br><span class="line"></span><br><span class="line"># 限制检索结果</span><br><span class="line"> SELECT  id FROM 表名  LIMIT 5;  # 前5 </span><br><span class="line"> SELECT  id FROM 表名  LIMIT 2,5;  #从 2+1 开始的  5个行</span><br><span class="line"> SELECT id FROM 表名 LIMIT 5 OFFSET 3;  # 从行3取5</span><br></pre></td></tr></table></figure><h2 id="3-排序检索-ORDER-BY-默认升序-LIMIT-OFFSET-DESC"><a href="#3-排序检索-ORDER-BY-默认升序-LIMIT-OFFSET-DESC" class="headerlink" title="3. 排序检索 ORDER   BY (默认升序) + LIMIT,  OFFSET, DESC"></a><strong>3. 排序检索 ORDER   BY (默认升序) + LIMIT,  OFFSET, DESC</strong></h2><p>可以根据非 select 字段排序。</p><p>SELECT  查询列表</p><p>FROM  表</p><p>【where 筛选条件】</p><p>ORDER BY  排序列表  [asc |  desc]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 按照某列排序,  多条件排序</span><br><span class="line">SELECT id FROM 表名 ORDER BY id ASC, age DESC;   # 可以根据其他列来排序</span><br><span class="line"></span><br><span class="line"># 按照多个条件排序</span><br><span class="line">SELECT id FROM 表名 ORDER BY age, size;   # 优先age, 重复时才根据size排序.</span><br><span class="line"></span><br><span class="line">#  指定降序  DESC</span><br><span class="line">SELECT id FROM 表名 ORDER BY age  DESC  size;  # DESC 只作用于在DESC 前面的, 所以 size仍然为升序</span><br><span class="line"></span><br><span class="line"># 找到最********的id</span><br><span class="line">SELECT id FROM 表名 ORDER BY age LIMIT 1;</span><br><span class="line"># 第二最的*******id</span><br><span class="line">SELECT id FROM 表名 ORDER BY age LIMIT 1 OFFSET 2;</span><br></pre></td></tr></table></figure><h2 id="4-条件查询"><a href="#4-条件查询" class="headerlink" title="4. 条件查询"></a><strong>4. 条件查询</strong></h2><h3 id="4-1-——逻辑运算-WHERE-AND-OR-NOT-IN-和EXISTS-看优化部分"><a href="#4-1-——逻辑运算-WHERE-AND-OR-NOT-IN-和EXISTS-看优化部分" class="headerlink" title="4.1  ——逻辑运算 WHERE + AND, OR,NOT IN 和EXISTS(看优化部分)"></a><strong>4.1  ——逻辑运算 WHERE + AND, OR,NOT</strong> <strong>IN 和EXISTS(看优化部分)</strong></h3><p><strong>作用：</strong></p><p>连接条件表达式</p><font color="red"><big>**如果计算次序不加括号时,  优先 AND**</big></font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#  =  !=  &lt;  &gt; &gt;=    &quot;BETWEEN 1 AND 2&quot;在指定值之间,包含端点</span><br><span class="line"># 不等于 ！=   或者  &lt;&gt;</span><br><span class="line">SELECT id FROM 表名 WHERE age=12 ORDER BY size;</span><br><span class="line"></span><br><span class="line"># 组合筛选  AND  OR</span><br><span class="line">SELECT id FROM 表名 WHERE age=12 AND size &lt; 10;</span><br><span class="line"></span><br><span class="line"># 计算次序,  不加括号时,  优先 AND</span><br><span class="line"># 解释: id&gt;3且age&gt;10,  或者 id=1</span><br><span class="line">SELECT id FROM 表名 WHERE id=1 OR id=3 AND age &gt; 10;   </span><br><span class="line"></span><br><span class="line"># NOT  否定后跟的所有条件.</span><br><span class="line">SELECT id FROM 表名 NOT WHERE id IN (1002, 1003)</span><br></pre></td></tr></table></figure><p><img src="/2020/04/11/mysql-必知必会7-综合内容/Users\Misaya\AppData\Local\YNote\data\elgong@126.com\e87e0bbb47ff40228ca7b6dbebad7954\clipboard.png" alt="img"></p><h3 id="4-2-——模糊查询-WHERE-LIKE-between-and-in-is-null"><a href="#4-2-——模糊查询-WHERE-LIKE-between-and-in-is-null" class="headerlink" title="4.2  ——模糊查询  WHERE + LIKE, between and, in, is null"></a><strong>4.2  ——模糊查询  WHERE + LIKE, between and, in, is null</strong></h3><ul><li><strong>like + 通配符：</strong> 参考7.</li><li><strong>between and ：</strong> 包含临界值， 不可颠倒顺序</li><li><strong>in：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># between and</span><br><span class="line">SELECT  * FROM 表名  WHERE id BETWEEN 100 and 120;</span><br><span class="line"></span><br><span class="line"># IN 取值必须在括号内</span><br><span class="line">SELECT id FROM 表名 WHERE id IN (1002, 1003)</span><br><span class="line"></span><br><span class="line"># IS NULL 筛选出空值  IS NOT NULL</span><br><span class="line">SELECT id FROM 表名 WHERE age IS NULL;</span><br></pre></td></tr></table></figure><p><strong>补. 空值处理 IFNULL(字段，空值时返回值)</strong></p><p><code>SELECT IFNULL(price, 0) FROM 表名;</code></p><h2 id="5-通配符-LIKE-正则表达式-REGEXP-都-不区分大小写"><a href="#5-通配符-LIKE-正则表达式-REGEXP-都-不区分大小写" class="headerlink" title="5. 通配符   LIKE + % , _   + 正则表达式 REGEXP   都**不区分大小写**"></a><strong>5. 通配符   LIKE + % , _   + 正则表达式</strong> <strong>REGEXP   都**</strong>不区分大小写**</h2><ol><li><p>通配符速度慢, 不要放在搜索开始处</p></li><li><p><strong>LIKE 匹配整个串,  正则表达式可以匹配子串</strong></p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#  通配符</span><br><span class="line">#  % 匹配0,1,多个字符</span><br><span class="line">SELECT id FROM 表名 WHERE string LIKE &apos;s%&apos;;   # s开头   </span><br><span class="line"></span><br><span class="line"># 下划线 _ , 匹配单个字符</span><br><span class="line"># 需要匹配 _ 时， 用转义   \_</span><br><span class="line">SELECT id FROM 表名 WHERE string LIKE &apos;s_&apos;;  </span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">#  正则表达式 REGEXP</span><br><span class="line"># 标准表达</span><br><span class="line">SELECT name FROM customers WHERE name REGEXP &apos;1000&apos;;</span><br><span class="line"></span><br><span class="line">&apos;.&apos;   # 任意一个字符</span><br><span class="line">&apos;A1&apos;| &apos;B2&apos;  # 匹配两个串之一</span><br><span class="line">&apos;[1-9]&apos;     # 匹配 1~9 范围内的值</span><br><span class="line">&apos;[123]&apos;     # 匹配1，2，3之一， 等价于【1 | 2 | 3】</span><br><span class="line">&apos;[^123]&apos;    # 匹配非123的值</span><br><span class="line">&apos;\\.&apos;       # 特殊字符转译   </span><br><span class="line"></span><br><span class="line"># 匹配多个实例, 不能单独出现,必须是指定上边的某种字符的匹配</span><br><span class="line"># 例如 &apos;.*&apos; 而不是&apos;*&apos;</span><br><span class="line">&apos;*&apos;  # 0或多个匹配</span><br><span class="line">&apos;+&apos;  # 1或多个匹配</span><br><span class="line">&apos;?&apos;  # 0或者1个匹配</span><br><span class="line">&#123;n&#125;  # 指定数目匹配</span><br><span class="line">&#123;n,&#125;  # 不少于指定数目的匹配</span><br><span class="line">&#123;n,m&#125;  # 数目范围,不超过255</span><br><span class="line"></span><br><span class="line">#定位元字符</span><br><span class="line">&apos;^&apos;   # 开始位置</span><br><span class="line">&apos;$&apos;   # 结尾</span><br><span class="line">&apos;[[:&lt;:]]&apos;  # 词开始</span><br><span class="line">&apos;[[:&lt;:]]&apos;  # 词结尾</span><br><span class="line"></span><br><span class="line"># 举例:</span><br><span class="line">&apos;^[1-9]&apos;   </span><br><span class="line">BINARY &apos;J 1000&apos;     # 指定区分大小写</span><br><span class="line"></span><br><span class="line">&apos;[a-zA-Z0-9]&apos;   # 匹配所有字符</span><br></pre></td></tr></table></figure><h2 id="6-数据处理常用函数-不区分大小写"><a href="#6-数据处理常用函数-不区分大小写" class="headerlink" title="6. 数据处理常用函数 (不区分大小写)"></a><strong>6. 数据处理常用函数 (不区分大小写)</strong></h2><ul><li>字符函数</li><li>数学函数</li><li>日期函数</li><li>其他函数</li><li>流程函数</li></ul><p>字符函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 文本处理函数</span><br><span class="line"># 1. 字符串字节个数,  汉字算三个字符</span><br><span class="line">Length() </span><br><span class="line"></span><br><span class="line"># 2. 拼接</span><br><span class="line">CONCAT(id, &quot;_&quot;, name)</span><br><span class="line"></span><br><span class="line"># 3. 大写 小写</span><br><span class="line">Lower()  # 小写</span><br><span class="line">Upper()  # 大写</span><br><span class="line"></span><br><span class="line"># 4. 返回子串的字符, 数据库索引从1开始</span><br><span class="line">SubStr(last_name, start) </span><br><span class="line">SubStr(last_name, start, length)   # 长度</span><br><span class="line"></span><br><span class="line"># 5. 查找子串, 返回第一次出现的索引， 查不到返回0</span><br><span class="line">INSTR(&quot;待查子串abcd&quot;, &quot;a&quot;)</span><br><span class="line"></span><br><span class="line"># 6. 去空格</span><br><span class="line">Trim(), LTrim(), RTrim()  </span><br><span class="line"></span><br><span class="line"># 7. 指定长度填充</span><br><span class="line">LPAD(name, length, &apos;*&apos;)</span><br><span class="line">RPAD(name, length, &apos;*&apos;)</span><br><span class="line"></span><br><span class="line"># 8. 替换</span><br><span class="line">REPLACE(原串, &apos;被替换串&apos;, &apos;新串&apos;)</span><br><span class="line"></span><br><span class="line"># 9. 字符串字符长度, 汉字也算 1个字符</span><br><span class="line">CHAR_LENGTH(s)  </span><br><span class="line">Soundex()   # 返回串的SOUNDEX值</span><br></pre></td></tr></table></figure><p>数学函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 1. 四舍五入</span><br><span class="line">ROUND(1.6);   # 2</span><br><span class="line">ROUND(1.567, 2)  # 小数点保留两位</span><br><span class="line"></span><br><span class="line"># 2. 上取整， &gt;=该参数的最小整数</span><br><span class="line">CEIL(1.00) </span><br><span class="line"># 下取整,   &lt;=该参数的最大整数</span><br><span class="line">FLOOR(-9.99)   # -10</span><br><span class="line"></span><br><span class="line"># 3. 小数点直接截断</span><br><span class="line">TRUNCATE(1.69999, 1)  # 1.6</span><br><span class="line"></span><br><span class="line"># 4. 取余数</span><br><span class="line">MOD(10, 3)  # 10%3</span><br><span class="line"></span><br><span class="line">ABS(x)   # 绝对值</span><br><span class="line">AVG(age)  # 某列的平均值 </span><br><span class="line">EXP(x)</span><br><span class="line">RAND()  # 0到1的随机数</span><br></pre></td></tr></table></figure><p>日期函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NOW()   # 当前日期和时间</span><br><span class="line">CURDATE() # 当前日期，不含时间</span><br><span class="line">Date()  # 返回时间中的日期部分....</span><br><span class="line">Day()   # 返回时间中的天数部分</span><br><span class="line">Year(NOW())</span><br><span class="line">Time()</span><br><span class="line">Month()  </span><br><span class="line">Hour()</span><br><span class="line">DateDiff()  # 计算日期差</span><br><span class="line"></span><br><span class="line"># 字符串转日期</span><br><span class="line">STR_TO_DATE(&apos;02-19-2020&apos;, &quot;%m-%d-%Y&quot;)</span><br><span class="line"></span><br><span class="line"># 日期的格式化输出</span><br><span class="line">DATE_FORMAT(NOW(), &apos;%y年%m月%d日&apos;)</span><br></pre></td></tr></table></figure><p>其他函数</p><p><code>VERSION()</code></p><h2 id="7-流程控制函数"><a href="#7-流程控制函数" class="headerlink" title="7. 流程控制函数"></a><strong>7. 流程控制函数</strong></h2><p>IF(逻辑判断， 成立执行， 不成立执行)</p><p>CASE:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># IF</span><br><span class="line">IF(10&gt;5, &apos;大&apos;, &apos;小&apos;)</span><br><span class="line">SELECT name IF(salary IS NULL, &quot;没薪水&quot;, &quot;有薪水&quot;)</span><br><span class="line"></span><br><span class="line"># CASE 第一种使用</span><br><span class="line">CASE &apos;要判断的表达式&apos;</span><br><span class="line">WHEN &apos;常量1&apos; then 值(没有分号) / 表达式(有分号);</span><br><span class="line">WHEN &apos;常量2&apos; then 值(没有分号) / 表达式(有分号);</span><br><span class="line">WHEN &apos;常量3&apos; then 值(没有分号) / 表达式(有分号);</span><br><span class="line">...</span><br><span class="line">ELSE 值(没有分号) / 表达式(有分号);</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line"># CASE 第二种语句</span><br><span class="line">CASE </span><br><span class="line">WHEN 表达式 then 值(没有分号) / 表达式(有分号);</span><br><span class="line">WHEN 表达式 then 值(没有分号) / 表达式(有分号);</span><br><span class="line">WHEN 表达式 then 值(没有分号) / 表达式(有分号);</span><br><span class="line">...</span><br><span class="line">ELSE 值(没有分号) / 表达式(有分号);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><h2 id="8-数据汇总-聚集函数-AVG-COUNT-MAX-MIN-SUM"><a href="#8-数据汇总-聚集函数-AVG-COUNT-MAX-MIN-SUM" class="headerlink" title="8. 数据汇总-聚集函数  AVG, COUNT, MAX, MIN, SUM"></a><strong>8. 数据汇总-聚集函数  AVG, COUNT, MAX, MIN, SUM</strong></h2><p>运行在行组, 计算和返回单个值的函数.</p><p>统计使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># AVG() 针对单列,  对多列需要使用多个</span><br><span class="line">SELECT AVG(age) AS avg_age FROM 表名;   # 忽略 NULL</span><br><span class="line"></span><br><span class="line"># COUNT() 函数</span><br><span class="line">COUNT(1);   # 行数</span><br><span class="line">COUNT(*);   # 表的行数, 含有 NULL的有数据行也可，但是不能全NULL</span><br><span class="line">COUNT(column)  # 某列非NULL 的个数</span><br><span class="line">COUNT(distinct 字段)  # 统计不重复的</span><br><span class="line"># 效率对比：</span><br><span class="line">MYISAM 储存引擎下， COUNT(*) 效率高</span><br><span class="line">INNODB 存储引擎下，COUNT(*) 和COUNT(1) 差不多，比COUNT(字段高)</span><br><span class="line"></span><br><span class="line"># 聚集不同的值 + DISTINCT</span><br><span class="line"># 聚集函数默认ALL</span><br><span class="line">SELECT AVG(DISTINCT age) FROM 表名;  # 对唯一值求均值</span><br><span class="line">SELECT COUNt(DISTINCT age) FROM 表名;  # 对age列的唯一值统计个数</span><br></pre></td></tr></table></figure><h2 id="9-数据分组查询-——-GROUP-BY-HAVING"><a href="#9-数据分组查询-——-GROUP-BY-HAVING" class="headerlink" title="9. 数据分组查询 —— GROUP BY,   HAVING"></a><strong>9. 数据分组查询 —— GROUP BY,   HAVING</strong></h2><h3 id="1-GROUP-BY-分组字段"><a href="#1-GROUP-BY-分组字段" class="headerlink" title="1. GROUP BY   分组字段"></a><strong>1. GROUP BY   分组字段</strong></h3><p>​          <font color="red"><big><strong>如果分组列中具有 NULL,  则NULL 将作为一个分组返回.</strong></big></font></p><h3 id="2-HAVING-过滤条件-WHERE-条件"><a href="#2-HAVING-过滤条件-WHERE-条件" class="headerlink" title="2. HAVING 过滤条件  =====WHERE 条件"></a><strong>2. HAVING 过滤条件  =====WHERE 条件</strong></h3><h3 id="3-必加-ORDER-BY-因为G出来的结果不保证排序了"><a href="#3-必加-ORDER-BY-因为G出来的结果不保证排序了" class="headerlink" title="3. 必加 ORDER BY,  因为G出来的结果不保证排序了."></a><strong>3. 必加 ORDER BY,  因为G出来的结果不保证排序了.</strong></h3><h3 id="4-能where-就不用having"><a href="#4-能where-就不用having" class="headerlink" title="4. 能where 就不用having"></a><strong>4. 能where 就不用having</strong></h3><ul><li><p><strong>按字段分组</strong></p></li><li><ul><li>GROUP BY id </li></ul></li><li><p><strong>按表达式或者函数</strong></p></li><li><ul><li>GROUP BY length(id)  AS  len   HAVING  len&gt;3;</li></ul></li><li><p><strong>按多个字段分组</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 分组统计值</span><br><span class="line">SELECT id, COUNT(*) AS num_ FROM 表名 GROUP BY id ORDER BY age;</span><br><span class="line"></span><br><span class="line"># 分组过滤  大于2的值</span><br><span class="line">SELECT age FROM 表名 GROUP BY  id  HAVING COUNT(*)&gt;=2 ORDER BY age;</span><br></pre></td></tr></table></figure><h2 id="10-子查询-IN-括号"><a href="#10-子查询-IN-括号" class="headerlink" title="10. 子查询  IN + 括号"></a><strong>10. 子查询  IN + 括号</strong></h2><ul><li>查询的结果作为另一个查询的条件,然后多层嵌套.</li><li>内层查询<strong>建立一个临时表</strong>。费时间.</li><li>优化需要用join 联结表替代….</li></ul><p><strong>where 和 having 后可放的子查询：</strong></p><ul><li><p>子查询放在小括号内</p></li><li><p><strong>标量子查询（单值）</strong>，一般配合单行操作符使用：  &gt;  &lt;   &gt;=  =  &lt;&gt;</p></li><li><p><strong>列子查询（单列多行）</strong>， 一般配合多行操作符使用：  </p></li><li><ul><li>IN   列表中的一个</li><li>ANY/SOME   </li><li>ALL</li></ul></li></ul><p><strong>select 后可以放的子查询：</strong></p><p><strong>from 后可以放的子查询：</strong></p><ul><li><p>必须起别名</p></li><li><ul><li>FROM (子查询表)  newtable </li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 标量子查询</span><br><span class="line"># 1. 谁工资比  elgong 高</span><br><span class="line">SELECT  * FROM employee </span><br><span class="line">WHERE salary&gt;(select salary from emplot WHERE name = &apos;elgong&apos;);</span><br><span class="line"></span><br><span class="line"># 查询超过平均工资的员工信息</span><br><span class="line">select avg(sal) from emp;   /* avg(sal)=2000 */</span><br><span class="line">select * from emp where sal &gt;= 2000;</span><br><span class="line">/* 子查询方法 */</span><br><span class="line">select * from emp where sal &gt;= (select avg(sal) from emp);</span><br></pre></td></tr></table></figure><h2 id="11-连接查询——JOIN-联结表-INNER-JOIN-LEFT-JOIN-RIGHT-JOIN"><a href="#11-连接查询——JOIN-联结表-INNER-JOIN-LEFT-JOIN-RIGHT-JOIN" class="headerlink" title="11. 连接查询——JOIN 联结表 ( INNER JOIN, LEFT JOIN, RIGHT JOIN)"></a><strong>11. 连接查询——JOIN 联结表 ( INNER JOIN, LEFT JOIN, RIGHT JOIN)</strong></h2><p><strong>注意判断驱动表是哪个？  查询计划  explain</strong></p><p>正常情况下，from 后的表是驱动表，但是当出现下面情况，驱动表变成了 class。</p><p>分析： 当 where 后的条件使得表之间数据多少不一样时，数据少的为主表</p><p><strong>小表驱动大表的原则</strong></p><p><code>select * from student left join class on  class.classid = student.classid where class.classid = 2;</code></p><p><strong>概念:    联结指两张表,或者多张表之间组合在一起进行查询, 是在运行时做的操作;</strong></p><ul><li><p><strong>left JOIN </strong> (左联结)保证读取主表的全部数据</p></li><li><p><strong>right JOIN</strong>  (右联结) 保证读取主表的全部数据</p></li><li><p><strong>inner JOIN</strong>  (内部联结,等值联结)  只读取共有的数据</p></li><li><p><strong>自联结:  </strong>常用来代替从同一个表检索数据的子查询.  FROM table1 AS t1, table2 AS t2, WHERE t1.col = t2.col;</p></li><li><p><strong>自然联结: </strong> 联结有主副表之分,  在INNER JOIN 之前的是主表, 待查询的输出中,排前边的内容所在的表为主表.</p></li></ul><p>左外联结可通过颠倒FROM 或者WHERE 子句中表的顺序转换成右外部联结</p><p><strong>连接的分类</strong></p><ul><li><p>SQL92语法</p></li><li><ul><li><p><strong>等值连接</strong></p></li><li><ul><li><code>FROM table1 AS t1, table2 AS t2, table3 AS t3  WHERE t1.col = t2.col  AND t2.c = t3.c ;</code>    </li></ul></li><li><p><strong>自连接（单表）</strong></p></li><li><ul><li>同表不同名</li><li><code>FROM   employees   e1,  employees  e2  WHERE  e1.id = e2.iidd</code></li></ul></li></ul></li><li><p>SQL99语法</p></li><li><ul><li>SELECT   查询列表</li><li><code>FROM   表1  别名  [连接类型]   join        表2  别名   on          连接条件</code></li></ul></li><li><ul><li><p><strong>内连接</strong>  inner join</p></li><li><p><strong>外连接</strong>  left， right</p></li><li><ul><li>主表全部显示</li><li>从表中没有与主表匹配的结果，显示NULL</li><li>等价于==== 内连接结果 + 主表有而从表没有的记录</li><li>左外和右外，交换表顺序可以等价效果</li></ul></li><li><p><strong>全外连接</strong>  full join</p></li><li><p><strong>交叉连接</strong>   cross join</p></li><li><ul><li>笛卡尔乘机</li></ul></li><li><p><strong>非等值连接</strong></p></li><li><ul><li>FROM e  join g on e.salary  BETWEEN g.low AND g.upper</li></ul></li><li><p><strong>自连接</strong></p></li><li><ul><li>一样的join on   不同名的同一张表</li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 创建联结表的两种方式</span><br><span class="line"># 1. 等值连接  WHERE 表1.id = 表2.id AND 表2.size = 表3.size</span><br><span class="line">SELECT vendors.vendor_name, product.prod_name, product.prod_price </span><br><span class="line">FROM product,vendors </span><br><span class="line">WHERE vendors.vendor_id = product.vendor_id </span><br><span class="line">ORDER BY vendor_name;</span><br><span class="line"></span><br><span class="line"># 2.内部联结(等值联结) 表的键数量相同  FROM 表1 INNER JOIN 表2 ON 表1.id = 表2.id</span><br><span class="line">SELECT v.vendor_name, p.prod_name, p.prod_price </span><br><span class="line">FROM product AS p </span><br><span class="line">INNER JOIN vendors AS v </span><br><span class="line">ON v.vendor_id = p.vendor_id  </span><br><span class="line">ORDER BY v.vendor_name;</span><br><span class="line"></span><br><span class="line"># </span><br><span class="line"># 对联结的表使用聚合方法</span><br><span class="line">待补充.....</span><br></pre></td></tr></table></figure><p><img src="/2020/04/11/mysql-必知必会7-综合内容/Users\Misaya\AppData\Local\YNote\data\elgong@126.com\e6a36fe8659843b897ed6b6e6ee6977d\clipboard.png" alt="img"></p><h2 id="12-分页查询"><a href="#12-分页查询" class="headerlink" title="12. 分页查询"></a><strong>12. 分页查询</strong></h2><p>  <strong>LIMIT  行X(从0开始),  size;</strong></p><p>  <strong>LIMIT  size OFFSET  size;</strong></p><p><strong>当要显示的数据，需要分页显示</strong> </p><ul><li>从行0开始</li><li>从第四行开始，检索5行</li><li><strong>LIMIT   3,  5</strong></li><li><strong>LIMIT   5  OFFSET  3</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#  查询前5条数据</span><br><span class="line">SELECT  *  FROM employees LIMIT 0, 5;</span><br><span class="line"></span><br><span class="line"># 查询11到25条数据</span><br><span class="line">SELECT  *  FROM employees LIMIT 10, 25-11+1;</span><br><span class="line"></span><br><span class="line"># 计算公式</span><br><span class="line">LIMIT (page-1)*size,  size;</span><br></pre></td></tr></table></figure><h2 id="13-联合查询-union-（自动去重，union-all-不去重）"><a href="#13-联合查询-union-（自动去重，union-all-不去重）" class="headerlink" title="13. 联合查询  union  （自动去重，union all  不去重）"></a><strong>13. 联合查询  union  （自动去重，union all  不去重）</strong></h2><p>将多条查询语句合并成一个结果</p><p><strong>特点：</strong></p><ul><li>查询 <strong>列数</strong> 和 <strong>列顺序</strong> 必须一致</li><li>自动去重</li><li>不去重  union all</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT   *   FROM    e1   WHERE   </span><br><span class="line">UNION</span><br><span class="line">SELECT   *   FROM    e1   WHERE</span><br></pre></td></tr></table></figure><h2 id="14-视图"><a href="#14-视图" class="headerlink" title="14. 视图"></a><strong>14. 视图</strong></h2><p>视图是虚拟的表, 是对其基表的封装.</p><p>使用的好处:</p><ol><li><p>重用 SQL 语句</p></li><li><p>使用表的部分,即过滤掉部分数据</p></li></ol><p>限制:</p><ol><li><p>图名唯一</p></li><li><p>视图可以嵌套</p></li><li><p>视图的ORDER BY  次于 从该视图检索数据的ORDER</p></li><li><p>视图可以和表一起使用</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 创建视图</span><br><span class="line">CREATE VIEW  viewname AS</span><br><span class="line">SELECT * FROM table WHERE id!=1;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、关系型数据库Mysql&quot;&gt;&lt;a href=&quot;#一、关系型数据库Mysql&quot; class=&quot;headerlink&quot; title=&quot;一、关系型数据库Mysql&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、关系型数据库Mysql&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;数据库（Datab
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.elgong.top/categories/mysql/"/>
    
    
      <category term="mysql-必知必会系列" scheme="http://www.elgong.top/tags/mysql-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>mysql-必知必会2-数据操作语言DML</title>
    <link href="http://www.elgong.top/2020/04/11/mysql-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A2-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80DML/"/>
    <id>http://www.elgong.top/2020/04/11/mysql-必知必会2-数据操作语言DML/</id>
    <published>2020-04-11T03:24:42.000Z</published>
    <updated>2020-04-11T03:33:47.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DML-数据操作语言"><a href="#DML-数据操作语言" class="headerlink" title="DML  数据操作语言"></a><strong>DML  数据操作语言</strong></h1><ul><li><strong>插入  INSERT</strong> </li><li><strong>更新  UPDATE</strong></li><li><strong>删除  DELETE</strong></li></ul><h2 id="1-插入"><a href="#1-插入" class="headerlink" title="1.  插入"></a><strong>1.  插入</strong></h2><p><strong>规则： 插入值的类型要一致</strong></p><ul><li>语法1：</li></ul><p>​        <code>INSERT   INTO   表名（列名） VALUES ( 值1...)</code></p><ul><li>语法2：</li></ul><p>​        <code>INSERT   INTO   表名 SET  列名1=值1，列名2=值2</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#  插入 INSERT</span><br><span class="line">#  插入完整行,或者部分</span><br><span class="line">INSERT INTO customers(</span><br><span class="line">    cust_name,</span><br><span class="line">    cust_address,</span><br><span class="line">    cust_city,</span><br><span class="line">    cust_state)</span><br><span class="line">VALUES(</span><br><span class="line">    &apos;elgong&apos;,</span><br><span class="line">    &apos;1552460315&apos;,</span><br><span class="line">    &apos;hangzhou&apos;,</span><br><span class="line">    &apos;1&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#  插入多行</span><br><span class="line">INSERT INTO customers(</span><br><span class="line">    cust_name,</span><br><span class="line">    cust_address,</span><br><span class="line">    cust_city,</span><br><span class="line">    cust_state)</span><br><span class="line">VALUES(</span><br><span class="line">    &apos;elgong&apos;,</span><br><span class="line">    &apos;1552460315&apos;,</span><br><span class="line">    &apos;hangzhou&apos;,</span><br><span class="line">    &apos;1&apos;</span><br><span class="line">),</span><br><span class="line">(</span><br><span class="line">    &apos;gel&apos;,</span><br><span class="line">    &apos;178905324&apos;,</span><br><span class="line">    &apos;hangzhou&apos;,</span><br><span class="line">    &apos;0&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="2-更新（缺了where-就全部更新啦，一定要注意）"><a href="#2-更新（缺了where-就全部更新啦，一定要注意）" class="headerlink" title="2.  更新（缺了where 就全部更新啦，一定要注意）"></a><strong>2.  更新（</strong><font color="red"><big>缺了where 就全部更新啦，一定要注意</big></font>）</h2><ul><li><p>单表更新语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE   表名   SET  列名1=值 ...  WHERE  筛选条件;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>多表更新语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE   表名  SET  列名1=值...   </span><br><span class="line"></span><br><span class="line">WHERE  连接条件 AND  筛选条件;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#  更新 UPDATE  SET</span><br><span class="line">#  更新某行的某些列值</span><br><span class="line">UPDATE customers </span><br><span class="line">SET cust_email = &quot;1552460315@qq.com&quot;,   #  列1</span><br><span class="line">    cust_name = &quot;ELGONG&quot;</span><br><span class="line">WHERE cust_id = 1;</span><br></pre></td></tr></table></figure><p><strong>3.  删除</strong></p><p><strong>删除整行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#   删除</span><br><span class="line">#  删除特定行</span><br><span class="line">DELETE FROM customers WHERE cust_id=1;</span><br><span class="line"></span><br><span class="line">#  删除所有行</span><br><span class="line">DELETE FROM customers ;  </span><br><span class="line">TRUNCATE TABLE;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DML-数据操作语言&quot;&gt;&lt;a href=&quot;#DML-数据操作语言&quot; class=&quot;headerlink&quot; title=&quot;DML  数据操作语言&quot;&gt;&lt;/a&gt;&lt;strong&gt;DML  数据操作语言&lt;/strong&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;插入  I
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.elgong.top/categories/mysql/"/>
    
    
      <category term="mysql-必知必会系列" scheme="http://www.elgong.top/tags/mysql-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>mysql-必知必会1-数据定义语言DDL</title>
    <link href="http://www.elgong.top/2020/04/11/mysql-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A1-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80DDL/"/>
    <id>http://www.elgong.top/2020/04/11/mysql-必知必会1-数据定义语言DDL/</id>
    <published>2020-04-11T03:15:23.000Z</published>
    <updated>2020-04-11T03:21:09.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库和表的创建，修改，删除"><a href="#数据库和表的创建，修改，删除" class="headerlink" title="数据库和表的创建，修改，删除"></a><strong>数据库和表的创建，修改，删除</strong></h1><ul><li>创建  create</li><li>修改  alter</li><li>删除  drop</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># ########  数据库相关</span><br><span class="line"># 创建库</span><br><span class="line">CREATE DATABASE 库名 IF NOT EXISTS;</span><br><span class="line"></span><br><span class="line"># 修改库名</span><br><span class="line">RENAME DATABASE  books  TO   新库名;</span><br><span class="line"></span><br><span class="line"># 删除库</span><br><span class="line">DROP DATABASE  IF EXISTS books;</span><br><span class="line"></span><br><span class="line"># ######### 表相关</span><br><span class="line">#  创建表</span><br><span class="line">CREATE TABLE   IF NOT EXISTS customers</span><br><span class="line">(</span><br><span class="line">    cust_id    int    NOT NULL AUTO_INCREMENT,  #  自动增加</span><br><span class="line">    cust_name  char(50) NOT NULL  DEFAULT GEL,  #  设默认值</span><br><span class="line">    cust_address char(50) NULL,</span><br><span class="line">   cust_city  char(50) NULL,</span><br><span class="line">   cust_state  char(5) NULL,</span><br><span class="line">   cust_email  char(255) NULL,</span><br><span class="line">   PRIMARY KEY (cust_id)   #  指定主键</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE   IF NOT EXISTS student</span><br><span class="line">(</span><br><span class="line">    id    int    NOT NULL AUTO_INCREMENT,  </span><br><span class="line">    name  char(50) NOT NULL,  </span><br><span class="line">    address char(50) NULL,</span><br><span class="line">    city  char(50) NULL,</span><br><span class="line">    email  char(255) NULL,</span><br><span class="line">   PRIMARY KEY (id) </span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#  更新表</span><br><span class="line">#  添加一列 ADD</span><br><span class="line">ALTER TABLE customers ADD cust_phone CHAR(20);</span><br><span class="line"></span><br><span class="line">#  删除表 </span><br><span class="line">DROP TABLE customers</span><br><span class="line">#  修改表名</span><br><span class="line">RENAME TABLE customers TO customers222;  </span><br><span class="line">#  修改列名</span><br><span class="line">ALTER  TABLE book CHANGE COLUMN 旧名  新名  类型;</span><br><span class="line"></span><br><span class="line">#  修改列名，约束</span><br><span class="line">ALTER  TABLE book MODIFY COLUMN 列名  类型;</span><br><span class="line"></span><br><span class="line">#  删除一列 DROP</span><br><span class="line">ALTER TABLE customers DROP COLUMN cust_phone;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库和表的创建，修改，删除&quot;&gt;&lt;a href=&quot;#数据库和表的创建，修改，删除&quot; class=&quot;headerlink&quot; title=&quot;数据库和表的创建，修改，删除&quot;&gt;&lt;/a&gt;&lt;strong&gt;数据库和表的创建，修改，删除&lt;/strong&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.elgong.top/categories/mysql/"/>
    
    
      <category term="mysql-必知必会系列" scheme="http://www.elgong.top/tags/mysql-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>版本控制-git</title>
    <link href="http://www.elgong.top/2020/03/28/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-git/"/>
    <id>http://www.elgong.top/2020/03/28/版本控制-git/</id>
    <published>2020-03-28T04:17:11.000Z</published>
    <updated>2020-03-28T04:24:01.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-git-的作用"><a href="#1-git-的作用" class="headerlink" title="1. git 的作用"></a>1. git 的作用</h1><ul><li>版本控制</li><li>协同开发</li></ul><h1 id="2-文件的状态"><a href="#2-文件的状态" class="headerlink" title="2. 文件的状态"></a>2. 文件的状态</h1><ul><li>untracked  (新建的文件)</li><li>unmodified  （提交后进入仓库的文件与当前文件相同，即没修过）</li><li>modified  (commit 之前)</li><li>staged  （commit 之后）</li></ul><h1 id="3-一般使用流程"><a href="#3-一般使用流程" class="headerlink" title="3. 一般使用流程"></a>3. 一般使用流程</h1><h4 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h4><ul><li><code>git init</code></li></ul><h4 id="变更的文件加入暂存区"><a href="#变更的文件加入暂存区" class="headerlink" title="变更的文件加入暂存区"></a>变更的文件加入暂存区</h4><ul><li><code>git add .</code></li></ul><h4 id="提交变更"><a href="#提交变更" class="headerlink" title="提交变更"></a>提交变更</h4><ul><li><code>git commit -m</code></li></ul><h4 id="查看commit日志-并返回某一次提交的版本"><a href="#查看commit日志-并返回某一次提交的版本" class="headerlink" title="查看commit日志, 并返回某一次提交的版本"></a>查看commit日志, 并返回某一次提交的版本</h4><ul><li><code>git log</code>   (### 弹出commit id)</li><li><code>git reset 7hdadsu2qe21e921821e --hard</code></li><li>如果想恢复最新的   <code>git  relog</code></li></ul><h4 id="从暂存区-移除某些文件（add-的文件有多余）"><a href="#从暂存区-移除某些文件（add-的文件有多余）" class="headerlink" title="从暂存区 移除某些文件（add 的文件有多余）"></a>从暂存区 移除某些文件（add 的文件有多余）</h4><ul><li><code>git reset &lt;fileName&gt;</code></li></ul><h1 id="4-分支合作管理"><a href="#4-分支合作管理" class="headerlink" title="4. 分支合作管理"></a>4. 分支合作管理</h1><ul><li>创建分支<ul><li><code>git checkout -b &lt;分支name&gt; &lt;template继承的commit,默认当前&gt;</code></li></ul></li><li>切换分支<ul><li><code>git checkout master</code></li></ul></li><li>查看所有分支<ul><li><code>git branch</code></li></ul></li><li>合并分支的变更（合并到当前master）<ul><li><code>git meger  branch-2</code></li><li>有冲突时，会提示======</li></ul></li></ul><h1 id="5-remote-仓库的使用"><a href="#5-remote-仓库的使用" class="headerlink" title="5. remote 仓库的使用"></a>5. remote 仓库的使用</h1><ul><li><p>下载远端仓库到本地</p><ul><li><code>git clone  ......git</code></li></ul></li><li><p>创建本地的分支</p><ul><li><code>git checkout -b local-A</code></li></ul></li><li><p>在远端仓库设置分支(第一次需要)</p><ul><li><code>git push -set-upstream origin local-A</code></li></ul></li><li><p>提交本地分支到远端</p><ul><li><code>git push</code></li></ul></li><li><p>第一次拉取远端仓库的分支，到本地</p><ul><li><code>git fetch</code>    </li><li><code>git checkout -b &lt;name&gt;</code>origin<code>&lt;template继承的commit,默认当前&gt;</code></li></ul></li><li><p>以后再从远端更新本地</p><ul><li><code>git pull</code> （自动fetch + merge）  </li></ul></li></ul><h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><ul><li><code>git merge</code></li><li><code>git pull</code></li><li><code>git fetch</code></li><li><code>git rebase</code> （版本合并时。。）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-git-的作用&quot;&gt;&lt;a href=&quot;#1-git-的作用&quot; class=&quot;headerlink&quot; title=&quot;1. git 的作用&quot;&gt;&lt;/a&gt;1. git 的作用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;版本控制&lt;/li&gt;
&lt;li&gt;协同开发&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 
      
    
    </summary>
    
      <category term="git" scheme="http://www.elgong.top/categories/git/"/>
    
    
      <category term="版本控制" scheme="http://www.elgong.top/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
</feed>
