<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>elgong&#39;s Home.</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.elgong.top/"/>
  <updated>2020-06-09T14:02:08.812Z</updated>
  <id>http://www.elgong.top/</id>
  
  <author>
    <name>elgong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis学习-复制</title>
    <link href="http://www.elgong.top/2020/06/09/redis%E5%AD%A6%E4%B9%A0-%E5%A4%8D%E5%88%B6/"/>
    <id>http://www.elgong.top/2020/06/09/redis学习-复制/</id>
    <published>2020-06-09T13:57:30.442Z</published>
    <updated>2020-06-09T14:02:08.812Z</updated>
    
    <content type="html"><![CDATA[<p>[toc] </p><h1 id="Redis6-复制（由主到从）"><a href="#Redis6-复制（由主到从）" class="headerlink" title="Redis6-复制（由主到从）"></a>Redis6-复制（由主到从）</h1><blockquote><p>当存在主从多个节点时，才会出现复制，且复制的方向只能由主节点流向从节点</p></blockquote><p>[toc]</p><h2 id="一、-redis-集群的拓扑结构"><a href="#一、-redis-集群的拓扑结构" class="headerlink" title="一、 redis 集群的拓扑结构"></a>一、 redis 集群的拓扑结构</h2><h3 id="主备结构-一主一从"><a href="#主备结构-一主一从" class="headerlink" title="主备结构-一主一从"></a>主备结构-一主一从</h3><ul><li>可以只在从节点开启 AOF</li></ul><h3 id="读写分类结构-一主多从"><a href="#读写分类结构-一主多从" class="headerlink" title="读写分类结构-一主多从"></a>读写分类结构-一主多从</h3><blockquote><p>慢查询可以 使用从节点，防止主节点的阻塞，提高并发性</p></blockquote><h3 id="解决网络负载过重-树状主从结构"><a href="#解决网络负载过重-树状主从结构" class="headerlink" title="解决网络负载过重-树状主从结构"></a>解决网络负载过重-树状主从结构</h3><blockquote><p>一主多从，主节点的网络负载很大，利用多级结构可以减少主节点的网络负载</p></blockquote><h2 id="二、-复制涉及的环节"><a href="#二、-复制涉及的环节" class="headerlink" title="二、 复制涉及的环节"></a>二、 复制涉及的环节</h2><h3 id="建立复制"><a href="#建立复制" class="headerlink" title="建立复制"></a>建立复制</h3><p><strong>复制流的方向</strong>：只能从主节点流向从节点</p><p><strong>配置</strong>： 只能从节点配置！</p><ul><li>配置文件中添加 <code>slaveof masterHost masterPort</code></li><li>redis 启动命令后加入 <code>--slaveof masterHost masterPort</code></li><li>直接执行该命令</li></ul><p><strong>查看复制的状态</strong>：<code>info replication</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line">    # Replication</span><br><span class="line">    role:master</span><br><span class="line">    connected_slaves:0</span><br><span class="line">    master_replid:923b3aeddad7f8966ea67a788dd7098fe8e99fca</span><br><span class="line">    master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">    master_repl_offset:14</span><br><span class="line">    second_repl_offset:-1</span><br><span class="line">    repl_backlog_active:1</span><br><span class="line">    repl_backlog_size:1048576</span><br><span class="line">    repl_backlog_first_byte_offset:1</span><br><span class="line">    repl_backlog_histlen:14</span><br></pre></td></tr></table></figure></p><h3 id="断开复制"><a href="#断开复制" class="headerlink" title="断开复制"></a>断开复制</h3><p><strong>直接断开复制关系，从节点自动升级为主节点</strong><br><code>slaveof no one</code></p><h3 id="切换复制源"><a href="#切换复制源" class="headerlink" title="切换复制源"></a>切换复制源</h3><blockquote><p>注意切换后，会先清空之前的缓存，然后重新复制<br><code>slaveof masterHost masterPort</code></p></blockquote><h3 id="复制的时间间隔粒度？"><a href="#复制的时间间隔粒度？" class="headerlink" title="复制的时间间隔粒度？"></a>复制的时间间隔粒度？</h3><p>控制参数 <code>repl-disable-tcp-nodelay</code> 默认关闭</p><ul><li>关闭时：主节点有新数据产生，会及时发送给从节点</li><li>开启时：固定时间间隔发送给从节点，linux一般默认40ms</li></ul><h2 id="三、复制的具体流程-6步"><a href="#三、复制的具体流程-6步" class="headerlink" title="三、复制的具体流程 (6步)"></a>三、复制的具体流程 (6步)</h2><ol><li>从节点 执行 <code>slaveof host master</code> <ul><li>指令后，从节点保存主节点的信息（ip + port）</li><li>信息可以通过 <code>info replication</code> 获取</li></ul></li><li>从节点与主节点建立 socket 连接         <ul><li>从节点开启定时任务来维护复制的逻辑</li><li>连接不上，会断开重新连接</li></ul></li><li>从节点 主动通信，发送 <code>ping</code></li><li>需要 权限验证， <code>auth password</code> <ul><li>requirepass是配置在主节点的，masterauth是配置在从节点</li><li>具体在 redis.conf 中配置</li></ul></li><li><p>主从同步数据（全量复制和部分复制）</p></li><li><p>修改命令的持续写入从节点</p></li></ol><blockquote><p>全量复制一般只在第一次复制，剩下的就是每次复制执行的命令</p></blockquote><p>下面详细讲述全量复制的过程：</p><h3 id="psync指令-完成数据同步（包括全量和部分）"><a href="#psync指令-完成数据同步（包括全量和部分）" class="headerlink" title="psync指令 完成数据同步（包括全量和部分）"></a>psync指令 完成数据同步（包括全量和部分）</h3><p><strong>格式</strong>：<br><code>psync {runId}{offset}</code></p><p><strong>runId</strong>:  主节点运行 id， 重启后会自动改变</p><p><strong>offset</strong>: 从节点已经复试的数据偏移量，第一次默认为 -1</p><h4 id="全量复制的流程"><a href="#全量复制的流程" class="headerlink" title="全量复制的流程"></a>全量复制的流程</h4><ol><li>从节点发送 <code>psync</code> 进行同步， 无法得知主节点运行id，所以发送 <code>psync-1</code> </li><li>主节点 发现<code>psync-1</code>,判定需要全量复制，返回 运行id 和 offset</li><li>从节点保存 运行id 和 offset</li><li>主节点执行 <code>bgsave</code>, 将产生的 <code>RDB</code> 文件发送到从节点</li><li>同时主节点仍在处理命令，将命令写入了 缓冲区，再次把缓冲区的命令发送给 从节点（注意可能出现的缓冲区溢出，当写入超过1mb）</li></ol><h4 id="部分复制的流程"><a href="#部分复制的流程" class="headerlink" title="部分复制的流程"></a>部分复制的流程</h4><blockquote><p>针对网络异常导致的命令丢失等，做出了优化，避免使用全量复制来解决少量数据的问题</p></blockquote><ol><li>主从节点之间出现网络中断，并且超 <code>repl-timeout</code> 设定的时间，主节点可以得知断开了，写入命令都存在缓冲区</li><li>当主从连接恢复，由于从节点保存了 主节点的id 和复制偏移值，直接作为 <code>psync</code>参数继续传递</li></ol><h2 id="四、心跳检测"><a href="#四、心跳检测" class="headerlink" title="四、心跳检测"></a>四、心跳检测</h2><blockquote><p>主从节点连接后，会维护一个长连接，互相发送心跳命令</p></blockquote><p><strong>主节点</strong>：</p><ul><li>每10s发送一次 <code>ping</code>, 来检测从节点的状态</li><li>参数 <code>repl-ping-slave-period</code> 可以设置时间间隔</li></ul><p><strong>从节点</strong>：</p><ul><li>每1s 发送一次 <code>replconf ack{offset}</code></li><li>上报自身已经复制到的偏移量</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc] &lt;/p&gt;
&lt;h1 id=&quot;Redis6-复制（由主到从）&quot;&gt;&lt;a href=&quot;#Redis6-复制（由主到从）&quot; class=&quot;headerlink&quot; title=&quot;Redis6-复制（由主到从）&quot;&gt;&lt;/a&gt;Redis6-复制（由主到从）&lt;/h1&gt;&lt;blockq
      
    
    </summary>
    
      <category term="缓存中间件" scheme="http://www.elgong.top/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="redis" scheme="http://www.elgong.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis-持久化</title>
    <link href="http://www.elgong.top/2020/06/01/redis-%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://www.elgong.top/2020/06/01/redis-持久化/</id>
    <published>2020-05-31T16:16:27.000Z</published>
    <updated>2020-06-07T13:44:57.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h1><p>[toc]</p><p>Redis 是基于内存的k-v服务，内存在断电时无法保存数据，因此需要做数据的备份操作。</p><p>Redis 有两种备份方式：</p><ul><li>内存快照的持久化保存 RDB<ul><li>适合全量复制，容灾备份，每日周期性定时执行（间隔6小时） </li><li>压缩后的二进制文件，恢复速度快</li><li>耗时长，无法做到实时备份</li></ul></li><li>记录修改操作日志的持久化保存 AOF<ul><li>实时备份（1s 一次）</li></ul></li></ul><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><blockquote><p>内存快照的二进制压缩格式</p></blockquote><h3 id="RDB-备份流程"><a href="#RDB-备份流程" class="headerlink" title="RDB 备份流程"></a>RDB 备份流程</h3><p><img src="https://note.youdao.com/yws/public/resource/e035e0d66921bedda6618e6b77e6a985/xmlnote/7FD7F9AB88734CB0A9E0227F16C4BB2E/31348" alt="image"> </p><ol><li>执行<code>bgsave</code> 命令，判断RDF 或 AOF子进程是否在运行，如果存在则直接退出；</li><li>主进程<code>fork</code> 产生子进程，子进程用来执行备份操作（<strong>会阻塞主进程</strong>）；</li><li>子进程根据父进程生成的临时快照文件来创建 RDB 文件，替换旧 RDB 文件；</li><li>子进程发送完成信号给父进程，父进程会统计相关信息；</li></ol><blockquote><p>linux 进程中的 fork :<br>fork函数得到的子进程从父进程的继承了整个进程的地址空间，包括：进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设置、进程优先级、进程组号、当前工作目录、根目录、资源限制、控制终端等。</p><p>fork 不会拷贝父进程的物理空间，会共用</p></blockquote><h3 id="RDB-什么情况下会被触发？"><a href="#RDB-什么情况下会被触发？" class="headerlink" title="RDB 什么情况下会被触发？"></a>RDB 什么情况下会被触发？</h3><p>触发 RDB 备份 主要是两个命令： <code>save</code> 和 <code>bgsave</code></p><ul><li>save:<ul><li>主线程去执行 RDB 备份，所以无法响应请求；</li></ul></li><li>bgsave:<ul><li>子进程去执行备份，只在fork 阶段产生阻塞；</li></ul></li></ul><p>所以，我们只需要知道 <code>bgsave</code> 什么时候触发调用就行。</p><ul><li>配置<code>save m n</code> ：即 m 秒内数据集被修改了n次，则触发<code>bgsave</code> </li><li>从节点的全量复制：主节点会将<code>RDB</code>文件传递到从节点</li><li><code>debug reload</code> 时</li><li>执行 <code>shutdown</code>时</li><li>从节点需要全量复制时？？？</li></ul><p><strong>AOF 默认是关闭的，但优先级高于 RDB</strong></p><h3 id="相关的指令"><a href="#相关的指令" class="headerlink" title="相关的指令"></a>相关的指令</h3><h4 id="运行期指定-RDB-文件保存地址"><a href="#运行期指定-RDB-文件保存地址" class="headerlink" title="运行期指定 RDB 文件保存地址"></a>运行期指定 RDB 文件保存地址</h4><p><code>config set dir {newDir}</code></p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>append only file</p><blockquote><p>日志记录修改操作，可以实时记录备份 </p></blockquote><h3 id="AOF-备份流程"><a href="#AOF-备份流程" class="headerlink" title="AOF 备份流程"></a>AOF 备份流程</h3><p><img src="https://note.youdao.com/yws/public/resource/e035e0d66921bedda6618e6b77e6a985/xmlnote/2C252F2CBCCD410F8E742C301F097554/31383" alt="image"></p><ol><li>写入命令会追加到 aof_buf 缓冲区中;</li><li>根据对应的策略 写入到硬盘；</li><li>当文件过于大时，会重写 AOF 文件;</li><li>重启优先加载 AOF 文件;</li></ol><h4 id="AOF-备份-1-命令写入"><a href="#AOF-备份-1-命令写入" class="headerlink" title="AOF 备份-1.命令写入"></a>AOF 备份-1.命令写入</h4><ul><li><p>先写入缓存区，然后再备份到硬盘中；</p></li><li><p>直接写入文本协议格式</p></li></ul><h4 id="AOF-备份-2-文件同步策略"><a href="#AOF-备份-2-文件同步策略" class="headerlink" title="AOF 备份-2.文件同步策略"></a>AOF 备份-2.文件同步策略</h4><p>同步策略： 配置 <code>appendfsync</code> 参数</p><ul><li>always</li><li>everysec （默认配置， 1s 执行一次写入）</li><li>no</li></ul><h4 id="AOF-备份-3-重写机制"><a href="#AOF-备份-3-重写机制" class="headerlink" title="AOF 备份-3.重写机制"></a>AOF 备份-3.重写机制</h4><p>重写的主要点：</p><ul><li>被删除的无效数据不需要在写入</li><li>过期数据不需要在写入</li><li>多条命令可以合并</li></ul><p><strong>手动触发重写命令</strong>： <code>bgrewriteaof</code></p><h4 id="AOF-备份-4-重启加载"><a href="#AOF-备份-4-重启加载" class="headerlink" title="AOF 备份-4. 重启加载"></a>AOF 备份-4. 重启加载</h4><p>比 RDB 优先级别高</p><h3 id="如何配置相关参数？"><a href="#如何配置相关参数？" class="headerlink" title="如何配置相关参数？"></a>如何配置相关参数？</h3><ol><li>开启 AOF功能<br> 配置 <code>appendonly yes</code></li></ol><h3 id="AOF-什么情况下会被触发？"><a href="#AOF-什么情况下会被触发？" class="headerlink" title="AOF 什么情况下会被触发？"></a>AOF 什么情况下会被触发？</h3><p>根据备份策略，一般是定时触发</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis-持久化&quot;&gt;&lt;a href=&quot;#Redis-持久化&quot; class=&quot;headerlink&quot; title=&quot;Redis 持久化&quot;&gt;&lt;/a&gt;Redis 持久化&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;Redis 是基于内存的k-v服务，内存在断电时无法保存数
      
    
    </summary>
    
      <category term="缓存中间件" scheme="http://www.elgong.top/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="redis" scheme="http://www.elgong.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis学习-Jedis 使用</title>
    <link href="http://www.elgong.top/2020/05/16/redis%E5%AD%A6%E4%B9%A0-Jedis-%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.elgong.top/2020/05/16/redis学习-Jedis-使用/</id>
    <published>2020-05-15T16:17:58.000Z</published>
    <updated>2020-05-15T16:26:59.337Z</updated>
    
    <content type="html"><![CDATA[<p>[toc] </p><p>[toc]</p><blockquote><p>本系列文章整理摘抄自<redis 开发与运维=""></redis></p></blockquote><h1 id="客户端怎么和-Redis-服务器连接？"><a href="#客户端怎么和-Redis-服务器连接？" class="headerlink" title="客户端怎么和 Redis 服务器连接？"></a>客户端怎么和 Redis 服务器连接？</h1><p>客户端和 Redis 服务器的通信是 建立在 TCP 连接的基础上的。</p><p>并且 Redis 制定了 RESP 序列化协议，是一个简单地通信约定。</p><h2 id="Resp序列化协议"><a href="#Resp序列化协议" class="headerlink" title="Resp序列化协议"></a>Resp序列化协议</h2><p><code>*&lt;参数数量&gt;\r\n$&lt;参数1的字节数量&gt;\r\n&lt;参数1&gt;\r\n$&lt;参数2的字节数量&gt;\r\n&lt;参数2&gt;\r\n</code></p><p>来给可视化一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*&lt;参数数量&gt;\r\n</span><br><span class="line">$&lt;参数1的字节数量&gt;\r\n</span><br><span class="line">&lt;参数1&gt;\r\n</span><br><span class="line">$&lt;参数2的字节数量&gt;\r\n</span><br><span class="line">&lt;参数2&gt;\r\n</span><br></pre></td></tr></table></figure></p><p>其他可以参考该书章节。</p><h1 id="Jedis-连接池的使用"><a href="#Jedis-连接池的使用" class="headerlink" title="Jedis 连接池的使用"></a>Jedis 连接池的使用</h1><p>简单的API 介绍</p><p><strong>获取 jedis连接</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line"></span><br><span class="line">Jedis jedis = null;</span><br><span class="line">try &#123;</span><br><span class="line">    jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line">    </span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    logger.error(e.getMessage(),e);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    if (jedis != null) &#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//  String</span><br><span class="line">jedis.set(&quot;key&quot;, &quot;value&quot;);</span><br><span class="line">jedis.get(&quot;key&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//  hset -字典</span><br><span class="line">jedis.set(&quot;hash&quot;, &quot;key1&quot;, &quot;value1&quot;);</span><br><span class="line">jedis.set(&quot;hash&quot;, &quot;key2&quot;, &quot;value2&quot;);</span><br><span class="line">jedis.get(&quot;key1&quot;)</span><br><span class="line"></span><br><span class="line">//  list -列表</span><br><span class="line">jedis.rpush(&quot;mylist&quot;, &quot;1&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// set -集合</span><br><span class="line">jedis.sadd(&quot;set&quot;, &quot;aaa&quot;);</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure><h2 id="springboot-环境下的使用"><a href="#springboot-环境下的使用" class="headerlink" title="springboot 环境下的使用"></a>springboot 环境下的使用</h2><h3 id="1-maven-依赖"><a href="#1-maven-依赖" class="headerlink" title="1. maven 依赖"></a>1. maven 依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.4.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.14&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h3><p><strong>配置类 -&gt; 从 application.preperties 读取配置项，并且配置</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;redis&quot;)</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line">  // 私有属性 </span><br><span class="line">    </span><br><span class="line">  // 配置项</span><br><span class="line">  get... set...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>poolFactory 工厂类创建 pool</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RedisPoolFactory &#123;</span><br><span class="line"></span><br><span class="line">    // 注入配置项</span><br><span class="line">    @Autowired</span><br><span class="line">    RedisConfig redisConfig;</span><br><span class="line"></span><br><span class="line">    // Bean注解 ： 根据方法创建对象，类型是JedisPool</span><br><span class="line">    @Bean</span><br><span class="line">    public JedisPool JedisPoolFactory()&#123;</span><br><span class="line"></span><br><span class="line">        JedisPoolConfig poolConfig = new JedisPoolConfig();</span><br><span class="line">        </span><br><span class="line">        // 各种配置</span><br><span class="line">        poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle());</span><br><span class="line">        poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal());</span><br><span class="line">        poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxTotal()*1000);</span><br><span class="line"></span><br><span class="line">        JedisPool jedisPool = new JedisPool(poolConfig, redisConfig.getHost(),                                      redisConfig.getPort(),                                                  redisConfig.getTimeout()*1000,                                          redisConfig.getPassword(), 0);</span><br><span class="line"></span><br><span class="line">        return jedisPool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Redis 服务类 开始封装各种服务</strong></p><p>当然，也要为服务模块化，比如 <code>RedisUserService</code>, <code>RedisMiaoshaService</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line"> public class RedisService &#123;</span><br><span class="line">    // 注入，@Bean 产生的jedisPool</span><br><span class="line">    @Autowired</span><br><span class="line">    JedisPool jedisPool;</span><br><span class="line">    </span><br><span class="line">    public &lt;T&gt; boolean set(IProfixForKey prefix, String key, T value)&#123;</span><br><span class="line"></span><br><span class="line">        Jedis resource = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            // 拿到连接</span><br><span class="line">            resource = jedisPool.getResource();</span><br><span class="line">            </span><br><span class="line">            // 封装一下key, 加上特点的头信息，例如： dbName:tableName:id</span><br><span class="line">            String strValue = beanToString(value);</span><br><span class="line">    </span><br><span class="line">            // 生成key</span><br><span class="line">            String realKey = prefix.getPrefix() + key;</span><br><span class="line">    </span><br><span class="line">            if (strValue == null || strValue.length() &lt;= 0)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 设置</span><br><span class="line">            resource.set(realKey, strValue);</span><br><span class="line">    </span><br><span class="line">            return true;</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            returnToPool(resource);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="非-spring-环境下的使用"><a href="#非-spring-环境下的使用" class="headerlink" title="非 spring 环境下的使用"></a>非 spring 环境下的使用</h2><p>举个例子，不知道合不合适。</p><p><strong>单例模式 来创建 JedisPool</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class JedisFactory &#123;</span><br><span class="line"></span><br><span class="line">    private volatile  static JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    private volatile static JedisPoolConfig poolConfig;</span><br><span class="line">    private volatile static String ip;</span><br><span class="line">    private volatile static int port;</span><br><span class="line">    private volatile static int timeout;</span><br><span class="line">    private volatile static String password;</span><br><span class="line">    private volatile static int database;</span><br><span class="line"></span><br><span class="line">    private JedisFactory() &#123;</span><br><span class="line"></span><br><span class="line">        //JedisPoolConfig poolConfig, String ip, int port, int timeout, String password, int database</span><br><span class="line">        /* apache common-pool 工具</span><br><span class="line">        *</span><br><span class="line">        * JedisPoolConfig</span><br><span class="line">        * */</span><br><span class="line">        this.jedisPool = new JedisPool(poolConfig, ip, port, timeout , password, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static JedisPool getJedisPool()&#123;</span><br><span class="line"></span><br><span class="line">        if (jedisPool == null)&#123;</span><br><span class="line"></span><br><span class="line">            synchronized (JedisFactory.class)&#123;</span><br><span class="line"></span><br><span class="line">                if (jedisPool == null)&#123;</span><br><span class="line">                    jedisPool = new JedisPool(JedisFactory.poolConfig, JedisFactory.ip, JedisFactory.port,</span><br><span class="line">                                              JedisFactory.timeout,  JedisFactory.password, JedisFactory.database);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setJedisPoolConfig(JedisPoolConfig poolConfig, String ip, int port, int timeout, String password, int database)&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot; 配置jedis 参数...&quot;);</span><br><span class="line">        JedisFactory.poolConfig = poolConfig;</span><br><span class="line">        JedisFactory.ip = ip;</span><br><span class="line">        JedisFactory.port = port;</span><br><span class="line">        JedisFactory.timeout = timeout * 1000;</span><br><span class="line">        JedisFactory.password = password;</span><br><span class="line">        JedisFactory.database = database;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>JedisService</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package top.elgong.jedis;</span><br><span class="line"></span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line">import redis.clients.jedis.JedisPool;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">*</span><br><span class="line">*   解决redis 用到的</span><br><span class="line">* */</span><br><span class="line">public class JedisService &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     */</span><br><span class="line">    public void set(String key, String value)&#123;</span><br><span class="line">        Jedis resource = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            JedisPool jedisPool = JedisFactory.getJedisPool();</span><br><span class="line"></span><br><span class="line">            resource = jedisPool.getResource();</span><br><span class="line"></span><br><span class="line">            resource.set(key, value);</span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line"></span><br><span class="line">            // 送回连接池中</span><br><span class="line">            if (resource != null)&#123;</span><br><span class="line">                resource.close();  // close 就是送回池子</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    *</span><br><span class="line">    * */</span><br><span class="line">    public String get(String key)&#123;</span><br><span class="line">        Jedis resource = null;</span><br><span class="line">        String ret = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            JedisPool jedisPool = JedisFactory.getJedisPool();</span><br><span class="line">            resource = jedisPool.getResource();</span><br><span class="line"></span><br><span class="line">            ret = resource.get(key);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            // 送回连接池中</span><br><span class="line">            if (resource != null)&#123;</span><br><span class="line">                resource.close();  // close 就是送回池子</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package top.elgong.jedis;</span><br><span class="line"></span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line">import redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static JedisService jedisService = new JedisService();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        JedisPoolConfig poolConfig = new JedisPoolConfig();</span><br><span class="line">        String ip = &quot;121.41.111.45&quot;;</span><br><span class="line">        int port = 6379;</span><br><span class="line">        int timeout = 300;</span><br><span class="line">        String password = &quot;Gelqq666%&quot;;</span><br><span class="line">        int database = 0;</span><br><span class="line"></span><br><span class="line">        JedisFactory.setJedisPoolConfig(poolConfig, ip, port, timeout, password, database);</span><br><span class="line"></span><br><span class="line">        jedisService.set(&quot;leetcode-java:jedis:test:key1&quot;, &quot;haha-&quot; + LocalDateTime.now().toString());</span><br><span class="line"></span><br><span class="line">        String s = jedisService.get(&quot;leetcode-java:jedis:test:key1&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Jedis-Pipline-的使用"><a href="#Jedis-Pipline-的使用" class="headerlink" title="Jedis Pipline 的使用"></a>Jedis Pipline 的使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = new Jedis(&quot;127.0.0.1&quot;);</span><br><span class="line"></span><br><span class="line">// 1)生成pipeline对象</span><br><span class="line">Pipeline pipeline = jedis.pipelined();</span><br><span class="line"></span><br><span class="line">// 2)pipeline执行命令， 注意此时命令并未真正执行</span><br><span class="line">for (String key : keys) &#123;</span><br><span class="line">    pipeline.del(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3)执行命令</span><br><span class="line">pipeline.sync();</span><br></pre></td></tr></table></figure><h1 id="Jedis-Lua-脚本"><a href="#Jedis-Lua-脚本" class="headerlink" title="Jedis Lua 脚本"></a>Jedis Lua 脚本</h1><p>待补充。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc] &lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列文章整理摘抄自&lt;redis 开发与运维=&quot;&quot;&gt;&lt;/redis&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;客户端怎么和-Redis-服务器连接？&quot;&gt;&lt;a href=&quot;#客户端怎么
      
    
    </summary>
    
      <category term="缓存中间件" scheme="http://www.elgong.top/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="redis" scheme="http://www.elgong.top/tags/redis/"/>
    
      <category term="jedis" scheme="http://www.elgong.top/tags/jedis/"/>
    
  </entry>
  
  <entry>
    <title>redis学习-缓存设计中要提前考虑的事情</title>
    <link href="http://www.elgong.top/2020/05/16/redis%E5%AD%A6%E4%B9%A0-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%AD%E8%A6%81%E6%8F%90%E5%89%8D%E8%80%83%E8%99%91%E7%9A%84%E4%BA%8B%E6%83%85/"/>
    <id>http://www.elgong.top/2020/05/16/redis学习-缓存设计中要提前考虑的事情/</id>
    <published>2020-05-15T16:16:33.000Z</published>
    <updated>2020-05-15T16:26:27.077Z</updated>
    
    <content type="html"><![CDATA[<p>[toc] </p><p>[toc]</p><blockquote><p>本系列文章整理摘抄自<redis 开发与运维=""></redis></p><h1 id="缓存设计前需要权衡成本和收益"><a href="#缓存设计前需要权衡成本和收益" class="headerlink" title="缓存设计前需要权衡成本和收益"></a>缓存设计前需要权衡成本和收益</h1></blockquote><h2 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h2><ul><li><strong>加速读写</strong></li><li><strong>降低后端负载</strong></li></ul><h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><ul><li><strong>数据不一致性</strong><ul><li>缓存层和存储层数据势必会有不一致的时间，需要考虑如何避免对业务造成的影响。 </li></ul></li><li><strong>代码维护成本</strong><ul><li>redis 和 mysql 两方代码都要考虑。</li></ul></li></ul><h1 id="缓存如何更新？"><a href="#缓存如何更新？" class="headerlink" title="缓存如何更新？"></a>缓存如何更新？</h1><p>基于内存的缓存不可能将所有的数据都做缓存，一般针对的都是<strong>热点数据</strong>。热点数据具有时效性，过了一定时间将成为<strong>非热点数据</strong>。</p><p>所以，缓存数据通常具有生命时长，到达指定的时间后，将被更新或者删除。</p><p>熟悉缓存的常用更新策略，才能针对业务场景做出合理的选择。</p><h2 id="更新策略1：-LRU-LFU-FIFO-算法"><a href="#更新策略1：-LRU-LFU-FIFO-算法" class="headerlink" title="更新策略1： LRU/LFU/FIFO 算法"></a>更新策略1： LRU/LFU/FIFO 算法</h2><p>通常缓存量超过了预设的最大值时，将会采取以上策略，具体由 <code>maxmemory-policy</code> 参数指定。</p><p><strong>一致性最差。</strong></p><h2 id="更新策略2-超时剔除"><a href="#更新策略2-超时剔除" class="headerlink" title="更新策略2: 超时剔除"></a>更新策略2: 超时剔除</h2><p>通过给缓存数据设置过期时间，让其在过期时间后自动删除，例如Redis提供的<code>expire</code>命令。 </p><p><strong>一致性取决于时间窗口。</strong></p><h2 id="更新策略3-主动更新"><a href="#更新策略3-主动更新" class="headerlink" title="更新策略3: 主动更新"></a>更新策略3: 主动更新</h2><p>当堆数据一致性要求高时，在更新存储层数据后，需要立即更新缓存中的数据。</p><p><strong>一致性最好。</strong></p><h2 id="最佳实践方案"><a href="#最佳实践方案" class="headerlink" title="最佳实践方案"></a>最佳实践方案</h2><h3 id="低一致性业务"><a href="#低一致性业务" class="headerlink" title="低一致性业务"></a>低一致性业务</h3><p>配置最大内存 + 淘汰策略</p><h3 id="高一致性业务"><a href="#高一致性业务" class="headerlink" title="高一致性业务"></a>高一致性业务</h3><p>超时剔除 + 主动更新</p><h1 id="缓存的粒度如何选？"><a href="#缓存的粒度如何选？" class="headerlink" title="缓存的粒度如何选？"></a>缓存的粒度如何选？</h1><p>对于缓存数据库的内容时，要考虑缓存全部字段，或者部分字段。</p><ul><li>全部字段：<ul><li>全部缓存占用空间过大</li><li>并不是所有字段都用的到</li></ul></li><li>部分字段：<ul><li>未来可能用到新字段 </li></ul></li></ul><h1 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h1><p>在系统刚上线，直接将数据加载进缓存系统，提前准备。</p><h1 id="缓存穿透问题（针对无效查询）"><a href="#缓存穿透问题（针对无效查询）" class="headerlink" title="缓存穿透问题（针对无效查询）"></a>缓存穿透问题（针对无效查询）</h1><h2 id="概念描述"><a href="#概念描述" class="headerlink" title="概念描述"></a>概念描述</h2><p>缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不命中。</p><h2 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h2><ul><li>问题1：业务代码或者数据出现问题</li><li>问题2：恶意攻击，爬虫造成的大量空命中</li></ul><h2 id="造成的影响"><a href="#造成的影响" class="headerlink" title="造成的影响"></a>造成的影响</h2><p>如果出现大量的缓存穿透，会对后端的数据库产生大流量的冲击，严重可使得数据库服务宕机。</p><h2 id="通用解决方案"><a href="#通用解决方案" class="headerlink" title="通用解决方案"></a>通用解决方案</h2><h3 id="问题如何发现？"><a href="#问题如何发现？" class="headerlink" title="问题如何发现？"></a>问题如何发现？</h3><p>统计<strong>总调用数、 缓存层命中数、 存储层命中数</strong>，如果发现大量存储层空命中， 可能就是出现了缓存穿透问题。</p><h3 id="问题如何预防？"><a href="#问题如何预防？" class="headerlink" title="问题如何预防？"></a>问题如何预防？</h3><h4 id="问题1的解决-缓存空对象-设置短过期时间"><a href="#问题1的解决-缓存空对象-设置短过期时间" class="headerlink" title="问题1的解决. 缓存空对象 + 设置短过期时间"></a>问题1的解决. 缓存空对象 + 设置短过期时间</h4><p>实时性高。</p><p>存储层不命中后，仍然将空对象保留到缓存层中，之后再访问这个数据将会从缓存中获取，这样就保护了后端数据源。 </p><h4 id="问题2的解决-布隆过滤器拦截（缓存层之前对存在的key做保存）"><a href="#问题2的解决-布隆过滤器拦截（缓存层之前对存在的key做保存）" class="headerlink" title="问题2的解决. 布隆过滤器拦截（缓存层之前对存在的key做保存）"></a>问题2的解决. 布隆过滤器拦截（缓存层之前对存在的key做保存）</h4><p>实时性差。</p><p>访问缓存层和存储层之前，将存在的key用布隆过滤器提前保存起来， 做第一层拦截</p><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><h2 id="概念描述-1"><a href="#概念描述-1" class="headerlink" title="概念描述"></a>概念描述</h2><p>发生大规模的缓存失效的情况，或者缓存层宕机，大量流量冲入存储层。</p><h2 id="产生的原因-1"><a href="#产生的原因-1" class="headerlink" title="产生的原因"></a>产生的原因</h2><p>缓存服务由于各种原因失效了。</p><h2 id="造成的影响-1"><a href="#造成的影响-1" class="headerlink" title="造成的影响"></a>造成的影响</h2><p>数据库服务宕机。</p><h2 id="通用解决方案-1"><a href="#通用解决方案-1" class="headerlink" title="通用解决方案"></a>通用解决方案</h2><h3 id="提前的规划：-保证缓存服务的高可用。"><a href="#提前的规划：-保证缓存服务的高可用。" class="headerlink" title="提前的规划： 保证缓存服务的高可用。"></a>提前的规划： 保证缓存服务的高可用。</h3><p>主从 + 哨兵， 集群。<br>Redis Sentinel和RedisCluster都实现了高可用</p><h3 id="出现雪崩时的处理：隔离组件做限流和降级处理"><a href="#出现雪崩时的处理：隔离组件做限流和降级处理" class="headerlink" title="出现雪崩时的处理：隔离组件做限流和降级处理"></a>出现雪崩时的处理：隔离组件做限流和降级处理</h3><ul><li>ehcache本地缓存 + Hystrix限流并降级,避免MySQL被搞死。</li><li>加锁排队（并发量不高的情况下）</li></ul><p><strong>Hystrix限流并降级的流程</strong></p><p>海量的用户请求出现：</p><ul><li>首先通过限流组件Hystrix限流（只有预定的请求进入存储层）</li><li>对于未通过的流量，直接导到 预定的降级处理方案，比如友好的提示等待。</li></ul><h3 id="3-提前排演测试"><a href="#3-提前排演测试" class="headerlink" title="3. 提前排演测试"></a>3. 提前排演测试</h3><h1 id="缓存击-针对失效数据-热点数据高并发访问时，失效来不及重建"><a href="#缓存击-针对失效数据-热点数据高并发访问时，失效来不及重建" class="headerlink" title="缓存击(针对失效数据)-热点数据高并发访问时，失效来不及重建"></a>缓存击(针对失效数据)-热点数据高并发访问时，失效来不及重建</h1><h2 id="概念描述-2"><a href="#概念描述-2" class="headerlink" title="概念描述"></a>概念描述</h2><p>当热点数据并发访问量非常大，由于之前设置了过期时间，失效后难以短时间重建。</p><p>比如： 热点的娱乐新闻。</p><h2 id="产生的原因-2"><a href="#产生的原因-2" class="headerlink" title="产生的原因"></a>产生的原因</h2><p>缓存服务由于各种原因失效了。</p><h2 id="造成的影响-2"><a href="#造成的影响-2" class="headerlink" title="造成的影响"></a>造成的影响</h2><p>数据库服务宕机。</p><h2 id="通用解决方案-2"><a href="#通用解决方案-2" class="headerlink" title="通用解决方案"></a>通用解决方案</h2><h3 id="1-限制重建的线程数-互斥锁"><a href="#1-限制重建的线程数-互斥锁" class="headerlink" title="1. 限制重建的线程数 - 互斥锁"></a>1. 限制重建的线程数 - 互斥锁</h3><p>并不是所有的线程都需要去重建，第一个遇到的线程重建，其他线程等待即可。</p><h4 id="互斥锁的实现1：通过setnx-和-expire命令实现"><a href="#互斥锁的实现1：通过setnx-和-expire命令实现" class="headerlink" title="互斥锁的实现1：通过setnx 和 expire命令实现"></a>互斥锁的实现1：通过setnx 和 expire命令实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">String get(String key) &#123;</span><br><span class="line">    // 从Redis中获取数据</span><br><span class="line">    String value = redis.get(key);</span><br><span class="line">    // 如果value为空， 则开始重构缓存</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        // 只允许一个线程重构缓存， 使用nx， 并设置过期时间ex</span><br><span class="line">        String mutexKey = &quot;mutext:key:&quot; + key;</span><br><span class="line">        if (redis.set(mutexKey, &quot;1&quot;, &quot;ex 180&quot;, &quot;nx&quot;)) &#123;</span><br><span class="line">            // 从数据源获取数据</span><br><span class="line">            value = db.get(key);</span><br><span class="line">            // 回写Redis， 并设置过期时间</span><br><span class="line">            redis.setex(key, timeout, value);</span><br><span class="line">            // 删除key_mutex</span><br><span class="line">            redis.delete(mutexKey);</span><br><span class="line">        &#125;/</span><br><span class="line">        / 其他线程休息50毫秒后重试</span><br><span class="line">        else &#123;</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">            get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="互斥锁的实现2：通过watch和Redis的事务命令实现"><a href="#互斥锁的实现2：通过watch和Redis的事务命令实现" class="headerlink" title="互斥锁的实现2：通过watch和Redis的事务命令实现"></a>互斥锁的实现2：通过watch和Redis的事务命令实现</h4><h3 id="2-永不过期"><a href="#2-永不过期" class="headerlink" title="2. 永不过期"></a>2. 永不过期</h3><p>但是会出现数据不一致的情况。</p><h3 id="3-错峰失效"><a href="#3-错峰失效" class="headerlink" title="3. 错峰失效"></a>3. 错峰失效</h3><p>不要让热点数据集中失效，而是一批一批，分时间段的失效</p><h3 id="4-失效后sleep-rand-这样不会所有请求都去立刻查db"><a href="#4-失效后sleep-rand-这样不会所有请求都去立刻查db" class="headerlink" title="4. 失效后sleep(rand()) 这样不会所有请求都去立刻查db"></a>4. 失效后sleep(rand()) 这样不会所有请求都去立刻查db</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc] &lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列文章整理摘抄自&lt;redis 开发与运维=&quot;&quot;&gt;&lt;/redis&gt;&lt;/p&gt;
&lt;h1 id=&quot;缓存设计前需要权衡成本和收益&quot;&gt;&lt;a href=&quot;#缓存设计前需要权衡成本和收益&quot; class=&quot;h
      
    
    </summary>
    
      <category term="缓存中间件" scheme="http://www.elgong.top/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="redis" scheme="http://www.elgong.top/tags/redis/"/>
    
      <category term="缓存雪崩" scheme="http://www.elgong.top/tags/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/"/>
    
      <category term="缓存穿透" scheme="http://www.elgong.top/tags/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/"/>
    
      <category term="缓存击穿" scheme="http://www.elgong.top/tags/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/"/>
    
  </entry>
  
  <entry>
    <title>redis学习-常用API</title>
    <link href="http://www.elgong.top/2020/05/16/redis%E5%AD%A6%E4%B9%A0-%E5%B8%B8%E7%94%A8API/"/>
    <id>http://www.elgong.top/2020/05/16/redis学习-常用API/</id>
    <published>2020-05-15T16:15:05.000Z</published>
    <updated>2020-05-15T16:15:53.124Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><blockquote><p>本系列文章整理摘抄自<redis 开发与运维=""></redis></p><h1 id="全局命令"><a href="#全局命令" class="headerlink" title="全局命令"></a>全局命令</h1></blockquote><h2 id="1-查看所有键-keys"><a href="#1-查看所有键-keys" class="headerlink" title="1. 查看所有键 keys"></a>1. 查看所有键 <strong>keys</strong></h2><p>遍历所有的键，时间复杂度O(n), 线上禁止使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys *</span><br></pre></td></tr></table></figure></p><h2 id="2-键总数-dbsize"><a href="#2-键总数-dbsize" class="headerlink" title="2. 键总数 dbsize"></a>2. 键总数 <strong>dbsize</strong></h2><p>该指令直接获取Redis 内置的键总数变量， 时间复杂度 O(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbsize</span><br></pre></td></tr></table></figure></p><h2 id="3-键是否存在-exist"><a href="#3-键是否存在-exist" class="headerlink" title="3. 键是否存在 exist"></a>3. 键是否存在 <strong>exist</strong></h2><p>存在返回1， 不存在返回0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exist key</span><br></pre></td></tr></table></figure></p><h2 id="4-删除键-del"><a href="#4-删除键-del" class="headerlink" title="4. 删除键 del"></a>4. 删除键 <strong>del</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key1  key2  key3</span><br></pre></td></tr></table></figure><h2 id="5-设置键过期-expire"><a href="#5-设置键过期-expire" class="headerlink" title="5. 设置键过期 expire"></a>5. 设置键过期 <strong>expire</strong></h2><p>成功返回1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// expire key seconds</span><br><span class="line">set key helloword</span><br><span class="line">expire key 10</span><br></pre></td></tr></table></figure></p><h2 id="6-查询键过期-ttl"><a href="#6-查询键过期-ttl" class="headerlink" title="6. 查询键过期 ttl"></a>6. 查询键过期 <strong>ttl</strong></h2><ul><li>返回 &gt;0 : 剩余的过期时间</li><li>返回 -1 : 键没设置过期时间</li><li>返回 -2 ：键不存在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ttl key</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-键的类型-type"><a href="#7-键的类型-type" class="headerlink" title="7. 键的类型  type"></a>7. 键的类型  <strong>type</strong></h2><p>若键不存在，返回 none<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure></p><h1 id="5种常用的数据类型"><a href="#5种常用的数据类型" class="headerlink" title="5种常用的数据类型"></a>5种常用的数据类型</h1><p>Redis 是字典服务器，其中键都是字符串类型，并且数据结构也都是在字符串类型上构建的。</p><p>而字符串类型的底层实现值可以为字符串，整数，浮点数，二进制。</p><p>字符串类型最大不能超过 512MB.</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="1-设置值-set、setex、setnx、set-xx"><a href="#1-设置值-set、setex、setnx、set-xx" class="headerlink" title="1. 设置值 set、setex、setnx、set .. xx"></a>1. 设置值 set、setex、setnx、set .. xx</h4><p>==set 命令的参数：==</p><ul><li>ex seconds: 秒过期</li><li>px milliseconds ： 毫秒过期</li><li>nx ：键必须不存在 （失败返回 0）</li><li>xx ：键必须存在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// set key value [ex seconds] [px milliseconds] [nx | xx]</span><br><span class="line"></span><br><span class="line">set hello world ex 60</span><br></pre></td></tr></table></figure></li></ul><p>==设置时间:==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setex key seconds value</span><br></pre></td></tr></table></figure><p>==设置不存在的key==</p><font color="red" size="5">setnx 可以作为分布式锁的一种实现方案</font><ul><li>失败： 返回 0</li><li>成功： 返回 1<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx key value</span><br></pre></td></tr></table></figure></li></ul><p>==设置存在的key==</p><ul><li>失败： 返回 nil</li><li>成功： 返回 ok<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value xx</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-获取值-get"><a href="#2-获取值-get" class="headerlink" title="2. 获取值 get"></a>2. 获取值 get</h4><p>==获取键值==</p><ul><li>不存在： 返回 nil</li><li>存在：   返回值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-批量设置值-mset"><a href="#3-批量设置值-mset" class="headerlink" title="3. 批量设置值 mset"></a>3. 批量设置值 mset</h4><font color="red" size="3">批量操作可以减少网络资源的浪费</font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key1 value1   key2 value2    key3 value3</span><br></pre></td></tr></table></figure>#### 4. 批量获取值 mget如果有空的， 该空值返回 nil<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget key1  key2  key3</span><br></pre></td></tr></table></figure>#### 5. 计数操作 incr、decr、incrby(自增指定值)、decrby(自减指定值)<font color="red" size="3">redis 的计数不是cas, 因为是单线程，不会出现冲突</font>- 不存在：  自动创建并返回1- 存在：    返回增后的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 自增</span><br><span class="line">//incr key</span><br></pre></td></tr></table></figure>### 不常用命令#### 1. 追加值 append <font color="red" size="3">可以对incr 的整数或者其他类型追加，因为它们都是string类型</font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// append key  value</span><br></pre></td></tr></table></figure><h4 id="2-字符串的长度-strlen"><a href="#2-字符串的长度-strlen" class="headerlink" title="2. 字符串的长度 strlen"></a>2. 字符串的长度 strlen</h4><ul><li>不存在：   返回 0 </li><li>存在：     返回字符串长度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// strlen key</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-设置并且返回原值-getset"><a href="#3-设置并且返回原值-getset" class="headerlink" title="3. 设置并且返回原值  getset"></a>3. 设置并且返回原值  getset</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// getset key value</span><br></pre></td></tr></table></figure><h4 id="4-设置指定位置的字符"><a href="#4-设置指定位置的字符" class="headerlink" title="4. 设置指定位置的字符"></a>4. 设置指定位置的字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// setrange key offset value</span><br></pre></td></tr></table></figure><h4 id="5-获取部分字符串"><a href="#5-获取部分字符串" class="headerlink" title="5. 获取部分字符串"></a>5. 获取部分字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// getrange key start end</span><br></pre></td></tr></table></figure><h3 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h3><p>字符串类型内部有3 种编码，</p><ul><li>int :    8字节</li><li>embstr ：&lt;= 39 字节的字符串</li><li>raw ：   &gt; 39 字节的字符串</li></ul><p>查看类型的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object  encoding key1</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1. 缓存"></a>1. 缓存</h4><font color="red" size="3">加速读写并减轻后端数据库的压力</font><p>推荐的key 定义规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 业务名：对象名：id：[属性]</span><br><span class="line"></span><br><span class="line">miaosha:item:itemId:price</span><br></pre></td></tr></table></figure><h4 id="2-计数"><a href="#2-计数" class="headerlink" title="2. 计数"></a>2. 计数</h4><p>实现业务上的快速技术、查询缓存，能够异步的写入数据库，减少数据库的访问压力。</p><h4 id="3-session-共享"><a href="#3-session-共享" class="headerlink" title="3. session 共享"></a>3. session 共享</h4><p>web 服务通常由多台服务器协同提供用户访问的服务，而用户登陆后的登陆信息如何保存？</p><p>借助 Redis 缓存将 用户session 集中管理，当用户登陆和查询时，在 Redis 服务器更新或者查询即可。</p><h4 id="4-限速"><a href="#4-限速" class="headerlink" title="4. 限速"></a>4. 限速</h4><p>比如限制单位时间内验证码的次数。</p><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="1-设置值-hset-amp-hsetnx-不存在才设置"><a href="#1-设置值-hset-amp-hsetnx-不存在才设置" class="headerlink" title="1. 设置值 hset &amp; hsetnx (不存在才设置)"></a>1. 设置值 hset &amp; hsetnx (不存在才设置)</h4><p><strong>hset:</strong></p><ul><li>成功： 返回 1</li><li>失败： 返回 0 </li></ul><p><strong>hsetnx</strong></p><ul><li>成功：</li><li>失败：<br><font color="red" size="3"> 待验证</font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// hashkey : value</span><br><span class="line">hset key hashKey value</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-获取值-hget"><a href="#2-获取值-hget" class="headerlink" title="2. 获取值 hget"></a>2. 获取值 hget</h4><p>不存在： 返回nil<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hget key</span><br></pre></td></tr></table></figure></p><h4 id="3-删除值-hdel-key-field"><a href="#3-删除值-hdel-key-field" class="headerlink" title="3. 删除值 hdel key field"></a>3. 删除值 hdel key field</h4><ul><li>删除成功：返回 1</li><li>删除失败：返回 0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// hset  mykey key1 value1</span><br><span class="line">// hset  mykey key2 value2</span><br><span class="line"></span><br><span class="line">hdel  mykey  key1</span><br><span class="line">// 删除后再查询会返回 nil</span><br></pre></td></tr></table></figure><h4 id="4-计算field-个数-hlen"><a href="#4-计算field-个数-hlen" class="headerlink" title="4. 计算field 个数 hlen"></a>4. 计算field 个数 hlen</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen mykey</span><br></pre></td></tr></table></figure><h4 id="5-批量设置或者获取-hmset-amp-hmget"><a href="#5-批量设置或者获取-hmset-amp-hmget" class="headerlink" title="5. 批量设置或者获取 hmset &amp; hmget"></a>5. 批量设置或者获取 hmset &amp; hmget</h4><p><strong>hmset</strong> </p><ul><li>成功返回 OK</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hmset  mykey key3 value3  key4 value 4</span><br><span class="line"></span><br><span class="line">// 批量获取返回</span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br></pre></td></tr></table></figure><h4 id="6-判断field-是否存在-hexists"><a href="#6-判断field-是否存在-hexists" class="headerlink" title="6. 判断field 是否存在 hexists"></a>6. 判断field 是否存在 hexists</h4><ul><li>存在： 返回 1</li><li>不存在： 返回 0<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexists  mykey key3</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-获取所有的field-hkeys"><a href="#7-获取所有的field-hkeys" class="headerlink" title="7. 获取所有的field, hkeys"></a>7. 获取所有的field, hkeys</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hkeys mykey</span><br><span class="line"></span><br><span class="line">// 返回</span><br><span class="line"></span><br><span class="line">1) &quot;key2&quot;</span><br><span class="line">2) &quot;key1&quot;</span><br><span class="line">3) &quot;key3&quot;</span><br><span class="line">4) &quot;key4&quot;</span><br><span class="line">5) &quot;key5&quot;</span><br></pre></td></tr></table></figure><h4 id="8-获取所有的value，-hvals-mykey"><a href="#8-获取所有的value，-hvals-mykey" class="headerlink" title="8. 获取所有的value， hvals mykey"></a>8. 获取所有的value， hvals mykey</h4><h4 id="9-获取-k-v-：-hgetall-mykey"><a href="#9-获取-k-v-：-hgetall-mykey" class="headerlink" title="9. 获取 k - v ： hgetall mykey"></a>9. 获取 k - v ： hgetall mykey</h4><font color="red" size="3">值太多时，会引起阻塞，线上可以 hscan  和 hmget</font><h4 id="10-values-的自增-hincrby-hincrbyfloat"><a href="#10-values-的自增-hincrby-hincrbyfloat" class="headerlink" title="10. values 的自增  hincrby hincrbyfloat"></a>10. values 的自增  hincrby hincrbyfloat</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hincrby</span><br></pre></td></tr></table></figure><h4 id="11-计算value的字符串长度（需要Redis3-2以上）-hstrlen"><a href="#11-计算value的字符串长度（需要Redis3-2以上）-hstrlen" class="headerlink" title="11. 计算value的字符串长度（需要Redis3.2以上） hstrlen"></a>11. 计算value的字符串长度（需要Redis3.2以上） hstrlen</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hstrlen mykey key1</span><br></pre></td></tr></table></figure><h3 id="内部编码-1"><a href="#内部编码-1" class="headerlink" title="内部编码"></a>内部编码</h3><p>哈希类型内部编码主要有两种：</p><ul><li>ziplist （更省内存）（数量小于512且value 小于64字节时，默认使用）</li><li>hashtable  读写时间复杂度 O(1)</li></ul><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="利用-hash-存储-数据库中的整行字段"><a href="#利用-hash-存储-数据库中的整行字段" class="headerlink" title="利用 hash 存储 数据库中的整行字段"></a>利用 hash 存储 数据库中的整行字段</h4><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul><li>列表用来储存多个有序的字符串。</li><li>可以当队列和堆栈使用</li></ul><h3 id="主要的操作："><a href="#主要的操作：" class="headerlink" title="主要的操作："></a>主要的操作：</h3><ul><li>添加 <code>rpush &amp; lpush</code>,  <code>linsert</code></li><li>删除 <code>lpop &amp; rpop</code>, <code>lrem</code>, <code>ltrim</code></li><li>查找 <code>lrange</code>,   <code>lindex</code>, <code>llen</code></li><li>修改  <code>lset</code></li><li>阻塞 <code>blpop &amp; brpop</code></li></ul><h4 id="1-添加-lpush-amp-rpush-linsert"><a href="#1-添加-lpush-amp-rpush-linsert" class="headerlink" title="1. 添加 lpush &amp; rpush, linsert"></a>1. 添加 lpush &amp; rpush, linsert</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 左，右插入</span><br><span class="line">lpush elgong.list  1</span><br><span class="line"></span><br><span class="line">rpush elgong.lsit  2</span><br><span class="line"></span><br><span class="line">// 指定位置插入</span><br><span class="line">linsert  elgong.list  after| before  location  value</span><br></pre></td></tr></table></figure><h4 id="2-删除-rpop-amp-lpop-lrem"><a href="#2-删除-rpop-amp-lpop-lrem" class="headerlink" title="2. 删除 rpop &amp; lpop, lrem"></a>2. 删除 rpop &amp; lpop, lrem</h4><p><strong>lrem</strong> 删除指定元素<br><code>lrem elgong.list  count  value</code></p><ul><li>value 为被删除的值</li><li>count &gt; 0:  从左往右删除 count 个</li><li>count = 0:  全部删除</li><li>count &lt; 0： 从右往左删除 count 个</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpop elgong.list</span><br><span class="line">lpop elgong.list</span><br><span class="line"></span><br><span class="line">// 删除指定的元素</span><br></pre></td></tr></table></figure><h4 id="3-查找-lrange-，-lindex，-llen"><a href="#3-查找-lrange-，-lindex，-llen" class="headerlink" title="3. 查找 lrange ， lindex， llen"></a>3. 查找 lrange ， lindex， llen</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取从左到右 所有元素</span><br><span class="line">lrange elgong.list 0  -1</span><br><span class="line"></span><br><span class="line">// 指定范围查找</span><br><span class="line">lrange elgong.list  start  end</span><br><span class="line"></span><br><span class="line">// 获取指定下标的元素, 索引为2</span><br><span class="line">lindex  elgong.list 2</span><br></pre></td></tr></table></figure><h4 id="4-修改-lset"><a href="#4-修改-lset" class="headerlink" title="4. 修改 lset"></a>4. 修改 lset</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lset key index newValue</span><br></pre></td></tr></table></figure><h4 id="5-阻塞-blpop-amp-brpop"><a href="#5-阻塞-blpop-amp-brpop" class="headerlink" title="5. 阻塞 blpop &amp; brpop"></a>5. 阻塞 blpop &amp; brpop</h4><p>有参数 timeout，</p><p>如果timeout = 0， 一直阻塞<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 等到list有值时再返回</span><br><span class="line">blpop elgong.list  0</span><br><span class="line"></span><br><span class="line">// 阻塞最长3s</span><br><span class="line">blpop elgong.list  3</span><br></pre></td></tr></table></figure></p><h3 id="内部编码-2"><a href="#内部编码-2" class="headerlink" title="内部编码"></a>内部编码</h3><ul><li>ziplist （长度小于512， 单值 小于64 字节时默认采用）</li><li>linkedlist</li></ul><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="1-消息队列"><a href="#1-消息队列" class="headerlink" title="1. 消息队列"></a>1. 消息队列</h4><p>通过阻塞可以实现生产者消费者模式。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="内部编码-3"><a href="#内部编码-3" class="headerlink" title="内部编码"></a>内部编码</h3><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><h3 id="不常用命令"><a href="#不常用命令" class="headerlink" title="不常用命令"></a>不常用命令</h3><h3 id="内部编码-4"><a href="#内部编码-4" class="headerlink" title="内部编码"></a>内部编码</h3><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><h1 id="键的管理"><a href="#键的管理" class="headerlink" title="键的管理"></a>键的管理</h1><p>常用的指令入 del, exists, expire, type, object.</p><h2 id="6-键的重命名-rename"><a href="#6-键的重命名-rename" class="headerlink" title="6. 键的重命名 rename"></a>6. 键的重命名 rename</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename elgong.list  newlist</span><br></pre></td></tr></table></figure><h2 id="7-随机返回一个键-randomKey"><a href="#7-随机返回一个键-randomKey" class="headerlink" title="7. 随机返回一个键 randomKey"></a>7. 随机返回一个键 randomKey</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randomKey</span><br></pre></td></tr></table></figure><h2 id="8-键过期时间"><a href="#8-键过期时间" class="headerlink" title="8. 键过期时间"></a>8. 键过期时间</h2><h2 id="9-键的遍历"><a href="#9-键的遍历" class="headerlink" title="9. 键的遍历"></a>9. 键的遍历</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 匹配</span><br><span class="line">keys [j,r]edis</span><br><span class="line">// 输出： jedis 和 redis 中存在的</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列文章整理摘抄自&lt;redis 开发与运维=&quot;&quot;&gt;&lt;/redis&gt;&lt;/p&gt;
&lt;h1 id=&quot;全局命令&quot;&gt;&lt;a href=&quot;#全局命令&quot; class=&quot;headerlink&quot; title=&quot;全局命令&quot;&gt;&lt;/a&gt;全局命令&lt;/
      
    
    </summary>
    
      <category term="缓存中间件" scheme="http://www.elgong.top/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="redis" scheme="http://www.elgong.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Bloom Filter 布隆过滤器</title>
    <link href="http://www.elgong.top/2020/05/16/Bloom-Filter-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://www.elgong.top/2020/05/16/Bloom-Filter-布隆过滤器/</id>
    <published>2020-05-15T16:12:25.000Z</published>
    <updated>2020-05-15T16:14:14.913Z</updated>
    
    <content type="html"><![CDATA[<p>[toc] </p><p>[toc]</p><p><a href="https://github.com/google/guava" target="_blank" rel="noopener">谷歌开源的Guava的布隆过滤器</a></p><h1 id="布隆过滤器是什么？"><a href="#布隆过滤器是什么？" class="headerlink" title="布隆过滤器是什么？"></a>布隆过滤器是什么？</h1><p>布隆过滤器由很长的<strong>二进制向量</strong>和一系列<strong>随机映射函数</strong>组成。</p><p>布隆过滤器可以用于检索一个元素是否在一个集合中。</p><p>它能给出的答案是： ==<strong>一定不存在 /可能存在</strong>==</p><h1 id="布隆过滤器的应用场景？"><a href="#布隆过滤器的应用场景？" class="headerlink" title="布隆过滤器的应用场景？"></a>布隆过滤器的应用场景？</h1><ul><li><strong>提升磁盘查询未命中的效率</strong><ul><li>通过bloom filter 过滤掉一定不存在的数据查询，减少访问磁盘和网络的次数。</li></ul></li><li><strong>redis限流-缓存击穿问题</strong><ul><li>redis 缓存前加一层布隆过滤器，应对缓存击穿问题 </li></ul></li><li><strong>海量网页黑名单</strong></li><li><strong>爬虫网址判重系统</strong></li></ul><h1 id="布隆过滤器的优缺点"><a href="#布隆过滤器的优缺点" class="headerlink" title="布隆过滤器的优缺点?"></a>布隆过滤器的优缺点?</h1><ul><li><strong>优点</strong>：<ul><li>布隆过滤器存储空间和插入/查询时间都是常数 O（k）</li><li>随机映射函数间独立，可以并行计算</li></ul></li><li><strong>缺点</strong>：<ul><li>随着存入的元素数量增加，误算率随之增加。</li><li>无法删除，因为不能确定元素是否真的在bitmap中。</li></ul></li></ul><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>布隆过滤器是一个很长的二进制向量，配合K 个随机映射函数，主要的操作是两个：<br><strong>插入</strong>和<strong>查找</strong></p><p><strong>插入时</strong>： 元素通过k 个随机映射函数，得到 k 个索引， 将二进制向量中的对应位置 置1</p><p><strong>查找时</strong>： 元素通过k 个随机映射函数，得到 k 个索引，查看对应位置是否全为1， 如果有0则一定不存在。</p><h2 id="怎么选择-参数？"><a href="#怎么选择-参数？" class="headerlink" title="怎么选择 参数？"></a>怎么选择 参数？</h2><p>假设输入元素的个数为 n，二进制向量的长度为m（也就是布隆过滤器大小），所容忍的误判率p和随机映射函数的个数k。计算公式如下：（小数向上取整）</p><p><img src="/2020/05/16/Bloom-Filter-布隆过滤器/F6AD6F9EB403400A8E5208E3422A2EBF" alt="image"></p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import java.util.BitSet;</span><br><span class="line"></span><br><span class="line">public class MyBloomFilter &#123;</span><br><span class="line">    //2&lt;&lt;25表示32亿个比特位</span><br><span class="line">    private static final int DEFAULT_SIZE= 2&lt;&lt; 25;</span><br><span class="line">    private  static  final int[] seeds=new int[]&#123;3,5,7,11,13,19,23,37&#125;;</span><br><span class="line">   </span><br><span class="line">    //这么大存储在BitSet</span><br><span class="line">    private BitSet bits=new BitSet(DEFAULT_SIZE);</span><br><span class="line">    private SimpleHash[] func=new SimpleHash[seeds.length];</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       </span><br><span class="line">        //可疑网站</span><br><span class="line">        String value=&quot;www.baidu.com&quot;;</span><br><span class="line">        MyBloomFilter filter=new MyBloomFilter();</span><br><span class="line">      </span><br><span class="line">        //加入之前判断一下</span><br><span class="line">        System.out.println(filter.contains(value));</span><br><span class="line">        filter.add(value);</span><br><span class="line">      </span><br><span class="line">        //加入之后判断一下</span><br><span class="line">        System.out.println(filter.contains(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //构造函数</span><br><span class="line">    public MyBloomFilter()&#123;</span><br><span class="line">        for(int i=0;i&lt;seeds.length;i++)&#123;</span><br><span class="line">            func[i]=new SimpleHash(DEFAULT_SIZE,seeds[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加网站</span><br><span class="line">    public void add(String value)&#123;</span><br><span class="line">        for (SimpleHash f : func) &#123;</span><br><span class="line">            bits.set(f.hash(value),true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断可疑网站是否存在</span><br><span class="line">    public boolean contains(String value)&#123;</span><br><span class="line">        if(value==null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean ret=true;</span><br><span class="line">        for (SimpleHash f : func) &#123;</span><br><span class="line">            ret=ret&amp;&amp;bits.get(f.hash(value));</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class SimpleHash &#123;</span><br><span class="line">        private int cap;</span><br><span class="line">        private int seed;</span><br><span class="line">        public SimpleHash(int cap,int seed)&#123;</span><br><span class="line">            this.cap=cap;</span><br><span class="line">            this.seed=seed;</span><br><span class="line">        &#125;</span><br><span class="line">        public int hash(String value)&#123;</span><br><span class="line">            int result=0;</span><br><span class="line">            int len=value.length();</span><br><span class="line">            for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">                result=seed*result+value.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">            return (cap-1)&amp;result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc] &lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/google/guava&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;谷歌开源的Guava的布隆过滤器&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;布隆过滤
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://www.elgong.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="布隆过滤器" scheme="http://www.elgong.top/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>redis学习-redis的价值</title>
    <link href="http://www.elgong.top/2020/05/12/redis%E5%AD%A6%E4%B9%A0-redis%E7%9A%84%E4%BB%B7%E5%80%BC/"/>
    <id>http://www.elgong.top/2020/05/12/redis学习-redis的价值/</id>
    <published>2020-05-11T16:06:27.000Z</published>
    <updated>2020-05-15T16:08:18.775Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><blockquote><p>本系列文章整理摘抄自<redis 开发与运维=""></redis></p><h1 id="Redis-是什么？"><a href="#Redis-是什么？" class="headerlink" title="Redis 是什么？"></a>Redis 是什么？</h1></blockquote><p>Redis 是一种 基于键值对的 <code>NOSQL</code> 内存数据库, 具有丰富的数据类型和基于内存的快速读写能力,单线程命令处理机制。</p><p>Redis 的值类型有多种：</p><ul><li>string</li><li>hash</li><li>list</li><li>set</li><li>zset (有序集合)</li><li>Bitmaps (位图)</li><li>HyperLogLog</li><li>GEO  (地理信息定位)</li></ul><p>Redis 提供了一下的附加功能：</p><ul><li>键的有效期</li><li>发布订阅</li><li>事务</li><li>Pipeline 流水线</li><li>Lua脚本</li><li>可持久化（RDB 和 AOF 两种策略）</li></ul><h1 id="Redis-有哪些特点？"><a href="#Redis-有哪些特点？" class="headerlink" title="Redis 有哪些特点？"></a>Redis 有哪些特点？</h1><p>Redis 有5大重要的特征：</p><ul><li><strong>读写速度快</strong>（读写速度可达10万/秒）<ul><li>基于内存</li><li>C 语言实现</li><li>单线程架构（IO多路模型），省却了线程间调度</li></ul></li><li><strong>基于键值对的字典服务器</strong></li><li><strong>可持久化</strong></li><li><strong>主从复制</strong></li><li><strong>高可用 &amp; 分布式</strong></li></ul><h1 id="Redis-应用场景有哪些？"><a href="#Redis-应用场景有哪些？" class="headerlink" title="Redis 应用场景有哪些？"></a>Redis 应用场景有哪些？</h1><ul><li>缓存</li><li>排行榜系统(提供列表和有序集合)</li><li>计数器 （网站播放数，电商浏览数）</li><li>社交网络（点赞，粉丝，共同爱好，推送，下拉刷新）</li><li>消息队列</li><li>session 共享</li><li>限制访问的次数</li></ul><h1 id="为什么选择单线程？"><a href="#为什么选择单线程？" class="headerlink" title="为什么选择单线程？"></a>为什么选择单线程？</h1><p>官方的解释：</p><p>我们知道，运算和处理速度上，CPU &gt;&gt;&gt; 内存 &gt;&gt;&gt; 硬盘和网络。</p><ul><li>原因1：<strong>单线程内存读写速度优于多线程的并发切换消耗</strong></li></ul><p>CPU并不是Redis的瓶颈，因为通常Redis要么受内存限制，要么受网络限制，而多线程的线程调度消耗的资源要比在内存读取数据大得多，所以选择了单线程 + IO 多路复用模型。</p><ul><li>原因2：<strong>数据的一致性</strong></li></ul><p>单线程的操作，一定是线程安全的，并且避免了使用锁同步等。</p><font color="red" size="4">为了最大程度地利用CPU，可以在同一服务器上启动多个Redis实例，并为每个实例绑定一个CPU.  (Linux 通过 `taskset -c 1,2,3 /etc/init.d/mysql start`)</font><h1 id="Redis-的不足之处？"><a href="#Redis-的不足之处？" class="headerlink" title="Redis 的不足之处？"></a>Redis 的不足之处？</h1><p>数据有冷热之分，热点数据可以放在Redis 中，加速读写，减少对后端数据库的访问压力。</p><p>但是过于冷的数据，会浪费内存空间。</p><h1 id="与同类型的技术的横向对比？"><a href="#与同类型的技术的横向对比？" class="headerlink" title="与同类型的技术的横向对比？"></a>与同类型的技术的横向对比？</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列文章整理摘抄自&lt;redis 开发与运维=&quot;&quot;&gt;&lt;/redis&gt;&lt;/p&gt;
&lt;h1 id=&quot;Redis-是什么？&quot;&gt;&lt;a href=&quot;#Redis-是什么？&quot; class=&quot;headerlink&quot; title=&quot;Redi
      
    
    </summary>
    
      <category term="缓存中间件" scheme="http://www.elgong.top/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="redis" scheme="http://www.elgong.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>将博客搬至CSDN</title>
    <link href="http://www.elgong.top/2020/04/22/%E5%B0%86%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%87%B3CSDN/"/>
    <id>http://www.elgong.top/2020/04/22/将博客搬至CSDN/</id>
    <published>2020-04-22T04:21:03.000Z</published>
    <updated>2020-04-22T04:22:27.029Z</updated>
    
    <content type="html"><![CDATA[<p>本文为满足将博客内容搬迁至csdn 的审核要求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文为满足将博客内容搬迁至csdn 的审核要求。&lt;/p&gt;

      
    
    </summary>
    
      <category term="闲聊" scheme="http://www.elgong.top/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="http://www.elgong.top/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>Java 向上转型&amp;向下转型</title>
    <link href="http://www.elgong.top/2020/04/22/Java-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B/"/>
    <id>http://www.elgong.top/2020/04/22/Java-向上转型-向下转型/</id>
    <published>2020-04-22T03:53:28.000Z</published>
    <updated>2020-04-22T03:57:29.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="向上转型和向下转型"><a href="#向上转型和向下转型" class="headerlink" title="向上转型和向下转型"></a>向上转型和向下转型</h1><ul><li><strong>向上转型：</strong>  父类引用 指向子类对象<ul><li>调用效果： 父类的属性  +    <font color="red"><big>父类的方法（未被子类重写）+ 子类的方法 （重写了父类）</big></font></li></ul></li><li><strong>向下转型：</strong><ul><li>调用效果：子类的属性  +  子类的方法 </li></ul></li></ul><p>例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.elgong.cast;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Father.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 静态类变量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> staticInt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String staticStr = <span class="string">"father static str"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 实例变量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Int = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span>  String Str = <span class="string">"father str"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  会被子类覆盖的方法  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"被子类覆盖的方法 :say "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  不被子类覆盖的方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOnlyFather</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"未被子类覆盖的方法 : sayOnlyFather"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 私有方法默认为  fianl， 不可被继承， 也不参与转型 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" father sleep"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.elgong.cast;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Son.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 子类的 变量区 */</span></span><br><span class="line">    <span class="comment">/* 静态变量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> staticInt = <span class="number">111</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String staticStr = <span class="string">"son static str"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 实例变量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Int = <span class="number">222</span>;</span><br><span class="line">    <span class="keyword">public</span>  String Str = <span class="string">"son  str"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 子类独有的变量 */</span></span><br><span class="line">    <span class="keyword">public</span> String strOnlySon = <span class="string">"str Only Son"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类重写的方法：say"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类独有的方法： son sleep : "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.elgong.cast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" 向上转型：  "</span>);</span><br><span class="line">        <span class="comment">/* 向上转型 */</span></span><br><span class="line">        Father f = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line">        System.out.println(f.Int);  <span class="comment">// 打印 2</span></span><br><span class="line">        System.out.println(f.Str);  <span class="comment">// 打印 father  str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        f.say();  <span class="comment">// 打印 son say :</span></span><br><span class="line">        f.sayOnlyFather();  <span class="comment">// 打印   father say 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 向下转型 */</span></span><br><span class="line">        System.out.println(<span class="string">" 向下转型：  "</span>);</span><br><span class="line">        Son s = (Son)f;</span><br><span class="line"></span><br><span class="line">        System.out.println(s.Int);  <span class="comment">// 打印   222</span></span><br><span class="line">        System.out.println(s.Str);  <span class="comment">// 打印   son  str</span></span><br><span class="line">        System.out.println(s.strOnlySon);   <span class="comment">// 打印   strOnlySon</span></span><br><span class="line"></span><br><span class="line">        s.say();  <span class="comment">// 打印  son say : </span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;向上转型和向下转型&quot;&gt;&lt;a href=&quot;#向上转型和向下转型&quot; class=&quot;headerlink&quot; title=&quot;向上转型和向下转型&quot;&gt;&lt;/a&gt;向上转型和向下转型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;向上转型：&lt;/strong&gt;  父类引用 指向子类对象&lt;
      
    
    </summary>
    
      <category term="Java多态" scheme="http://www.elgong.top/categories/Java%E5%A4%9A%E6%80%81/"/>
    
    
      <category term="向上转型&amp;向下转型" scheme="http://www.elgong.top/tags/%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>蓄水池抽样算法</title>
    <link href="http://www.elgong.top/2020/04/19/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95/"/>
    <id>http://www.elgong.top/2020/04/19/蓄水池抽样算法/</id>
    <published>2020-04-19T09:18:21.000Z</published>
    <updated>2020-04-21T01:52:30.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、预备知识"><a href="#一、预备知识" class="headerlink" title="一、预备知识"></a>一、预备知识</h1><p>Java 随机数生成的方法：</p><p><code>java.util.Random</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Main.java </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定随机种子，默认以时间为种子</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random(<span class="number">2048</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成 0 ~ 99 之间的整数</span></span><br><span class="line">        System.out.println( random.nextInt(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成 0 ~ 1.0 之间的小数</span></span><br><span class="line">        System.out.println( random.nextDouble());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成 布尔</span></span><br><span class="line">        System.out.println( random.nextBoolean());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、海量数据随机采样K个的需求"><a href="#二、海量数据随机采样K个的需求" class="headerlink" title="二、海量数据随机采样K个的需求"></a>二、海量数据随机采样K个的需求</h1><p>从固定区间内随机采样数据十分简单，直接调用 <code>random.nextInt()</code> 就可以。</p><p><strong>但如果是长度未知的海量数据流呢？该如何实现等概率采样？</strong></p><p>​        答：蓄水池采样算法就是一种解决方案。</p><h1 id="三、实现原理（从未知长度的海量数据随机采样K个元素）"><a href="#三、实现原理（从未知长度的海量数据随机采样K个元素）" class="headerlink" title="三、实现原理（从未知长度的海量数据随机采样K个元素）"></a>三、实现原理（从未知长度的海量数据随机采样K个元素）</h1><h2 id="3-1-举例说明：从未知流中随机选择一个元素-K-1-的实现方法"><a href="#3-1-举例说明：从未知流中随机选择一个元素-K-1-的实现方法" class="headerlink" title="3.1 举例说明：从未知流中随机选择一个元素(K = 1)的实现方法"></a>3.1 <strong>举例说明：从未知流中随机选择一个元素(K = 1)的实现方法</strong></h2><ul><li><strong>当数据流中只有一个数据</strong>：<ul><li>直接返回该数据</li></ul></li><li><strong>当数据流中有两个数据</strong>：<ul><li>D0，D1 中随机选择一个。 概率均为 1/2</li></ul></li><li><strong>当数据流中有三个数据</strong><ul><li>Step1 : 处理 D0, D1 时 先保留一个，概率分别为 1/2</li><li>Step2 :处理 D3 时, 1/3 的概率保留D3, 1 - 1/3 的概率保留 Step1 中的结果</li></ul></li><li><strong>递推下去</strong>      </li></ul><h2 id="3-2-解析：假设流的长度只有3"><a href="#3-2-解析：假设流的长度只有3" class="headerlink" title="3.2 解析：假设流的长度只有3"></a>3.2 <strong>解析：假设流的长度只有3</strong></h2><p>数据 D1 被采样概率：（1/2）<em> (2/3) = 1/3<br>数据 D2 被采样概率：（1/2）</em>(2/3) = 1/3<br>数据 D3 被采样概率：  1/3</p><h2 id="3-3-算法描述"><a href="#3-3-算法描述" class="headerlink" title="3.3 算法描述"></a>3.3 算法描述</h2><ul><li>先选取数据流中的前k个元素，保存在池子pool中；</li><li>从第j（k + 1 &lt;= j &lt;= n）个元素开始<ul><li>每次先以概率 p = k/j选择是否让第j个元素留下；<ul><li>若j被选中，则从A中随机选择一个元素并用该元素j替换它</li><li>否则直接淘汰该元素；</li></ul></li></ul></li><li>重复步骤2直到结束，最后集合A中剩下的就是保证随机抽取的k个元素。</li></ul><h1 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private int[] sampling(int K) &#123;</span><br><span class="line">    int[] pool = new int[K];</span><br><span class="line">    </span><br><span class="line">    // 前 K 个元素直接放入数组中</span><br><span class="line">    for (int i = 0; i &lt; K; i++) &#123; </span><br><span class="line">        pool[i] = stream[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = K; i &lt; N; i++) &#123; // K + 1 个元素开始进行概率采样</span><br><span class="line">        int r = random.nextInt(i + 1);</span><br><span class="line">        // 这里其实就是k/j的体现</span><br><span class="line">        if (r &lt; K) &#123;</span><br><span class="line">            pool[r] = stream[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、leetcode-题目："><a href="#五、leetcode-题目：" class="headerlink" title="五、leetcode 题目："></a>五、leetcode 题目：</h1><p><a href="https://leetcode-cn.com/problems/random-pick-index/" target="_blank" rel="noopener">T1. 随机数索引</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 蓄水池算法：</span></span><br><span class="line"><span class="comment">    只对重复值采用蓄水池算法</span></span><br><span class="line"><span class="comment">    出现次数     概率</span></span><br><span class="line"><span class="comment">    1            1</span></span><br><span class="line"><span class="comment">    2            1/2</span></span><br><span class="line"><span class="comment">    3            1/3</span></span><br><span class="line"><span class="comment">    4            1/4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = getIndex(nums, target);</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 统计出现的次数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (target == nums[i])&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (index == -<span class="number">1</span>)&#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> r = random.nextInt(count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>)&#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/linked-list-random-node/" target="_blank" rel="noopener">T2. 链表中随机选择节点</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@param</span> head The linked list's head.</span></span><br><span class="line"><span class="comment">        Note that the head is guaranteed to be not null, so it contains at least one node. */</span></span><br><span class="line">    <span class="keyword">private</span> ListNode head;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns a random node's value. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        ListNode now = head;</span><br><span class="line">        <span class="keyword">int</span> ret = -<span class="number">1</span>;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (now != <span class="keyword">null</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ret == -<span class="number">1</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                ret = now.val;</span><br><span class="line">                now = now.next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> rm = random.nextInt(count );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rm == <span class="number">0</span>)&#123;</span><br><span class="line">                ret =  now.val;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            now = now.next;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、预备知识&quot;&gt;&lt;a href=&quot;#一、预备知识&quot; class=&quot;headerlink&quot; title=&quot;一、预备知识&quot;&gt;&lt;/a&gt;一、预备知识&lt;/h1&gt;&lt;p&gt;Java 随机数生成的方法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java.util.Random&lt;/code&gt;&lt;/p
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://www.elgong.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="蓄水池抽样算法 海量数据随机采样" scheme="http://www.elgong.top/tags/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%9A%8F%E6%9C%BA%E9%87%87%E6%A0%B7/"/>
    
  </entry>
  
  <entry>
    <title>mysql-必知必会7-综合内容</title>
    <link href="http://www.elgong.top/2020/04/11/mysql-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A7-%E7%BB%BC%E5%90%88%E5%86%85%E5%AE%B9/"/>
    <id>http://www.elgong.top/2020/04/11/mysql-必知必会7-综合内容/</id>
    <published>2020-04-11T03:35:36.000Z</published>
    <updated>2020-04-11T04:08:35.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、关系型数据库Mysql"><a href="#一、关系型数据库Mysql" class="headerlink" title="一、关系型数据库Mysql"></a><strong>一、关系型数据库Mysql</strong></h1><p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。</p><ul><li><strong>数据库:</strong> 数据库是一些关联表的集合。.</li><li><strong>数据表:</strong> 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li><li><strong>列:</strong> 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。</li><li><strong>行：</strong>一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</li><li><strong>冗余</strong>：存储两倍数据，冗余可以使系统速度更快。</li><li><strong>主键</strong>：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li><li><strong>外键：</strong>外键用于关联两个表。</li><li><strong>复合键</strong>：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li><li><strong>索引：</strong>使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li><li><p><strong>参照完整性:</strong> 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性</p></li><li><p><strong>主键: 表示特定行.</strong></p><ul><li>主键不能重复</li><li>每行必有主键,且不能为 NULL</li></ul></li><li><p><strong>外键:</strong>  product 只存产品信息, 和供应商ID,  vendors 存供应商的信息(主键是ID),则vendors的主键就是product的外键.</p></li></ul><p>MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。</p><h1 id="二、-安装与删"><a href="#二、-安装与删" class="headerlink" title="二、 安装与删"></a><strong>二、 安装与删</strong></h1><ul><li><p>删除mysql</p><p><code>sudo apt purge mysql-* sudo apt autoremove</code></p></li><li><p>安装mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server </span><br><span class="line">sudo apt install mysql-client </span><br><span class="line">sudo apt install libmysqlclient-dev `</span><br></pre></td></tr></table></figure></li></ul><p><strong>数据库规范：</strong></p><ul><li>关键字大写，表名，列名小写</li><li>索引从1开始</li><li>每条命令用分号隔开</li><li><p>注释</p></li><li><p>单行注释   #</p></li><li>单行注释  — 注释文</li><li>多行注释  /<em> </em>/</li></ul><font color="red"><big>索引从1开始！</big></font><h1 id="三、常用命令"><a href="#三、常用命令" class="headerlink" title="三、常用命令"></a><strong>三、常用命令</strong></h1><h2 id="指令执行顺序："><a href="#指令执行顺序：" class="headerlink" title="指令执行顺序："></a><strong>指令执行顺序：</strong></h2><p><strong>SELECT  FROM  WHERE   GROUP BY  HAVING  ORDER BY LIMIT.</strong></p>   <font color="red"><big>开始 **->** FROM子句 **->** WHERE子句 **->** GROUP BY子句 **->** HAVING子句 **->** ORDER BY子句 **->** SELECT子句 **->** LIMIT子句 **->** 最终结果 </big></font>    <font color="red"><big>每个步骤都会为下一个步骤生成一个虚拟表</big></font><h2 id="1-登陆系统-选择数据库"><a href="#1-登陆系统-选择数据库" class="headerlink" title="1. 登陆系统, 选择数据库"></a><strong>1. 登陆系统, 选择数据库</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql -u 用户名 -p 密码</span><br><span class="line">mysql -h localhost -P 3306 -p</span><br><span class="line"></span><br><span class="line"># 查看所有数据库列表</span><br><span class="line">SHOW DATABSASES;</span><br><span class="line"># 查看选择的数据库中的表的列表</span><br><span class="line">SHOW TABLES;</span><br><span class="line"># 查看表中的列有哪些</span><br><span class="line">SHOW COLUMNS FROM 表名;  ||  DESCRIBE 表名;</span><br><span class="line"></span><br><span class="line"># 选择库</span><br><span class="line">USE 数据库的名字;</span><br><span class="line"></span><br><span class="line"># 查看表结构</span><br><span class="line">DESC 表名;</span><br></pre></td></tr></table></figure><h2 id="2-基础查询——检索-SELECT-DISTINCT"><a href="#2-基础查询——检索-SELECT-DISTINCT" class="headerlink" title="2 基础查询——检索 SELECT + DISTINCT"></a><strong>2 基础查询——检索 SELECT + DISTINCT</strong></h2><p>SELECT 子句 固定的顺序:</p><p><strong>SELECT  FROM  WHERE （原始表有的字段）  GROUP BY  HAVING  （分组后有的字段）ORDER BY LIMIT.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 选择多个字段 `着重号`当字段名与关键字冲突，用它可以避免冲突</span><br><span class="line">SELECT id, `name`, price FROM 表名; </span><br><span class="line"></span><br><span class="line"># 起别名 AS, 可以省略SELECT salary &quot;Month Salary&quot; from employees;</span><br><span class="line">SELECT salary AS &quot;Month Salary&quot; from employees;</span><br><span class="line"></span><br><span class="line"># 字符串拼接 concat</span><br><span class="line"># 特别注意+：  </span><br><span class="line"># 1+9=10  两个数值型做加法</span><br><span class="line"># &apos;12&apos;+ 3 = 15 字符转整数，再加 </span><br><span class="line"># &apos;job&apos;+2 = 2  转换失败，则字符串变0</span><br><span class="line"># null+任何值 = null</span><br><span class="line">SELECT concat(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) , price FROM 表名; </span><br><span class="line"></span><br><span class="line"># 检索所有字段</span><br><span class="line">SELECT * FROM 表名;</span><br><span class="line"></span><br><span class="line"># 字段去重  DISTINCT</span><br><span class="line">SELECT DISTINCT id FROM 表名;   # 不能应用于多列</span><br><span class="line"></span><br><span class="line"># 限制检索结果</span><br><span class="line"> SELECT  id FROM 表名  LIMIT 5;  # 前5 </span><br><span class="line"> SELECT  id FROM 表名  LIMIT 2,5;  #从 2+1 开始的  5个行</span><br><span class="line"> SELECT id FROM 表名 LIMIT 5 OFFSET 3;  # 从行3取5</span><br></pre></td></tr></table></figure><h2 id="3-排序检索-ORDER-BY-默认升序-LIMIT-OFFSET-DESC"><a href="#3-排序检索-ORDER-BY-默认升序-LIMIT-OFFSET-DESC" class="headerlink" title="3. 排序检索 ORDER   BY (默认升序) + LIMIT,  OFFSET, DESC"></a><strong>3. 排序检索 ORDER   BY (默认升序) + LIMIT,  OFFSET, DESC</strong></h2><p>可以根据非 select 字段排序。</p><p>SELECT  查询列表</p><p>FROM  表</p><p>【where 筛选条件】</p><p>ORDER BY  排序列表  [asc |  desc]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 按照某列排序,  多条件排序</span><br><span class="line">SELECT id FROM 表名 ORDER BY id ASC, age DESC;   # 可以根据其他列来排序</span><br><span class="line"></span><br><span class="line"># 按照多个条件排序</span><br><span class="line">SELECT id FROM 表名 ORDER BY age, size;   # 优先age, 重复时才根据size排序.</span><br><span class="line"></span><br><span class="line">#  指定降序  DESC</span><br><span class="line">SELECT id FROM 表名 ORDER BY age  DESC  size;  # DESC 只作用于在DESC 前面的, 所以 size仍然为升序</span><br><span class="line"></span><br><span class="line"># 找到最********的id</span><br><span class="line">SELECT id FROM 表名 ORDER BY age LIMIT 1;</span><br><span class="line"># 第二最的*******id</span><br><span class="line">SELECT id FROM 表名 ORDER BY age LIMIT 1 OFFSET 2;</span><br></pre></td></tr></table></figure><h2 id="4-条件查询"><a href="#4-条件查询" class="headerlink" title="4. 条件查询"></a><strong>4. 条件查询</strong></h2><h3 id="4-1-——逻辑运算-WHERE-AND-OR-NOT-IN-和EXISTS-看优化部分"><a href="#4-1-——逻辑运算-WHERE-AND-OR-NOT-IN-和EXISTS-看优化部分" class="headerlink" title="4.1  ——逻辑运算 WHERE + AND, OR,NOT IN 和EXISTS(看优化部分)"></a><strong>4.1  ——逻辑运算 WHERE + AND, OR,NOT</strong> <strong>IN 和EXISTS(看优化部分)</strong></h3><p><strong>作用：</strong></p><p>连接条件表达式</p><font color="red"><big>**如果计算次序不加括号时,  优先 AND**</big></font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#  =  !=  &lt;  &gt; &gt;=    &quot;BETWEEN 1 AND 2&quot;在指定值之间,包含端点</span><br><span class="line"># 不等于 ！=   或者  &lt;&gt;</span><br><span class="line">SELECT id FROM 表名 WHERE age=12 ORDER BY size;</span><br><span class="line"></span><br><span class="line"># 组合筛选  AND  OR</span><br><span class="line">SELECT id FROM 表名 WHERE age=12 AND size &lt; 10;</span><br><span class="line"></span><br><span class="line"># 计算次序,  不加括号时,  优先 AND</span><br><span class="line"># 解释: id&gt;3且age&gt;10,  或者 id=1</span><br><span class="line">SELECT id FROM 表名 WHERE id=1 OR id=3 AND age &gt; 10;   </span><br><span class="line"></span><br><span class="line"># NOT  否定后跟的所有条件.</span><br><span class="line">SELECT id FROM 表名 NOT WHERE id IN (1002, 1003)</span><br></pre></td></tr></table></figure><p><img src="/2020/04/11/mysql-必知必会7-综合内容/Users\Misaya\AppData\Local\YNote\data\elgong@126.com\e87e0bbb47ff40228ca7b6dbebad7954\clipboard.png" alt="img"></p><h3 id="4-2-——模糊查询-WHERE-LIKE-between-and-in-is-null"><a href="#4-2-——模糊查询-WHERE-LIKE-between-and-in-is-null" class="headerlink" title="4.2  ——模糊查询  WHERE + LIKE, between and, in, is null"></a><strong>4.2  ——模糊查询  WHERE + LIKE, between and, in, is null</strong></h3><ul><li><strong>like + 通配符：</strong> 参考7.</li><li><strong>between and ：</strong> 包含临界值， 不可颠倒顺序</li><li><strong>in：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># between and</span><br><span class="line">SELECT  * FROM 表名  WHERE id BETWEEN 100 and 120;</span><br><span class="line"></span><br><span class="line"># IN 取值必须在括号内</span><br><span class="line">SELECT id FROM 表名 WHERE id IN (1002, 1003)</span><br><span class="line"></span><br><span class="line"># IS NULL 筛选出空值  IS NOT NULL</span><br><span class="line">SELECT id FROM 表名 WHERE age IS NULL;</span><br></pre></td></tr></table></figure><p><strong>补. 空值处理 IFNULL(字段，空值时返回值)</strong></p><p><code>SELECT IFNULL(price, 0) FROM 表名;</code></p><h2 id="5-通配符-LIKE-正则表达式-REGEXP-都-不区分大小写"><a href="#5-通配符-LIKE-正则表达式-REGEXP-都-不区分大小写" class="headerlink" title="5. 通配符   LIKE + % , _   + 正则表达式 REGEXP   都**不区分大小写**"></a><strong>5. 通配符   LIKE + % , _   + 正则表达式</strong> <strong>REGEXP   都**</strong>不区分大小写**</h2><ol><li><p>通配符速度慢, 不要放在搜索开始处</p></li><li><p><strong>LIKE 匹配整个串,  正则表达式可以匹配子串</strong></p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#  通配符</span><br><span class="line">#  % 匹配0,1,多个字符</span><br><span class="line">SELECT id FROM 表名 WHERE string LIKE &apos;s%&apos;;   # s开头   </span><br><span class="line"></span><br><span class="line"># 下划线 _ , 匹配单个字符</span><br><span class="line"># 需要匹配 _ 时， 用转义   \_</span><br><span class="line">SELECT id FROM 表名 WHERE string LIKE &apos;s_&apos;;  </span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">#  正则表达式 REGEXP</span><br><span class="line"># 标准表达</span><br><span class="line">SELECT name FROM customers WHERE name REGEXP &apos;1000&apos;;</span><br><span class="line"></span><br><span class="line">&apos;.&apos;   # 任意一个字符</span><br><span class="line">&apos;A1&apos;| &apos;B2&apos;  # 匹配两个串之一</span><br><span class="line">&apos;[1-9]&apos;     # 匹配 1~9 范围内的值</span><br><span class="line">&apos;[123]&apos;     # 匹配1，2，3之一， 等价于【1 | 2 | 3】</span><br><span class="line">&apos;[^123]&apos;    # 匹配非123的值</span><br><span class="line">&apos;\\.&apos;       # 特殊字符转译   </span><br><span class="line"></span><br><span class="line"># 匹配多个实例, 不能单独出现,必须是指定上边的某种字符的匹配</span><br><span class="line"># 例如 &apos;.*&apos; 而不是&apos;*&apos;</span><br><span class="line">&apos;*&apos;  # 0或多个匹配</span><br><span class="line">&apos;+&apos;  # 1或多个匹配</span><br><span class="line">&apos;?&apos;  # 0或者1个匹配</span><br><span class="line">&#123;n&#125;  # 指定数目匹配</span><br><span class="line">&#123;n,&#125;  # 不少于指定数目的匹配</span><br><span class="line">&#123;n,m&#125;  # 数目范围,不超过255</span><br><span class="line"></span><br><span class="line">#定位元字符</span><br><span class="line">&apos;^&apos;   # 开始位置</span><br><span class="line">&apos;$&apos;   # 结尾</span><br><span class="line">&apos;[[:&lt;:]]&apos;  # 词开始</span><br><span class="line">&apos;[[:&lt;:]]&apos;  # 词结尾</span><br><span class="line"></span><br><span class="line"># 举例:</span><br><span class="line">&apos;^[1-9]&apos;   </span><br><span class="line">BINARY &apos;J 1000&apos;     # 指定区分大小写</span><br><span class="line"></span><br><span class="line">&apos;[a-zA-Z0-9]&apos;   # 匹配所有字符</span><br></pre></td></tr></table></figure><h2 id="6-数据处理常用函数-不区分大小写"><a href="#6-数据处理常用函数-不区分大小写" class="headerlink" title="6. 数据处理常用函数 (不区分大小写)"></a><strong>6. 数据处理常用函数 (不区分大小写)</strong></h2><ul><li>字符函数</li><li>数学函数</li><li>日期函数</li><li>其他函数</li><li>流程函数</li></ul><p>字符函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 文本处理函数</span><br><span class="line"># 1. 字符串字节个数,  汉字算三个字符</span><br><span class="line">Length() </span><br><span class="line"></span><br><span class="line"># 2. 拼接</span><br><span class="line">CONCAT(id, &quot;_&quot;, name)</span><br><span class="line"></span><br><span class="line"># 3. 大写 小写</span><br><span class="line">Lower()  # 小写</span><br><span class="line">Upper()  # 大写</span><br><span class="line"></span><br><span class="line"># 4. 返回子串的字符, 数据库索引从1开始</span><br><span class="line">SubStr(last_name, start) </span><br><span class="line">SubStr(last_name, start, length)   # 长度</span><br><span class="line"></span><br><span class="line"># 5. 查找子串, 返回第一次出现的索引， 查不到返回0</span><br><span class="line">INSTR(&quot;待查子串abcd&quot;, &quot;a&quot;)</span><br><span class="line"></span><br><span class="line"># 6. 去空格</span><br><span class="line">Trim(), LTrim(), RTrim()  </span><br><span class="line"></span><br><span class="line"># 7. 指定长度填充</span><br><span class="line">LPAD(name, length, &apos;*&apos;)</span><br><span class="line">RPAD(name, length, &apos;*&apos;)</span><br><span class="line"></span><br><span class="line"># 8. 替换</span><br><span class="line">REPLACE(原串, &apos;被替换串&apos;, &apos;新串&apos;)</span><br><span class="line"></span><br><span class="line"># 9. 字符串字符长度, 汉字也算 1个字符</span><br><span class="line">CHAR_LENGTH(s)  </span><br><span class="line">Soundex()   # 返回串的SOUNDEX值</span><br></pre></td></tr></table></figure><p>数学函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 1. 四舍五入</span><br><span class="line">ROUND(1.6);   # 2</span><br><span class="line">ROUND(1.567, 2)  # 小数点保留两位</span><br><span class="line"></span><br><span class="line"># 2. 上取整， &gt;=该参数的最小整数</span><br><span class="line">CEIL(1.00) </span><br><span class="line"># 下取整,   &lt;=该参数的最大整数</span><br><span class="line">FLOOR(-9.99)   # -10</span><br><span class="line"></span><br><span class="line"># 3. 小数点直接截断</span><br><span class="line">TRUNCATE(1.69999, 1)  # 1.6</span><br><span class="line"></span><br><span class="line"># 4. 取余数</span><br><span class="line">MOD(10, 3)  # 10%3</span><br><span class="line"></span><br><span class="line">ABS(x)   # 绝对值</span><br><span class="line">AVG(age)  # 某列的平均值 </span><br><span class="line">EXP(x)</span><br><span class="line">RAND()  # 0到1的随机数</span><br></pre></td></tr></table></figure><p>日期函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NOW()   # 当前日期和时间</span><br><span class="line">CURDATE() # 当前日期，不含时间</span><br><span class="line">Date()  # 返回时间中的日期部分....</span><br><span class="line">Day()   # 返回时间中的天数部分</span><br><span class="line">Year(NOW())</span><br><span class="line">Time()</span><br><span class="line">Month()  </span><br><span class="line">Hour()</span><br><span class="line">DateDiff()  # 计算日期差</span><br><span class="line"></span><br><span class="line"># 字符串转日期</span><br><span class="line">STR_TO_DATE(&apos;02-19-2020&apos;, &quot;%m-%d-%Y&quot;)</span><br><span class="line"></span><br><span class="line"># 日期的格式化输出</span><br><span class="line">DATE_FORMAT(NOW(), &apos;%y年%m月%d日&apos;)</span><br></pre></td></tr></table></figure><p>其他函数</p><p><code>VERSION()</code></p><h2 id="7-流程控制函数"><a href="#7-流程控制函数" class="headerlink" title="7. 流程控制函数"></a><strong>7. 流程控制函数</strong></h2><p>IF(逻辑判断， 成立执行， 不成立执行)</p><p>CASE:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># IF</span><br><span class="line">IF(10&gt;5, &apos;大&apos;, &apos;小&apos;)</span><br><span class="line">SELECT name IF(salary IS NULL, &quot;没薪水&quot;, &quot;有薪水&quot;)</span><br><span class="line"></span><br><span class="line"># CASE 第一种使用</span><br><span class="line">CASE &apos;要判断的表达式&apos;</span><br><span class="line">WHEN &apos;常量1&apos; then 值(没有分号) / 表达式(有分号);</span><br><span class="line">WHEN &apos;常量2&apos; then 值(没有分号) / 表达式(有分号);</span><br><span class="line">WHEN &apos;常量3&apos; then 值(没有分号) / 表达式(有分号);</span><br><span class="line">...</span><br><span class="line">ELSE 值(没有分号) / 表达式(有分号);</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line"># CASE 第二种语句</span><br><span class="line">CASE </span><br><span class="line">WHEN 表达式 then 值(没有分号) / 表达式(有分号);</span><br><span class="line">WHEN 表达式 then 值(没有分号) / 表达式(有分号);</span><br><span class="line">WHEN 表达式 then 值(没有分号) / 表达式(有分号);</span><br><span class="line">...</span><br><span class="line">ELSE 值(没有分号) / 表达式(有分号);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><h2 id="8-数据汇总-聚集函数-AVG-COUNT-MAX-MIN-SUM"><a href="#8-数据汇总-聚集函数-AVG-COUNT-MAX-MIN-SUM" class="headerlink" title="8. 数据汇总-聚集函数  AVG, COUNT, MAX, MIN, SUM"></a><strong>8. 数据汇总-聚集函数  AVG, COUNT, MAX, MIN, SUM</strong></h2><p>运行在行组, 计算和返回单个值的函数.</p><p>统计使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># AVG() 针对单列,  对多列需要使用多个</span><br><span class="line">SELECT AVG(age) AS avg_age FROM 表名;   # 忽略 NULL</span><br><span class="line"></span><br><span class="line"># COUNT() 函数</span><br><span class="line">COUNT(1);   # 行数</span><br><span class="line">COUNT(*);   # 表的行数, 含有 NULL的有数据行也可，但是不能全NULL</span><br><span class="line">COUNT(column)  # 某列非NULL 的个数</span><br><span class="line">COUNT(distinct 字段)  # 统计不重复的</span><br><span class="line"># 效率对比：</span><br><span class="line">MYISAM 储存引擎下， COUNT(*) 效率高</span><br><span class="line">INNODB 存储引擎下，COUNT(*) 和COUNT(1) 差不多，比COUNT(字段高)</span><br><span class="line"></span><br><span class="line"># 聚集不同的值 + DISTINCT</span><br><span class="line"># 聚集函数默认ALL</span><br><span class="line">SELECT AVG(DISTINCT age) FROM 表名;  # 对唯一值求均值</span><br><span class="line">SELECT COUNt(DISTINCT age) FROM 表名;  # 对age列的唯一值统计个数</span><br></pre></td></tr></table></figure><h2 id="9-数据分组查询-——-GROUP-BY-HAVING"><a href="#9-数据分组查询-——-GROUP-BY-HAVING" class="headerlink" title="9. 数据分组查询 —— GROUP BY,   HAVING"></a><strong>9. 数据分组查询 —— GROUP BY,   HAVING</strong></h2><h3 id="1-GROUP-BY-分组字段"><a href="#1-GROUP-BY-分组字段" class="headerlink" title="1. GROUP BY   分组字段"></a><strong>1. GROUP BY   分组字段</strong></h3><p>​          <font color="red"><big><strong>如果分组列中具有 NULL,  则NULL 将作为一个分组返回.</strong></big></font></p><h3 id="2-HAVING-过滤条件-WHERE-条件"><a href="#2-HAVING-过滤条件-WHERE-条件" class="headerlink" title="2. HAVING 过滤条件  =====WHERE 条件"></a><strong>2. HAVING 过滤条件  =====WHERE 条件</strong></h3><h3 id="3-必加-ORDER-BY-因为G出来的结果不保证排序了"><a href="#3-必加-ORDER-BY-因为G出来的结果不保证排序了" class="headerlink" title="3. 必加 ORDER BY,  因为G出来的结果不保证排序了."></a><strong>3. 必加 ORDER BY,  因为G出来的结果不保证排序了.</strong></h3><h3 id="4-能where-就不用having"><a href="#4-能where-就不用having" class="headerlink" title="4. 能where 就不用having"></a><strong>4. 能where 就不用having</strong></h3><ul><li><p><strong>按字段分组</strong></p></li><li><ul><li>GROUP BY id </li></ul></li><li><p><strong>按表达式或者函数</strong></p></li><li><ul><li>GROUP BY length(id)  AS  len   HAVING  len&gt;3;</li></ul></li><li><p><strong>按多个字段分组</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 分组统计值</span><br><span class="line">SELECT id, COUNT(*) AS num_ FROM 表名 GROUP BY id ORDER BY age;</span><br><span class="line"></span><br><span class="line"># 分组过滤  大于2的值</span><br><span class="line">SELECT age FROM 表名 GROUP BY  id  HAVING COUNT(*)&gt;=2 ORDER BY age;</span><br></pre></td></tr></table></figure><h2 id="10-子查询-IN-括号"><a href="#10-子查询-IN-括号" class="headerlink" title="10. 子查询  IN + 括号"></a><strong>10. 子查询  IN + 括号</strong></h2><ul><li>查询的结果作为另一个查询的条件,然后多层嵌套.</li><li>内层查询<strong>建立一个临时表</strong>。费时间.</li><li>优化需要用join 联结表替代….</li></ul><p><strong>where 和 having 后可放的子查询：</strong></p><ul><li><p>子查询放在小括号内</p></li><li><p><strong>标量子查询（单值）</strong>，一般配合单行操作符使用：  &gt;  &lt;   &gt;=  =  &lt;&gt;</p></li><li><p><strong>列子查询（单列多行）</strong>， 一般配合多行操作符使用：  </p></li><li><ul><li>IN   列表中的一个</li><li>ANY/SOME   </li><li>ALL</li></ul></li></ul><p><strong>select 后可以放的子查询：</strong></p><p><strong>from 后可以放的子查询：</strong></p><ul><li><p>必须起别名</p></li><li><ul><li>FROM (子查询表)  newtable </li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 标量子查询</span><br><span class="line"># 1. 谁工资比  elgong 高</span><br><span class="line">SELECT  * FROM employee </span><br><span class="line">WHERE salary&gt;(select salary from emplot WHERE name = &apos;elgong&apos;);</span><br><span class="line"></span><br><span class="line"># 查询超过平均工资的员工信息</span><br><span class="line">select avg(sal) from emp;   /* avg(sal)=2000 */</span><br><span class="line">select * from emp where sal &gt;= 2000;</span><br><span class="line">/* 子查询方法 */</span><br><span class="line">select * from emp where sal &gt;= (select avg(sal) from emp);</span><br></pre></td></tr></table></figure><h2 id="11-连接查询——JOIN-联结表-INNER-JOIN-LEFT-JOIN-RIGHT-JOIN"><a href="#11-连接查询——JOIN-联结表-INNER-JOIN-LEFT-JOIN-RIGHT-JOIN" class="headerlink" title="11. 连接查询——JOIN 联结表 ( INNER JOIN, LEFT JOIN, RIGHT JOIN)"></a><strong>11. 连接查询——JOIN 联结表 ( INNER JOIN, LEFT JOIN, RIGHT JOIN)</strong></h2><p><strong>注意判断驱动表是哪个？  查询计划  explain</strong></p><p>正常情况下，from 后的表是驱动表，但是当出现下面情况，驱动表变成了 class。</p><p>分析： 当 where 后的条件使得表之间数据多少不一样时，数据少的为主表</p><p><strong>小表驱动大表的原则</strong></p><p><code>select * from student left join class on  class.classid = student.classid where class.classid = 2;</code></p><p><strong>概念:    联结指两张表,或者多张表之间组合在一起进行查询, 是在运行时做的操作;</strong></p><ul><li><p><strong>left JOIN </strong> (左联结)保证读取主表的全部数据</p></li><li><p><strong>right JOIN</strong>  (右联结) 保证读取主表的全部数据</p></li><li><p><strong>inner JOIN</strong>  (内部联结,等值联结)  只读取共有的数据</p></li><li><p><strong>自联结:  </strong>常用来代替从同一个表检索数据的子查询.  FROM table1 AS t1, table2 AS t2, WHERE t1.col = t2.col;</p></li><li><p><strong>自然联结: </strong> 联结有主副表之分,  在INNER JOIN 之前的是主表, 待查询的输出中,排前边的内容所在的表为主表.</p></li></ul><p>左外联结可通过颠倒FROM 或者WHERE 子句中表的顺序转换成右外部联结</p><p><strong>连接的分类</strong></p><ul><li><p>SQL92语法</p></li><li><ul><li><p><strong>等值连接</strong></p></li><li><ul><li><code>FROM table1 AS t1, table2 AS t2, table3 AS t3  WHERE t1.col = t2.col  AND t2.c = t3.c ;</code>    </li></ul></li><li><p><strong>自连接（单表）</strong></p></li><li><ul><li>同表不同名</li><li><code>FROM   employees   e1,  employees  e2  WHERE  e1.id = e2.iidd</code></li></ul></li></ul></li><li><p>SQL99语法</p></li><li><ul><li>SELECT   查询列表</li><li><code>FROM   表1  别名  [连接类型]   join        表2  别名   on          连接条件</code></li></ul></li><li><ul><li><p><strong>内连接</strong>  inner join</p></li><li><p><strong>外连接</strong>  left， right</p></li><li><ul><li>主表全部显示</li><li>从表中没有与主表匹配的结果，显示NULL</li><li>等价于==== 内连接结果 + 主表有而从表没有的记录</li><li>左外和右外，交换表顺序可以等价效果</li></ul></li><li><p><strong>全外连接</strong>  full join</p></li><li><p><strong>交叉连接</strong>   cross join</p></li><li><ul><li>笛卡尔乘机</li></ul></li><li><p><strong>非等值连接</strong></p></li><li><ul><li>FROM e  join g on e.salary  BETWEEN g.low AND g.upper</li></ul></li><li><p><strong>自连接</strong></p></li><li><ul><li>一样的join on   不同名的同一张表</li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 创建联结表的两种方式</span><br><span class="line"># 1. 等值连接  WHERE 表1.id = 表2.id AND 表2.size = 表3.size</span><br><span class="line">SELECT vendors.vendor_name, product.prod_name, product.prod_price </span><br><span class="line">FROM product,vendors </span><br><span class="line">WHERE vendors.vendor_id = product.vendor_id </span><br><span class="line">ORDER BY vendor_name;</span><br><span class="line"></span><br><span class="line"># 2.内部联结(等值联结) 表的键数量相同  FROM 表1 INNER JOIN 表2 ON 表1.id = 表2.id</span><br><span class="line">SELECT v.vendor_name, p.prod_name, p.prod_price </span><br><span class="line">FROM product AS p </span><br><span class="line">INNER JOIN vendors AS v </span><br><span class="line">ON v.vendor_id = p.vendor_id  </span><br><span class="line">ORDER BY v.vendor_name;</span><br><span class="line"></span><br><span class="line"># </span><br><span class="line"># 对联结的表使用聚合方法</span><br><span class="line">待补充.....</span><br></pre></td></tr></table></figure><p><img src="/2020/04/11/mysql-必知必会7-综合内容/Users\Misaya\AppData\Local\YNote\data\elgong@126.com\e6a36fe8659843b897ed6b6e6ee6977d\clipboard.png" alt="img"></p><h2 id="12-分页查询"><a href="#12-分页查询" class="headerlink" title="12. 分页查询"></a><strong>12. 分页查询</strong></h2><p>  <strong>LIMIT  行X(从0开始),  size;</strong></p><p>  <strong>LIMIT  size OFFSET  size;</strong></p><p><strong>当要显示的数据，需要分页显示</strong> </p><ul><li>从行0开始</li><li>从第四行开始，检索5行</li><li><strong>LIMIT   3,  5</strong></li><li><strong>LIMIT   5  OFFSET  3</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#  查询前5条数据</span><br><span class="line">SELECT  *  FROM employees LIMIT 0, 5;</span><br><span class="line"></span><br><span class="line"># 查询11到25条数据</span><br><span class="line">SELECT  *  FROM employees LIMIT 10, 25-11+1;</span><br><span class="line"></span><br><span class="line"># 计算公式</span><br><span class="line">LIMIT (page-1)*size,  size;</span><br></pre></td></tr></table></figure><h2 id="13-联合查询-union-（自动去重，union-all-不去重）"><a href="#13-联合查询-union-（自动去重，union-all-不去重）" class="headerlink" title="13. 联合查询  union  （自动去重，union all  不去重）"></a><strong>13. 联合查询  union  （自动去重，union all  不去重）</strong></h2><p>将多条查询语句合并成一个结果</p><p><strong>特点：</strong></p><ul><li>查询 <strong>列数</strong> 和 <strong>列顺序</strong> 必须一致</li><li>自动去重</li><li>不去重  union all</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT   *   FROM    e1   WHERE   </span><br><span class="line">UNION</span><br><span class="line">SELECT   *   FROM    e1   WHERE</span><br></pre></td></tr></table></figure><h2 id="14-视图"><a href="#14-视图" class="headerlink" title="14. 视图"></a><strong>14. 视图</strong></h2><p>视图是虚拟的表, 是对其基表的封装.</p><p>使用的好处:</p><ol><li><p>重用 SQL 语句</p></li><li><p>使用表的部分,即过滤掉部分数据</p></li></ol><p>限制:</p><ol><li><p>图名唯一</p></li><li><p>视图可以嵌套</p></li><li><p>视图的ORDER BY  次于 从该视图检索数据的ORDER</p></li><li><p>视图可以和表一起使用</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 创建视图</span><br><span class="line">CREATE VIEW  viewname AS</span><br><span class="line">SELECT * FROM table WHERE id!=1;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、关系型数据库Mysql&quot;&gt;&lt;a href=&quot;#一、关系型数据库Mysql&quot; class=&quot;headerlink&quot; title=&quot;一、关系型数据库Mysql&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、关系型数据库Mysql&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;数据库（Datab
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.elgong.top/categories/mysql/"/>
    
    
      <category term="mysql-必知必会系列" scheme="http://www.elgong.top/tags/mysql-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>mysql-必知必会2-数据操作语言DML</title>
    <link href="http://www.elgong.top/2020/04/11/mysql-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A2-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80DML/"/>
    <id>http://www.elgong.top/2020/04/11/mysql-必知必会2-数据操作语言DML/</id>
    <published>2020-04-11T03:24:42.000Z</published>
    <updated>2020-04-11T03:33:47.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DML-数据操作语言"><a href="#DML-数据操作语言" class="headerlink" title="DML  数据操作语言"></a><strong>DML  数据操作语言</strong></h1><ul><li><strong>插入  INSERT</strong> </li><li><strong>更新  UPDATE</strong></li><li><strong>删除  DELETE</strong></li></ul><h2 id="1-插入"><a href="#1-插入" class="headerlink" title="1.  插入"></a><strong>1.  插入</strong></h2><p><strong>规则： 插入值的类型要一致</strong></p><ul><li>语法1：</li></ul><p>​        <code>INSERT   INTO   表名（列名） VALUES ( 值1...)</code></p><ul><li>语法2：</li></ul><p>​        <code>INSERT   INTO   表名 SET  列名1=值1，列名2=值2</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#  插入 INSERT</span><br><span class="line">#  插入完整行,或者部分</span><br><span class="line">INSERT INTO customers(</span><br><span class="line">    cust_name,</span><br><span class="line">    cust_address,</span><br><span class="line">    cust_city,</span><br><span class="line">    cust_state)</span><br><span class="line">VALUES(</span><br><span class="line">    &apos;elgong&apos;,</span><br><span class="line">    &apos;1552460315&apos;,</span><br><span class="line">    &apos;hangzhou&apos;,</span><br><span class="line">    &apos;1&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#  插入多行</span><br><span class="line">INSERT INTO customers(</span><br><span class="line">    cust_name,</span><br><span class="line">    cust_address,</span><br><span class="line">    cust_city,</span><br><span class="line">    cust_state)</span><br><span class="line">VALUES(</span><br><span class="line">    &apos;elgong&apos;,</span><br><span class="line">    &apos;1552460315&apos;,</span><br><span class="line">    &apos;hangzhou&apos;,</span><br><span class="line">    &apos;1&apos;</span><br><span class="line">),</span><br><span class="line">(</span><br><span class="line">    &apos;gel&apos;,</span><br><span class="line">    &apos;178905324&apos;,</span><br><span class="line">    &apos;hangzhou&apos;,</span><br><span class="line">    &apos;0&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="2-更新（缺了where-就全部更新啦，一定要注意）"><a href="#2-更新（缺了where-就全部更新啦，一定要注意）" class="headerlink" title="2.  更新（缺了where 就全部更新啦，一定要注意）"></a><strong>2.  更新（</strong><font color="red"><big>缺了where 就全部更新啦，一定要注意</big></font>）</h2><ul><li><p>单表更新语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE   表名   SET  列名1=值 ...  WHERE  筛选条件;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>多表更新语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE   表名  SET  列名1=值...   </span><br><span class="line"></span><br><span class="line">WHERE  连接条件 AND  筛选条件;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#  更新 UPDATE  SET</span><br><span class="line">#  更新某行的某些列值</span><br><span class="line">UPDATE customers </span><br><span class="line">SET cust_email = &quot;1552460315@qq.com&quot;,   #  列1</span><br><span class="line">    cust_name = &quot;ELGONG&quot;</span><br><span class="line">WHERE cust_id = 1;</span><br></pre></td></tr></table></figure><p><strong>3.  删除</strong></p><p><strong>删除整行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#   删除</span><br><span class="line">#  删除特定行</span><br><span class="line">DELETE FROM customers WHERE cust_id=1;</span><br><span class="line"></span><br><span class="line">#  删除所有行</span><br><span class="line">DELETE FROM customers ;  </span><br><span class="line">TRUNCATE TABLE;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DML-数据操作语言&quot;&gt;&lt;a href=&quot;#DML-数据操作语言&quot; class=&quot;headerlink&quot; title=&quot;DML  数据操作语言&quot;&gt;&lt;/a&gt;&lt;strong&gt;DML  数据操作语言&lt;/strong&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;插入  I
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.elgong.top/categories/mysql/"/>
    
    
      <category term="mysql-必知必会系列" scheme="http://www.elgong.top/tags/mysql-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>mysql-必知必会1-数据定义语言DDL</title>
    <link href="http://www.elgong.top/2020/04/11/mysql-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A1-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80DDL/"/>
    <id>http://www.elgong.top/2020/04/11/mysql-必知必会1-数据定义语言DDL/</id>
    <published>2020-04-11T03:15:23.000Z</published>
    <updated>2020-04-11T03:21:09.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库和表的创建，修改，删除"><a href="#数据库和表的创建，修改，删除" class="headerlink" title="数据库和表的创建，修改，删除"></a><strong>数据库和表的创建，修改，删除</strong></h1><ul><li>创建  create</li><li>修改  alter</li><li>删除  drop</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># ########  数据库相关</span><br><span class="line"># 创建库</span><br><span class="line">CREATE DATABASE 库名 IF NOT EXISTS;</span><br><span class="line"></span><br><span class="line"># 修改库名</span><br><span class="line">RENAME DATABASE  books  TO   新库名;</span><br><span class="line"></span><br><span class="line"># 删除库</span><br><span class="line">DROP DATABASE  IF EXISTS books;</span><br><span class="line"></span><br><span class="line"># ######### 表相关</span><br><span class="line">#  创建表</span><br><span class="line">CREATE TABLE   IF NOT EXISTS customers</span><br><span class="line">(</span><br><span class="line">    cust_id    int    NOT NULL AUTO_INCREMENT,  #  自动增加</span><br><span class="line">    cust_name  char(50) NOT NULL  DEFAULT GEL,  #  设默认值</span><br><span class="line">    cust_address char(50) NULL,</span><br><span class="line">   cust_city  char(50) NULL,</span><br><span class="line">   cust_state  char(5) NULL,</span><br><span class="line">   cust_email  char(255) NULL,</span><br><span class="line">   PRIMARY KEY (cust_id)   #  指定主键</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE   IF NOT EXISTS student</span><br><span class="line">(</span><br><span class="line">    id    int    NOT NULL AUTO_INCREMENT,  </span><br><span class="line">    name  char(50) NOT NULL,  </span><br><span class="line">    address char(50) NULL,</span><br><span class="line">    city  char(50) NULL,</span><br><span class="line">    email  char(255) NULL,</span><br><span class="line">   PRIMARY KEY (id) </span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#  更新表</span><br><span class="line">#  添加一列 ADD</span><br><span class="line">ALTER TABLE customers ADD cust_phone CHAR(20);</span><br><span class="line"></span><br><span class="line">#  删除表 </span><br><span class="line">DROP TABLE customers</span><br><span class="line">#  修改表名</span><br><span class="line">RENAME TABLE customers TO customers222;  </span><br><span class="line">#  修改列名</span><br><span class="line">ALTER  TABLE book CHANGE COLUMN 旧名  新名  类型;</span><br><span class="line"></span><br><span class="line">#  修改列名，约束</span><br><span class="line">ALTER  TABLE book MODIFY COLUMN 列名  类型;</span><br><span class="line"></span><br><span class="line">#  删除一列 DROP</span><br><span class="line">ALTER TABLE customers DROP COLUMN cust_phone;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库和表的创建，修改，删除&quot;&gt;&lt;a href=&quot;#数据库和表的创建，修改，删除&quot; class=&quot;headerlink&quot; title=&quot;数据库和表的创建，修改，删除&quot;&gt;&lt;/a&gt;&lt;strong&gt;数据库和表的创建，修改，删除&lt;/strong&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.elgong.top/categories/mysql/"/>
    
    
      <category term="mysql-必知必会系列" scheme="http://www.elgong.top/tags/mysql-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>版本控制-git</title>
    <link href="http://www.elgong.top/2020/03/28/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-git/"/>
    <id>http://www.elgong.top/2020/03/28/版本控制-git/</id>
    <published>2020-03-28T04:17:11.000Z</published>
    <updated>2020-03-28T04:24:01.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-git-的作用"><a href="#1-git-的作用" class="headerlink" title="1. git 的作用"></a>1. git 的作用</h1><ul><li>版本控制</li><li>协同开发</li></ul><h1 id="2-文件的状态"><a href="#2-文件的状态" class="headerlink" title="2. 文件的状态"></a>2. 文件的状态</h1><ul><li>untracked  (新建的文件)</li><li>unmodified  （提交后进入仓库的文件与当前文件相同，即没修过）</li><li>modified  (commit 之前)</li><li>staged  （commit 之后）</li></ul><h1 id="3-一般使用流程"><a href="#3-一般使用流程" class="headerlink" title="3. 一般使用流程"></a>3. 一般使用流程</h1><h4 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h4><ul><li><code>git init</code></li></ul><h4 id="变更的文件加入暂存区"><a href="#变更的文件加入暂存区" class="headerlink" title="变更的文件加入暂存区"></a>变更的文件加入暂存区</h4><ul><li><code>git add .</code></li></ul><h4 id="提交变更"><a href="#提交变更" class="headerlink" title="提交变更"></a>提交变更</h4><ul><li><code>git commit -m</code></li></ul><h4 id="查看commit日志-并返回某一次提交的版本"><a href="#查看commit日志-并返回某一次提交的版本" class="headerlink" title="查看commit日志, 并返回某一次提交的版本"></a>查看commit日志, 并返回某一次提交的版本</h4><ul><li><code>git log</code>   (### 弹出commit id)</li><li><code>git reset 7hdadsu2qe21e921821e --hard</code></li><li>如果想恢复最新的   <code>git  relog</code></li></ul><h4 id="从暂存区-移除某些文件（add-的文件有多余）"><a href="#从暂存区-移除某些文件（add-的文件有多余）" class="headerlink" title="从暂存区 移除某些文件（add 的文件有多余）"></a>从暂存区 移除某些文件（add 的文件有多余）</h4><ul><li><code>git reset &lt;fileName&gt;</code></li></ul><h1 id="4-分支合作管理"><a href="#4-分支合作管理" class="headerlink" title="4. 分支合作管理"></a>4. 分支合作管理</h1><ul><li>创建分支<ul><li><code>git checkout -b &lt;分支name&gt; &lt;template继承的commit,默认当前&gt;</code></li></ul></li><li>切换分支<ul><li><code>git checkout master</code></li></ul></li><li>查看所有分支<ul><li><code>git branch</code></li></ul></li><li>合并分支的变更（合并到当前master）<ul><li><code>git meger  branch-2</code></li><li>有冲突时，会提示======</li></ul></li></ul><h1 id="5-remote-仓库的使用"><a href="#5-remote-仓库的使用" class="headerlink" title="5. remote 仓库的使用"></a>5. remote 仓库的使用</h1><ul><li><p>下载远端仓库到本地</p><ul><li><code>git clone  ......git</code></li></ul></li><li><p>创建本地的分支</p><ul><li><code>git checkout -b local-A</code></li></ul></li><li><p>在远端仓库设置分支(第一次需要)</p><ul><li><code>git push -set-upstream origin local-A</code></li></ul></li><li><p>提交本地分支到远端</p><ul><li><code>git push</code></li></ul></li><li><p>第一次拉取远端仓库的分支，到本地</p><ul><li><code>git fetch</code>    </li><li><code>git checkout -b &lt;name&gt;</code>origin<code>&lt;template继承的commit,默认当前&gt;</code></li></ul></li><li><p>以后再从远端更新本地</p><ul><li><code>git pull</code> （自动fetch + merge）  </li></ul></li></ul><h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><ul><li><code>git merge</code></li><li><code>git pull</code></li><li><code>git fetch</code></li><li><code>git rebase</code> （版本合并时。。）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-git-的作用&quot;&gt;&lt;a href=&quot;#1-git-的作用&quot; class=&quot;headerlink&quot; title=&quot;1. git 的作用&quot;&gt;&lt;/a&gt;1. git 的作用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;版本控制&lt;/li&gt;
&lt;li&gt;协同开发&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 
      
    
    </summary>
    
      <category term="git" scheme="http://www.elgong.top/categories/git/"/>
    
    
      <category term="版本控制" scheme="http://www.elgong.top/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java集合-目录</title>
    <link href="http://www.elgong.top/2020/01/01/Java-%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84/"/>
    <id>http://www.elgong.top/2020/01/01/Java-集合结构/</id>
    <published>2020-01-01T08:10:40.000Z</published>
    <updated>2020-02-20T04:41:37.804Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/01/01/Java-集合结构/集合.png" alt="logo"></p><p>Java 集合类都在java.util包中，提供了如可变长数组，集合，队列，堆栈，链表等数据结构。<br>宏观上看整个结构可以分为两大部分： 属于单列集合Collection 接口和带映射的多列集合的Map接口。</p><ul><li><p><a href="www.elgong.top"><strong>Collection</strong></a> 接口：集合的基本操作和属性</p><ul><li><p><strong>List</strong> 接口：有序列表</p><ul><li><a href="www.elgong.top"><strong>ArrayList</strong></a>：  可变长的数组。 </li><li><a href="www.elgong.top"><strong>LinkedList</strong></a>： 双端队列的链表结构。 </li></ul></li><li><p><strong>Set</strong> 接口： 不重复元素的集合</p><ul><li><a href="www.elgong.top"><strong>HashSet</strong></a>： HashMap 实现的，无序。</li><li><a href="www.elgong.top"><strong>TreeSet</strong></a>：  HashMTree 实现的，有序。</li></ul></li><li><strong>Queue</strong> 接口： <ul><li><strong>Deque</strong> 接口：  <a href="www.elgong.top"><strong>LinkedList</strong></a></li></ul></li></ul></li><li><p><a href="http://zhuzhuyule.xyz" target="_blank" rel="noopener"><strong>Map</strong></a> 接口：key-value键值对的映射接口</p><ul><li><a href="http://zhuzhuyule.xyz" target="_blank" rel="noopener"><strong>HashMap</strong></a>：<em>数组+链表</em> 组成的哈希表，无序。</li><li><a href="http://zhuzhuyule.xyz" target="_blank" rel="noopener"><strong>TreeMap</strong></a>：基于 <em>红黑树的排序顺序</em> 存储键/值对，有序。</li><li><a href="http://zhuzhuyule.xyz" target="_blank" rel="noopener"><strong>Hashtable</strong></a>： HashMap类很相似，支持同步。</li></ul></li></ul><p><strong>两个工具类</strong>：</p><ul><li><strong>Arrays</strong></li><li><strong>Collections</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2020/01/01/Java-集合结构/集合.png&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;
&lt;p&gt;Java 集合类都在java.util包中，提供了如可变长数组，集合，队列，堆栈，链表等数据结构。&lt;br&gt;宏观上看整个结构可以分为两大部分： 属于单列集合C
      
    
    </summary>
    
      <category term="Java基础" scheme="http://www.elgong.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java集合" scheme="http://www.elgong.top/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础学习笔记</title>
    <link href="http://www.elgong.top/2019/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.elgong.top/2019/12/16/计算机基础学习笔记/</id>
    <published>2019-12-16T05:47:07.000Z</published>
    <updated>2020-04-21T02:41:32.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Computer-Basics-Notes-Links"><a href="#Computer-Basics-Notes-Links" class="headerlink" title="Computer-Basics-Notes-Links"></a>Computer-Basics-Notes-Links</h1><p><a href="https://github.com/elgong/Computer-Basics-Notes-Links" target="_blank" rel="noopener">github地址</a></p><h1 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h1><blockquote><p>我在学习计算机基础的过程中整理了一部分笔记，但都比较零散，有些稍微连贯的内容已经整理为博客，而大部分还没来得及整理成md格式，我先整理出链接。为了尽可能的清晰展示笔记脉络，下文将分门别类的列出，有需要请自取。<br>笔记内容大部分都是参考了网上的博客以及书籍，整理笔记的习惯也是刚刚养成的，从开始整理笔记后，发现自己对于做过的东西，能够随着笔记很快的回忆起来，遇到一些问题能够快速从笔记里找到答案也是比较舒服的。笔记是用有道云分享的，我未来仍然会继续梳理这些笔记，如果有任何的错误或者意见，麻烦您联系我哈。</p></blockquote><h2 id="第一章-计算机基础篇"><a href="#第一章-计算机基础篇" class="headerlink" title="第一章  计算机基础篇"></a>第一章  计算机基础篇</h2><blockquote><p>基础部分是一些语言相关的知识点。</p></blockquote><h3 id="1-1-Java-相关"><a href="#1-1-Java-相关" class="headerlink" title="1.1 Java 相关"></a>1.1 Java 相关</h3><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ul><li><a href="http://note.youdao.com/noteshare?id=f869167b77cb73b67478290ffdcf45bc&amp;sub=06694CB1F00B45CBA1D4BD1A4B62320C" target="_blank" rel="noopener">Java面向对象-多态</a></li></ul><h4 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h4><ul><li><p><a href="http://note.youdao.com/noteshare?id=def11ef6e833a11434137d6fec1c834a&amp;sub=DD0083BFCFE14839A721700413B41F38" target="_blank" rel="noopener">java.lang.Object 类</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=fb941f5b4a01adf474496df328542a91&amp;sub=02C7EDC387984E3BADE744B9280EA1E6" target="_blank" rel="noopener">java.lang.Integer等基本类型包装类</a></p></li></ul><h4 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h4><ul><li><p><a href="http://note.youdao.com/noteshare?id=7bdd684a91766f6b448e5328f1fed251&amp;sub=0DEE02584D22485EACF337D5F846ACCE0" target="_blank" rel="noopener">接口和抽象类的概念</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=eb3b5e1f37828c301015c1fcc48b2ee9&amp;sub=B77DF9D467AE48948C63CEE6D7B51FB5" target="_blank" rel="noopener">java.io.Serializable接口</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=af26732dc5f501e490a3f57c6b46333c&amp;sub=1E9132AF928342728B68D66845201D05" target="_blank" rel="noopener">java.lang.AbstractStringBuilder</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=62429dcbeb51676d855b0c46d89ea67b&amp;sub=7D9CC78E517B46A19C567A567DDA0C1E" target="_blank" rel="noopener">java.lang.CharSequence接口</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=4309c54f9e557075dc953a25a1e9aea4&amp;sub=4AF6A4102AD6494F884069B5F75DB663" target="_blank" rel="noopener">java.lang.Comparable 接口</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=d7525d979bbcfac0ad602e0f90124a39&amp;sub=9B8E20EC1E924C988EB9DEC3C059FE4F" target="_blank" rel="noopener">java.lang.Iterable 接口</a></p></li></ul><h4 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h4><ul><li><p><a href="http://note.youdao.com/noteshare?id=3f13ce83c60473cb2d03ac7d500b3771&amp;sub=77608E57EC404A3D925D5BADFABA9F0C" target="_blank" rel="noopener">Java集合的结构</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=8d5718ecf80ea7c1cd144c848afb556f&amp;sub=D12BF9FEA9B54873871F5BDC532FB46A" target="_blank" rel="noopener">java.util.Arrays工具类</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=55f2b8f2004cc365aa3200283f918642&amp;sub=373C38673F3D4233869F2FA181CF6C77" target="_blank" rel="noopener">java.util.Collections 工具类</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=2d1b0ca8f6ee80acab26bac64e65752b&amp;sub=BC00717F11EC48DBAA3187C99E27FB67" target="_blank" rel="noopener">集合类之间的转换</a></p></li></ul><h5 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h5><ul><li><p><a href="http://note.youdao.com/noteshare?id=cf4402932c37eeda65d2cb48b771fa85&amp;sub=38A358238D644B009E8D35E85BC3958A" target="_blank" rel="noopener">java.util.Collection 接口</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=35066dabdc8838cbf4a81a6064d3a278&amp;sub=B08F3371DAF94E0A8577E14A355948F7" target="_blank" rel="noopener">java.util.List 接口</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=ac00534071924ed6812c3087ff89522d&amp;sub=7CF204D01C2846469F874ABE719F122E" target="_blank" rel="noopener">java.util.ArrayList 类</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=24e53ad8811d97e37ae725caef30e87c&amp;sub=3580B9F523B14B9A8346594FAB7428B7" target="_blank" rel="noopener">java.util.LinkedList 类</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=3fefcc71bac40f731582cda7de9680a9&amp;sub=FD48F85901CA48C2A1FDBFB356072932" target="_blank" rel="noopener">java.util.Vector类-线程安全</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=7ca967ab85ba51315d576614e4debb88&amp;sub=D7FB8F63F9524697A2B6C92EBC997759" target="_blank" rel="noopener">java.util.Stack类-线程安全</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=e69b12c5f34e8999a63f901e66cf6349&amp;sub=378BBC5185DD4901949BA8D6CC586117" target="_blank" rel="noopener">java.util.Queue 接口</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=70bcfde9362d131a6cc9769df7c6a195&amp;sub=4CCDF46A03F64701B726C3B5B17EE5C7" target="_blank" rel="noopener">java.util.Deque 接口</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=a8e52263383bbff56bba83c4437e62a5&amp;sub=273730F39B6345348B400731471932CD" target="_blank" rel="noopener">java.util.ArrayDeque 类</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=d5807c6cbb3dfcd1c6a6fa2587f2a53a&amp;sub=8DB19EF833FF477C8241702AB6C728D4" target="_blank" rel="noopener">java.util.PriorityQueue 类</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=78367406564a757c47fbb5fd74ab4118&amp;sub=CD2FAD0FE2EE433EAFEB76285A06D389" target="_blank" rel="noopener">java.util.Set 接口</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=473ccb760a498a837a6fca3373b1f6d1&amp;sub=EF96DCB65AD1431BBCFBB52F21896643" target="_blank" rel="noopener">java.util.HashSet 类</a></p></li></ul><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><ul><li><p><a href="http://note.youdao.com/noteshare?id=8066dded44e4cba4a621fe78ed94c4a9&amp;sub=B9652D8B6D7940FFB5C92A5106BCC277" target="_blank" rel="noopener">java.util.Map 接口</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=de517d176afdc4e3d0c9887c437bee17&amp;sub=459B4CAF65FF4D67BFBE91DCED6E050E" target="_blank" rel="noopener">java.util.TreeMap 类</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=791e29ca757ab1dedb8f80d872c940b1&amp;sub=70D9B6BA82AF4889ACAD0A52F18C456D" target="_blank" rel="noopener">java.util.HashMap 类</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=473ccb760a498a837a6fca3373b1f6d1&amp;sub=EF96DCB65AD1431BBCFBB52F21896643" target="_blank" rel="noopener">java.util.HashSet 类</a></p></li></ul><h4 id="IO-模型与IO流"><a href="#IO-模型与IO流" class="headerlink" title="IO 模型与IO流"></a>IO 模型与IO流</h4><ul><li><p><a href="http://note.youdao.com/noteshare?id=658c32dde4ecf6c8525649914d0f8560&amp;sub=FF09583558E14D2BA25680647013CBA3" target="_blank" rel="noopener">标准步骤：</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=3dec994dd95a401eed7aabdfb1c5c15f&amp;sub=CAB6771BB0F044F895A705B8AB7514BC" target="_blank" rel="noopener">针对oj系统中的输入问题</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=1a496522d91fa47b4f3132aa97228ab7&amp;sub=CD032B0A9E714FE9ABB2BE05B49CEE75" target="_blank" rel="noopener">java IO之AutoCloseable接口</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=e496eb1243c65be077e6193400f6209d&amp;sub=5594861B9BE845BFAFB4BD14D7DE49D4" target="_blank" rel="noopener">IO篇1-Java IO模型</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=8ef12e2d0ce1d93b444eb430ba110fe3&amp;sub=B6822523990E474D869C822BFCD5DFB2" target="_blank" rel="noopener">IO篇2-Java NIO</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=2e291882966fc1b4d7f3efafdd39d32e&amp;sub=CE23D5FE57DC45709F74AFEB3A49F22E" target="_blank" rel="noopener">IO篇3-Java NIO 零拷贝</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=07cbfb2c33782cd85f62e05ff298740d&amp;sub=CC14B7D2EBB64930A3E7E8C4241EBD83" target="_blank" rel="noopener">IO篇4-Linux 内核的 select&amp;epoll</a></p></li></ul><h4 id="多线程与并发"><a href="#多线程与并发" class="headerlink" title="多线程与并发"></a>多线程与并发</h4><ul><li><p><a href="http://note.youdao.com/noteshare?id=b7407e24b468fd58df564afcbf749183&amp;sub=954EE84618B44B6FAFE4931E4F691873" target="_blank" rel="noopener">synchronized 锁的JVM中实现原理-偏向</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=0f69c79fd2c666de113882fd3ac72abf&amp;sub=61118765FB1F4B85B048C652460A5768" target="_blank" rel="noopener">线程的创建</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=49735f35157748a107270cb85fbb867c&amp;sub=0D34816A0AA24981B0B61EB87A64C8D4" target="_blank" rel="noopener">线程间的通信</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=12aac80f35ab764277a810af76852cb2&amp;sub=4A4D685F065F46B9B60D9703CEE04D29" target="_blank" rel="noopener">线程的生命周期</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=8d401fdafcc6c5712042fa06f6e3850b&amp;sub=96CD2BBFE5914F089493A803A5B7D020" target="_blank" rel="noopener">对象和变量的并发访问（可见性，原子性)</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=ed1aa8d1cf7688f52c1598735165a2dc&amp;sub=15233B8FCFFB4E11AC6167CE4BF4077E" target="_blank" rel="noopener">java.util.concurrent.locks包 </a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=291668d9a729451d6c913b3137c9640f&amp;sub=B28DDF08EC1F4457BFF740A9D8869FE5" target="_blank" rel="noopener">J.U.C多线程1-Executor 框架的梳理</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=5b0658b7d6383586ef61f9c80ef3d249&amp;sub=CE01D9FD424D45BCA78F88E1A0149C0D" target="_blank" rel="noopener">J.U.C多线程2-ThreadPoolExecutor线程</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=cb9e9ac4838bfdbb7e23f67711f2a84a&amp;sub=859FFFFB9E664A18BB2DBE355F094405" target="_blank" rel="noopener">实现BlockingQueue接口的阻塞队列</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=19714d2d692039c32ebba2ee3e4829e0&amp;sub=2F7585F44D7E4DBE84E9487A24766668" target="_blank" rel="noopener">J.U.C多线程3-CAS比较和交换 </a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=6a89441511d69a3bced7209ba47b736b&amp;sub=4A1DC26FB09D4E0C9D6086E37FDEAD6B" target="_blank" rel="noopener">J.U.C多线程3-AQS 同步器框架的梳理</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=4ef9100e71f2628636a4bff9b73fe882&amp;sub=7998ABD160384F36A606B72FB7493232" target="_blank" rel="noopener">J.U.C多线程4-AQS框架的应用</a></p></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p><a href="http://note.youdao.com/noteshare?id=d30458d5aac2da6b78824e51dbd982a5&amp;sub=1C451DD2DB6F4481AB58D42E0AA63C44" target="_blank" rel="noopener">泛型（泛型接口、泛型类、泛型方法）</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=d7092de3662bbf7b0d73b15313fbab0f&amp;sub=95A433A8DC2A4E6FBCF8B54D4767BC40" target="_blank" rel="noopener">字符串类型-String,StringBuilder</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=9b7abb4a2896be59b9ed6629d028a5c6&amp;sub=4C6D630F214D45DCA01450F1907C6266" target="_blank" rel="noopener">java 编码规范- google</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=a3af60be0ecf53e817c4954ab4b3f2dd&amp;sub=80F0D1E1017E4522B63882A48BE17CF2" target="_blank" rel="noopener">Java8- Lambda 表达式</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=29117a52793f44078077602c6f47252f&amp;sub=9B5D88DF10A94DCD968EA4C8263241C9" target="_blank" rel="noopener">动手实现ArrayList</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=893e0088e06c4e3cd1073a6abeb7bda4&amp;sub=AE4EBC77232149368BEFD526D435B452" target="_blank" rel="noopener">java 知识点梳理</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=2b866c01ebed8c2f6594e3357ae349be&amp;sub=AA305E3F95724374B5A3C5D96D654270" target="_blank" rel="noopener">Java 刷题遇到的问题</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=7c544d8a0a428eb5c142c36e771c5fac&amp;sub=1DE4594384FD444F9C705D73C3A26556" target="_blank" rel="noopener">基本数据类型and 初始化</a></p></li></ul><h4 id="jvm-虚拟机"><a href="#jvm-虚拟机" class="headerlink" title="jvm 虚拟机"></a>jvm 虚拟机</h4><ul><li><p><a href="http://note.youdao.com/noteshare?id=4be4640b0d30a46e8e4936fca48fc4da&amp;sub=E4ACF7E445F4469FB7C49A184325AA3A" target="_blank" rel="noopener">jvm1-内存模型-运行时数据区</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=044b5c8d572a50aa43f7476075feacd6&amp;sub=CB5ACEE22D7C4B119E920A983456E348" target="_blank" rel="noopener">jvm2-类加载机制</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=38a77fc1b5541c7443a42bb8936ad699&amp;sub=AC6273A6423A45D49DF9D7BA2C02D087" target="_blank" rel="noopener">jvm3-对象的创建过程</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=85b9df0570061425d77cd09d542758a3&amp;sub=C25619379B2547F5A492FB6900FA53F9" target="_blank" rel="noopener">jvm4-垃圾回收机制 </a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=3f927397764ecb9a72e25d53d1a8447e&amp;sub=DB8BF7AF904E4224A287A4B22D114460" target="_blank" rel="noopener">自定义类加载器实现热部署，热替换</a></p></li></ul><h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><ul><li><p><a href="http://note.youdao.com/noteshare?id=6f70c51df350a1da3b7353b5f0876ba1&amp;sub=A890AA4181A64A17B14D21040C1A9724" target="_blank" rel="noopener">反射</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=cfb346b9be695d57572367fd3143531e&amp;sub=DE178E988586406F87227AC75BD725CE" target="_blank" rel="noopener">Java 动态代理</a></p></li></ul><h3 id="1-2-数据库相关"><a href="#1-2-数据库相关" class="headerlink" title="1.2 数据库相关"></a>1.2 数据库相关</h3><h4 id="数据库的安装"><a href="#数据库的安装" class="headerlink" title="数据库的安装"></a>数据库的安装</h4><ul><li><p><a href="http://note.youdao.com/noteshare?id=eec529b536dfe09cbbb2d2305a9cec2c&amp;sub=DB98C14DBC15458ABE1B8461CD4C6988" target="_blank" rel="noopener">windwos 环境中 mysql 数据库安装</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=32e1a61698644f735e5ae33a0d285bee&amp;sub=WEB845b970c5cb400fcf42e04843dbd70af" target="_blank" rel="noopener">ubuntu 环境中 mysql 安装</a></p></li></ul><h4 id="学习笔记-1"><a href="#学习笔记-1" class="headerlink" title="学习笔记"></a>学习笔记</h4><ul><li><p><a href="http://note.youdao.com/noteshare?id=c98cc599b42b416ea2bd0aec7fd11fff&amp;sub=833E6D40B97E4F2F98EFD56C010FE4C7" target="_blank" rel="noopener">JDBC 使用</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=71dd174ad72a6cca26ae011637d4a705&amp;sub=E3BE9112006D4380953846BA1E446964" target="_blank" rel="noopener">mysql必知必会</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=4d74a6536781f195ffb428a0aa74fabe&amp;sub=9A407FE68AB54120B18950BEE5500BAF" target="_blank" rel="noopener">数据库-三大范式</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=78c16d370ba2bf4d06fd1d253072d582&amp;sub=6B15DEFDC24B4353A5820B68A5FB2C05" target="_blank" rel="noopener">数据库ER图基础</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=f0c534778c8fde528be10f4ffdb2c03b&amp;sub=336222838CDC4F249C1210E24D3701AD" target="_blank" rel="noopener">mysql必知必会1-DDL数据定义语言</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=360395368205af6b9cd43b67c17200af&amp;sub=3BAEE4ACEA0F4FC2A40AB4DC39965766" target="_blank" rel="noopener">mysql必知必会2-DML数据操作语句</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=3a8535b5bdf8fbe6b46b85a8f6ab707e&amp;sub=0C9D47245F604624A95E1982D45157F2" target="_blank" rel="noopener">mysql必知必会3-TCL事务控制语言</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=5a66c81500067c3bafc11fb31cc56cd6&amp;sub=6ADA92683A36438EB254D18AE729A6FA" target="_blank" rel="noopener">mysql必知必会4-数据类型和约束</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=8b1f73787548684951c21dea07576331&amp;sub=E95C55AAF40F4378B7A14176911B4B81" target="_blank" rel="noopener">mysql必知必会5-视图</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=d71e1773bdfb453b885ec8280980823e&amp;sub=B0AFAE28DCC94DF09AE25F420927921E" target="_blank" rel="noopener">mysql必知必会6-变量，存储过程，函数….</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=71dd174ad72a6cca26ae011637d4a705&amp;sub=E3BE9112006D4380953846BA1E446964" target="_blank" rel="noopener">mysql必知必会7</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=003c0cce526f2a71945614993d250377&amp;sub=56317DB968F04FE3BCC0D482D083C877" target="_blank" rel="noopener">索引优化1-索引的概念 </a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=a527e1fa83cc6b429814c2f8710b891c&amp;sub=9B9BDA5A138144B5A5A5E5C4BE6CE1D1" target="_blank" rel="noopener">索引优化2-Mysql索引的底层实现 </a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=f35d29b727ca3a228bfad4aac0a9e9e6&amp;sub=53F88FCDB69547E895DAD25A7D402035" target="_blank" rel="noopener">索引优化3- explain 查看执行计划 </a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=a83b6505ac7dbb6b3c69afd1860b8ccb&amp;sub=C419B2D7DA254E589E0F449A60544A1C" target="_blank" rel="noopener">Sql语句优化-查询截取分析 </a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=f8935a502a43186c1c821ad33ccc2c6d&amp;sub=5D286DE5F8304B8BA7290255DBF15C0C" target="_blank" rel="noopener">mysql-数据库锁的机制和原理 </a></p></li></ul><h3 id="1-3-计算机网络相关"><a href="#1-3-计算机网络相关" class="headerlink" title="1.3 计算机网络相关"></a>1.3 计算机网络相关</h3><ul><li><p><a href="http://note.youdao.com/noteshare?id=92e3adba9198d367e976bcc3f772d149&amp;sub=7F7B0D8B9F3E4D7996815384809C35EA" target="_blank" rel="noopener">互联网协议入门1-模型分层</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=8c41ad2717d4deee47f83841e49d755b&amp;sub=C0C042EE387F4A0096F427CE6F391887" target="_blank" rel="noopener">互联网协议入门2-访问网页的过程</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=e7f3f660c5df2335b7eccb7be89ce514&amp;sub=A775AFCC161A4388859120A340BDC6CB" target="_blank" rel="noopener">互联网协议入门3-TCP协议详细内容</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=71031b3ed61c6e8bd302a8577f6c396f&amp;sub=0F5DF1F408844E7184F3A6BB5F868F89" target="_blank" rel="noopener">互联网协议入门4-Http协议（应用层)</a></p></li></ul><h3 id="1-4-Python-相关"><a href="#1-4-Python-相关" class="headerlink" title="1.4 Python 相关"></a>1.4 Python 相关</h3><ul><li><p><a href="http://note.youdao.com/noteshare?id=398da3b52370f6976e9a67cb3be4cd24&amp;sub=WEBf9be5147ccbf73c569b46bb2a5ffe942" target="_blank" rel="noopener">Anaconda 使用</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=a813207158a22cfa902dbeba640bdf87&amp;sub=E61484FE7B0D4D999DF1A462FA780049" target="_blank" rel="noopener">python 性能优化</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=dde4ed2eb6eea6c45926d251689e3d4e&amp;sub=4A1EA0D89E634DEC9DD294C13012EFCA" target="_blank" rel="noopener">python 内存管理</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=9146e0886cac1bdaec8cce2e5081cfe0&amp;sub=060F7616DF954602BB641EC52D0F6110" target="_blank" rel="noopener">python 包管理</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=3724fe43398de6c5fbd75dd8c452987e&amp;sub=7837405EB49045FF8C22156022261A94" target="_blank" rel="noopener">知识积累</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=bfbf2eb0c5bccf64974fe260e1bdf131&amp;sub=A8906CE9DF0E47F19377CD49BF2DFA6F" target="_blank" rel="noopener">python 数据模型</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=0f7309f661031855b1e257072ceab9b9&amp;sub=E6CAEE5B6F7043779DF1F3A95923DC0F" target="_blank" rel="noopener">Set 集合  交并差运算</a></p></li></ul><h4 id="pandas-包"><a href="#pandas-包" class="headerlink" title="pandas 包"></a>pandas 包</h4><ul><li><p><a href="http://note.youdao.com/noteshare?id=f191fc11a263f303532d40c02c1f2161&amp;sub=3F6F9858E4DA4B7A9245F66557B15AB4" target="_blank" rel="noopener">pandas</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=64c2febf14a2e0f96bcbc868375500b9&amp;sub=0B21232330E442118F68ADFB44DECA6E" target="_blank" rel="noopener">pandas-1数据结构</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=7b8a86d71c5321171292fa000666efc8&amp;sub=A1102303D97F4E2D836A588F4882C5E2" target="_blank" rel="noopener">pandas-2索引和选择数据</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=02c6e6a9916d2f600153fa5402395c29&amp;sub=0CF2D73FB22140A29F3838CF6EF299B9" target="_blank" rel="noopener">pandas-分层和多级索引</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=b8d6c15c3d603261cee9b6771732c5a5&amp;sub=WEB9f17e5d4ecb0520c9c27c8145f3450dc" target="_blank" rel="noopener">pandas-4分组与聚合</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=57496ba2051b12d778ac17612d871354&amp;sub=62AE7AB578AF4B3A9D630676179C8CA0" target="_blank" rel="noopener">pandas-5缺失值处理</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=f16646b876ddb2c5ec482e316ca881dd&amp;sub=8024BDCE94B4455FA20514234C7233C0" target="_blank" rel="noopener">pandas-6重复值处理</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=5210591266c5f2472eab6bdb0e1adc7e&amp;sub=7B85239BB0C74343830F3EBBC34F43A0" target="_blank" rel="noopener">pandas-7时间处理</a></p></li></ul><h3 id="1-5-数据结构与算法相关"><a href="#1-5-数据结构与算法相关" class="headerlink" title="1.5 数据结构与算法相关"></a>1.5 数据结构与算法相关</h3><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul><li><p><a href="http://note.youdao.com/noteshare?id=77d45fd3df6dc9821a505972246afc67&amp;sub=CBBC8BE4E72147248464A2C136D8A893" target="_blank" rel="noopener">链表入门-单链表</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=2038af6c36c144a0005d3f7cb7cbd6e1&amp;sub=19BC0DEA04654C51970F77E363746D36" target="_blank" rel="noopener">双向链表</a></p></li></ul><h4 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h4><ul><li><p><a href="http://note.youdao.com/noteshare?id=3d87798249099424c8f688932e054d34&amp;sub=962de575938af485eb5896712a3fa88bhttp://note.youdao.com/noteshare?id=3d87798249099424c8f688932e054d34&amp;sub=962de575938af485eb5896712a3fa88b" target="_blank" rel="noopener">树结构1-二叉树的种类 </a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=a93bf51802eb22ed23e7f01baeecdfd9&amp;sub=C2561C42F8354E2787F3F58DC19CC2F5" target="_blank" rel="noopener">树结构2-二叉树的四种遍历</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=6595e3f3a04494d53c79ac4f14156b45&amp;sub=36364C54AB334D5B85B1871D6758FFF7" target="_blank" rel="noopener">树结构3- 二叉排序树 </a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=ff1c7f5f5c5439a5bcf29746bafacd8e&amp;sub=524DD42459CF4A43AB7CD89A74D83BAB" target="_blank" rel="noopener">树结构4- 完全二叉树-堆排序 </a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=28a1554677d3108539d237ed2dbfb3a9&amp;sub=6917ECACABFC4BE99B0840940E1492C3" target="_blank" rel="noopener">树结构5-红黑树 </a></p></li></ul><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul><li><a href="http://note.youdao.com/noteshare?id=32bb87989cc88c68f94b697a2309e577&amp;sub=CB4F1BAE4B48482B895E4B334EC920B7" target="_blank" rel="noopener">栈 - Stack</a></li></ul><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul><li><p><a href="http://note.youdao.com/noteshare?id=2bf63868f3e17320b15a68783a6f1d89&amp;sub=35032594A3AB441EB7DB3344B71213EF" target="_blank" rel="noopener">动态规划-DP</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=47da45a5509c7f21f5905c65ec87c12d&amp;sub=E525698B083343B382EFC767181A2755" target="_blank" rel="noopener">DFS和回溯算法- 暴力搜索的优化方案</a></p></li></ul><h4 id="一般算法"><a href="#一般算法" class="headerlink" title="一般算法"></a>一般算法</h4><ul><li><p><a href="http://note.youdao.com/noteshare?id=6139197ff7cc443d83b73f578ced01d2&amp;sub=3671B7672DA341359DF0C57DAA5114E3" target="_blank" rel="noopener">二分查找</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=417cd36012151f1465f6b179a68c2559&amp;sub=39B0B9975CC34C589CCCF7A4A619E921" target="_blank" rel="noopener">最大公约数与最小公倍数</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=b9bb5b1c7a7f968392ca087beb53a288&amp;sub=7AC07884471A4FFBAC433400CC8DD668" target="_blank" rel="noopener">素数和合数</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=900f90e3d481dcabbd5ce22df8452e4b&amp;sub=2A9F48EDC9824721A63091F213AE84DF" target="_blank" rel="noopener">排序算法-Java版</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=34e1f4c6bbc849e28017b14d1aa1ed3d&amp;sub=04B030FDEA424189A387F2B149670138" target="_blank" rel="noopener">蓄水池采样算法</a></p></li></ul><h3 id="1-6-设计模式"><a href="#1-6-设计模式" class="headerlink" title="1.6 设计模式"></a>1.6 设计模式</h3><ul><li><p><a href="http://note.youdao.com/noteshare?id=9b725da8bd83d6d2fa6628449036fa76&amp;sub=61D7D7C472CC4F6FA40978D2EEE3F253" target="_blank" rel="noopener">单例模式</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=3258d6710e66d885a3a213d45eea14be&amp;sub=9E8B81697FD248EDBAAB8B203ACDD4B9" target="_blank" rel="noopener">汇总 </a></p></li></ul><h2 id="第二章-计算机提高篇"><a href="#第二章-计算机提高篇" class="headerlink" title="第二章  计算机提高篇"></a>第二章  计算机提高篇</h2><blockquote><p>提高篇是一些具体的学习方向，我学的比较杂。</p></blockquote><h3 id="2-1-机器学习与数据挖掘"><a href="#2-1-机器学习与数据挖掘" class="headerlink" title="2.1 机器学习与数据挖掘"></a>2.1 机器学习与数据挖掘</h3><ul><li><a href="http://note.youdao.com/noteshare?id=a2a581480ef2d48c22c8972e2c1289ea&amp;sub=WEBe5a19e45418f24614a27d5c871dbeef6" target="_blank" rel="noopener">特征工程中的问题</a></li></ul><h4 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h4><ul><li><p><a href="http://note.youdao.com/noteshare?id=72d77f019bd4fc8cde5d77f1479213a3&amp;sub=3A0C8DB3DE554ED5B70179B18DEBDB6F" target="_blank" rel="noopener">决策树-1基本概念</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=6b4b7d196688d64889da3563eb4b194d&amp;sub=E48B826F34CB41769382CA5DD11DE54F" target="_blank" rel="noopener">决策树-2 ID3算法</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=51ba5d9d9611ae2284c2612d5f38b721&amp;sub=C40D67A492D4428EB698D146897932F2" target="_blank" rel="noopener">决策树-3 CART分类回归树</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=8fd42b53e1a611131199f17d399820c7&amp;sub=F7FA6EBCE1CC4A95875DD83B2CF9C551" target="_blank" rel="noopener">CART 分类回归树</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=d5d006e5d1680bb1b93f6cdc68973b60&amp;sub=C12A5DC3350C49CA8862D51287908CE4" target="_blank" rel="noopener">sklearn 决策树使用技巧</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=3a209c356ed655acacf08699cef27150&amp;sub=E0880A97A8264449BD714025A98BFE52" target="_blank" rel="noopener">sklearn整理-决策树</a></p></li></ul><h4 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h4><ul><li><a href="http://note.youdao.com/noteshare?id=d1d1a974ade3ab72cd8ff9fbab061e78&amp;sub=6C8F11DB78FA417AA9F4D0DA30351077" target="_blank" rel="noopener">常见的神经网络</a></li></ul><h4 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h4><ul><li><p><a href="http://note.youdao.com/noteshare?id=fb4b442794aac472bdd7663b026a2dab&amp;sub=939B2AAEB6F94E32ABAD4A54B8AF1358" target="_blank" rel="noopener">集成学习提升算法-Adaboost</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=eb03f9b12281363b052e0ed071833b13&amp;sub=WEBb2a9d589fb05754f76c2b2af09a826c1" target="_blank" rel="noopener">XGBoost -python package introduction</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=2039180d0a9ad5b39339c93e8c70040d&amp;sub=9C48D93E6A1E4C1186E6F37EF222F528" target="_blank" rel="noopener">梯度提升树-GBDT</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=e4ac54bae64eb94641594ad5f4a2cd6d&amp;sub=8232CAC65C0A4FDC9EDED033B6A4770F" target="_blank" rel="noopener">sklearn整理-集成学习-随机森林</a></p></li></ul><h4 id="模型评价"><a href="#模型评价" class="headerlink" title="模型评价"></a>模型评价</h4><ul><li><p><a href="http://note.youdao.com/noteshare?id=c76dbbe346dbd32a62cd4303f7bf4864&amp;sub=753D4CFE21084BA78B0506697A415A0C" target="_blank" rel="noopener">ROC与AUC</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=030f5d8884e6a0914891ebf2289318fa&amp;sub=28D75EDB51044316AB154021B0EB6BEA" target="_blank" rel="noopener">机器学习的方差与偏差</a></p></li></ul><h4 id="参与的一些竞赛"><a href="#参与的一些竞赛" class="headerlink" title="参与的一些竞赛"></a>参与的一些竞赛</h4><ul><li><a href="http://note.youdao.com/noteshare?id=1d8176b82fc84b0a3906fbd53979041c&amp;sub=305B25CE269F45DCA311DBE8C20DAF67" target="_blank" rel="noopener">ali-新人实战赛o2o优惠券使用预测</a></li></ul><ul><li><p><a href="http://note.youdao.com/noteshare?id=5b2fa1c8320743190649812b394b3ed5&amp;sub=27291314B2C74B09ABF8619277EE8A5E" target="_blank" rel="noopener">ccf-2019</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=52c517d38463d99b24672f0195ecabfe&amp;sub=WEBf24a84a951b3b16a0685ed029a28b960" target="_blank" rel="noopener">dc-2019-商品购买转化率预测</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=2fd9687a7cb8c10210bf738536dd8021&amp;sub=AE7E1B49101546F093C7C2B993A736A3" target="_blank" rel="noopener">竞赛提升方法-tricks</a></p></li></ul><ul><li><a href="http://note.youdao.com/noteshare?id=f43a977d8705582da02c202f295dadcc&amp;sub=74C22A94ABB74B309807A886F50A5863" target="_blank" rel="noopener">sklearn 脑图</a></li></ul><h3 id="2-2-大数据与Hadoop"><a href="#2-2-大数据与Hadoop" class="headerlink" title="2.2 大数据与Hadoop"></a>2.2 大数据与Hadoop</h3><h4 id="多台机器的分布式环境安装"><a href="#多台机器的分布式环境安装" class="headerlink" title="多台机器的分布式环境安装"></a>多台机器的分布式环境安装</h4><ul><li><a href="http://note.youdao.com/noteshare?id=e284c332fb9766d6487d925c4381ae22&amp;sub=E4980D34F8A347DC9C1E2C23C5A48D17" target="_blank" rel="noopener">1.hadoop分布式集群安装</a></li></ul><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><ul><li><a href="http://note.youdao.com/noteshare?id=773c4878eaec8cc266c5074691a3d780&amp;sub=68CE094D754C46CDA96C8CFA00401DF2" target="_blank" rel="noopener">Hadoop RPC</a></li></ul><h4 id="mapreduce-实验"><a href="#mapreduce-实验" class="headerlink" title="mapreduce 实验"></a>mapreduce 实验</h4><ul><li><p><a href="http://note.youdao.com/noteshare?id=710757567d678841cb43e891531c63b9&amp;sub=BA97FAC420754425A2FE07E67D6B6EAD" target="_blank" rel="noopener">实验1.  多表关联</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=7c251c3514764eb58fdad72de78bf6a5&amp;sub=FF9F53C4D1A04E008FA61A85A9CE0F01" target="_blank" rel="noopener">实验2.  最高温度统计</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=226bf0abd5e44ed6eae69f5250024bcf&amp;sub=5EE9A40650BB4AD2A661C65DFBC57FC5" target="_blank" rel="noopener">实验3.  单表关联</a></p></li></ul><h3 id="2-3-VUE"><a href="#2-3-VUE" class="headerlink" title="2.3 VUE"></a>2.3 VUE</h3><h4 id="VUE-安装"><a href="#VUE-安装" class="headerlink" title="VUE 安装"></a>VUE 安装</h4><ul><li><a href="http://note.youdao.com/noteshare?id=c60a733187bef04fa0404429eb2d1f30&amp;sub=3F4FE35DF8E349A395F8C4C19AA7BBE4" target="_blank" rel="noopener">开发环境搭建</a></li></ul><h3 id="2-4-Spring-框架"><a href="#2-4-Spring-框架" class="headerlink" title="2.4 Spring 框架"></a>2.4 Spring 框架</h3><ul><li><p><a href="http://note.youdao.com/noteshare?id=7181c4a539cade23a864c8e970b05833&amp;sub=771654DC28474896BAB711DD289A052C" target="_blank" rel="noopener">Spring-1控制反转（IOC）和依赖注入</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=32da7b7e487b45fd4fde7906fb9436a1&amp;sub=BAF8F0AE43DB42B399AC14B01FE74689" target="_blank" rel="noopener">Spring-2AOP 面向切面编程-基于动态代</a></p></li><li><p><a href="http://note.youdao.com/noteshare?id=2caa6adcf719adaba44ad57fcad131e4&amp;sub=8E30EF145E8A4972867B5476DF2DD607" target="_blank" rel="noopener">Spring-3事务管理Transaction Manager</a></p></li></ul><h2 id="第三章-工具使用"><a href="#第三章-工具使用" class="headerlink" title="第三章  工具使用"></a>第三章  工具使用</h2><ul><li><a href="http://note.youdao.com/noteshare?id=82f292615812b23fec6c7ce9fcc35ec4&amp;sub=6FC7D088767948388F03769F13A2C971" target="_blank" rel="noopener">vscode 使用记录</a></li></ul><h2 id="第四章-收藏的书籍"><a href="#第四章-收藏的书籍" class="headerlink" title="第四章  收藏的书籍"></a>第四章  收藏的书籍</h2><ul><li><a href="http://note.youdao.com/noteshare?id=57e1d26f1f078dc70a5b18392b29a841" target="_blank" rel="noopener">书籍收藏</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Computer-Basics-Notes-Links&quot;&gt;&lt;a href=&quot;#Computer-Basics-Notes-Links&quot; class=&quot;headerlink&quot; title=&quot;Computer-Basics-Notes-Links&quot;&gt;&lt;/a&gt;Compu
      
    
    </summary>
    
      <category term="计算机基础梳理" scheme="http://www.elgong.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/"/>
    
    
      <category term="学习笔记" scheme="http://www.elgong.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>决策树2-ID3算法</title>
    <link href="http://www.elgong.top/2019/09/12/%E5%86%B3%E7%AD%96%E6%A0%912-ID3%E7%AE%97%E6%B3%95/"/>
    <id>http://www.elgong.top/2019/09/12/决策树2-ID3算法/</id>
    <published>2019-09-12T11:04:01.000Z</published>
    <updated>2020-02-20T04:41:37.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="决策树-2-ID3算法"><a href="#决策树-2-ID3算法" class="headerlink" title="决策树-2 ID3算法"></a>决策树-2 ID3算法</h1><blockquote><p>决策树-1基本概念中已经提到了ID3算法，这篇博客再梳理一遍，算法描述部分搬运了统计学习方法的内容，更详细内容可以参考这本书。</p></blockquote><h3 id="ID3-算法的思路"><a href="#ID3-算法的思路" class="headerlink" title="ID3 算法的思路"></a>ID3 算法的思路</h3><ul><li>输入：训练集 <code>D</code>, 特征集 <code>A</code>， 阈值 <code>ε</code>；</li><li>分叉：最优属性划分依据是<font color="#FF0000"> 最大信息增益；</font> </li><li>结束条件：用完所有特征，特征信息增益很小，树的深度超过限制；</li><li>返回：一颗树<code>T</code>。</li></ul><h3 id="ID3-算法描述"><a href="#ID3-算法描述" class="headerlink" title="ID3 算法描述"></a>ID3 算法描述</h3><blockquote><p>这里的描述可作为编程实现时的指导，树的建立过程是递归实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ID3Tree</span><span class="params">(D, A，ε )</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>  D 的实例属于同类别 K ||  特征集 A 特征空:</span><br><span class="line">    </span><br><span class="line">        <span class="number">1.</span> 决策树 T为单结点树</span><br><span class="line">        <span class="number">2.</span> 标记类别 K (数量最多的类别)</span><br><span class="line">        <span class="keyword">return</span>  T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="number">1.</span> 计算所有特征相对于 D 的信息增益</span><br><span class="line">        <span class="number">2.</span> 找到信息增益最大特征 Amax</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> Amax  小于 阈值 ε:</span><br><span class="line">            <span class="number">1.</span> 决策树 T为单结点树</span><br><span class="line">            <span class="number">2.</span> 标记类别 K (数量最多的类别)</span><br><span class="line">            <span class="keyword">return</span>  T</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            依照特征 Amax 的每一个取值 ai，划分数据集Di, 并且标记Di类别，构建子节点</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 递归</span></span><br><span class="line">            对每个结点Di，以Di为训练集， A-Amax为特征集，递归调用 ID3Tree()</span><br><span class="line">            <span class="keyword">return</span> 由结点和子结点构成的树</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;决策树-2-ID3算法&quot;&gt;&lt;a href=&quot;#决策树-2-ID3算法&quot; class=&quot;headerlink&quot; title=&quot;决策树-2 ID3算法&quot;&gt;&lt;/a&gt;决策树-2 ID3算法&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;决策树-1基本概念中已经提到了ID3算法，
      
    
    </summary>
    
      <category term="机器学习方法" scheme="http://www.elgong.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="ID3" scheme="http://www.elgong.top/tags/ID3/"/>
    
  </entry>
  
  <entry>
    <title>决策树3-CART分类回归树</title>
    <link href="http://www.elgong.top/2019/09/12/%E5%86%B3%E7%AD%96%E6%A0%913-CART%E5%88%86%E7%B1%BB%E5%9B%9E%E5%BD%92%E6%A0%91/"/>
    <id>http://www.elgong.top/2019/09/12/决策树3-CART分类回归树/</id>
    <published>2019-09-12T10:58:19.000Z</published>
    <updated>2020-02-20T04:41:37.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CART-分类回归树"><a href="#CART-分类回归树" class="headerlink" title="CART-分类回归树"></a>CART-分类回归树</h1><h3 id="CART-算法的思路"><a href="#CART-算法的思路" class="headerlink" title="CART 算法的思路"></a>CART 算法的思路</h3><blockquote><p>特征选择：最优属性划分依据是<font color="#FF0000"> 基尼系数（分类）/平方误差（回归）；</font> </p><p>CART 树是二叉树结构。</p></blockquote><p>主要就两步骤：</p><ol><li>树的生成 </li><li>树的剪枝</li></ol><h3 id="分类树"><a href="#分类树" class="headerlink" title="分类树"></a>分类树</h3><blockquote><p>分类树与ID3, C4.5的流程一致。</p></blockquote><h3 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h3><blockquote><p>回归树选择最佳划分属性和划分点时的依据是 <code>平方误差</code>。</p></blockquote><p>一张图即可理解。</p><p><img src="/2019/09/12/决策树3-CART分类回归树/CART.png" alt="logo"></p><p>与分类树的主要区别是选择最佳属性的评价指标变了。根据最小化均方误差的原则选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CART-分类回归树&quot;&gt;&lt;a href=&quot;#CART-分类回归树&quot; class=&quot;headerlink&quot; title=&quot;CART-分类回归树&quot;&gt;&lt;/a&gt;CART-分类回归树&lt;/h1&gt;&lt;h3 id=&quot;CART-算法的思路&quot;&gt;&lt;a href=&quot;#CART-算法的思路&quot;
      
    
    </summary>
    
      <category term="机器学习方法" scheme="http://www.elgong.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="CART树" scheme="http://www.elgong.top/tags/CART%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>pandas-8分层和多级索引</title>
    <link href="http://www.elgong.top/2019/08/13/pandas-%E5%88%86%E5%B1%82%E5%92%8C%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95/"/>
    <id>http://www.elgong.top/2019/08/13/pandas-分层和多级索引/</id>
    <published>2019-08-13T02:54:12.000Z</published>
    <updated>2020-02-20T04:41:37.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pandas-8-分层和多级索引"><a href="#pandas-8-分层和多级索引" class="headerlink" title="pandas -8 分层和多级索引"></a>pandas -8 分层和多级索引</h1><blockquote><p>Multi-level indexing. 在 “<a href="http://www.elgong.top/2019/07/25/pandas-%E7%B4%A2%E5%BC%95%E5%92%8C%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE/">pandas -2 索引和选择数据</a>” 一节中, 已经提到了如何选择行列元素, 而Series 和 Dataframe 是低维度的数据结构，对于更高维度的数据，可以通过分层和多级索引来实现。</p></blockquote><h2 id="分层索引的创建"><a href="#分层索引的创建" class="headerlink" title="分层索引的创建"></a>分层索引的创建</h2><blockquote><p>创建分层索引的方式有很多, 这里直接摘抄自官方的文档，可以通过元组，列表，Dataframe, arrays 等方式生成分层索引。</p><p>同时要知道，通过 groupby 分组操作之后得到的也是这种分层结构。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    //  1. 元组</span><br><span class="line">In: </span><br><span class="line"></span><br><span class="line">    arrays = [[&apos;bar&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;baz&apos;, &apos;foo&apos;, &apos;foo&apos;,&apos;qux&apos;, &apos;qux&apos;], [&apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;]]</span><br><span class="line">    tuples = list(zip(*arrays))</span><br><span class="line">Out: </span><br><span class="line">    [(&apos;bar&apos;, &apos;one&apos;),</span><br><span class="line">     (&apos;bar&apos;, &apos;two&apos;),</span><br><span class="line">     (&apos;baz&apos;, &apos;one&apos;),</span><br><span class="line">     (&apos;baz&apos;, &apos;two&apos;),</span><br><span class="line">     (&apos;foo&apos;, &apos;one&apos;),</span><br><span class="line">     (&apos;foo&apos;, &apos;two&apos;),</span><br><span class="line">     (&apos;qux&apos;, &apos;one&apos;),</span><br><span class="line">     (&apos;qux&apos;, &apos;two&apos;)]</span><br><span class="line"></span><br><span class="line">In:</span><br><span class="line">    index = pd.MultiIndex.from_tuples(tuples, names=[&apos;first&apos;, &apos;second&apos;])</span><br><span class="line">    df = pd.Series(np.random.randn(8), index=index)</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">    first  second</span><br><span class="line">    bar    one       0.469112</span><br><span class="line">           two      -0.282863</span><br><span class="line">    baz    one      -1.509059</span><br><span class="line">           two      -1.135632</span><br><span class="line">    foo    one       1.212112</span><br><span class="line">           two      -0.173215</span><br><span class="line">    qux    one       0.119209</span><br><span class="line">           two      -1.044236</span><br><span class="line">    dtype: float64</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 2. dataftame</span><br><span class="line">    </span><br><span class="line">    index = pd.MultiIndex.from_frame(df)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 3. arrays</span><br><span class="line">    </span><br><span class="line">In: </span><br><span class="line">    arrays = [np.array([&apos;bar&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;baz&apos;, &apos;foo&apos;, &apos;foo&apos;, &apos;qux&apos;, &apos;qux&apos;]),</span><br><span class="line">              np.array([&apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;])]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     s = pd.Series(np.random.randn(8), index=arrays)</span><br></pre></td></tr></table></figure><h2 id="从DataFrame-产生-MultiIndex"><a href="#从DataFrame-产生-MultiIndex" class="headerlink" title="从DataFrame 产生 MultiIndex"></a>从DataFrame 产生 MultiIndex</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = df.set_index([&apos;col1&apos;,&apos;col2&apos;])</span><br></pre></td></tr></table></figure><h2 id="MultiIndex-转化成-列"><a href="#MultiIndex-转化成-列" class="headerlink" title="MultiIndex 转化成 列"></a>MultiIndex 转化成 列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = df.reset_index()</span><br></pre></td></tr></table></figure><h2 id="选择不同层"><a href="#选择不同层" class="headerlink" title="选择不同层"></a>选择不同层</h2><blockquote><p>查看不同层的索引值。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In:</span><br><span class="line">    index.get_level_values(0)</span><br><span class="line">    </span><br><span class="line">    index.get_level_values(&quot;name&quot;)</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">    Index([&apos;bar&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;baz&apos;, &apos;foo&apos;, &apos;foo&apos;, &apos;qux&apos;, &apos;qux&apos;], dtype=&apos;object&apos;, name=&apos;first&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>根据不同层索引</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df[&quot;bar&quot;]</span><br><span class="line">df[&quot;one&quot;]</span><br><span class="line">df[&quot;bar&quot;][&quot;one&quot;]</span><br><span class="line"></span><br><span class="line">// 元组</span><br><span class="line">df.loc[(&apos;bar&apos;, &apos;two&apos;)]</span><br></pre></td></tr></table></figure><font color="0xff111">  注意, 切片时不会改变 多层索引。 </font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pandas-8-分层和多级索引&quot;&gt;&lt;a href=&quot;#pandas-8-分层和多级索引&quot; class=&quot;headerlink&quot; title=&quot;pandas -8 分层和多级索引&quot;&gt;&lt;/a&gt;pandas -8 分层和多级索引&lt;/h1&gt;&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="pandas系列教程" scheme="http://www.elgong.top/categories/pandas%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="pandas-MultiIndex" scheme="http://www.elgong.top/tags/pandas-MultiIndex/"/>
    
  </entry>
  
  <entry>
    <title>mysql-索引篇2-索引的底层实现</title>
    <link href="http://www.elgong.top/2019/08/12/mysql-%E7%B4%A2%E5%BC%95%E7%AF%872-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.elgong.top/2019/08/12/mysql-索引篇2-索引的底层实现/</id>
    <published>2019-08-12T03:02:57.000Z</published>
    <updated>2020-04-11T03:09:33.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、常用的索引底层结构有哪些？"><a href="#一、常用的索引底层结构有哪些？" class="headerlink" title="一、常用的索引底层结构有哪些？"></a>一、常用的索引底层结构有哪些？</h1><p>==<strong>索引是一种排序的，便于查找的数据结构。</strong>==</p><p>下面是一些常见数据结构的概念，具体每种类型的详细特点，再去看别的文档吧。</p><h2 id="1-二叉查找树："><a href="#1-二叉查找树：" class="headerlink" title="1. 二叉查找树："></a><strong>1. 二叉查找树：</strong></h2><p>​        左子树的键值小于根的键值，右子树的键值大于根的键值。</p><h2 id="2-AVL-树："><a href="#2-AVL-树：" class="headerlink" title="2. AVL 树："></a><strong>2. AVL 树：</strong></h2><p>​       平衡二叉树（AVL 树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为 1。</p><h2 id="3-红黑树："><a href="#3-红黑树：" class="headerlink" title="3. 红黑树："></a><strong>3. 红黑树：</strong></h2><p>​      每个节点都带有颜色属性的二叉查找树。</p><h2 id="4-平衡多路查找树（M阶的-B树）："><a href="#4-平衡多路查找树（M阶的-B树）：" class="headerlink" title="4. 平衡多路查找树（M阶的 B树）："></a><strong>4. 平衡多路查找树（M阶的 B树）：</strong></h2><h2 id="为磁盘等外存储设备设计的一种平衡查找树。"><a href="#为磁盘等外存储设备设计的一种平衡查找树。" class="headerlink" title="为磁盘等外存储设备设计的一种平衡查找树。"></a><strong>为磁盘等外存储设备设计的一种平衡查找树。</strong></h2><ul><li>每个节点最多有<strong>m-1个关键字</strong>（可以存有的键值对）。</li><li>根节点最少可以只有1个<strong>关键字</strong>。</li><li>非根节点至少有m/2个<strong>关键字</strong>。</li><li>每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li><li>所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。</li><li>==<strong>每个节点都存有索引和数据，也就是对应的key和value。</strong>==</li><li>==<strong>数据库中的节点 value 其实是指针。。</strong>==</li></ul><h2 id="5-B-树："><a href="#5-B-树：" class="headerlink" title="5. B+树："></a><strong>5. B+树：</strong></h2><p>B+树其实和B树是非常相似的，我们首先看看<strong>相同点</strong>。</p><ul><li>根节点至少一个元素</li><li>非根节点元素范围：m/2 &lt;= k &lt;= m-1</li></ul><p><strong>不同点</strong>：</p><ul><li>B+树有两种类型的节点：==<strong>内部节点不存储数据，只存储索引，数据都存储在叶子节点。</strong>==</li><li>内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。<strong>叶子结点中的记录也按照key的大小排列</strong>。</li><li>每个叶子结点都存有相邻叶子结点的指针，<strong>叶子结点本身依关键字的大小自小而大顺序链接。</strong></li><li><strong>父节点存有右孩子的第一个元素的索引</strong>。</li></ul><p><img src="https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/35C585A0A1CA45A48325427D3856F495/25313" alt="img"></p><h1 id="二、Mysql-的两种存储引擎的索引"><a href="#二、Mysql-的两种存储引擎的索引" class="headerlink" title="二、Mysql 的两种存储引擎的索引"></a>二、Mysql 的两种存储引擎的索引</h1><p>文档主要介绍 MyISAM 和 InnoDB 两个存储引擎的索引实现方式。 两者均使用的B+ 树实现的索引。</p><h2 id="2-1-InnoDB索引实现"><a href="#2-1-InnoDB索引实现" class="headerlink" title="2.1 InnoDB索引实现"></a><strong>2.1 InnoDB索引实现</strong></h2><h3 id="1）主键索引（聚簇索引，B-树）："><a href="#1）主键索引（聚簇索引，B-树）：" class="headerlink" title="1）主键索引（聚簇索引，B+树）："></a><strong>1）主键索引（聚簇索引，B+树）：</strong></h3><p>   <strong>主键默认采用聚簇索引</strong>（聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致），且一张表只允许存在一个聚簇索引。</p><p>​        ==<strong>聚簇索引的叶子节点就是数据节点（存放完整的行数据）</strong>==</p><p>​        ==<strong>非聚簇索引</strong>的叶子节点保存<strong>非完整行的数据</strong>（只有对应的键值数据） + <strong>书签</strong>（主键的聚集索引的索引值）==</p><p>​        叶子节点是<strong>数据页(默认16K)</strong>。==每个数据页上存放的是完整的行记录。B+ 树将 叶子页加载到内存后，再去查找对应数据行。==</p><p>​        非叶子节点、存放的仅仅是键值及指向数据页的偏移量</p><p><strong>聚集索引的好处：</strong></p><ul><li>对于<strong>主键的排序查找非常的快</strong>（因为其叶子节点是用双向链表链接的）</li><li><p>对于<strong>主键的范围查找非常的快</strong>（因为通过叶子节点的上层中间节点，就可以得到叶结点的范围值）</p><p> <strong>在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构</strong>，**这棵树的叶节点data域保存了完整的数据记录。索引的key是数据表的主键（primary key），因此InnoDB表数据文件本身就是主索引。</p></li></ul><p><img src="https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/0C52AD61056947BFB3ADB363A745E21E/25366" alt="img"></p><p><strong>InnoDB存储引擎的最小存储单元是页(16K)</strong>，页可以用于存放数据也可以用于存放键值+指针, <strong>在InnoDB中B+树高度一般为1-3层</strong>，<strong>它就能满足千万级的数据存储</strong>。在查找数据时一次页的查找代表一次IO，所以通过<strong>主键索引查询通常只需要1-3次IO操作即可查找到数据</strong>。</p><p><strong>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有）</strong>，如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><h3 id="2）InnoDB的辅助索引（非聚簇索引，B-树-B树）"><a href="#2）InnoDB的辅助索引（非聚簇索引，B-树-B树）" class="headerlink" title="2）InnoDB的辅助索引（非聚簇索引，B+树/ B树）"></a><strong>2）InnoDB的辅助索引（非聚簇索引，B+树/ B树）</strong></h3><p><strong>B+树：</strong></p><p><strong>非聚簇索引</strong>的叶子节点保存<strong>非完整行的数据</strong>（只有对应的键值数据） + <strong>书签</strong>（主键的聚集索引的索引值）</p><p><strong>二级索引使用非聚簇索引。</strong></p><p><strong>通过二级索引查询首先，查到是主键值和对应的数据字段，如果查询的字段更多，InnoDB再根据查到的主键值通过主键索引找到相应的数据块。</strong>（ 这个流程叫 <strong>回表</strong>）</p><p><strong>B树：覆盖索引用到的。</strong></p><p>InnoDB 表是基于<strong>聚簇索引</strong>建立的。因此InnoDB 的索引能提供一种非常快速的主键查找性能。它的辅助索引（Secondary Index， 也就是非主键索引）也会包含主键列，所以，如果主键定义的比较大，其他索引也将很大。如果想在表上定义 、很多索引，则<strong>争取尽量把主键定义得小一些</strong>。InnoDB 不会压缩索引。</p><p>   文字符的ASCII码作为比较准则。<strong>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录</strong>。</p><p><img src="https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/FD856A9A723440D296A95C46A86E1431/25390" alt="img"></p><p><strong>1、为什么不建议使用过长的字段作为主键？</strong></p><p><strong>因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。</strong></p><p><strong>2、用非单调的字段作为主键在InnoDB中不是个好主意？</strong></p><p><strong>因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效。</strong></p><h2 id="2-2-MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。"><a href="#2-2-MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。" class="headerlink" title="2.2  MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。"></a><strong>2.2  MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</strong></h2><p>MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</p><h3 id="1）主键索引（非聚簇索引，B-树）："><a href="#1）主键索引（非聚簇索引，B-树）：" class="headerlink" title="1）主键索引（非聚簇索引，B+树）："></a><strong>1）主键索引（非聚簇索引，B+树）：</strong></h3><p>MyISAM引擎使用B+Tree作为索引结构，<strong>叶节点的data域存放的是数据记录的地址</strong>。下图是MyISAM主键索引的原理图：</p><p><img src="https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/B431C4572E464F8B9E410C3F74685439/25416" alt="img"></p><h3 id="2）辅助索引（Secondary-key）"><a href="#2）辅助索引（Secondary-key）" class="headerlink" title="2）辅助索引（Secondary key）"></a><strong>2）辅助索引（Secondary key）</strong></h3><p><strong>在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求</strong> <strong>key是唯一</strong>，而辅助索引的key可以重复。</p><p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，<strong>MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</strong></p><p>MyISAM的索引方式也叫做“<strong>非聚簇</strong>”的，之所以这么称呼是为了与InnoDB的聚簇索引区分。</p><h1 id="三、为什么说B-树比B树更适合数据库索引？"><a href="#三、为什么说B-树比B树更适合数据库索引？" class="headerlink" title="三、为什么说B+树比B树更适合数据库索引？"></a>三、为什么说B+树比B树更适合数据库索引？</h1><p><strong>1、 B+树的磁盘读写代价更低</strong>：B+树的内部节点并没有指向关键字具体信息的指针，因此<strong>其内部节点相对B树更小</strong>，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，<strong>一次性读入内存的需要查找的关键字也就越多</strong>，相对IO读写次数就降低了。<strong>（B 树 非叶子节点中还包含了数据指针，所以占空间大）</strong></p><p><strong>2、B+树的查询效率更加稳定（数据都存在叶子节点，路径都是从根到叶子的路径，一般3次以下的IO读取，等于树的高度）</strong></p><p>B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少），指针少的情况下要保存大量数据，<strong>只能增加树的高度，导致IO操作变多</strong>，查询性能变低；</p><p><strong>3、由于B+树的数据都存储在叶子结点中，非叶子点均为索引，**</strong>方便全盘扫描和范围查找。**</p><p>但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，<strong>需要进行一次中序遍历按序来扫</strong>，所以<strong>B+树更加适合在区间查询的情况</strong>，所以通常B+树用于数据库索引。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、常用的索引底层结构有哪些？&quot;&gt;&lt;a href=&quot;#一、常用的索引底层结构有哪些？&quot; class=&quot;headerlink&quot; title=&quot;一、常用的索引底层结构有哪些？&quot;&gt;&lt;/a&gt;一、常用的索引底层结构有哪些？&lt;/h1&gt;&lt;p&gt;==&lt;strong&gt;索引是一种排序的
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.elgong.top/categories/mysql/"/>
    
    
      <category term="数据库索引" scheme="http://www.elgong.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
</feed>
