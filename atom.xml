<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>elgong&#39;s Home.</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.elgong.top/"/>
  <updated>2020-04-19T09:22:22.530Z</updated>
  <id>http://www.elgong.top/</id>
  
  <author>
    <name>elgong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>蓄水池抽样算法</title>
    <link href="http://www.elgong.top/2020/04/19/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95/"/>
    <id>http://www.elgong.top/2020/04/19/蓄水池抽样算法/</id>
    <published>2020-04-19T09:18:21.000Z</published>
    <updated>2020-04-19T09:22:22.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、预备知识"><a href="#一、预备知识" class="headerlink" title="一、预备知识"></a>一、预备知识</h1><p>Java 随机数生成的方法：</p><p><code>java.util.Random</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Main.java </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Random random = <span class="keyword">new</span> Random(<span class="number">2048</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成 0 ~ 99 之间的整数</span></span><br><span class="line">        System.out.println( random.nextInt(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成 0 ~ 1.0 之间的小数</span></span><br><span class="line">        System.out.println( random.nextDouble());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成 布尔</span></span><br><span class="line">        System.out.println( random.nextBoolean());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、采样需求"><a href="#二、采样需求" class="headerlink" title="二、采样需求"></a>二、采样需求</h1><p>从固定区间内随机采样数据十分简单，直接调用 <code>random.nextInt()</code> 就可以。</p><p><strong>但如果是长度未知的海量数据流呢？该如何实现等概率采样？</strong></p><p>​        答：蓄水池采样算法就是一种解决方案。</p><h1 id="三、实现原理（从未知长度的海量数据随机采样K个元素）"><a href="#三、实现原理（从未知长度的海量数据随机采样K个元素）" class="headerlink" title="三、实现原理（从未知长度的海量数据随机采样K个元素）"></a>三、实现原理（从未知长度的海量数据随机采样K个元素）</h1><h2 id="3-1-举例说明：从未知流中随机选择一个元素-K-1-的实现方法"><a href="#3-1-举例说明：从未知流中随机选择一个元素-K-1-的实现方法" class="headerlink" title="3.1 举例说明：从未知流中随机选择一个元素(K = 1)的实现方法"></a>3.1 <strong>举例说明：从未知流中随机选择一个元素(K = 1)的实现方法</strong></h2><ul><li><strong>当数据流中只有一个数据</strong>：<ul><li>直接返回该数据</li></ul></li><li><strong>当数据流中有两个数据</strong>：<ul><li>D0，D1 中随机选择一个。 概率均为 1/2</li></ul></li><li><strong>当数据流中有三个数据</strong><ul><li>Step1 : 处理 D0, D1 时 先保留一个，概率分别为 1/2</li><li>Step2 :处理 D3 时, 1/3 的概率保留D3, 1 - 1/3 的概率保留 Step1 中的结果</li></ul></li><li><strong>递推下去</strong>      </li></ul><h2 id="3-2-解析：假设流的长度只有3"><a href="#3-2-解析：假设流的长度只有3" class="headerlink" title="3.2 解析：假设流的长度只有3"></a>3.2 <strong>解析：假设流的长度只有3</strong></h2><p>数据 D1 被采样概率：（1/2）<em> (2/3) = 1/3<br>数据 D2 被采样概率：（1/2）</em>(2/3) = 1/3<br>数据 D3 被采样概率：  1/3</p><h2 id="3-3-算法描述"><a href="#3-3-算法描述" class="headerlink" title="3.3 算法描述"></a>3.3 算法描述</h2><ul><li>先选取数据流中的前k个元素，保存在池子pool中；</li><li>从第j（k + 1 &lt;= j &lt;= n）个元素开始<ul><li>每次先以概率 p = k/j选择是否让第j个元素留下；<ul><li>若j被选中，则从A中随机选择一个元素并用该元素j替换它</li><li>否则直接淘汰该元素；</li></ul></li></ul></li><li>重复步骤2直到结束，最后集合A中剩下的就是保证随机抽取的k个元素。</li></ul><h1 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private int[] sampling(int K) &#123;</span><br><span class="line">    int[] pool = new int[K];</span><br><span class="line">    </span><br><span class="line">    // 前 K 个元素直接放入数组中</span><br><span class="line">    for (int i = 0; i &lt; K; i++) &#123; </span><br><span class="line">        pool[i] = stream[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = K; i &lt; N; i++) &#123; // K + 1 个元素开始进行概率采样</span><br><span class="line">        int r = random.nextInt(i + 1);</span><br><span class="line">        // 这里其实就是k/j的体现</span><br><span class="line">        if (r &lt; K) &#123;</span><br><span class="line">            pool[r] = stream[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、leetcode-题目："><a href="#五、leetcode-题目：" class="headerlink" title="五、leetcode 题目："></a>五、leetcode 题目：</h1><p><a href="https://leetcode-cn.com/problems/random-pick-index/" target="_blank" rel="noopener">T1. 随机数索引</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 蓄水池算法：</span></span><br><span class="line"><span class="comment">    只对重复值采用蓄水池算法</span></span><br><span class="line"><span class="comment">    出现次数     概率</span></span><br><span class="line"><span class="comment">    1            1</span></span><br><span class="line"><span class="comment">    2            1/2</span></span><br><span class="line"><span class="comment">    3            1/3</span></span><br><span class="line"><span class="comment">    4            1/4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = getIndex(nums, target);</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 统计出现的次数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (target == nums[i])&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (index == -<span class="number">1</span>)&#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> r = random.nextInt(count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>)&#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/linked-list-random-node/" target="_blank" rel="noopener">T2. 链表中随机选择节点</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@param</span> head The linked list's head.</span></span><br><span class="line"><span class="comment">        Note that the head is guaranteed to be not null, so it contains at least one node. */</span></span><br><span class="line">    <span class="keyword">private</span> ListNode head;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns a random node's value. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        ListNode now = head;</span><br><span class="line">        <span class="keyword">int</span> ret = -<span class="number">1</span>;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (now != <span class="keyword">null</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ret == -<span class="number">1</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                ret = now.val;</span><br><span class="line">                now = now.next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> rm = random.nextInt(count );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rm == <span class="number">0</span>)&#123;</span><br><span class="line">                ret =  now.val;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            now = now.next;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、预备知识&quot;&gt;&lt;a href=&quot;#一、预备知识&quot; class=&quot;headerlink&quot; title=&quot;一、预备知识&quot;&gt;&lt;/a&gt;一、预备知识&lt;/h1&gt;&lt;p&gt;Java 随机数生成的方法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java.util.Random&lt;/code&gt;&lt;/p
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://www.elgong.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="蓄水池抽样算法 海量数据随机采样" scheme="http://www.elgong.top/tags/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%9A%8F%E6%9C%BA%E9%87%87%E6%A0%B7/"/>
    
  </entry>
  
  <entry>
    <title>mysql-必知必会7-综合内容</title>
    <link href="http://www.elgong.top/2020/04/11/mysql-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A7-%E7%BB%BC%E5%90%88%E5%86%85%E5%AE%B9/"/>
    <id>http://www.elgong.top/2020/04/11/mysql-必知必会7-综合内容/</id>
    <published>2020-04-11T03:35:36.000Z</published>
    <updated>2020-04-11T04:08:35.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、关系型数据库Mysql"><a href="#一、关系型数据库Mysql" class="headerlink" title="一、关系型数据库Mysql"></a><strong>一、关系型数据库Mysql</strong></h1><p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。</p><ul><li><strong>数据库:</strong> 数据库是一些关联表的集合。.</li><li><strong>数据表:</strong> 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li><li><strong>列:</strong> 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。</li><li><strong>行：</strong>一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</li><li><strong>冗余</strong>：存储两倍数据，冗余可以使系统速度更快。</li><li><strong>主键</strong>：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li><li><strong>外键：</strong>外键用于关联两个表。</li><li><strong>复合键</strong>：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li><li><strong>索引：</strong>使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li><li><p><strong>参照完整性:</strong> 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性</p></li><li><p><strong>主键: 表示特定行.</strong></p><ul><li>主键不能重复</li><li>每行必有主键,且不能为 NULL</li></ul></li><li><p><strong>外键:</strong>  product 只存产品信息, 和供应商ID,  vendors 存供应商的信息(主键是ID),则vendors的主键就是product的外键.</p></li></ul><p>MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。</p><h1 id="二、-安装与删"><a href="#二、-安装与删" class="headerlink" title="二、 安装与删"></a><strong>二、 安装与删</strong></h1><ul><li><p>删除mysql</p><p><code>sudo apt purge mysql-* sudo apt autoremove</code></p></li><li><p>安装mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server </span><br><span class="line">sudo apt install mysql-client </span><br><span class="line">sudo apt install libmysqlclient-dev `</span><br></pre></td></tr></table></figure></li></ul><p><strong>数据库规范：</strong></p><ul><li>关键字大写，表名，列名小写</li><li>索引从1开始</li><li>每条命令用分号隔开</li><li><p>注释</p></li><li><p>单行注释   #</p></li><li>单行注释  — 注释文</li><li>多行注释  /<em> </em>/</li></ul><font color="red"><big>索引从1开始！</big></font><h1 id="三、常用命令"><a href="#三、常用命令" class="headerlink" title="三、常用命令"></a><strong>三、常用命令</strong></h1><h2 id="指令执行顺序："><a href="#指令执行顺序：" class="headerlink" title="指令执行顺序："></a><strong>指令执行顺序：</strong></h2><p><strong>SELECT  FROM  WHERE   GROUP BY  HAVING  ORDER BY LIMIT.</strong></p>   <font color="red"><big>开始 **->** FROM子句 **->** WHERE子句 **->** GROUP BY子句 **->** HAVING子句 **->** ORDER BY子句 **->** SELECT子句 **->** LIMIT子句 **->** 最终结果 </big></font>    <font color="red"><big>每个步骤都会为下一个步骤生成一个虚拟表</big></font><h2 id="1-登陆系统-选择数据库"><a href="#1-登陆系统-选择数据库" class="headerlink" title="1. 登陆系统, 选择数据库"></a><strong>1. 登陆系统, 选择数据库</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql -u 用户名 -p 密码</span><br><span class="line">mysql -h localhost -P 3306 -p</span><br><span class="line"></span><br><span class="line"># 查看所有数据库列表</span><br><span class="line">SHOW DATABSASES;</span><br><span class="line"># 查看选择的数据库中的表的列表</span><br><span class="line">SHOW TABLES;</span><br><span class="line"># 查看表中的列有哪些</span><br><span class="line">SHOW COLUMNS FROM 表名;  ||  DESCRIBE 表名;</span><br><span class="line"></span><br><span class="line"># 选择库</span><br><span class="line">USE 数据库的名字;</span><br><span class="line"></span><br><span class="line"># 查看表结构</span><br><span class="line">DESC 表名;</span><br></pre></td></tr></table></figure><h2 id="2-基础查询——检索-SELECT-DISTINCT"><a href="#2-基础查询——检索-SELECT-DISTINCT" class="headerlink" title="2 基础查询——检索 SELECT + DISTINCT"></a><strong>2 基础查询——检索 SELECT + DISTINCT</strong></h2><p>SELECT 子句 固定的顺序:</p><p><strong>SELECT  FROM  WHERE （原始表有的字段）  GROUP BY  HAVING  （分组后有的字段）ORDER BY LIMIT.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 选择多个字段 `着重号`当字段名与关键字冲突，用它可以避免冲突</span><br><span class="line">SELECT id, `name`, price FROM 表名; </span><br><span class="line"></span><br><span class="line"># 起别名 AS, 可以省略SELECT salary &quot;Month Salary&quot; from employees;</span><br><span class="line">SELECT salary AS &quot;Month Salary&quot; from employees;</span><br><span class="line"></span><br><span class="line"># 字符串拼接 concat</span><br><span class="line"># 特别注意+：  </span><br><span class="line"># 1+9=10  两个数值型做加法</span><br><span class="line"># &apos;12&apos;+ 3 = 15 字符转整数，再加 </span><br><span class="line"># &apos;job&apos;+2 = 2  转换失败，则字符串变0</span><br><span class="line"># null+任何值 = null</span><br><span class="line">SELECT concat(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) , price FROM 表名; </span><br><span class="line"></span><br><span class="line"># 检索所有字段</span><br><span class="line">SELECT * FROM 表名;</span><br><span class="line"></span><br><span class="line"># 字段去重  DISTINCT</span><br><span class="line">SELECT DISTINCT id FROM 表名;   # 不能应用于多列</span><br><span class="line"></span><br><span class="line"># 限制检索结果</span><br><span class="line"> SELECT  id FROM 表名  LIMIT 5;  # 前5 </span><br><span class="line"> SELECT  id FROM 表名  LIMIT 2,5;  #从 2+1 开始的  5个行</span><br><span class="line"> SELECT id FROM 表名 LIMIT 5 OFFSET 3;  # 从行3取5</span><br></pre></td></tr></table></figure><h2 id="3-排序检索-ORDER-BY-默认升序-LIMIT-OFFSET-DESC"><a href="#3-排序检索-ORDER-BY-默认升序-LIMIT-OFFSET-DESC" class="headerlink" title="3. 排序检索 ORDER   BY (默认升序) + LIMIT,  OFFSET, DESC"></a><strong>3. 排序检索 ORDER   BY (默认升序) + LIMIT,  OFFSET, DESC</strong></h2><p>可以根据非 select 字段排序。</p><p>SELECT  查询列表</p><p>FROM  表</p><p>【where 筛选条件】</p><p>ORDER BY  排序列表  [asc |  desc]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 按照某列排序,  多条件排序</span><br><span class="line">SELECT id FROM 表名 ORDER BY id ASC, age DESC;   # 可以根据其他列来排序</span><br><span class="line"></span><br><span class="line"># 按照多个条件排序</span><br><span class="line">SELECT id FROM 表名 ORDER BY age, size;   # 优先age, 重复时才根据size排序.</span><br><span class="line"></span><br><span class="line">#  指定降序  DESC</span><br><span class="line">SELECT id FROM 表名 ORDER BY age  DESC  size;  # DESC 只作用于在DESC 前面的, 所以 size仍然为升序</span><br><span class="line"></span><br><span class="line"># 找到最********的id</span><br><span class="line">SELECT id FROM 表名 ORDER BY age LIMIT 1;</span><br><span class="line"># 第二最的*******id</span><br><span class="line">SELECT id FROM 表名 ORDER BY age LIMIT 1 OFFSET 2;</span><br></pre></td></tr></table></figure><h2 id="4-条件查询"><a href="#4-条件查询" class="headerlink" title="4. 条件查询"></a><strong>4. 条件查询</strong></h2><h3 id="4-1-——逻辑运算-WHERE-AND-OR-NOT-IN-和EXISTS-看优化部分"><a href="#4-1-——逻辑运算-WHERE-AND-OR-NOT-IN-和EXISTS-看优化部分" class="headerlink" title="4.1  ——逻辑运算 WHERE + AND, OR,NOT IN 和EXISTS(看优化部分)"></a><strong>4.1  ——逻辑运算 WHERE + AND, OR,NOT</strong> <strong>IN 和EXISTS(看优化部分)</strong></h3><p><strong>作用：</strong></p><p>连接条件表达式</p><font color="red"><big>**如果计算次序不加括号时,  优先 AND**</big></font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#  =  !=  &lt;  &gt; &gt;=    &quot;BETWEEN 1 AND 2&quot;在指定值之间,包含端点</span><br><span class="line"># 不等于 ！=   或者  &lt;&gt;</span><br><span class="line">SELECT id FROM 表名 WHERE age=12 ORDER BY size;</span><br><span class="line"></span><br><span class="line"># 组合筛选  AND  OR</span><br><span class="line">SELECT id FROM 表名 WHERE age=12 AND size &lt; 10;</span><br><span class="line"></span><br><span class="line"># 计算次序,  不加括号时,  优先 AND</span><br><span class="line"># 解释: id&gt;3且age&gt;10,  或者 id=1</span><br><span class="line">SELECT id FROM 表名 WHERE id=1 OR id=3 AND age &gt; 10;   </span><br><span class="line"></span><br><span class="line"># NOT  否定后跟的所有条件.</span><br><span class="line">SELECT id FROM 表名 NOT WHERE id IN (1002, 1003)</span><br></pre></td></tr></table></figure><p><img src="/2020/04/11/mysql-必知必会7-综合内容/Users\Misaya\AppData\Local\YNote\data\elgong@126.com\e87e0bbb47ff40228ca7b6dbebad7954\clipboard.png" alt="img"></p><h3 id="4-2-——模糊查询-WHERE-LIKE-between-and-in-is-null"><a href="#4-2-——模糊查询-WHERE-LIKE-between-and-in-is-null" class="headerlink" title="4.2  ——模糊查询  WHERE + LIKE, between and, in, is null"></a><strong>4.2  ——模糊查询  WHERE + LIKE, between and, in, is null</strong></h3><ul><li><strong>like + 通配符：</strong> 参考7.</li><li><strong>between and ：</strong> 包含临界值， 不可颠倒顺序</li><li><strong>in：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># between and</span><br><span class="line">SELECT  * FROM 表名  WHERE id BETWEEN 100 and 120;</span><br><span class="line"></span><br><span class="line"># IN 取值必须在括号内</span><br><span class="line">SELECT id FROM 表名 WHERE id IN (1002, 1003)</span><br><span class="line"></span><br><span class="line"># IS NULL 筛选出空值  IS NOT NULL</span><br><span class="line">SELECT id FROM 表名 WHERE age IS NULL;</span><br></pre></td></tr></table></figure><p><strong>补. 空值处理 IFNULL(字段，空值时返回值)</strong></p><p><code>SELECT IFNULL(price, 0) FROM 表名;</code></p><h2 id="5-通配符-LIKE-正则表达式-REGEXP-都-不区分大小写"><a href="#5-通配符-LIKE-正则表达式-REGEXP-都-不区分大小写" class="headerlink" title="5. 通配符   LIKE + % , _   + 正则表达式 REGEXP   都**不区分大小写**"></a><strong>5. 通配符   LIKE + % , _   + 正则表达式</strong> <strong>REGEXP   都**</strong>不区分大小写**</h2><ol><li><p>通配符速度慢, 不要放在搜索开始处</p></li><li><p><strong>LIKE 匹配整个串,  正则表达式可以匹配子串</strong></p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#  通配符</span><br><span class="line">#  % 匹配0,1,多个字符</span><br><span class="line">SELECT id FROM 表名 WHERE string LIKE &apos;s%&apos;;   # s开头   </span><br><span class="line"></span><br><span class="line"># 下划线 _ , 匹配单个字符</span><br><span class="line"># 需要匹配 _ 时， 用转义   \_</span><br><span class="line">SELECT id FROM 表名 WHERE string LIKE &apos;s_&apos;;  </span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">#  正则表达式 REGEXP</span><br><span class="line"># 标准表达</span><br><span class="line">SELECT name FROM customers WHERE name REGEXP &apos;1000&apos;;</span><br><span class="line"></span><br><span class="line">&apos;.&apos;   # 任意一个字符</span><br><span class="line">&apos;A1&apos;| &apos;B2&apos;  # 匹配两个串之一</span><br><span class="line">&apos;[1-9]&apos;     # 匹配 1~9 范围内的值</span><br><span class="line">&apos;[123]&apos;     # 匹配1，2，3之一， 等价于【1 | 2 | 3】</span><br><span class="line">&apos;[^123]&apos;    # 匹配非123的值</span><br><span class="line">&apos;\\.&apos;       # 特殊字符转译   </span><br><span class="line"></span><br><span class="line"># 匹配多个实例, 不能单独出现,必须是指定上边的某种字符的匹配</span><br><span class="line"># 例如 &apos;.*&apos; 而不是&apos;*&apos;</span><br><span class="line">&apos;*&apos;  # 0或多个匹配</span><br><span class="line">&apos;+&apos;  # 1或多个匹配</span><br><span class="line">&apos;?&apos;  # 0或者1个匹配</span><br><span class="line">&#123;n&#125;  # 指定数目匹配</span><br><span class="line">&#123;n,&#125;  # 不少于指定数目的匹配</span><br><span class="line">&#123;n,m&#125;  # 数目范围,不超过255</span><br><span class="line"></span><br><span class="line">#定位元字符</span><br><span class="line">&apos;^&apos;   # 开始位置</span><br><span class="line">&apos;$&apos;   # 结尾</span><br><span class="line">&apos;[[:&lt;:]]&apos;  # 词开始</span><br><span class="line">&apos;[[:&lt;:]]&apos;  # 词结尾</span><br><span class="line"></span><br><span class="line"># 举例:</span><br><span class="line">&apos;^[1-9]&apos;   </span><br><span class="line">BINARY &apos;J 1000&apos;     # 指定区分大小写</span><br><span class="line"></span><br><span class="line">&apos;[a-zA-Z0-9]&apos;   # 匹配所有字符</span><br></pre></td></tr></table></figure><h2 id="6-数据处理常用函数-不区分大小写"><a href="#6-数据处理常用函数-不区分大小写" class="headerlink" title="6. 数据处理常用函数 (不区分大小写)"></a><strong>6. 数据处理常用函数 (不区分大小写)</strong></h2><ul><li>字符函数</li><li>数学函数</li><li>日期函数</li><li>其他函数</li><li>流程函数</li></ul><p>字符函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 文本处理函数</span><br><span class="line"># 1. 字符串字节个数,  汉字算三个字符</span><br><span class="line">Length() </span><br><span class="line"></span><br><span class="line"># 2. 拼接</span><br><span class="line">CONCAT(id, &quot;_&quot;, name)</span><br><span class="line"></span><br><span class="line"># 3. 大写 小写</span><br><span class="line">Lower()  # 小写</span><br><span class="line">Upper()  # 大写</span><br><span class="line"></span><br><span class="line"># 4. 返回子串的字符, 数据库索引从1开始</span><br><span class="line">SubStr(last_name, start) </span><br><span class="line">SubStr(last_name, start, length)   # 长度</span><br><span class="line"></span><br><span class="line"># 5. 查找子串, 返回第一次出现的索引， 查不到返回0</span><br><span class="line">INSTR(&quot;待查子串abcd&quot;, &quot;a&quot;)</span><br><span class="line"></span><br><span class="line"># 6. 去空格</span><br><span class="line">Trim(), LTrim(), RTrim()  </span><br><span class="line"></span><br><span class="line"># 7. 指定长度填充</span><br><span class="line">LPAD(name, length, &apos;*&apos;)</span><br><span class="line">RPAD(name, length, &apos;*&apos;)</span><br><span class="line"></span><br><span class="line"># 8. 替换</span><br><span class="line">REPLACE(原串, &apos;被替换串&apos;, &apos;新串&apos;)</span><br><span class="line"></span><br><span class="line"># 9. 字符串字符长度, 汉字也算 1个字符</span><br><span class="line">CHAR_LENGTH(s)  </span><br><span class="line">Soundex()   # 返回串的SOUNDEX值</span><br></pre></td></tr></table></figure><p>数学函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 1. 四舍五入</span><br><span class="line">ROUND(1.6);   # 2</span><br><span class="line">ROUND(1.567, 2)  # 小数点保留两位</span><br><span class="line"></span><br><span class="line"># 2. 上取整， &gt;=该参数的最小整数</span><br><span class="line">CEIL(1.00) </span><br><span class="line"># 下取整,   &lt;=该参数的最大整数</span><br><span class="line">FLOOR(-9.99)   # -10</span><br><span class="line"></span><br><span class="line"># 3. 小数点直接截断</span><br><span class="line">TRUNCATE(1.69999, 1)  # 1.6</span><br><span class="line"></span><br><span class="line"># 4. 取余数</span><br><span class="line">MOD(10, 3)  # 10%3</span><br><span class="line"></span><br><span class="line">ABS(x)   # 绝对值</span><br><span class="line">AVG(age)  # 某列的平均值 </span><br><span class="line">EXP(x)</span><br><span class="line">RAND()  # 0到1的随机数</span><br></pre></td></tr></table></figure><p>日期函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NOW()   # 当前日期和时间</span><br><span class="line">CURDATE() # 当前日期，不含时间</span><br><span class="line">Date()  # 返回时间中的日期部分....</span><br><span class="line">Day()   # 返回时间中的天数部分</span><br><span class="line">Year(NOW())</span><br><span class="line">Time()</span><br><span class="line">Month()  </span><br><span class="line">Hour()</span><br><span class="line">DateDiff()  # 计算日期差</span><br><span class="line"></span><br><span class="line"># 字符串转日期</span><br><span class="line">STR_TO_DATE(&apos;02-19-2020&apos;, &quot;%m-%d-%Y&quot;)</span><br><span class="line"></span><br><span class="line"># 日期的格式化输出</span><br><span class="line">DATE_FORMAT(NOW(), &apos;%y年%m月%d日&apos;)</span><br></pre></td></tr></table></figure><p>其他函数</p><p><code>VERSION()</code></p><h2 id="7-流程控制函数"><a href="#7-流程控制函数" class="headerlink" title="7. 流程控制函数"></a><strong>7. 流程控制函数</strong></h2><p>IF(逻辑判断， 成立执行， 不成立执行)</p><p>CASE:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># IF</span><br><span class="line">IF(10&gt;5, &apos;大&apos;, &apos;小&apos;)</span><br><span class="line">SELECT name IF(salary IS NULL, &quot;没薪水&quot;, &quot;有薪水&quot;)</span><br><span class="line"></span><br><span class="line"># CASE 第一种使用</span><br><span class="line">CASE &apos;要判断的表达式&apos;</span><br><span class="line">WHEN &apos;常量1&apos; then 值(没有分号) / 表达式(有分号);</span><br><span class="line">WHEN &apos;常量2&apos; then 值(没有分号) / 表达式(有分号);</span><br><span class="line">WHEN &apos;常量3&apos; then 值(没有分号) / 表达式(有分号);</span><br><span class="line">...</span><br><span class="line">ELSE 值(没有分号) / 表达式(有分号);</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line"># CASE 第二种语句</span><br><span class="line">CASE </span><br><span class="line">WHEN 表达式 then 值(没有分号) / 表达式(有分号);</span><br><span class="line">WHEN 表达式 then 值(没有分号) / 表达式(有分号);</span><br><span class="line">WHEN 表达式 then 值(没有分号) / 表达式(有分号);</span><br><span class="line">...</span><br><span class="line">ELSE 值(没有分号) / 表达式(有分号);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><h2 id="8-数据汇总-聚集函数-AVG-COUNT-MAX-MIN-SUM"><a href="#8-数据汇总-聚集函数-AVG-COUNT-MAX-MIN-SUM" class="headerlink" title="8. 数据汇总-聚集函数  AVG, COUNT, MAX, MIN, SUM"></a><strong>8. 数据汇总-聚集函数  AVG, COUNT, MAX, MIN, SUM</strong></h2><p>运行在行组, 计算和返回单个值的函数.</p><p>统计使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># AVG() 针对单列,  对多列需要使用多个</span><br><span class="line">SELECT AVG(age) AS avg_age FROM 表名;   # 忽略 NULL</span><br><span class="line"></span><br><span class="line"># COUNT() 函数</span><br><span class="line">COUNT(1);   # 行数</span><br><span class="line">COUNT(*);   # 表的行数, 含有 NULL的有数据行也可，但是不能全NULL</span><br><span class="line">COUNT(column)  # 某列非NULL 的个数</span><br><span class="line">COUNT(distinct 字段)  # 统计不重复的</span><br><span class="line"># 效率对比：</span><br><span class="line">MYISAM 储存引擎下， COUNT(*) 效率高</span><br><span class="line">INNODB 存储引擎下，COUNT(*) 和COUNT(1) 差不多，比COUNT(字段高)</span><br><span class="line"></span><br><span class="line"># 聚集不同的值 + DISTINCT</span><br><span class="line"># 聚集函数默认ALL</span><br><span class="line">SELECT AVG(DISTINCT age) FROM 表名;  # 对唯一值求均值</span><br><span class="line">SELECT COUNt(DISTINCT age) FROM 表名;  # 对age列的唯一值统计个数</span><br></pre></td></tr></table></figure><h2 id="9-数据分组查询-——-GROUP-BY-HAVING"><a href="#9-数据分组查询-——-GROUP-BY-HAVING" class="headerlink" title="9. 数据分组查询 —— GROUP BY,   HAVING"></a><strong>9. 数据分组查询 —— GROUP BY,   HAVING</strong></h2><h3 id="1-GROUP-BY-分组字段"><a href="#1-GROUP-BY-分组字段" class="headerlink" title="1. GROUP BY   分组字段"></a><strong>1. GROUP BY   分组字段</strong></h3><p>​          <font color="red"><big><strong>如果分组列中具有 NULL,  则NULL 将作为一个分组返回.</strong></big></font></p><h3 id="2-HAVING-过滤条件-WHERE-条件"><a href="#2-HAVING-过滤条件-WHERE-条件" class="headerlink" title="2. HAVING 过滤条件  =====WHERE 条件"></a><strong>2. HAVING 过滤条件  =====WHERE 条件</strong></h3><h3 id="3-必加-ORDER-BY-因为G出来的结果不保证排序了"><a href="#3-必加-ORDER-BY-因为G出来的结果不保证排序了" class="headerlink" title="3. 必加 ORDER BY,  因为G出来的结果不保证排序了."></a><strong>3. 必加 ORDER BY,  因为G出来的结果不保证排序了.</strong></h3><h3 id="4-能where-就不用having"><a href="#4-能where-就不用having" class="headerlink" title="4. 能where 就不用having"></a><strong>4. 能where 就不用having</strong></h3><ul><li><p><strong>按字段分组</strong></p></li><li><ul><li>GROUP BY id </li></ul></li><li><p><strong>按表达式或者函数</strong></p></li><li><ul><li>GROUP BY length(id)  AS  len   HAVING  len&gt;3;</li></ul></li><li><p><strong>按多个字段分组</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 分组统计值</span><br><span class="line">SELECT id, COUNT(*) AS num_ FROM 表名 GROUP BY id ORDER BY age;</span><br><span class="line"></span><br><span class="line"># 分组过滤  大于2的值</span><br><span class="line">SELECT age FROM 表名 GROUP BY  id  HAVING COUNT(*)&gt;=2 ORDER BY age;</span><br></pre></td></tr></table></figure><h2 id="10-子查询-IN-括号"><a href="#10-子查询-IN-括号" class="headerlink" title="10. 子查询  IN + 括号"></a><strong>10. 子查询  IN + 括号</strong></h2><ul><li>查询的结果作为另一个查询的条件,然后多层嵌套.</li><li>内层查询<strong>建立一个临时表</strong>。费时间.</li><li>优化需要用join 联结表替代….</li></ul><p><strong>where 和 having 后可放的子查询：</strong></p><ul><li><p>子查询放在小括号内</p></li><li><p><strong>标量子查询（单值）</strong>，一般配合单行操作符使用：  &gt;  &lt;   &gt;=  =  &lt;&gt;</p></li><li><p><strong>列子查询（单列多行）</strong>， 一般配合多行操作符使用：  </p></li><li><ul><li>IN   列表中的一个</li><li>ANY/SOME   </li><li>ALL</li></ul></li></ul><p><strong>select 后可以放的子查询：</strong></p><p><strong>from 后可以放的子查询：</strong></p><ul><li><p>必须起别名</p></li><li><ul><li>FROM (子查询表)  newtable </li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 标量子查询</span><br><span class="line"># 1. 谁工资比  elgong 高</span><br><span class="line">SELECT  * FROM employee </span><br><span class="line">WHERE salary&gt;(select salary from emplot WHERE name = &apos;elgong&apos;);</span><br><span class="line"></span><br><span class="line"># 查询超过平均工资的员工信息</span><br><span class="line">select avg(sal) from emp;   /* avg(sal)=2000 */</span><br><span class="line">select * from emp where sal &gt;= 2000;</span><br><span class="line">/* 子查询方法 */</span><br><span class="line">select * from emp where sal &gt;= (select avg(sal) from emp);</span><br></pre></td></tr></table></figure><h2 id="11-连接查询——JOIN-联结表-INNER-JOIN-LEFT-JOIN-RIGHT-JOIN"><a href="#11-连接查询——JOIN-联结表-INNER-JOIN-LEFT-JOIN-RIGHT-JOIN" class="headerlink" title="11. 连接查询——JOIN 联结表 ( INNER JOIN, LEFT JOIN, RIGHT JOIN)"></a><strong>11. 连接查询——JOIN 联结表 ( INNER JOIN, LEFT JOIN, RIGHT JOIN)</strong></h2><p><strong>注意判断驱动表是哪个？  查询计划  explain</strong></p><p>正常情况下，from 后的表是驱动表，但是当出现下面情况，驱动表变成了 class。</p><p>分析： 当 where 后的条件使得表之间数据多少不一样时，数据少的为主表</p><p><strong>小表驱动大表的原则</strong></p><p><code>select * from student left join class on  class.classid = student.classid where class.classid = 2;</code></p><p><strong>概念:    联结指两张表,或者多张表之间组合在一起进行查询, 是在运行时做的操作;</strong></p><ul><li><p><strong>left JOIN </strong> (左联结)保证读取主表的全部数据</p></li><li><p><strong>right JOIN</strong>  (右联结) 保证读取主表的全部数据</p></li><li><p><strong>inner JOIN</strong>  (内部联结,等值联结)  只读取共有的数据</p></li><li><p><strong>自联结:  </strong>常用来代替从同一个表检索数据的子查询.  FROM table1 AS t1, table2 AS t2, WHERE t1.col = t2.col;</p></li><li><p><strong>自然联结: </strong> 联结有主副表之分,  在INNER JOIN 之前的是主表, 待查询的输出中,排前边的内容所在的表为主表.</p></li></ul><p>左外联结可通过颠倒FROM 或者WHERE 子句中表的顺序转换成右外部联结</p><p><strong>连接的分类</strong></p><ul><li><p>SQL92语法</p></li><li><ul><li><p><strong>等值连接</strong></p></li><li><ul><li><code>FROM table1 AS t1, table2 AS t2, table3 AS t3  WHERE t1.col = t2.col  AND t2.c = t3.c ;</code>    </li></ul></li><li><p><strong>自连接（单表）</strong></p></li><li><ul><li>同表不同名</li><li><code>FROM   employees   e1,  employees  e2  WHERE  e1.id = e2.iidd</code></li></ul></li></ul></li><li><p>SQL99语法</p></li><li><ul><li>SELECT   查询列表</li><li><code>FROM   表1  别名  [连接类型]   join        表2  别名   on          连接条件</code></li></ul></li><li><ul><li><p><strong>内连接</strong>  inner join</p></li><li><p><strong>外连接</strong>  left， right</p></li><li><ul><li>主表全部显示</li><li>从表中没有与主表匹配的结果，显示NULL</li><li>等价于==== 内连接结果 + 主表有而从表没有的记录</li><li>左外和右外，交换表顺序可以等价效果</li></ul></li><li><p><strong>全外连接</strong>  full join</p></li><li><p><strong>交叉连接</strong>   cross join</p></li><li><ul><li>笛卡尔乘机</li></ul></li><li><p><strong>非等值连接</strong></p></li><li><ul><li>FROM e  join g on e.salary  BETWEEN g.low AND g.upper</li></ul></li><li><p><strong>自连接</strong></p></li><li><ul><li>一样的join on   不同名的同一张表</li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 创建联结表的两种方式</span><br><span class="line"># 1. 等值连接  WHERE 表1.id = 表2.id AND 表2.size = 表3.size</span><br><span class="line">SELECT vendors.vendor_name, product.prod_name, product.prod_price </span><br><span class="line">FROM product,vendors </span><br><span class="line">WHERE vendors.vendor_id = product.vendor_id </span><br><span class="line">ORDER BY vendor_name;</span><br><span class="line"></span><br><span class="line"># 2.内部联结(等值联结) 表的键数量相同  FROM 表1 INNER JOIN 表2 ON 表1.id = 表2.id</span><br><span class="line">SELECT v.vendor_name, p.prod_name, p.prod_price </span><br><span class="line">FROM product AS p </span><br><span class="line">INNER JOIN vendors AS v </span><br><span class="line">ON v.vendor_id = p.vendor_id  </span><br><span class="line">ORDER BY v.vendor_name;</span><br><span class="line"></span><br><span class="line"># </span><br><span class="line"># 对联结的表使用聚合方法</span><br><span class="line">待补充.....</span><br></pre></td></tr></table></figure><p><img src="/2020/04/11/mysql-必知必会7-综合内容/Users\Misaya\AppData\Local\YNote\data\elgong@126.com\e6a36fe8659843b897ed6b6e6ee6977d\clipboard.png" alt="img"></p><h2 id="12-分页查询"><a href="#12-分页查询" class="headerlink" title="12. 分页查询"></a><strong>12. 分页查询</strong></h2><p>  <strong>LIMIT  行X(从0开始),  size;</strong></p><p>  <strong>LIMIT  size OFFSET  size;</strong></p><p><strong>当要显示的数据，需要分页显示</strong> </p><ul><li>从行0开始</li><li>从第四行开始，检索5行</li><li><strong>LIMIT   3,  5</strong></li><li><strong>LIMIT   5  OFFSET  3</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#  查询前5条数据</span><br><span class="line">SELECT  *  FROM employees LIMIT 0, 5;</span><br><span class="line"></span><br><span class="line"># 查询11到25条数据</span><br><span class="line">SELECT  *  FROM employees LIMIT 10, 25-11+1;</span><br><span class="line"></span><br><span class="line"># 计算公式</span><br><span class="line">LIMIT (page-1)*size,  size;</span><br></pre></td></tr></table></figure><h2 id="13-联合查询-union-（自动去重，union-all-不去重）"><a href="#13-联合查询-union-（自动去重，union-all-不去重）" class="headerlink" title="13. 联合查询  union  （自动去重，union all  不去重）"></a><strong>13. 联合查询  union  （自动去重，union all  不去重）</strong></h2><p>将多条查询语句合并成一个结果</p><p><strong>特点：</strong></p><ul><li>查询 <strong>列数</strong> 和 <strong>列顺序</strong> 必须一致</li><li>自动去重</li><li>不去重  union all</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT   *   FROM    e1   WHERE   </span><br><span class="line">UNION</span><br><span class="line">SELECT   *   FROM    e1   WHERE</span><br></pre></td></tr></table></figure><h2 id="14-视图"><a href="#14-视图" class="headerlink" title="14. 视图"></a><strong>14. 视图</strong></h2><p>视图是虚拟的表, 是对其基表的封装.</p><p>使用的好处:</p><ol><li><p>重用 SQL 语句</p></li><li><p>使用表的部分,即过滤掉部分数据</p></li></ol><p>限制:</p><ol><li><p>图名唯一</p></li><li><p>视图可以嵌套</p></li><li><p>视图的ORDER BY  次于 从该视图检索数据的ORDER</p></li><li><p>视图可以和表一起使用</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 创建视图</span><br><span class="line">CREATE VIEW  viewname AS</span><br><span class="line">SELECT * FROM table WHERE id!=1;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、关系型数据库Mysql&quot;&gt;&lt;a href=&quot;#一、关系型数据库Mysql&quot; class=&quot;headerlink&quot; title=&quot;一、关系型数据库Mysql&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、关系型数据库Mysql&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;数据库（Datab
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.elgong.top/categories/mysql/"/>
    
    
      <category term="mysql-必知必会系列" scheme="http://www.elgong.top/tags/mysql-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>mysql-必知必会2-数据操作语言DML</title>
    <link href="http://www.elgong.top/2020/04/11/mysql-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A2-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80DML/"/>
    <id>http://www.elgong.top/2020/04/11/mysql-必知必会2-数据操作语言DML/</id>
    <published>2020-04-11T03:24:42.000Z</published>
    <updated>2020-04-11T03:33:47.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DML-数据操作语言"><a href="#DML-数据操作语言" class="headerlink" title="DML  数据操作语言"></a><strong>DML  数据操作语言</strong></h1><ul><li><strong>插入  INSERT</strong> </li><li><strong>更新  UPDATE</strong></li><li><strong>删除  DELETE</strong></li></ul><h2 id="1-插入"><a href="#1-插入" class="headerlink" title="1.  插入"></a><strong>1.  插入</strong></h2><p><strong>规则： 插入值的类型要一致</strong></p><ul><li>语法1：</li></ul><p>​        <code>INSERT   INTO   表名（列名） VALUES ( 值1...)</code></p><ul><li>语法2：</li></ul><p>​        <code>INSERT   INTO   表名 SET  列名1=值1，列名2=值2</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#  插入 INSERT</span><br><span class="line">#  插入完整行,或者部分</span><br><span class="line">INSERT INTO customers(</span><br><span class="line">    cust_name,</span><br><span class="line">    cust_address,</span><br><span class="line">    cust_city,</span><br><span class="line">    cust_state)</span><br><span class="line">VALUES(</span><br><span class="line">    &apos;elgong&apos;,</span><br><span class="line">    &apos;1552460315&apos;,</span><br><span class="line">    &apos;hangzhou&apos;,</span><br><span class="line">    &apos;1&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#  插入多行</span><br><span class="line">INSERT INTO customers(</span><br><span class="line">    cust_name,</span><br><span class="line">    cust_address,</span><br><span class="line">    cust_city,</span><br><span class="line">    cust_state)</span><br><span class="line">VALUES(</span><br><span class="line">    &apos;elgong&apos;,</span><br><span class="line">    &apos;1552460315&apos;,</span><br><span class="line">    &apos;hangzhou&apos;,</span><br><span class="line">    &apos;1&apos;</span><br><span class="line">),</span><br><span class="line">(</span><br><span class="line">    &apos;gel&apos;,</span><br><span class="line">    &apos;178905324&apos;,</span><br><span class="line">    &apos;hangzhou&apos;,</span><br><span class="line">    &apos;0&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="2-更新（缺了where-就全部更新啦，一定要注意）"><a href="#2-更新（缺了where-就全部更新啦，一定要注意）" class="headerlink" title="2.  更新（缺了where 就全部更新啦，一定要注意）"></a><strong>2.  更新（</strong><font color="red"><big>缺了where 就全部更新啦，一定要注意</big></font>）</h2><ul><li><p>单表更新语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE   表名   SET  列名1=值 ...  WHERE  筛选条件;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>多表更新语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE   表名  SET  列名1=值...   </span><br><span class="line"></span><br><span class="line">WHERE  连接条件 AND  筛选条件;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#  更新 UPDATE  SET</span><br><span class="line">#  更新某行的某些列值</span><br><span class="line">UPDATE customers </span><br><span class="line">SET cust_email = &quot;1552460315@qq.com&quot;,   #  列1</span><br><span class="line">    cust_name = &quot;ELGONG&quot;</span><br><span class="line">WHERE cust_id = 1;</span><br></pre></td></tr></table></figure><p><strong>3.  删除</strong></p><p><strong>删除整行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#   删除</span><br><span class="line">#  删除特定行</span><br><span class="line">DELETE FROM customers WHERE cust_id=1;</span><br><span class="line"></span><br><span class="line">#  删除所有行</span><br><span class="line">DELETE FROM customers ;  </span><br><span class="line">TRUNCATE TABLE;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DML-数据操作语言&quot;&gt;&lt;a href=&quot;#DML-数据操作语言&quot; class=&quot;headerlink&quot; title=&quot;DML  数据操作语言&quot;&gt;&lt;/a&gt;&lt;strong&gt;DML  数据操作语言&lt;/strong&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;插入  I
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.elgong.top/categories/mysql/"/>
    
    
      <category term="mysql-必知必会系列" scheme="http://www.elgong.top/tags/mysql-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>mysql-必知必会1-数据定义语言DDL</title>
    <link href="http://www.elgong.top/2020/04/11/mysql-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A1-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80DDL/"/>
    <id>http://www.elgong.top/2020/04/11/mysql-必知必会1-数据定义语言DDL/</id>
    <published>2020-04-11T03:15:23.000Z</published>
    <updated>2020-04-11T03:21:09.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库和表的创建，修改，删除"><a href="#数据库和表的创建，修改，删除" class="headerlink" title="数据库和表的创建，修改，删除"></a><strong>数据库和表的创建，修改，删除</strong></h1><ul><li>创建  create</li><li>修改  alter</li><li>删除  drop</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># ########  数据库相关</span><br><span class="line"># 创建库</span><br><span class="line">CREATE DATABASE 库名 IF NOT EXISTS;</span><br><span class="line"></span><br><span class="line"># 修改库名</span><br><span class="line">RENAME DATABASE  books  TO   新库名;</span><br><span class="line"></span><br><span class="line"># 删除库</span><br><span class="line">DROP DATABASE  IF EXISTS books;</span><br><span class="line"></span><br><span class="line"># ######### 表相关</span><br><span class="line">#  创建表</span><br><span class="line">CREATE TABLE   IF NOT EXISTS customers</span><br><span class="line">(</span><br><span class="line">    cust_id    int    NOT NULL AUTO_INCREMENT,  #  自动增加</span><br><span class="line">    cust_name  char(50) NOT NULL  DEFAULT GEL,  #  设默认值</span><br><span class="line">    cust_address char(50) NULL,</span><br><span class="line">   cust_city  char(50) NULL,</span><br><span class="line">   cust_state  char(5) NULL,</span><br><span class="line">   cust_email  char(255) NULL,</span><br><span class="line">   PRIMARY KEY (cust_id)   #  指定主键</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE   IF NOT EXISTS student</span><br><span class="line">(</span><br><span class="line">    id    int    NOT NULL AUTO_INCREMENT,  </span><br><span class="line">    name  char(50) NOT NULL,  </span><br><span class="line">    address char(50) NULL,</span><br><span class="line">    city  char(50) NULL,</span><br><span class="line">    email  char(255) NULL,</span><br><span class="line">   PRIMARY KEY (id) </span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#  更新表</span><br><span class="line">#  添加一列 ADD</span><br><span class="line">ALTER TABLE customers ADD cust_phone CHAR(20);</span><br><span class="line"></span><br><span class="line">#  删除表 </span><br><span class="line">DROP TABLE customers</span><br><span class="line">#  修改表名</span><br><span class="line">RENAME TABLE customers TO customers222;  </span><br><span class="line">#  修改列名</span><br><span class="line">ALTER  TABLE book CHANGE COLUMN 旧名  新名  类型;</span><br><span class="line"></span><br><span class="line">#  修改列名，约束</span><br><span class="line">ALTER  TABLE book MODIFY COLUMN 列名  类型;</span><br><span class="line"></span><br><span class="line">#  删除一列 DROP</span><br><span class="line">ALTER TABLE customers DROP COLUMN cust_phone;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库和表的创建，修改，删除&quot;&gt;&lt;a href=&quot;#数据库和表的创建，修改，删除&quot; class=&quot;headerlink&quot; title=&quot;数据库和表的创建，修改，删除&quot;&gt;&lt;/a&gt;&lt;strong&gt;数据库和表的创建，修改，删除&lt;/strong&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.elgong.top/categories/mysql/"/>
    
    
      <category term="mysql-必知必会系列" scheme="http://www.elgong.top/tags/mysql-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>版本控制-git</title>
    <link href="http://www.elgong.top/2020/03/28/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-git/"/>
    <id>http://www.elgong.top/2020/03/28/版本控制-git/</id>
    <published>2020-03-28T04:17:11.000Z</published>
    <updated>2020-03-28T04:24:01.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-git-的作用"><a href="#1-git-的作用" class="headerlink" title="1. git 的作用"></a>1. git 的作用</h1><ul><li>版本控制</li><li>协同开发</li></ul><h1 id="2-文件的状态"><a href="#2-文件的状态" class="headerlink" title="2. 文件的状态"></a>2. 文件的状态</h1><ul><li>untracked  (新建的文件)</li><li>unmodified  （提交后进入仓库的文件与当前文件相同，即没修过）</li><li>modified  (commit 之前)</li><li>staged  （commit 之后）</li></ul><h1 id="3-一般使用流程"><a href="#3-一般使用流程" class="headerlink" title="3. 一般使用流程"></a>3. 一般使用流程</h1><h4 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h4><ul><li><code>git init</code></li></ul><h4 id="变更的文件加入暂存区"><a href="#变更的文件加入暂存区" class="headerlink" title="变更的文件加入暂存区"></a>变更的文件加入暂存区</h4><ul><li><code>git add .</code></li></ul><h4 id="提交变更"><a href="#提交变更" class="headerlink" title="提交变更"></a>提交变更</h4><ul><li><code>git commit -m</code></li></ul><h4 id="查看commit日志-并返回某一次提交的版本"><a href="#查看commit日志-并返回某一次提交的版本" class="headerlink" title="查看commit日志, 并返回某一次提交的版本"></a>查看commit日志, 并返回某一次提交的版本</h4><ul><li><code>git log</code>   (### 弹出commit id)</li><li><code>git reset 7hdadsu2qe21e921821e --hard</code></li><li>如果想恢复最新的   <code>git  relog</code></li></ul><h4 id="从暂存区-移除某些文件（add-的文件有多余）"><a href="#从暂存区-移除某些文件（add-的文件有多余）" class="headerlink" title="从暂存区 移除某些文件（add 的文件有多余）"></a>从暂存区 移除某些文件（add 的文件有多余）</h4><ul><li><code>git reset &lt;fileName&gt;</code></li></ul><h1 id="4-分支合作管理"><a href="#4-分支合作管理" class="headerlink" title="4. 分支合作管理"></a>4. 分支合作管理</h1><ul><li>创建分支<ul><li><code>git checkout -b &lt;分支name&gt; &lt;template继承的commit,默认当前&gt;</code></li></ul></li><li>切换分支<ul><li><code>git checkout master</code></li></ul></li><li>查看所有分支<ul><li><code>git branch</code></li></ul></li><li>合并分支的变更（合并到当前master）<ul><li><code>git meger  branch-2</code></li><li>有冲突时，会提示======</li></ul></li></ul><h1 id="5-remote-仓库的使用"><a href="#5-remote-仓库的使用" class="headerlink" title="5. remote 仓库的使用"></a>5. remote 仓库的使用</h1><ul><li><p>下载远端仓库到本地</p><ul><li><code>git clone  ......git</code></li></ul></li><li><p>创建本地的分支</p><ul><li><code>git checkout -b local-A</code></li></ul></li><li><p>在远端仓库设置分支(第一次需要)</p><ul><li><code>git push -set-upstream origin local-A</code></li></ul></li><li><p>提交本地分支到远端</p><ul><li><code>git push</code></li></ul></li><li><p>第一次拉取远端仓库的分支，到本地</p><ul><li><code>git fetch</code>    </li><li><code>git checkout -b &lt;name&gt;</code>origin<code>&lt;template继承的commit,默认当前&gt;</code></li></ul></li><li><p>以后再从远端更新本地</p><ul><li><code>git pull</code> （自动fetch + merge）  </li></ul></li></ul><h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><ul><li><code>git merge</code></li><li><code>git pull</code></li><li><code>git fetch</code></li><li><code>git rebase</code> （版本合并时。。）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-git-的作用&quot;&gt;&lt;a href=&quot;#1-git-的作用&quot; class=&quot;headerlink&quot; title=&quot;1. git 的作用&quot;&gt;&lt;/a&gt;1. git 的作用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;版本控制&lt;/li&gt;
&lt;li&gt;协同开发&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 
      
    
    </summary>
    
      <category term="git" scheme="http://www.elgong.top/categories/git/"/>
    
    
      <category term="版本控制" scheme="http://www.elgong.top/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java集合-目录</title>
    <link href="http://www.elgong.top/2020/01/01/Java-%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84/"/>
    <id>http://www.elgong.top/2020/01/01/Java-集合结构/</id>
    <published>2020-01-01T08:10:40.000Z</published>
    <updated>2020-02-20T04:41:37.804Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/01/01/Java-集合结构/集合.png" alt="logo"></p><p>Java 集合类都在java.util包中，提供了如可变长数组，集合，队列，堆栈，链表等数据结构。<br>宏观上看整个结构可以分为两大部分： 属于单列集合Collection 接口和带映射的多列集合的Map接口。</p><ul><li><p><a href="www.elgong.top"><strong>Collection</strong></a> 接口：集合的基本操作和属性</p><ul><li><p><strong>List</strong> 接口：有序列表</p><ul><li><a href="www.elgong.top"><strong>ArrayList</strong></a>：  可变长的数组。 </li><li><a href="www.elgong.top"><strong>LinkedList</strong></a>： 双端队列的链表结构。 </li></ul></li><li><p><strong>Set</strong> 接口： 不重复元素的集合</p><ul><li><a href="www.elgong.top"><strong>HashSet</strong></a>： HashMap 实现的，无序。</li><li><a href="www.elgong.top"><strong>TreeSet</strong></a>：  HashMTree 实现的，有序。</li></ul></li><li><strong>Queue</strong> 接口： <ul><li><strong>Deque</strong> 接口：  <a href="www.elgong.top"><strong>LinkedList</strong></a></li></ul></li></ul></li><li><p><a href="http://zhuzhuyule.xyz" target="_blank" rel="noopener"><strong>Map</strong></a> 接口：key-value键值对的映射接口</p><ul><li><a href="http://zhuzhuyule.xyz" target="_blank" rel="noopener"><strong>HashMap</strong></a>：<em>数组+链表</em> 组成的哈希表，无序。</li><li><a href="http://zhuzhuyule.xyz" target="_blank" rel="noopener"><strong>TreeMap</strong></a>：基于 <em>红黑树的排序顺序</em> 存储键/值对，有序。</li><li><a href="http://zhuzhuyule.xyz" target="_blank" rel="noopener"><strong>Hashtable</strong></a>： HashMap类很相似，支持同步。</li></ul></li></ul><p><strong>两个工具类</strong>：</p><ul><li><strong>Arrays</strong></li><li><strong>Collections</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2020/01/01/Java-集合结构/集合.png&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;
&lt;p&gt;Java 集合类都在java.util包中，提供了如可变长数组，集合，队列，堆栈，链表等数据结构。&lt;br&gt;宏观上看整个结构可以分为两大部分： 属于单列集合C
      
    
    </summary>
    
      <category term="Java基础" scheme="http://www.elgong.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java集合" scheme="http://www.elgong.top/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础学习笔记</title>
    <link href="http://www.elgong.top/2019/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.elgong.top/2019/12/16/计算机基础学习笔记/</id>
    <published>2019-12-16T05:47:07.000Z</published>
    <updated>2020-03-23T06:07:04.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Computer-Basics-Notes-Links"><a href="#Computer-Basics-Notes-Links" class="headerlink" title="Computer-Basics-Notes-Links"></a>Computer-Basics-Notes-Links</h1><p><a href="https://github.com/elgong/Computer-Basics-Notes-Links" target="_blank" rel="noopener">github地址</a></p><h1 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h1><blockquote><p>我在学习计算机基础的过程中整理了一部分笔记，但都比较零散，有些稍微连贯的内容已经整理为博客，而大部分还没来得及整理成md格式，我先整理出链接。为了尽可能的清晰展示笔记脉络，下文将分门别类的列出，有需要请自取。<br>笔记内容大部分都是参考了网上的博客以及书籍，整理笔记的习惯也是刚刚养成的，从开始整理笔记后，发现自己对于做过的东西，能够随着笔记很快的回忆起来，遇到一些问题能够快速从笔记里找到答案也是比较舒服的。笔记是用有道云分享的，我未来仍然会继续梳理这些笔记，如果有任何的错误或者意见，麻烦您联系我哈。</p></blockquote><h2 id="1-计算机基础篇"><a href="#1-计算机基础篇" class="headerlink" title="1.计算机基础篇"></a>1.计算机基础篇</h2><blockquote><p>基础部分是一些语言相关的知识点。</p></blockquote><h3 id="1-1-Java-相关"><a href="#1-1-Java-相关" class="headerlink" title="1.1 Java 相关"></a>1.1 Java 相关</h3><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p><a href="http://note.youdao.com/noteshare?id=f869167b77cb73b67478290ffdcf45bc&amp;sub=06694CB1F00B45CBA1D4BD1A4B62320C" target="_blank" rel="noopener">Java面向对象-多态</a></p><h4 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h4><p><a href="http://note.youdao.com/noteshare?id=def11ef6e833a11434137d6fec1c834a&amp;sub=DD0083BFCFE14839A721700413B41F38" target="_blank" rel="noopener">java.lang.Object 类</a></p><p><a href="http://note.youdao.com/noteshare?id=fb941f5b4a01adf474496df328542a91&amp;sub=02C7EDC387984E3BADE744B9280EA1E6" target="_blank" rel="noopener">java.lang.Integer等基本类型包装类</a></p><h4 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h4><p><a href="http://note.youdao.com/noteshare?id=7bdd684a91766f6b448e5328f1fed251&amp;sub=0DEE02584D22485EACF337D5F846ACCE0" target="_blank" rel="noopener">接口和抽象类的概念</a></p><p><a href="http://note.youdao.com/noteshare?id=eb3b5e1f37828c301015c1fcc48b2ee9&amp;sub=B77DF9D467AE48948C63CEE6D7B51FB5" target="_blank" rel="noopener">java.io.Serializable接口</a></p><p><a href="http://note.youdao.com/noteshare?id=af26732dc5f501e490a3f57c6b46333c&amp;sub=1E9132AF928342728B68D66845201D05" target="_blank" rel="noopener">java.lang.AbstractStringBuilder</a></p><p><a href="http://note.youdao.com/noteshare?id=62429dcbeb51676d855b0c46d89ea67b&amp;sub=7D9CC78E517B46A19C567A567DDA0C1E" target="_blank" rel="noopener">java.lang.CharSequence接口</a></p><p><a href="http://note.youdao.com/noteshare?id=4309c54f9e557075dc953a25a1e9aea4&amp;sub=4AF6A4102AD6494F884069B5F75DB663" target="_blank" rel="noopener">java.lang.Comparable 接口</a></p><p><a href="http://note.youdao.com/noteshare?id=d7525d979bbcfac0ad602e0f90124a39&amp;sub=9B8E20EC1E924C988EB9DEC3C059FE4F" target="_blank" rel="noopener">java.lang.Iterable 接口</a></p><h4 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h4><p><a href="http://note.youdao.com/noteshare?id=3f13ce83c60473cb2d03ac7d500b3771&amp;sub=77608E57EC404A3D925D5BADFABA9F0C" target="_blank" rel="noopener">Java集合的结构</a></p><p><a href="http://note.youdao.com/noteshare?id=8d5718ecf80ea7c1cd144c848afb556f&amp;sub=D12BF9FEA9B54873871F5BDC532FB46A" target="_blank" rel="noopener">java.util.Arrays工具类</a></p><p><a href="http://note.youdao.com/noteshare?id=55f2b8f2004cc365aa3200283f918642&amp;sub=373C38673F3D4233869F2FA181CF6C77" target="_blank" rel="noopener">java.util.Collections 工具类</a></p><p><a href="http://note.youdao.com/noteshare?id=2d1b0ca8f6ee80acab26bac64e65752b&amp;sub=BC00717F11EC48DBAA3187C99E27FB67" target="_blank" rel="noopener">集合类之间的转换</a></p><h4 id="Collection"><a href="#Collection" class="headerlink" title="##### Collection"></a>##### Collection</h4><p><a href="http://note.youdao.com/noteshare?id=cf4402932c37eeda65d2cb48b771fa85&amp;sub=38A358238D644B009E8D35E85BC3958A" target="_blank" rel="noopener">java.util.Collection 接口</a></p><p><a href="http://note.youdao.com/noteshare?id=35066dabdc8838cbf4a81a6064d3a278&amp;sub=B08F3371DAF94E0A8577E14A355948F7" target="_blank" rel="noopener">java.util.List 接口</a></p><p><a href="http://note.youdao.com/noteshare?id=ac00534071924ed6812c3087ff89522d&amp;sub=7CF204D01C2846469F874ABE719F122E" target="_blank" rel="noopener">java.util.ArrayList 类</a></p><p><a href="http://note.youdao.com/noteshare?id=24e53ad8811d97e37ae725caef30e87c&amp;sub=3580B9F523B14B9A8346594FAB7428B7" target="_blank" rel="noopener">java.util.LinkedList 类</a></p><p><a href="http://note.youdao.com/noteshare?id=3fefcc71bac40f731582cda7de9680a9&amp;sub=FD48F85901CA48C2A1FDBFB356072932" target="_blank" rel="noopener">java.util.Vector类-线程安全</a></p><p><a href="http://note.youdao.com/noteshare?id=7ca967ab85ba51315d576614e4debb88&amp;sub=D7FB8F63F9524697A2B6C92EBC997759" target="_blank" rel="noopener">java.util.Stack类-线程安全</a></p><p><a href="http://note.youdao.com/noteshare?id=e69b12c5f34e8999a63f901e66cf6349&amp;sub=378BBC5185DD4901949BA8D6CC586117" target="_blank" rel="noopener">java.util.Queue 接口</a></p><p><a href="http://note.youdao.com/noteshare?id=70bcfde9362d131a6cc9769df7c6a195&amp;sub=4CCDF46A03F64701B726C3B5B17EE5C7" target="_blank" rel="noopener">java.util.Deque 接口</a></p><p><a href="http://note.youdao.com/noteshare?id=a8e52263383bbff56bba83c4437e62a5&amp;sub=273730F39B6345348B400731471932CD" target="_blank" rel="noopener">java.util.ArrayDeque 类</a></p><p><a href="http://note.youdao.com/noteshare?id=d5807c6cbb3dfcd1c6a6fa2587f2a53a&amp;sub=8DB19EF833FF477C8241702AB6C728D4" target="_blank" rel="noopener">java.util.PriorityQueue 类</a></p><p><a href="http://note.youdao.com/noteshare?id=78367406564a757c47fbb5fd74ab4118&amp;sub=CD2FAD0FE2EE433EAFEB76285A06D389" target="_blank" rel="noopener">java.util.Set 接口</a></p><p><a href="http://note.youdao.com/noteshare?id=473ccb760a498a837a6fca3373b1f6d1&amp;sub=EF96DCB65AD1431BBCFBB52F21896643" target="_blank" rel="noopener">java.util.HashSet 类</a></p><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p><a href="http://note.youdao.com/noteshare?id=8066dded44e4cba4a621fe78ed94c4a9&amp;sub=B9652D8B6D7940FFB5C92A5106BCC277" target="_blank" rel="noopener">java.util.Map 接口</a></p><p><a href="http://note.youdao.com/noteshare?id=de517d176afdc4e3d0c9887c437bee17&amp;sub=459B4CAF65FF4D67BFBE91DCED6E050E" target="_blank" rel="noopener">java.util.TreeMap 类</a></p><p><a href="http://note.youdao.com/noteshare?id=791e29ca757ab1dedb8f80d872c940b1&amp;sub=70D9B6BA82AF4889ACAD0A52F18C456D" target="_blank" rel="noopener">java.util.HashMap 类</a></p><p><a href="http://note.youdao.com/noteshare?id=473ccb760a498a837a6fca3373b1f6d1&amp;sub=EF96DCB65AD1431BBCFBB52F21896643" target="_blank" rel="noopener">java.util.HashSet 类</a></p><h4 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h4><p><a href="http://note.youdao.com/noteshare?id=658c32dde4ecf6c8525649914d0f8560&amp;sub=FF09583558E14D2BA25680647013CBA3" target="_blank" rel="noopener">标准步骤：</a></p><p><a href="http://note.youdao.com/noteshare?id=3dec994dd95a401eed7aabdfb1c5c15f&amp;sub=CAB6771BB0F044F895A705B8AB7514BC" target="_blank" rel="noopener">针对oj系统中的输入问题</a></p><p><a href="http://note.youdao.com/noteshare?id=1a496522d91fa47b4f3132aa97228ab7&amp;sub=CD032B0A9E714FE9ABB2BE05B49CEE75" target="_blank" rel="noopener">java IO之AutoCloseable接口</a></p><h4 id="多线程与并发"><a href="#多线程与并发" class="headerlink" title="多线程与并发"></a>多线程与并发</h4><p><a href="http://note.youdao.com/noteshare?id=b7407e24b468fd58df564afcbf749183&amp;sub=954EE84618B44B6FAFE4931E4F691873" target="_blank" rel="noopener">synchronized 锁的JVM中实现原理-偏向</a></p><p><a href="http://note.youdao.com/noteshare?id=0f69c79fd2c666de113882fd3ac72abf&amp;sub=61118765FB1F4B85B048C652460A5768" target="_blank" rel="noopener">线程的创建</a></p><p><a href="http://note.youdao.com/noteshare?id=49735f35157748a107270cb85fbb867c&amp;sub=0D34816A0AA24981B0B61EB87A64C8D4" target="_blank" rel="noopener">线程间的通信</a></p><p><a href="http://note.youdao.com/noteshare?id=12aac80f35ab764277a810af76852cb2&amp;sub=4A4D685F065F46B9B60D9703CEE04D29" target="_blank" rel="noopener">线程的生命周期</a></p><p><a href="http://note.youdao.com/noteshare?id=8d401fdafcc6c5712042fa06f6e3850b&amp;sub=96CD2BBFE5914F089493A803A5B7D020" target="_blank" rel="noopener">对象和变量的并发访问（可见性，原子性</a></p><p><a href="http://note.youdao.com/noteshare?id=ed1aa8d1cf7688f52c1598735165a2dc&amp;sub=15233B8FCFFB4E11AC6167CE4BF4077E" target="_blank" rel="noopener">java.util.concurrent.locks包 </a></p><p><a href="http://note.youdao.com/noteshare?id=291668d9a729451d6c913b3137c9640f&amp;sub=B28DDF08EC1F4457BFF740A9D8869FE5" target="_blank" rel="noopener">J.U.C多线程1-Executor 框架的梳理</a></p><p><a href="http://note.youdao.com/noteshare?id=5b0658b7d6383586ef61f9c80ef3d249&amp;sub=CE01D9FD424D45BCA78F88E1A0149C0D" target="_blank" rel="noopener">J.U.C多线程2-ThreadPoolExecutor线程</a></p><p><a href="http://note.youdao.com/noteshare?id=cb9e9ac4838bfdbb7e23f67711f2a84a&amp;sub=859FFFFB9E664A18BB2DBE355F094405" target="_blank" rel="noopener">实现BlockingQueue接口的阻塞队列</a></p><p><a href="http://note.youdao.com/noteshare?id=19714d2d692039c32ebba2ee3e4829e0&amp;sub=2F7585F44D7E4DBE84E9487A24766668" target="_blank" rel="noopener">J.U.C多线程3-CAS比较和交换 </a></p><p><a href="http://note.youdao.com/noteshare?id=6a89441511d69a3bced7209ba47b736b&amp;sub=4A1DC26FB09D4E0C9D6086E37FDEAD6B" target="_blank" rel="noopener">J.U.C多线程3-AQS 同步器框架的梳理</a></p><p><a href="http://note.youdao.com/noteshare?id=4ef9100e71f2628636a4bff9b73fe882&amp;sub=7998ABD160384F36A606B72FB7493232" target="_blank" rel="noopener">J.U.C多线程4-AQS框架的应用</a></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><a href="http://note.youdao.com/noteshare?id=d30458d5aac2da6b78824e51dbd982a5&amp;sub=1C451DD2DB6F4481AB58D42E0AA63C44" target="_blank" rel="noopener">泛型（泛型接口、泛型类、泛型方法）</a></p><p><a href="http://note.youdao.com/noteshare?id=d7092de3662bbf7b0d73b15313fbab0f&amp;sub=95A433A8DC2A4E6FBCF8B54D4767BC40" target="_blank" rel="noopener">字符串类型-String,StringBuilder..</a></p><p><a href="http://note.youdao.com/noteshare?id=9b7abb4a2896be59b9ed6629d028a5c6&amp;sub=4C6D630F214D45DCA01450F1907C6266" target="_blank" rel="noopener">java 编码规范- google</a></p><p><a href="http://note.youdao.com/noteshare?id=a3af60be0ecf53e817c4954ab4b3f2dd&amp;sub=80F0D1E1017E4522B63882A48BE17CF2" target="_blank" rel="noopener">Java8- Lambda 表达式</a></p><p><a href="http://note.youdao.com/noteshare?id=29117a52793f44078077602c6f47252f&amp;sub=9B5D88DF10A94DCD968EA4C8263241C9" target="_blank" rel="noopener">动手实现ArrayList</a></p><p><a href="http://note.youdao.com/noteshare?id=893e0088e06c4e3cd1073a6abeb7bda4&amp;sub=AE4EBC77232149368BEFD526D435B452" target="_blank" rel="noopener">java 知识点梳理</a></p><p><a href="http://note.youdao.com/noteshare?id=2b866c01ebed8c2f6594e3357ae349be&amp;sub=AA305E3F95724374B5A3C5D96D654270" target="_blank" rel="noopener">Java 刷题遇到的问题</a></p><p><a href="http://note.youdao.com/noteshare?id=7c544d8a0a428eb5c142c36e771c5fac&amp;sub=1DE4594384FD444F9C705D73C3A26556" target="_blank" rel="noopener">基本数据类型and 初始化</a></p><h4 id="jvm-虚拟机"><a href="#jvm-虚拟机" class="headerlink" title="jvm 虚拟机"></a>jvm 虚拟机</h4><p><a href="http://note.youdao.com/noteshare?id=4be4640b0d30a46e8e4936fca48fc4da&amp;sub=E4ACF7E445F4469FB7C49A184325AA3A" target="_blank" rel="noopener">jvm1-内存模型-运行时数据区</a></p><p><a href="http://note.youdao.com/noteshare?id=044b5c8d572a50aa43f7476075feacd6&amp;sub=CB5ACEE22D7C4B119E920A983456E348" target="_blank" rel="noopener">jvm2-类加载机制</a></p><p><a href="http://note.youdao.com/noteshare?id=38a77fc1b5541c7443a42bb8936ad699&amp;sub=AC6273A6423A45D49DF9D7BA2C02D087" target="_blank" rel="noopener">jvm3-对象的创建过程</a></p><p><a href="http://note.youdao.com/noteshare?id=85b9df0570061425d77cd09d542758a3&amp;sub=C25619379B2547F5A492FB6900FA53F9" target="_blank" rel="noopener">jvm4-垃圾回收机制 </a></p><p><a href="http://note.youdao.com/noteshare?id=3f927397764ecb9a72e25d53d1a8447e&amp;sub=DB8BF7AF904E4224A287A4B22D114460" target="_blank" rel="noopener">自定义类加载器实现热部署，热替换</a></p><h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><p><a href="http://note.youdao.com/noteshare?id=6f70c51df350a1da3b7353b5f0876ba1&amp;sub=A890AA4181A64A17B14D21040C1A9724" target="_blank" rel="noopener">反射</a></p><p><a href="http://note.youdao.com/noteshare?id=cfb346b9be695d57572367fd3143531e&amp;sub=DE178E988586406F87227AC75BD725CE" target="_blank" rel="noopener">Java 动态代理</a></p><h3 id="1-2-数据库相关"><a href="#1-2-数据库相关" class="headerlink" title="1.2 数据库相关"></a>1.2 数据库相关</h3><h4 id="数据库的安装"><a href="#数据库的安装" class="headerlink" title="数据库的安装"></a>数据库的安装</h4><p><a href="http://note.youdao.com/noteshare?id=eec529b536dfe09cbbb2d2305a9cec2c&amp;sub=DB98C14DBC15458ABE1B8461CD4C6988" target="_blank" rel="noopener">windwos 环境中 mysql 数据库安装</a></p><p><a href="http://note.youdao.com/noteshare?id=32e1a61698644f735e5ae33a0d285bee&amp;sub=WEB845b970c5cb400fcf42e04843dbd70af" target="_blank" rel="noopener">ubuntu 环境中 mysql 安装</a></p><h4 id="学习笔记-1"><a href="#学习笔记-1" class="headerlink" title="学习笔记"></a>学习笔记</h4><p><a href="http://note.youdao.com/noteshare?id=c98cc599b42b416ea2bd0aec7fd11fff&amp;sub=833E6D40B97E4F2F98EFD56C010FE4C7" target="_blank" rel="noopener">JDBC 使用</a></p><p><a href="http://note.youdao.com/noteshare?id=71dd174ad72a6cca26ae011637d4a705&amp;sub=E3BE9112006D4380953846BA1E446964" target="_blank" rel="noopener">mysql必知必会</a></p><p><a href="http://note.youdao.com/noteshare?id=4d74a6536781f195ffb428a0aa74fabe&amp;sub=9A407FE68AB54120B18950BEE5500BAF" target="_blank" rel="noopener">数据库-三大范式</a></p><p><a href="http://note.youdao.com/noteshare?id=78c16d370ba2bf4d06fd1d253072d582&amp;sub=6B15DEFDC24B4353A5820B68A5FB2C05" target="_blank" rel="noopener">数据库ER图基础</a></p><p><a href="http://note.youdao.com/noteshare?id=f0c534778c8fde528be10f4ffdb2c03b&amp;sub=336222838CDC4F249C1210E24D3701AD" target="_blank" rel="noopener">mysql必知必会1-DDL数据定义语言</a></p><p><a href="http://note.youdao.com/noteshare?id=360395368205af6b9cd43b67c17200af&amp;sub=3BAEE4ACEA0F4FC2A40AB4DC39965766" target="_blank" rel="noopener">mysql必知必会2-DML数据操作语句</a></p><p><a href="http://note.youdao.com/noteshare?id=3a8535b5bdf8fbe6b46b85a8f6ab707e&amp;sub=0C9D47245F604624A95E1982D45157F2" target="_blank" rel="noopener">mysql必知必会3-TCL事务控制语言</a></p><p><a href="http://note.youdao.com/noteshare?id=5a66c81500067c3bafc11fb31cc56cd6&amp;sub=6ADA92683A36438EB254D18AE729A6FA" target="_blank" rel="noopener">mysql必知必会4-数据类型和约束</a></p><p><a href="http://note.youdao.com/noteshare?id=8b1f73787548684951c21dea07576331&amp;sub=E95C55AAF40F4378B7A14176911B4B81" target="_blank" rel="noopener">mysql必知必会5-视图</a></p><p><a href="http://note.youdao.com/noteshare?id=d71e1773bdfb453b885ec8280980823e&amp;sub=B0AFAE28DCC94DF09AE25F420927921E" target="_blank" rel="noopener">mysql必知必会6-变量，存储过程，函数….</a></p><p><a href="http://note.youdao.com/noteshare?id=71dd174ad72a6cca26ae011637d4a705&amp;sub=E3BE9112006D4380953846BA1E446964" target="_blank" rel="noopener">mysql必知必会7</a></p><p>(<a href="http://note.youdao.com/noteshare?id=79d83c8dcc01b75a80003dceb059f72b&amp;sub=FE5D2429B49241419E96AD94536EB55C" target="_blank" rel="noopener">http://note.youdao.com/noteshare?id=79d83c8dcc01b75a80003dceb059f72b&amp;sub=FE5D2429B49241419E96AD94536EB55C</a>)</p><p><a href="http://note.youdao.com/noteshare?id=003c0cce526f2a71945614993d250377&amp;sub=56317DB968F04FE3BCC0D482D083C877" target="_blank" rel="noopener">索引优化1-索引的概念 </a></p><p><a href="http://note.youdao.com/noteshare?id=a527e1fa83cc6b429814c2f8710b891c&amp;sub=9B9BDA5A138144B5A5A5E5C4BE6CE1D1" target="_blank" rel="noopener">索引优化2-Mysql索引的底层实现 </a></p><p><a href="http://note.youdao.com/noteshare?id=f35d29b727ca3a228bfad4aac0a9e9e6&amp;sub=53F88FCDB69547E895DAD25A7D402035" target="_blank" rel="noopener">索引优化3- explain 查看执行计划 </a></p><p><a href="http://note.youdao.com/noteshare?id=a83b6505ac7dbb6b3c69afd1860b8ccb&amp;sub=C419B2D7DA254E589E0F449A60544A1C" target="_blank" rel="noopener">Sql语句优化-查询截取分析 </a></p><p><a href="http://note.youdao.com/noteshare?id=f8935a502a43186c1c821ad33ccc2c6d&amp;sub=5D286DE5F8304B8BA7290255DBF15C0C" target="_blank" rel="noopener">mysql-数据库锁的机制和原理 </a></p><h3 id="1-3-计算机网络相关"><a href="#1-3-计算机网络相关" class="headerlink" title="1.3 计算机网络相关"></a>1.3 计算机网络相关</h3><p><a href="http://note.youdao.com/noteshare?id=92e3adba9198d367e976bcc3f772d149&amp;sub=7F7B0D8B9F3E4D7996815384809C35EA" target="_blank" rel="noopener">互联网协议入门1-模型分层</a></p><p><a href="http://note.youdao.com/noteshare?id=8c41ad2717d4deee47f83841e49d755b&amp;sub=C0C042EE387F4A0096F427CE6F391887" target="_blank" rel="noopener">互联网协议入门2-访问网页的过程</a></p><p><a href="http://note.youdao.com/noteshare?id=e7f3f660c5df2335b7eccb7be89ce514&amp;sub=A775AFCC161A4388859120A340BDC6CB" target="_blank" rel="noopener">互联网协议入门3-TCP协议详细内容（传?..</a></p><p><a href="http://note.youdao.com/noteshare?id=71031b3ed61c6e8bd302a8577f6c396f&amp;sub=0F5DF1F408844E7184F3A6BB5F868F89" target="_blank" rel="noopener">互联网协议入门4-Http协议（应用层）.n…</a></p><h3 id="1-4-Python-相关"><a href="#1-4-Python-相关" class="headerlink" title="1.4 Python 相关"></a>1.4 Python 相关</h3><p><a href="http://note.youdao.com/noteshare?id=398da3b52370f6976e9a67cb3be4cd24&amp;sub=WEBf9be5147ccbf73c569b46bb2a5ffe942" target="_blank" rel="noopener">Anaconda 使用</a></p><p><a href="http://note.youdao.com/noteshare?id=a813207158a22cfa902dbeba640bdf87&amp;sub=E61484FE7B0D4D999DF1A462FA780049" target="_blank" rel="noopener">python 性能优化</a></p><p><a href="http://note.youdao.com/noteshare?id=dde4ed2eb6eea6c45926d251689e3d4e&amp;sub=4A1EA0D89E634DEC9DD294C13012EFCA" target="_blank" rel="noopener">python 内存管理</a></p><p><a href="http://note.youdao.com/noteshare?id=9146e0886cac1bdaec8cce2e5081cfe0&amp;sub=060F7616DF954602BB641EC52D0F6110" target="_blank" rel="noopener">python 包管理</a></p><p><a href="http://note.youdao.com/noteshare?id=3724fe43398de6c5fbd75dd8c452987e&amp;sub=7837405EB49045FF8C22156022261A94" target="_blank" rel="noopener">知识积累</a></p><p><a href="http://note.youdao.com/noteshare?id=bfbf2eb0c5bccf64974fe260e1bdf131&amp;sub=A8906CE9DF0E47F19377CD49BF2DFA6F" target="_blank" rel="noopener">python 数据模型</a></p><p><a href="http://note.youdao.com/noteshare?id=0f7309f661031855b1e257072ceab9b9&amp;sub=E6CAEE5B6F7043779DF1F3A95923DC0F" target="_blank" rel="noopener">Set 集合  交并差运算</a></p><h4 id="pandas-包"><a href="#pandas-包" class="headerlink" title="pandas 包"></a>pandas 包</h4><p><a href="http://note.youdao.com/noteshare?id=f191fc11a263f303532d40c02c1f2161&amp;sub=3F6F9858E4DA4B7A9245F66557B15AB4" target="_blank" rel="noopener">pandas</a></p><p><a href="http://note.youdao.com/noteshare?id=57496ba2051b12d778ac17612d871354&amp;sub=62AE7AB578AF4B3A9D630676179C8CA0" target="_blank" rel="noopener">pandas-5缺失值处理</a></p><p><a href="http://note.youdao.com/noteshare?id=7b8a86d71c5321171292fa000666efc8&amp;sub=A1102303D97F4E2D836A588F4882C5E2" target="_blank" rel="noopener">pandas-2索引和选择数据</a></p><p><a href="http://note.youdao.com/noteshare?id=02c6e6a9916d2f600153fa5402395c29&amp;sub=0CF2D73FB22140A29F3838CF6EF299B9" target="_blank" rel="noopener">pandas-分层和多级索引</a></p><p><a href="http://note.youdao.com/noteshare?id=f16646b876ddb2c5ec482e316ca881dd&amp;sub=8024BDCE94B4455FA20514234C7233C0" target="_blank" rel="noopener">pandas-6重复值处理</a></p><p><a href="http://note.youdao.com/noteshare?id=5210591266c5f2472eab6bdb0e1adc7e&amp;sub=7B85239BB0C74343830F3EBBC34F43A0" target="_blank" rel="noopener">pandas-7时间处理</a></p><p><a href="http://note.youdao.com/noteshare?id=b8d6c15c3d603261cee9b6771732c5a5&amp;sub=WEB9f17e5d4ecb0520c9c27c8145f3450dc" target="_blank" rel="noopener">pandas-4分组与聚合</a></p><p><a href="http://note.youdao.com/noteshare?id=64c2febf14a2e0f96bcbc868375500b9&amp;sub=0B21232330E442118F68ADFB44DECA6E" target="_blank" rel="noopener">pandas-1数据结构</a></p><h3 id="1-5-数据结构与算法相关"><a href="#1-5-数据结构与算法相关" class="headerlink" title="1.5 数据结构与算法相关"></a>1.5 数据结构与算法相关</h3><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p><a href="http://note.youdao.com/noteshare?id=77d45fd3df6dc9821a505972246afc67&amp;sub=CBBC8BE4E72147248464A2C136D8A893" target="_blank" rel="noopener">链表入门-单链表</a></p><p><a href="http://note.youdao.com/noteshare?id=2038af6c36c144a0005d3f7cb7cbd6e1&amp;sub=19BC0DEA04654C51970F77E363746D36" target="_blank" rel="noopener">双向链表</a></p><h4 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h4><p>[树结构1-二叉树的种类 </p><p>](<a href="http://note.youdao.com/noteshare?id=3d87798249099424c8f688932e054d34&amp;sub=962de575938af485eb5896712a3fa88bhttp://note.youdao.com/noteshare?id=3d87798249099424c8f688932e054d34&amp;sub=962de575938af485eb5896712a3fa88b" target="_blank" rel="noopener">http://note.youdao.com/noteshare?id=3d87798249099424c8f688932e054d34&amp;sub=962de575938af485eb5896712a3fa88bhttp://note.youdao.com/noteshare?id=3d87798249099424c8f688932e054d34&amp;sub=962de575938af485eb5896712a3fa88b</a>)</p><p><a href="http://note.youdao.com/noteshare?id=a93bf51802eb22ed23e7f01baeecdfd9&amp;sub=C2561C42F8354E2787F3F58DC19CC2F5" target="_blank" rel="noopener">树结构2-二叉树的四种遍历</a></p><p><a href="http://note.youdao.com/noteshare?id=6595e3f3a04494d53c79ac4f14156b45&amp;sub=36364C54AB334D5B85B1871D6758FFF7" target="_blank" rel="noopener">树结构3- 二叉排序树 </a></p><p><a href="http://note.youdao.com/noteshare?id=ff1c7f5f5c5439a5bcf29746bafacd8e&amp;sub=524DD42459CF4A43AB7CD89A74D83BAB" target="_blank" rel="noopener">树结构4- 完全二叉树-堆排序 </a></p><p><a href="http://note.youdao.com/noteshare?id=28a1554677d3108539d237ed2dbfb3a9&amp;sub=6917ECACABFC4BE99B0840940E1492C3" target="_blank" rel="noopener">树结构5-红黑树 </a></p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p><a href="http://note.youdao.com/noteshare?id=32bb87989cc88c68f94b697a2309e577&amp;sub=CB4F1BAE4B48482B895E4B334EC920B7" target="_blank" rel="noopener">栈 - Stack</a></p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p><a href="http://note.youdao.com/noteshare?id=2bf63868f3e17320b15a68783a6f1d89&amp;sub=35032594A3AB441EB7DB3344B71213EF" target="_blank" rel="noopener">动态规划-DP</a></p><p><a href="http://note.youdao.com/noteshare?id=47da45a5509c7f21f5905c65ec87c12d&amp;sub=E525698B083343B382EFC767181A2755" target="_blank" rel="noopener">DFS和回溯算法- 暴力搜索的优化方案</a></p><h4 id="一般算法"><a href="#一般算法" class="headerlink" title="一般算法"></a>一般算法</h4><p><a href="http://note.youdao.com/noteshare?id=6139197ff7cc443d83b73f578ced01d2&amp;sub=3671B7672DA341359DF0C57DAA5114E3" target="_blank" rel="noopener">二分查找</a></p><p><a href="http://note.youdao.com/noteshare?id=417cd36012151f1465f6b179a68c2559&amp;sub=39B0B9975CC34C589CCCF7A4A619E921" target="_blank" rel="noopener">最大公约数与最小公倍数</a></p><p><a href="http://note.youdao.com/noteshare?id=b9bb5b1c7a7f968392ca087beb53a288&amp;sub=7AC07884471A4FFBAC433400CC8DD668" target="_blank" rel="noopener">素数和合数</a></p><p><a href="http://note.youdao.com/noteshare?id=900f90e3d481dcabbd5ce22df8452e4b&amp;sub=2A9F48EDC9824721A63091F213AE84DF" target="_blank" rel="noopener">排序算法-Java版</a></p><h3 id="1-6-设计模式"><a href="#1-6-设计模式" class="headerlink" title="1.6 设计模式"></a>1.6 设计模式</h3><p><a href="http://note.youdao.com/noteshare?id=9b725da8bd83d6d2fa6628449036fa76&amp;sub=61D7D7C472CC4F6FA40978D2EEE3F253" target="_blank" rel="noopener">单例模式</a></p><p><a href="http://note.youdao.com/noteshare?id=3258d6710e66d885a3a213d45eea14be&amp;sub=9E8B81697FD248EDBAAB8B203ACDD4B9" target="_blank" rel="noopener">汇总 </a></p><h2 id="2-计算机提高篇"><a href="#2-计算机提高篇" class="headerlink" title="2 计算机提高篇"></a>2 计算机提高篇</h2><blockquote><p>提高篇是一些具体的学习方向，我学的比较杂。</p></blockquote><h3 id="2-1-机器学习与数据挖掘"><a href="#2-1-机器学习与数据挖掘" class="headerlink" title="2.1 机器学习与数据挖掘"></a>2.1 机器学习与数据挖掘</h3><p><a href="http://note.youdao.com/noteshare?id=a2a581480ef2d48c22c8972e2c1289ea&amp;sub=WEBe5a19e45418f24614a27d5c871dbeef6" target="_blank" rel="noopener">特征工程中的问题</a></p><h4 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h4><p><a href="http://note.youdao.com/noteshare?id=72d77f019bd4fc8cde5d77f1479213a3&amp;sub=3A0C8DB3DE554ED5B70179B18DEBDB6F" target="_blank" rel="noopener">决策树-1基本概念</a></p><p><a href="http://note.youdao.com/noteshare?id=6b4b7d196688d64889da3563eb4b194d&amp;sub=E48B826F34CB41769382CA5DD11DE54F" target="_blank" rel="noopener">决策树-2 ID3算法</a></p><p><a href="http://note.youdao.com/noteshare?id=51ba5d9d9611ae2284c2612d5f38b721&amp;sub=C40D67A492D4428EB698D146897932F2" target="_blank" rel="noopener">决策树-3 CART分类回归树</a></p><p><a href="http://note.youdao.com/noteshare?id=8fd42b53e1a611131199f17d399820c7&amp;sub=F7FA6EBCE1CC4A95875DD83B2CF9C551" target="_blank" rel="noopener">CART 分类回归树</a></p><p><a href="http://note.youdao.com/noteshare?id=d5d006e5d1680bb1b93f6cdc68973b60&amp;sub=C12A5DC3350C49CA8862D51287908CE4" target="_blank" rel="noopener">sklearn 决策树使用技巧</a></p><p><a href="http://note.youdao.com/noteshare?id=3a209c356ed655acacf08699cef27150&amp;sub=E0880A97A8264449BD714025A98BFE52" target="_blank" rel="noopener">sklearn整理-决策树</a></p><h4 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h4><p><a href="http://note.youdao.com/noteshare?id=d1d1a974ade3ab72cd8ff9fbab061e78&amp;sub=6C8F11DB78FA417AA9F4D0DA30351077" target="_blank" rel="noopener">常见的神经网络</a></p><h4 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h4><p><a href="http://note.youdao.com/noteshare?id=fb4b442794aac472bdd7663b026a2dab&amp;sub=939B2AAEB6F94E32ABAD4A54B8AF1358" target="_blank" rel="noopener">集成学习提升算法-Adaboost</a></p><p><a href="http://note.youdao.com/noteshare?id=eb03f9b12281363b052e0ed071833b13&amp;sub=WEBb2a9d589fb05754f76c2b2af09a826c1" target="_blank" rel="noopener">XGBoost -python package introduction</a></p><p><a href="http://note.youdao.com/noteshare?id=2039180d0a9ad5b39339c93e8c70040d&amp;sub=9C48D93E6A1E4C1186E6F37EF222F528" target="_blank" rel="noopener">梯度提升树-GBDT</a></p><p><a href="http://note.youdao.com/noteshare?id=e4ac54bae64eb94641594ad5f4a2cd6d&amp;sub=8232CAC65C0A4FDC9EDED033B6A4770F" target="_blank" rel="noopener">sklearn整理-集成学习-随机森林</a></p><h4 id="模型评价"><a href="#模型评价" class="headerlink" title="模型评价"></a>模型评价</h4><p><a href="http://note.youdao.com/noteshare?id=c76dbbe346dbd32a62cd4303f7bf4864&amp;sub=753D4CFE21084BA78B0506697A415A0C" target="_blank" rel="noopener">ROC与AUC</a></p><p><a href="http://note.youdao.com/noteshare?id=030f5d8884e6a0914891ebf2289318fa&amp;sub=28D75EDB51044316AB154021B0EB6BEA" target="_blank" rel="noopener">机器学习的方差与偏差</a></p><h4 id="参与的一些竞赛"><a href="#参与的一些竞赛" class="headerlink" title="参与的一些竞赛"></a>参与的一些竞赛</h4><p><a href="http://note.youdao.com/noteshare?id=1d8176b82fc84b0a3906fbd53979041c&amp;sub=305B25CE269F45DCA311DBE8C20DAF67" target="_blank" rel="noopener">ali-新人实战赛o2o优惠券使用预测</a></p><p><a href="http://note.youdao.com/noteshare?id=5b2fa1c8320743190649812b394b3ed5&amp;sub=27291314B2C74B09ABF8619277EE8A5E" target="_blank" rel="noopener">ccf-2019</a></p><p><a href="http://note.youdao.com/noteshare?id=52c517d38463d99b24672f0195ecabfe&amp;sub=WEBf24a84a951b3b16a0685ed029a28b960" target="_blank" rel="noopener">dc-2019-商品购买转化率预测</a></p><p><a href="http://note.youdao.com/noteshare?id=2fd9687a7cb8c10210bf738536dd8021&amp;sub=AE7E1B49101546F093C7C2B993A736A3" target="_blank" rel="noopener">竞赛提升方法-tricks</a></p><p><a href="http://note.youdao.com/noteshare?id=f43a977d8705582da02c202f295dadcc&amp;sub=74C22A94ABB74B309807A886F50A5863" target="_blank" rel="noopener">sklearn 脑图</a></p><h3 id="2-2-大数据与Hadoop"><a href="#2-2-大数据与Hadoop" class="headerlink" title="2.2 大数据与Hadoop"></a>2.2 大数据与Hadoop</h3><h4 id="多台机器的分布式环境安装"><a href="#多台机器的分布式环境安装" class="headerlink" title="多台机器的分布式环境安装"></a>多台机器的分布式环境安装</h4><p><a href="http://note.youdao.com/noteshare?id=e284c332fb9766d6487d925c4381ae22&amp;sub=E4980D34F8A347DC9C1E2C23C5A48D17" target="_blank" rel="noopener">1.hadoop分布式集群安装</a></p><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p><a href="http://note.youdao.com/noteshare?id=773c4878eaec8cc266c5074691a3d780&amp;sub=68CE094D754C46CDA96C8CFA00401DF2" target="_blank" rel="noopener">Hadoop RPC</a></p><h4 id="mapreduce-实验"><a href="#mapreduce-实验" class="headerlink" title="mapreduce 实验"></a>mapreduce 实验</h4><p><a href="http://note.youdao.com/noteshare?id=710757567d678841cb43e891531c63b9&amp;sub=BA97FAC420754425A2FE07E67D6B6EAD" target="_blank" rel="noopener">实验1.  多表关联</a></p><p><a href="http://note.youdao.com/noteshare?id=7c251c3514764eb58fdad72de78bf6a5&amp;sub=FF9F53C4D1A04E008FA61A85A9CE0F01" target="_blank" rel="noopener">实验2.  最高温度统计</a></p><p><a href="http://note.youdao.com/noteshare?id=226bf0abd5e44ed6eae69f5250024bcf&amp;sub=5EE9A40650BB4AD2A661C65DFBC57FC5" target="_blank" rel="noopener">实验3.  单表关联</a></p><h3 id="2-3-VUE"><a href="#2-3-VUE" class="headerlink" title="2.3 VUE"></a>2.3 VUE</h3><h4 id="VUE-安装"><a href="#VUE-安装" class="headerlink" title="VUE 安装"></a>VUE 安装</h4><p><a href="http://note.youdao.com/noteshare?id=c60a733187bef04fa0404429eb2d1f30&amp;sub=3F4FE35DF8E349A395F8C4C19AA7BBE4" target="_blank" rel="noopener">开发环境搭建</a></p><h3 id="2-4-Spring-框架"><a href="#2-4-Spring-框架" class="headerlink" title="2.4 Spring 框架"></a>2.4 Spring 框架</h3><p><a href="http://note.youdao.com/noteshare?id=7181c4a539cade23a864c8e970b05833&amp;sub=771654DC28474896BAB711DD289A052C" target="_blank" rel="noopener">Spring-1控制反转（IOC）和依赖注入</a></p><p><a href="http://note.youdao.com/noteshare?id=32da7b7e487b45fd4fde7906fb9436a1&amp;sub=BAF8F0AE43DB42B399AC14B01FE74689" target="_blank" rel="noopener">Spring-2AOP 面向切面编程-基于动态代</a></p><p><a href="http://note.youdao.com/noteshare?id=2caa6adcf719adaba44ad57fcad131e4&amp;sub=8E30EF145E8A4972867B5476DF2DD607" target="_blank" rel="noopener">Spring-3事务管理Transaction Manager</a></p><h2 id="3-工具使用"><a href="#3-工具使用" class="headerlink" title="3. 工具使用"></a>3. 工具使用</h2><p><a href="http://note.youdao.com/noteshare?id=82f292615812b23fec6c7ce9fcc35ec4&amp;sub=6FC7D088767948388F03769F13A2C971" target="_blank" rel="noopener">vscode 使用记录</a></p><h2 id="4-收藏的书籍"><a href="#4-收藏的书籍" class="headerlink" title="4. 收藏的书籍"></a>4. 收藏的书籍</h2><p><a href="http://note.youdao.com/noteshare?id=57e1d26f1f078dc70a5b18392b29a841" target="_blank" rel="noopener">书籍收藏</a></p><p><a href="http://note.youdao.com/noteshare?id=57e1d26f1f078dc70a5b18392b29a841" target="_blank" rel="noopener">http://note.youdao.com/noteshare?id=57e1d26f1f078dc70a5b18392b29a841</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Computer-Basics-Notes-Links&quot;&gt;&lt;a href=&quot;#Computer-Basics-Notes-Links&quot; class=&quot;headerlink&quot; title=&quot;Computer-Basics-Notes-Links&quot;&gt;&lt;/a&gt;Compu
      
    
    </summary>
    
      <category term="计算机基础梳理" scheme="http://www.elgong.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/"/>
    
    
      <category term="学习笔记" scheme="http://www.elgong.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>决策树2-ID3算法</title>
    <link href="http://www.elgong.top/2019/09/12/%E5%86%B3%E7%AD%96%E6%A0%912-ID3%E7%AE%97%E6%B3%95/"/>
    <id>http://www.elgong.top/2019/09/12/决策树2-ID3算法/</id>
    <published>2019-09-12T11:04:01.000Z</published>
    <updated>2020-02-20T04:41:37.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="决策树-2-ID3算法"><a href="#决策树-2-ID3算法" class="headerlink" title="决策树-2 ID3算法"></a>决策树-2 ID3算法</h1><blockquote><p>决策树-1基本概念中已经提到了ID3算法，这篇博客再梳理一遍，算法描述部分搬运了统计学习方法的内容，更详细内容可以参考这本书。</p></blockquote><h3 id="ID3-算法的思路"><a href="#ID3-算法的思路" class="headerlink" title="ID3 算法的思路"></a>ID3 算法的思路</h3><ul><li>输入：训练集 <code>D</code>, 特征集 <code>A</code>， 阈值 <code>ε</code>；</li><li>分叉：最优属性划分依据是<font color="#FF0000"> 最大信息增益；</font> </li><li>结束条件：用完所有特征，特征信息增益很小，树的深度超过限制；</li><li>返回：一颗树<code>T</code>。</li></ul><h3 id="ID3-算法描述"><a href="#ID3-算法描述" class="headerlink" title="ID3 算法描述"></a>ID3 算法描述</h3><blockquote><p>这里的描述可作为编程实现时的指导，树的建立过程是递归实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ID3Tree</span><span class="params">(D, A，ε )</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>  D 的实例属于同类别 K ||  特征集 A 特征空:</span><br><span class="line">    </span><br><span class="line">        <span class="number">1.</span> 决策树 T为单结点树</span><br><span class="line">        <span class="number">2.</span> 标记类别 K (数量最多的类别)</span><br><span class="line">        <span class="keyword">return</span>  T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="number">1.</span> 计算所有特征相对于 D 的信息增益</span><br><span class="line">        <span class="number">2.</span> 找到信息增益最大特征 Amax</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> Amax  小于 阈值 ε:</span><br><span class="line">            <span class="number">1.</span> 决策树 T为单结点树</span><br><span class="line">            <span class="number">2.</span> 标记类别 K (数量最多的类别)</span><br><span class="line">            <span class="keyword">return</span>  T</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            依照特征 Amax 的每一个取值 ai，划分数据集Di, 并且标记Di类别，构建子节点</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 递归</span></span><br><span class="line">            对每个结点Di，以Di为训练集， A-Amax为特征集，递归调用 ID3Tree()</span><br><span class="line">            <span class="keyword">return</span> 由结点和子结点构成的树</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;决策树-2-ID3算法&quot;&gt;&lt;a href=&quot;#决策树-2-ID3算法&quot; class=&quot;headerlink&quot; title=&quot;决策树-2 ID3算法&quot;&gt;&lt;/a&gt;决策树-2 ID3算法&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;决策树-1基本概念中已经提到了ID3算法，
      
    
    </summary>
    
      <category term="机器学习方法" scheme="http://www.elgong.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="ID3" scheme="http://www.elgong.top/tags/ID3/"/>
    
  </entry>
  
  <entry>
    <title>决策树3-CART分类回归树</title>
    <link href="http://www.elgong.top/2019/09/12/%E5%86%B3%E7%AD%96%E6%A0%913-CART%E5%88%86%E7%B1%BB%E5%9B%9E%E5%BD%92%E6%A0%91/"/>
    <id>http://www.elgong.top/2019/09/12/决策树3-CART分类回归树/</id>
    <published>2019-09-12T10:58:19.000Z</published>
    <updated>2020-02-20T04:41:37.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CART-分类回归树"><a href="#CART-分类回归树" class="headerlink" title="CART-分类回归树"></a>CART-分类回归树</h1><h3 id="CART-算法的思路"><a href="#CART-算法的思路" class="headerlink" title="CART 算法的思路"></a>CART 算法的思路</h3><blockquote><p>特征选择：最优属性划分依据是<font color="#FF0000"> 基尼系数（分类）/平方误差（回归）；</font> </p><p>CART 树是二叉树结构。</p></blockquote><p>主要就两步骤：</p><ol><li>树的生成 </li><li>树的剪枝</li></ol><h3 id="分类树"><a href="#分类树" class="headerlink" title="分类树"></a>分类树</h3><blockquote><p>分类树与ID3, C4.5的流程一致。</p></blockquote><h3 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h3><blockquote><p>回归树选择最佳划分属性和划分点时的依据是 <code>平方误差</code>。</p></blockquote><p>一张图即可理解。</p><p><img src="/2019/09/12/决策树3-CART分类回归树/CART.png" alt="logo"></p><p>与分类树的主要区别是选择最佳属性的评价指标变了。根据最小化均方误差的原则选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CART-分类回归树&quot;&gt;&lt;a href=&quot;#CART-分类回归树&quot; class=&quot;headerlink&quot; title=&quot;CART-分类回归树&quot;&gt;&lt;/a&gt;CART-分类回归树&lt;/h1&gt;&lt;h3 id=&quot;CART-算法的思路&quot;&gt;&lt;a href=&quot;#CART-算法的思路&quot;
      
    
    </summary>
    
      <category term="机器学习方法" scheme="http://www.elgong.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="CART树" scheme="http://www.elgong.top/tags/CART%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>pandas-8分层和多级索引</title>
    <link href="http://www.elgong.top/2019/08/13/pandas-%E5%88%86%E5%B1%82%E5%92%8C%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95/"/>
    <id>http://www.elgong.top/2019/08/13/pandas-分层和多级索引/</id>
    <published>2019-08-13T02:54:12.000Z</published>
    <updated>2020-02-20T04:41:37.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pandas-8-分层和多级索引"><a href="#pandas-8-分层和多级索引" class="headerlink" title="pandas -8 分层和多级索引"></a>pandas -8 分层和多级索引</h1><blockquote><p>Multi-level indexing. 在 “<a href="http://www.elgong.top/2019/07/25/pandas-%E7%B4%A2%E5%BC%95%E5%92%8C%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE/">pandas -2 索引和选择数据</a>” 一节中, 已经提到了如何选择行列元素, 而Series 和 Dataframe 是低维度的数据结构，对于更高维度的数据，可以通过分层和多级索引来实现。</p></blockquote><h2 id="分层索引的创建"><a href="#分层索引的创建" class="headerlink" title="分层索引的创建"></a>分层索引的创建</h2><blockquote><p>创建分层索引的方式有很多, 这里直接摘抄自官方的文档，可以通过元组，列表，Dataframe, arrays 等方式生成分层索引。</p><p>同时要知道，通过 groupby 分组操作之后得到的也是这种分层结构。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    //  1. 元组</span><br><span class="line">In: </span><br><span class="line"></span><br><span class="line">    arrays = [[&apos;bar&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;baz&apos;, &apos;foo&apos;, &apos;foo&apos;,&apos;qux&apos;, &apos;qux&apos;], [&apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;]]</span><br><span class="line">    tuples = list(zip(*arrays))</span><br><span class="line">Out: </span><br><span class="line">    [(&apos;bar&apos;, &apos;one&apos;),</span><br><span class="line">     (&apos;bar&apos;, &apos;two&apos;),</span><br><span class="line">     (&apos;baz&apos;, &apos;one&apos;),</span><br><span class="line">     (&apos;baz&apos;, &apos;two&apos;),</span><br><span class="line">     (&apos;foo&apos;, &apos;one&apos;),</span><br><span class="line">     (&apos;foo&apos;, &apos;two&apos;),</span><br><span class="line">     (&apos;qux&apos;, &apos;one&apos;),</span><br><span class="line">     (&apos;qux&apos;, &apos;two&apos;)]</span><br><span class="line"></span><br><span class="line">In:</span><br><span class="line">    index = pd.MultiIndex.from_tuples(tuples, names=[&apos;first&apos;, &apos;second&apos;])</span><br><span class="line">    df = pd.Series(np.random.randn(8), index=index)</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">    first  second</span><br><span class="line">    bar    one       0.469112</span><br><span class="line">           two      -0.282863</span><br><span class="line">    baz    one      -1.509059</span><br><span class="line">           two      -1.135632</span><br><span class="line">    foo    one       1.212112</span><br><span class="line">           two      -0.173215</span><br><span class="line">    qux    one       0.119209</span><br><span class="line">           two      -1.044236</span><br><span class="line">    dtype: float64</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 2. dataftame</span><br><span class="line">    </span><br><span class="line">    index = pd.MultiIndex.from_frame(df)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 3. arrays</span><br><span class="line">    </span><br><span class="line">In: </span><br><span class="line">    arrays = [np.array([&apos;bar&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;baz&apos;, &apos;foo&apos;, &apos;foo&apos;, &apos;qux&apos;, &apos;qux&apos;]),</span><br><span class="line">              np.array([&apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;])]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     s = pd.Series(np.random.randn(8), index=arrays)</span><br></pre></td></tr></table></figure><h2 id="从DataFrame-产生-MultiIndex"><a href="#从DataFrame-产生-MultiIndex" class="headerlink" title="从DataFrame 产生 MultiIndex"></a>从DataFrame 产生 MultiIndex</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = df.set_index([&apos;col1&apos;,&apos;col2&apos;])</span><br></pre></td></tr></table></figure><h2 id="MultiIndex-转化成-列"><a href="#MultiIndex-转化成-列" class="headerlink" title="MultiIndex 转化成 列"></a>MultiIndex 转化成 列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = df.reset_index()</span><br></pre></td></tr></table></figure><h2 id="选择不同层"><a href="#选择不同层" class="headerlink" title="选择不同层"></a>选择不同层</h2><blockquote><p>查看不同层的索引值。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In:</span><br><span class="line">    index.get_level_values(0)</span><br><span class="line">    </span><br><span class="line">    index.get_level_values(&quot;name&quot;)</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">    Index([&apos;bar&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;baz&apos;, &apos;foo&apos;, &apos;foo&apos;, &apos;qux&apos;, &apos;qux&apos;], dtype=&apos;object&apos;, name=&apos;first&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>根据不同层索引</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df[&quot;bar&quot;]</span><br><span class="line">df[&quot;one&quot;]</span><br><span class="line">df[&quot;bar&quot;][&quot;one&quot;]</span><br><span class="line"></span><br><span class="line">// 元组</span><br><span class="line">df.loc[(&apos;bar&apos;, &apos;two&apos;)]</span><br></pre></td></tr></table></figure><font color="0xff111">  注意, 切片时不会改变 多层索引。 </font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pandas-8-分层和多级索引&quot;&gt;&lt;a href=&quot;#pandas-8-分层和多级索引&quot; class=&quot;headerlink&quot; title=&quot;pandas -8 分层和多级索引&quot;&gt;&lt;/a&gt;pandas -8 分层和多级索引&lt;/h1&gt;&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="pandas系列教程" scheme="http://www.elgong.top/categories/pandas%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="pandas-MultiIndex" scheme="http://www.elgong.top/tags/pandas-MultiIndex/"/>
    
  </entry>
  
  <entry>
    <title>mysql-索引篇2-索引的底层实现</title>
    <link href="http://www.elgong.top/2019/08/12/mysql-%E7%B4%A2%E5%BC%95%E7%AF%872-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.elgong.top/2019/08/12/mysql-索引篇2-索引的底层实现/</id>
    <published>2019-08-12T03:02:57.000Z</published>
    <updated>2020-04-11T03:09:33.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、常用的索引底层结构有哪些？"><a href="#一、常用的索引底层结构有哪些？" class="headerlink" title="一、常用的索引底层结构有哪些？"></a>一、常用的索引底层结构有哪些？</h1><p>==<strong>索引是一种排序的，便于查找的数据结构。</strong>==</p><p>下面是一些常见数据结构的概念，具体每种类型的详细特点，再去看别的文档吧。</p><h2 id="1-二叉查找树："><a href="#1-二叉查找树：" class="headerlink" title="1. 二叉查找树："></a><strong>1. 二叉查找树：</strong></h2><p>​        左子树的键值小于根的键值，右子树的键值大于根的键值。</p><h2 id="2-AVL-树："><a href="#2-AVL-树：" class="headerlink" title="2. AVL 树："></a><strong>2. AVL 树：</strong></h2><p>​       平衡二叉树（AVL 树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为 1。</p><h2 id="3-红黑树："><a href="#3-红黑树：" class="headerlink" title="3. 红黑树："></a><strong>3. 红黑树：</strong></h2><p>​      每个节点都带有颜色属性的二叉查找树。</p><h2 id="4-平衡多路查找树（M阶的-B树）："><a href="#4-平衡多路查找树（M阶的-B树）：" class="headerlink" title="4. 平衡多路查找树（M阶的 B树）："></a><strong>4. 平衡多路查找树（M阶的 B树）：</strong></h2><h2 id="为磁盘等外存储设备设计的一种平衡查找树。"><a href="#为磁盘等外存储设备设计的一种平衡查找树。" class="headerlink" title="为磁盘等外存储设备设计的一种平衡查找树。"></a><strong>为磁盘等外存储设备设计的一种平衡查找树。</strong></h2><ul><li>每个节点最多有<strong>m-1个关键字</strong>（可以存有的键值对）。</li><li>根节点最少可以只有1个<strong>关键字</strong>。</li><li>非根节点至少有m/2个<strong>关键字</strong>。</li><li>每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li><li>所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。</li><li>==<strong>每个节点都存有索引和数据，也就是对应的key和value。</strong>==</li><li>==<strong>数据库中的节点 value 其实是指针。。</strong>==</li></ul><h2 id="5-B-树："><a href="#5-B-树：" class="headerlink" title="5. B+树："></a><strong>5. B+树：</strong></h2><p>B+树其实和B树是非常相似的，我们首先看看<strong>相同点</strong>。</p><ul><li>根节点至少一个元素</li><li>非根节点元素范围：m/2 &lt;= k &lt;= m-1</li></ul><p><strong>不同点</strong>：</p><ul><li>B+树有两种类型的节点：==<strong>内部节点不存储数据，只存储索引，数据都存储在叶子节点。</strong>==</li><li>内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。<strong>叶子结点中的记录也按照key的大小排列</strong>。</li><li>每个叶子结点都存有相邻叶子结点的指针，<strong>叶子结点本身依关键字的大小自小而大顺序链接。</strong></li><li><strong>父节点存有右孩子的第一个元素的索引</strong>。</li></ul><p><img src="https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/35C585A0A1CA45A48325427D3856F495/25313" alt="img"></p><h1 id="二、Mysql-的两种存储引擎的索引"><a href="#二、Mysql-的两种存储引擎的索引" class="headerlink" title="二、Mysql 的两种存储引擎的索引"></a>二、Mysql 的两种存储引擎的索引</h1><p>文档主要介绍 MyISAM 和 InnoDB 两个存储引擎的索引实现方式。 两者均使用的B+ 树实现的索引。</p><h2 id="2-1-InnoDB索引实现"><a href="#2-1-InnoDB索引实现" class="headerlink" title="2.1 InnoDB索引实现"></a><strong>2.1 InnoDB索引实现</strong></h2><h3 id="1）主键索引（聚簇索引，B-树）："><a href="#1）主键索引（聚簇索引，B-树）：" class="headerlink" title="1）主键索引（聚簇索引，B+树）："></a><strong>1）主键索引（聚簇索引，B+树）：</strong></h3><p>   <strong>主键默认采用聚簇索引</strong>（聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致），且一张表只允许存在一个聚簇索引。</p><p>​        ==<strong>聚簇索引的叶子节点就是数据节点（存放完整的行数据）</strong>==</p><p>​        ==<strong>非聚簇索引</strong>的叶子节点保存<strong>非完整行的数据</strong>（只有对应的键值数据） + <strong>书签</strong>（主键的聚集索引的索引值）==</p><p>​        叶子节点是<strong>数据页(默认16K)</strong>。==每个数据页上存放的是完整的行记录。B+ 树将 叶子页加载到内存后，再去查找对应数据行。==</p><p>​        非叶子节点、存放的仅仅是键值及指向数据页的偏移量</p><p><strong>聚集索引的好处：</strong></p><ul><li>对于<strong>主键的排序查找非常的快</strong>（因为其叶子节点是用双向链表链接的）</li><li><p>对于<strong>主键的范围查找非常的快</strong>（因为通过叶子节点的上层中间节点，就可以得到叶结点的范围值）</p><p> <strong>在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构</strong>，**这棵树的叶节点data域保存了完整的数据记录。索引的key是数据表的主键（primary key），因此InnoDB表数据文件本身就是主索引。</p></li></ul><p><img src="https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/0C52AD61056947BFB3ADB363A745E21E/25366" alt="img"></p><p><strong>InnoDB存储引擎的最小存储单元是页(16K)</strong>，页可以用于存放数据也可以用于存放键值+指针, <strong>在InnoDB中B+树高度一般为1-3层</strong>，<strong>它就能满足千万级的数据存储</strong>。在查找数据时一次页的查找代表一次IO，所以通过<strong>主键索引查询通常只需要1-3次IO操作即可查找到数据</strong>。</p><p><strong>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有）</strong>，如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><h3 id="2）InnoDB的辅助索引（非聚簇索引，B-树-B树）"><a href="#2）InnoDB的辅助索引（非聚簇索引，B-树-B树）" class="headerlink" title="2）InnoDB的辅助索引（非聚簇索引，B+树/ B树）"></a><strong>2）InnoDB的辅助索引（非聚簇索引，B+树/ B树）</strong></h3><p><strong>B+树：</strong></p><p><strong>非聚簇索引</strong>的叶子节点保存<strong>非完整行的数据</strong>（只有对应的键值数据） + <strong>书签</strong>（主键的聚集索引的索引值）</p><p><strong>二级索引使用非聚簇索引。</strong></p><p><strong>通过二级索引查询首先，查到是主键值和对应的数据字段，如果查询的字段更多，InnoDB再根据查到的主键值通过主键索引找到相应的数据块。</strong>（ 这个流程叫 <strong>回表</strong>）</p><p><strong>B树：覆盖索引用到的。</strong></p><p>InnoDB 表是基于<strong>聚簇索引</strong>建立的。因此InnoDB 的索引能提供一种非常快速的主键查找性能。它的辅助索引（Secondary Index， 也就是非主键索引）也会包含主键列，所以，如果主键定义的比较大，其他索引也将很大。如果想在表上定义 、很多索引，则<strong>争取尽量把主键定义得小一些</strong>。InnoDB 不会压缩索引。</p><p>   文字符的ASCII码作为比较准则。<strong>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录</strong>。</p><p><img src="https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/FD856A9A723440D296A95C46A86E1431/25390" alt="img"></p><p><strong>1、为什么不建议使用过长的字段作为主键？</strong></p><p><strong>因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。</strong></p><p><strong>2、用非单调的字段作为主键在InnoDB中不是个好主意？</strong></p><p><strong>因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效。</strong></p><h2 id="2-2-MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。"><a href="#2-2-MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。" class="headerlink" title="2.2  MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。"></a><strong>2.2  MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</strong></h2><p>MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</p><h3 id="1）主键索引（非聚簇索引，B-树）："><a href="#1）主键索引（非聚簇索引，B-树）：" class="headerlink" title="1）主键索引（非聚簇索引，B+树）："></a><strong>1）主键索引（非聚簇索引，B+树）：</strong></h3><p>MyISAM引擎使用B+Tree作为索引结构，<strong>叶节点的data域存放的是数据记录的地址</strong>。下图是MyISAM主键索引的原理图：</p><p><img src="https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/B431C4572E464F8B9E410C3F74685439/25416" alt="img"></p><h3 id="2）辅助索引（Secondary-key）"><a href="#2）辅助索引（Secondary-key）" class="headerlink" title="2）辅助索引（Secondary key）"></a><strong>2）辅助索引（Secondary key）</strong></h3><p><strong>在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求</strong> <strong>key是唯一</strong>，而辅助索引的key可以重复。</p><p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，<strong>MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</strong></p><p>MyISAM的索引方式也叫做“<strong>非聚簇</strong>”的，之所以这么称呼是为了与InnoDB的聚簇索引区分。</p><h1 id="三、为什么说B-树比B树更适合数据库索引？"><a href="#三、为什么说B-树比B树更适合数据库索引？" class="headerlink" title="三、为什么说B+树比B树更适合数据库索引？"></a>三、为什么说B+树比B树更适合数据库索引？</h1><p><strong>1、 B+树的磁盘读写代价更低</strong>：B+树的内部节点并没有指向关键字具体信息的指针，因此<strong>其内部节点相对B树更小</strong>，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，<strong>一次性读入内存的需要查找的关键字也就越多</strong>，相对IO读写次数就降低了。<strong>（B 树 非叶子节点中还包含了数据指针，所以占空间大）</strong></p><p><strong>2、B+树的查询效率更加稳定（数据都存在叶子节点，路径都是从根到叶子的路径，一般3次以下的IO读取，等于树的高度）</strong></p><p>B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少），指针少的情况下要保存大量数据，<strong>只能增加树的高度，导致IO操作变多</strong>，查询性能变低；</p><p><strong>3、由于B+树的数据都存储在叶子结点中，非叶子点均为索引，**</strong>方便全盘扫描和范围查找。**</p><p>但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，<strong>需要进行一次中序遍历按序来扫</strong>，所以<strong>B+树更加适合在区间查询的情况</strong>，所以通常B+树用于数据库索引。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、常用的索引底层结构有哪些？&quot;&gt;&lt;a href=&quot;#一、常用的索引底层结构有哪些？&quot; class=&quot;headerlink&quot; title=&quot;一、常用的索引底层结构有哪些？&quot;&gt;&lt;/a&gt;一、常用的索引底层结构有哪些？&lt;/h1&gt;&lt;p&gt;==&lt;strong&gt;索引是一种排序的
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.elgong.top/categories/mysql/"/>
    
    
      <category term="数据库索引" scheme="http://www.elgong.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql-索引篇1-索引的概念</title>
    <link href="http://www.elgong.top/2019/08/11/mysql-%E7%B4%A2%E5%BC%95%E7%AF%871-%E7%B4%A2%E5%BC%95%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>http://www.elgong.top/2019/08/11/mysql-索引篇1-索引的概念/</id>
    <published>2019-08-11T02:46:16.000Z</published>
    <updated>2020-04-11T03:02:11.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、索引的概念"><a href="#一、索引的概念" class="headerlink" title="一、索引的概念"></a><strong>一、索引的概念</strong></h1><h2 id="1-1-索引的作用"><a href="#1-1-索引的作用" class="headerlink" title="1.1 索引的作用"></a>1.1 索引的作用</h2><h2 id="1-2-索引的分类（还不清楚到底怎么归类）"><a href="#1-2-索引的分类（还不清楚到底怎么归类）" class="headerlink" title="1.2 索引的分类（还不清楚到底怎么归类）**"></a>1.2 索引的分类（还不清楚到底怎么归类）**</h2><p><strong>查看有哪些索引：</strong>   <code>SHOW   index;</code></p><p><strong>聚簇索引（主键索引)</strong>    <strong>每张表只能有一个</strong>，<strong>数据和索引在同一个文件</strong></p><p>​        按照每张表的主键构造一颗B+树，同时叶子节点中存放的即为整张表的记录数据。</p><p><strong>辅助索引（二级索引）</strong>: <strong>叶子节点并不包含行记录的全部数据</strong></p><p>​       非主键索引，叶子节点=键值+书签（行的索引值）</p><p><strong>覆盖索引：</strong> <strong>（extra 提示using index）</strong></p><p>​       InnoDB存储引擎支持覆盖索引，即从<strong>辅助索引中就可以得到查询的记录</strong>，而不需要查询聚集索引中的记录了（不需要回表操作）。</p><p>​       覆盖索引并不适用于任意的索引类型，<strong>索引必须存储列的值</strong>，所以<font color="red"><big><strong>不需要回表操作。</strong></big></font></p><p>MySQL只能使用B-树.</p><p><strong>联合索引：</strong></p><p>​        联合索引也是一棵<strong>B+树，其键值数量大于等于2。键值都是排序的</strong>，通过叶子节点可以逻辑上顺序的读出所有数据。</p><p><strong>单值索引：</strong> 一个索引只包含单个列</p><p><strong>多值索引、复合索引</strong>（<strong>组合索引</strong>）: 即一个索包含多个列</p><p><strong>复合索引</strong>只会对与创建索引时的排序顺序完全相同或相反的 order by语句进行优化</p><p><strong>唯一索引</strong>: 索引唯一，但可以null， 声明unique关键字时,会为其字段自动添加唯一索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 单值索引 </span><br><span class="line">#外部创建 </span><br><span class="line">CREATE INDEX [indexname]ON t1(colname); </span><br><span class="line"></span><br><span class="line">#创建表的时候创建 </span><br><span class="line">CREATE TABLE mytable(   ID INT NOT NULL,    username VARCHAR(16) NOT NULL,   INDEX [indexName] (username(length))   );  </span><br><span class="line"></span><br><span class="line">#alter语句添加 </span><br><span class="line">ALTER table tableName ADD INDEX indexName(columnName)  </span><br><span class="line"></span><br><span class="line">// 复合索引 </span><br><span class="line">CREATE INDEX idx_c1_c2_c3ON tablename(c1,c2,c3)</span><br></pre></td></tr></table></figure><p><img src="https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/35ED850E7CCF446C903DD2A0AED7AABE/18916" alt="img"></p><h2 id="1-3-创建"><a href="#1-3-创建" class="headerlink" title="1.3 创建"></a><strong>1.3 创建</strong></h2><p><img src="https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/5FAAFB8FB8BD43CC8F2CD5853ED88350/18908" alt="img"></p><h2 id="1-4-什么时候该创建索引？"><a href="#1-4-什么时候该创建索引？" class="headerlink" title="1.4 什么时候该创建索引？"></a><strong>1.4 什么时候该创建索引？</strong></h2><p><img src="https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/7C97A4A5F692496686ED1CB7890E0543/18901" alt="img"></p><p><strong>不该创建？</strong></p><p><img src="https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/ADE489407E394B16856C9B839E2416DE/18902" alt="img"></p><p>对于最长使用的查询，可以针对性的建立索引来优化速度。</p><p>join查询在有索引条件下</p><p>　　驱动表有索引不会使用到索引</p><p>　　被驱动表建立索引会使用到索引</p><h1 id="二、性能分析和优化策略"><a href="#二、性能分析和优化策略" class="headerlink" title="二、性能分析和优化策略"></a><strong>二、性能分析和优化策略</strong></h1><p><img src="https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/20D9F3FA33FF41E2AB5EAB6EA9D24A25/18895" alt="img"></p><p><img src="https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/7AC131346BED4F13AA046DA87FEFC40C/18894" alt="img"></p><p><img src="https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/61AED2EF4E4D4DEB8D33DEBCBFD93175/18857" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、索引的概念&quot;&gt;&lt;a href=&quot;#一、索引的概念&quot; class=&quot;headerlink&quot; title=&quot;一、索引的概念&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、索引的概念&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;1-1-索引的作用&quot;&gt;&lt;a href=&quot;#1-1-索引的
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.elgong.top/categories/mysql/"/>
    
    
      <category term="数据库索引" scheme="http://www.elgong.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>pandas-6重复值处理</title>
    <link href="http://www.elgong.top/2019/08/09/pandas-%E9%87%8D%E5%A4%8D%E5%80%BC%E5%A4%84%E7%90%86/"/>
    <id>http://www.elgong.top/2019/08/09/pandas-重复值处理/</id>
    <published>2019-08-09T07:26:52.000Z</published>
    <updated>2020-02-20T04:41:37.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pandas-6-重复值处理"><a href="#pandas-6-重复值处理" class="headerlink" title="pandas -6 重复值处理"></a>pandas -6 重复值处理</h1><blockquote><p>如果你想找到或者删除 <code>DataFrame</code>中重复的行, 可以使用 <code>duplicated</code> 和 <code>drop_duplicates</code></p></blockquote><h2 id="查找重复值"><a href="#查找重复值" class="headerlink" title="查找重复值"></a>查找重复值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">example:</span><br><span class="line">        col1  col2     c</span><br><span class="line">    0    one   x   -1.067137</span><br><span class="line">    1    one   y    0.309500</span><br><span class="line">    2    two   x   -0.211056</span><br><span class="line">    3    two   y   -1.842023</span><br><span class="line">    4    two   x   -0.390820</span><br><span class="line">    5  three   x   -1.964475</span><br><span class="line">    6   four   x    1.298329</span><br><span class="line">In:</span><br><span class="line">    // 单列</span><br><span class="line">    df.duplicated(&quot;col1&quot;, keep=&quot;first&quot;)</span><br><span class="line">    </span><br><span class="line">    // 多列</span><br><span class="line">    // df.duplicated([&quot;col1&quot;, &quot;col2&quot;], keep=&quot;first&quot;)</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">    0    False</span><br><span class="line">    1     True</span><br><span class="line">    2    False</span><br><span class="line">    3     True</span><br><span class="line">    4     True</span><br><span class="line">    5    False</span><br><span class="line">    6    False</span><br><span class="line">    dtype: bool</span><br><span class="line">    </span><br><span class="line">    // 默认 keep = &quot;first&quot;,第一次出现的不算重复，返回False</span><br><span class="line">    // keep = &quot;last&quot;, 最后出现的不算重复</span><br><span class="line">    // keep = False, 重复值均返回 True</span><br></pre></td></tr></table></figure><h2 id="删除重复值"><a href="#删除重复值" class="headerlink" title="删除重复值"></a>删除重复值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In:</span><br><span class="line">    df.drop_duplicates(&apos;col1&apos;)</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">        col1  col2    c</span><br><span class="line">    0    one   x    -1.067137</span><br><span class="line">    2    two   x    -0.211056</span><br><span class="line">    5  three   x    -1.964475</span><br><span class="line">    6   four   x     1.298329</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pandas-6-重复值处理&quot;&gt;&lt;a href=&quot;#pandas-6-重复值处理&quot; class=&quot;headerlink&quot; title=&quot;pandas -6 重复值处理&quot;&gt;&lt;/a&gt;pandas -6 重复值处理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;如果你想找到或
      
    
    </summary>
    
      <category term="pandas系列教程" scheme="http://www.elgong.top/categories/pandas%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="pandas" scheme="http://www.elgong.top/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>pandas-5缺失值处理</title>
    <link href="http://www.elgong.top/2019/08/09/pandas-%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%A4%84%E7%90%86/"/>
    <id>http://www.elgong.top/2019/08/09/pandas-缺失值处理/</id>
    <published>2019-08-09T01:33:30.000Z</published>
    <updated>2020-02-20T04:41:37.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pandas-5-缺失值处理"><a href="#pandas-5-缺失值处理" class="headerlink" title="pandas -5 缺失值处理"></a>pandas -5 缺失值处理</h1><blockquote><p>统计数据中存在缺失值是十分常见的问题, 而对于缺失值的处理，是数据挖掘的一个重要环节。pandas 有一系列的方法处理缺失值。</p></blockquote><h2 id="缺失值的类型"><a href="#缺失值的类型" class="headerlink" title="缺失值的类型"></a>缺失值的类型</h2><p>判断方法只记住万能的 <code>pd.isnull</code> 即可。</p><blockquote><p>数值</p></blockquote><pre><code>  pd.isna  pd.isnull  np.isnan</code></pre><blockquote><p>字符串</p></blockquote><pre><code>  pd.isna  pd.isnull</code></pre><blockquote><p>时间</p></blockquote><pre><code>  pd.isna  pd.isnull  np.isnat</code></pre><h2 id="缺失值的统计"><a href="#缺失值的统计" class="headerlink" title="缺失值的统计"></a>缺失值的统计</h2><pre><code>  df.isnull().sum()</code></pre><h2 id="丢掉缺失值"><a href="#丢掉缺失值" class="headerlink" title="丢掉缺失值"></a>丢掉缺失值</h2><pre><code>  // 某列有缺失值, 删除  df[ pd.isnull(df[&quot;columns&quot;])]  // Series   df.columns.dropna()  // DataFrame  // axis: axis=0 （默认）表示操作行，axis=1 表示操作列;  // how : any 表示一行/列有任意元素为空时即丢弃，all 一行/列所有值都为空时才丢弃。  // subset: 参数表示删除时只考虑的索引或列名。  // thresh: 比如 thresh=3，会在一行/列中至少有 3 个非空值时将其保留。  df.dropna(axis=0, how=&quot;any&quot;, subset=[&quot;city&quot;, &quot;sex&quot;])</code></pre><h2 id="填充缺失值"><a href="#填充缺失值" class="headerlink" title="填充缺失值"></a>填充缺失值</h2><blockquote><p>数据量少的情况下，直接丢掉不可取，可以适当补充数据。</p></blockquote><pre><code>   // 前值填充 ffill     后值填充  bfill   df.columns.fillna(method = &quot;ffill&quot;)   // 实值填充   df.fillna(0)   // 均值填充   df[&quot;columns&quot;].fillna(df[&quot;columns&quot;].mean(), inplace=True)   // 众数   mode()[0]   // 中位数   median()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pandas-5-缺失值处理&quot;&gt;&lt;a href=&quot;#pandas-5-缺失值处理&quot; class=&quot;headerlink&quot; title=&quot;pandas -5 缺失值处理&quot;&gt;&lt;/a&gt;pandas -5 缺失值处理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;统计数据中存在
      
    
    </summary>
    
      <category term="pandas系列教程" scheme="http://www.elgong.top/categories/pandas%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="pandas" scheme="http://www.elgong.top/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>pandas-7时间&amp;日期处理</title>
    <link href="http://www.elgong.top/2019/08/06/pandas-%E6%97%B6%E9%97%B4-%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/"/>
    <id>http://www.elgong.top/2019/08/06/pandas-时间-日期处理/</id>
    <published>2019-08-06T00:42:00.000Z</published>
    <updated>2020-02-20T04:41:37.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pandas-7-时间-amp-日期处理"><a href="#pandas-7-时间-amp-日期处理" class="headerlink" title="pandas -7 时间&amp;日期处理"></a>pandas -7 时间&amp;日期处理</h1><h2 id="pandas-常出现的时间格式"><a href="#pandas-常出现的时间格式" class="headerlink" title="pandas 常出现的时间格式"></a>pandas 常出现的时间格式</h2><ul><li>字符串类型 <code>object</code></li></ul><blockquote><p>一般是字符串类型，pandas 储存string时 使用 narray， 每一个object 是一个指针</p></blockquote><ul><li>datetime 类型 <code>datetime64</code></li></ul><ul><li>timedelta 类型</li></ul><blockquote><p>表示时间差的数据类型</p></blockquote><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ol><li><code>object</code> 2 <code>datetime</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 方法1</span><br><span class="line">df[1] = pd.to_datetime(df[1], format=&apos;%d.%m.%Y&apos;)</span><br><span class="line"></span><br><span class="line"># 指定format，速度会加快很多。</span><br><span class="line"></span><br><span class="line">// 方法2</span><br><span class="line">dateStr = &quot;2019-02-03&quot;</span><br><span class="line"></span><br><span class="line">myDate = datetime.strptime(dateStr, &quot;&quot;%Y-%m-%d&quot;&quot;)</span><br></pre></td></tr></table></figure><ol><li><code>datetime</code> 2 <code>object</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df[&quot;time_list&quot;] = df[&quot;time_list&quot;].strftime(&quot;%Y-%m-%d&quot;)</span><br><span class="line"></span><br><span class="line">// Y 2019</span><br><span class="line">// y  19</span><br></pre></td></tr></table></figure><h2 id="datetime-相关操作"><a href="#datetime-相关操作" class="headerlink" title="datetime 相关操作"></a>datetime 相关操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 查看列元素的年，月，日，星期（整数型）</span><br><span class="line">df[&quot;time&quot;].dt.year</span><br><span class="line">df[&quot;time&quot;].dt.month</span><br><span class="line">df[&quot;time&quot;].dt.day</span><br><span class="line">df[&quot;time&quot;].dt.weekday  # 星期一是0</span><br><span class="line"></span><br><span class="line">// 一年中的第几天,第几周</span><br><span class="line">df[&quot;time&quot;].dt.dayofyear</span><br><span class="line">df[&quot;time&quot;].dt.weekofyear</span><br><span class="line">// 查看列元素 某年的数据数量</span><br><span class="line">df[df[&quot;time&quot;].dt.year == 2019].shape</span><br></pre></td></tr></table></figure><h2 id="时间运算"><a href="#时间运算" class="headerlink" title="时间运算"></a>时间运算</h2><ol><li>计算时间差</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 计算时间差， 结果为timedelta</span><br><span class="line">df[&quot;时间差&quot;] = df[&quot;时间1&quot;] - df[&quot;时间2&quot;]</span><br><span class="line"></span><br><span class="line">// 转换成 天数差</span><br><span class="line">df[&quot;时间差&quot;].days</span><br></pre></td></tr></table></figure><ol><li>计算未来日期</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// N天后的日期</span><br><span class="line">// 天  days,   时 hours， 周 weeks</span><br><span class="line">df[&quot;时间&quot;] = df[&quot;时间1&quot;] - timedelta(days=10)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pandas-7-时间-amp-日期处理&quot;&gt;&lt;a href=&quot;#pandas-7-时间-amp-日期处理&quot; class=&quot;headerlink&quot; title=&quot;pandas -7 时间&amp;amp;日期处理&quot;&gt;&lt;/a&gt;pandas -7 时间&amp;amp;日期处理&lt;/h1
      
    
    </summary>
    
      <category term="pandas系列教程" scheme="http://www.elgong.top/categories/pandas%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="pandas" scheme="http://www.elgong.top/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>机器学习模型的偏差与方差</title>
    <link href="http://www.elgong.top/2019/08/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%81%8F%E5%B7%AE%E4%B8%8E%E6%96%B9%E5%B7%AE/"/>
    <id>http://www.elgong.top/2019/08/01/机器学习模型的偏差与方差/</id>
    <published>2019-08-01T08:43:19.000Z</published>
    <updated>2020-02-20T04:41:37.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习的方差与偏差"><a href="#机器学习的方差与偏差" class="headerlink" title="机器学习的方差与偏差"></a>机器学习的方差与偏差</h1><blockquote><p>方差与偏差，总是迷迷糊糊的，每次看了就会，过了就忘。今天看到一个非常棒的解释，迫不及待马上整理下来了。</p></blockquote><h2 id="机器学习的目标函数"><a href="#机器学习的目标函数" class="headerlink" title="机器学习的目标函数"></a>机器学习的目标函数</h2><p>机器学习模型学习的是数据集的条件概率分布，得到一个决策函数。整个学习过程围绕着最小化（或者最大化）目标函数进行优化参数，目标函数的通常形式的定义是：</p><pre><code>Obj = L(θ) + λΩ(θ)</code></pre><p><code>L(θ)</code> 是损失函数，衡量模型对训练集拟合程度的好坏(对应偏差)；</p><p><code>Ω(θ)</code> 是正则项，是衡量模型的复杂程度（对应方差）；</p><font color="#FF0000"> 目标函数定义为损失函数和正则项两部分，是为了平衡模型的偏差和方差（Bias Variance Trade-off）。</font> <h2 id="偏差与学习器"><a href="#偏差与学习器" class="headerlink" title="偏差与学习器"></a>偏差与学习器</h2><blockquote><p>偏差描述了 <font color="#FF0000">学习器的拟合能力</font> （对训练集的）。</p></blockquote><p>学习器在训练集表现越好，损失越低，则模型的偏差越小。</p><h2 id="方差与学习器"><a href="#方差与学习器" class="headerlink" title="方差与学习器"></a>方差与学习器</h2><blockquote><p>方差描述了 <font color="#FF0000"> 学习器的泛化能力</font>(对测试集)。</p></blockquote><p>学习器在测试集表现越好，则模型的方差越低。</p><h2 id="偏差与方差之间的关系"><a href="#偏差与方差之间的关系" class="headerlink" title="偏差与方差之间的关系"></a>偏差与方差之间的关系</h2><blockquote><p>我们最想要的是低偏差，低方差的模型，然而现实很难达到两者都极致的低。有时候需要用提高偏差来降低方差，毕竟模型的泛化能力十分重要。</p></blockquote><p>当损失函数达到极小值，模型对训练集的拟合达到了最佳效果，==对应着低偏差==，而这种情况下，往往对训练集的特点学的过于细微，而缺乏泛化能力。</p><p>根据 ==奥坎姆剃刀原则==, 同样准确率，模型越简单越好，所以通过正则化等方式，削弱模型的拟合能力，降低过拟合的风险。通过提高偏差，来主动降低方差。</p><p>最终我们要平衡方差与偏差，从而得到一个合理的模型。</p><p><img src="/2019/08/01/机器学习模型的偏差与方差/biasvariance.png" alt="biasvariance"></p><h2 id="调整方差与偏差的方法"><a href="#调整方差与偏差的方法" class="headerlink" title="调整方差与偏差的方法"></a>调整方差与偏差的方法</h2><p>待补充。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习的方差与偏差&quot;&gt;&lt;a href=&quot;#机器学习的方差与偏差&quot; class=&quot;headerlink&quot; title=&quot;机器学习的方差与偏差&quot;&gt;&lt;/a&gt;机器学习的方差与偏差&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;方差与偏差，总是迷迷糊糊的，每次看了就会，过了就忘
      
    
    </summary>
    
      <category term="机器学习方法" scheme="http://www.elgong.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="方差与偏差" scheme="http://www.elgong.top/tags/%E6%96%B9%E5%B7%AE%E4%B8%8E%E5%81%8F%E5%B7%AE/"/>
    
  </entry>
  
  <entry>
    <title>XGBoost</title>
    <link href="http://www.elgong.top/2019/07/30/XGBoost/"/>
    <id>http://www.elgong.top/2019/07/30/XGBoost/</id>
    <published>2019-07-30T14:02:00.000Z</published>
    <updated>2020-02-20T04:41:37.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xgboost-学习笔记"><a href="#xgboost-学习笔记" class="headerlink" title="xgboost 学习笔记"></a>xgboost 学习笔记</h1><blockquote><p>主要内容均来自官方文档，官方文档是英文版，所以简单的翻译了一下，方便日后查看。<br><a href="https://xgboost.readthedocs.io/en/latest/python/python_intro.html" target="_blank" rel="noopener">详细内容见官方手册</a></p><h2 id="安装-XGBoost"><a href="#安装-XGBoost" class="headerlink" title="安装 XGBoost"></a>安装 XGBoost</h2></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu -python3:</span><br><span class="line">    pip3 install xgboost</span><br><span class="line"> </span><br><span class="line">导入:</span><br><span class="line">    import xgboost as xgb</span><br></pre></td></tr></table></figure><h2 id="数据接口"><a href="#数据接口" class="headerlink" title="数据接口"></a>数据接口</h2><p><code>XGBoost</code> 可以从以下结构中加载数据：</p><ul><li>LibSVM text format file</li><li>CSV</li><li>Numpy 2D array</li><li>Scipy 2D sparse array</li><li>Pandas</li><li>XGBoost binary buffer file.</li></ul><p>加载的数据都放在 <code>DMatrix</code>对象中，下面是具体加载的过程演示：</p><ul><li><p>LibSVM text format file</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dtrain = xgb.DMatrix(<span class="string">'train.svm.txt'</span>)</span><br><span class="line">dtest = xgb.DMatrix(<span class="string">'test.svm.buffer'</span>)</span><br></pre></td></tr></table></figure></li><li><p>CSV</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 需要指定标签所在的列</span><br><span class="line">dtrain = xgb.DMatrix(<span class="string">'train.csv?format=csv&amp;label_column=0'</span>)</span><br><span class="line">dtest = xgb.DMatrix(<span class="string">'test.csv?format=csv&amp;label_column=0'</span>)</span><br></pre></td></tr></table></figure></li></ul><font color="#FF0000">  XGBoost 不支持种类特征，需要先加载为Numpy数组，然后进行 `one-hot` 编码;推荐使用pandas 加载数据.</font> <ul><li><p>Numpy</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.rand(<span class="number">5</span>, <span class="number">10</span>)  <span class="comment"># 5个样本，每个样本10个特征</span></span><br><span class="line">label = np.random.randint(<span class="number">2</span>, size=<span class="number">5</span>)  <span class="comment"># 二值标签</span></span><br><span class="line"></span><br><span class="line">dtrain = xgb.DMatrix(data, label=label)</span><br></pre></td></tr></table></figure></li><li><p>Scipy</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">csr = scipy.sparse.csr_matrix((dat, (row, col)))</span><br><span class="line">dtrain = xgb.DMatrix(csr)</span><br></pre></td></tr></table></figure></li><li><p>Pandas</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = pandas.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">4</span>,<span class="number">3</span>)), columns=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line">label = pandas.DataFrame(np.random.randint(<span class="number">2</span>, size=<span class="number">4</span>))</span><br><span class="line">dtrain = xgb.DMatrix(data, label=label)</span><br></pre></td></tr></table></figure></li><li><p>保存为 XGBoost 二进制文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dtrain = xgb.DMatrix(<span class="string">'train.svm.txt'</span>)</span><br><span class="line">dtrain.save_binary(<span class="string">'train.buffer'</span>)</span><br></pre></td></tr></table></figure></li><li><p>缺失值处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dtrain = xgb.DMatrix(data, label=label, missing=<span class="number">-999.0</span>)</span><br></pre></td></tr></table></figure></li><li><p>样本权重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = np.random.rand(5, 1)</span><br><span class="line">dtrain = xgb.DMatrix(data, label=label, missing=-999.0, weight=w)</span><br></pre></td></tr></table></figure></li></ul><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><blockquote><p>XGBoost 可以通过列表或者字典来设置参数，例如：</p></blockquote><ul><li><p>Booster 参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">param = &#123;<span class="string">'max_depth'</span>: <span class="number">2</span>, <span class="string">'eta'</span>: <span class="number">1</span>, <span class="string">'objective'</span>: <span class="string">'binary:logistic'</span>&#125;</span><br><span class="line">param[<span class="string">'nthread'</span>] = <span class="number">4</span></span><br><span class="line">param[<span class="string">'eval_metric'</span>] = <span class="string">'auc'</span></span><br></pre></td></tr></table></figure></li><li><p>指定多个评估指标</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">param[<span class="string">'eval_metric'</span>] = [<span class="string">'auc'</span>, <span class="string">'ams@0'</span>]</span><br></pre></td></tr></table></figure></li><li><p>指定验证集来监视性能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evallist = [(dtest, <span class="string">'eval'</span>), (dtrain, <span class="string">'train'</span>)]</span><br></pre></td></tr></table></figure></li></ul><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><ul><li><p>模型训练</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num_round = 10</span><br><span class="line">bst = xgb.train(param, dtrain, num_round, evallist)</span><br></pre></td></tr></table></figure></li><li><p>模型保存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bst.save_model(<span class="string">'0001.model'</span>)</span><br></pre></td></tr></table></figure></li><li><p>保存模型和特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dump model</span></span><br><span class="line">bst.dump_model(<span class="string">'dump.raw.txt'</span>)</span><br><span class="line"><span class="comment"># dump model with feature map</span></span><br><span class="line">bst.dump_model(<span class="string">'dump.raw.txt'</span>, <span class="string">'featmap.txt'</span>)</span><br></pre></td></tr></table></figure></li><li><p>模型加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bst = xgb.Booster(&#123;&apos;nthread&apos;: 4&#125;)  # init model</span><br><span class="line">bst.load_model(&apos;model.bin&apos;)  # load data</span><br></pre></td></tr></table></figure></li></ul><h2 id="早停"><a href="#早停" class="headerlink" title="早停"></a>早停</h2><blockquote><p>如果你有验证集，则可以使用早停机制来寻找最佳的 <code>num_round</code>, 需要将 验证集传入 <code>evals</code>,如果传入多个，则使用最后一个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train(..., evals=evals, early_stopping_rounds=10)</span><br></pre></td></tr></table></figure></p></blockquote><p>如果模型在 <code>early_stopping_rounds</code>次，监控的参数 <code>param[&#39;eval_metric&#39;]</code> 都没有提升，则会停止训练，<code>train</code> 返回的是最后一次训练的模型，而不是最佳模型，最佳模型可以通过一下方式找到：</p><ul><li><code>bst.best_score</code></li><li><code>bst.best_iteration</code></li><li><code>bst.best_ntree_limit</code>  # 使用最佳模型</li></ul><p>同样的，监控多个参数时，最后一个参数起早停的作用。</p><h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><p>已经训练好的模型，或者已经加载的模型可以拿来预测新数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.rand(7, 10)</span><br><span class="line">dtest = xgb.DMatrix(data)</span><br><span class="line">ypred = bst.predict(dtest)</span><br></pre></td></tr></table></figure></p><p>使用最佳的迭代次数的模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ypred = bst.predict(dtest, ntree_limit=bst.best_ntree_limit)</span><br></pre></td></tr></table></figure></p><h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><p>你可以使用绘图模块来画出树结构：</p><ul><li>绘制参数重要性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xgb.plot_importance(bst)</span><br></pre></td></tr></table></figure><ul><li>绘制目标树</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xgb.plot_tree(bst, num_trees=2)</span><br></pre></td></tr></table></figure><ul><li>Ipython 中绘制树</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xgb.to_graphviz(bst, num_trees=2)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;xgboost-学习笔记&quot;&gt;&lt;a href=&quot;#xgboost-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;xgboost 学习笔记&quot;&gt;&lt;/a&gt;xgboost 学习笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;主要内容均来自官方文档，官方文档是
      
    
    </summary>
    
      <category term="XGBoost" scheme="http://www.elgong.top/categories/XGBoost/"/>
    
    
      <category term="XGBoost" scheme="http://www.elgong.top/tags/XGBoost/"/>
    
  </entry>
  
  <entry>
    <title>pandas-2索引和选择数据</title>
    <link href="http://www.elgong.top/2019/07/25/pandas-2%E7%B4%A2%E5%BC%95%E5%92%8C%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE/"/>
    <id>http://www.elgong.top/2019/07/25/pandas-2索引和选择数据/</id>
    <published>2019-07-24T23:01:01.000Z</published>
    <updated>2020-02-20T04:41:37.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pandas-2-索引和选择数据"><a href="#pandas-2-索引和选择数据" class="headerlink" title="pandas -2 索引和选择数据"></a>pandas -2 索引和选择数据</h1><blockquote><p>对于一种数据结构,最基本的操作就应该是增删改查了。</p></blockquote><h2 id="1-行列选择"><a href="#1-行列选择" class="headerlink" title="1. 行列选择"></a>1. 行列选择</h2><p>行选择和列选择有许多方法，很容易记混，常用的要记住。<br>主要方法有三种： <code>iloc</code>, <code>loc</code>, <code>[]</code></p><h3 id="行选择"><a href="#行选择" class="headerlink" title="行选择"></a>行选择</h3><ul><li><p>切片 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 切片</span><br><span class="line">df[a:b]</span><br><span class="line"></span><br><span class="line">// 隔1行选择</span><br><span class="line">df[::2]</span><br></pre></td></tr></table></figure></li><li><p>指定位置</p><p><code>df.iloc[1, 1]</code></p><p><code>df.iloc[1:10, 2:3]</code></p><p><code>df.iloc[1:10][&#39;Price&#39;]</code></p></li><li><p>指定索引</p><p><code>df.loc[&quot;index1&quot;, &quot;index2&quot;]</code></p></li><li><p>按照条件查找</p><p><code>df[( df[&quot;row2&quot;] == 1) &amp; (df[&quot;row2&quot;] == &quot;null&quot;)]</code></p><p><code>df.loc[( df[&quot;row2&quot;] == 1) &amp; (df[&quot;row2&quot;] == &quot;null&quot;)]</code></p></li><li><p>根据列的多个值,选择行</p><p><code>List = [1,2,3,4,5]</code><br><code>train[train[&quot;customer_id&quot;].isin(List)]</code></p></li></ul><h3 id="列选择"><a href="#列选择" class="headerlink" title="列选择"></a>列选择</h3><ul><li><p>通过列标签选择单列</p><p>  <code>df[&quot;price&quot;]</code></p></li><li><p>通过列标签选择多列</p><p> <code>df[[&quot;price&quot;, &quot;time&quot;]]</code></p></li><li><p>通过列索引,选择前3列</p><p><code>df.iloc[:, :3]</code> </p></li></ul><h3 id="行列选择"><a href="#行列选择" class="headerlink" title="行列选择"></a>行列选择</h3><p>  <code>df.loc[&quot;index1&quot; : &quot;index2&quot;,  [&quot;price&quot;]]</code></p><p>  <code>df.iloc[a:b][&#39;Price&#39;]</code></p><h3 id="随机采样行或者列"><a href="#随机采样行或者列" class="headerlink" title="随机采样行或者列"></a>随机采样行或者列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s.sample(frac=0.5)</span><br><span class="line">// 参数</span><br><span class="line">// 默认选择行，n = 行数，  frac = 比例</span><br><span class="line">// replace: 默认False 无放回采样</span><br><span class="line">// weights: 样本采样权重</span><br><span class="line">// axis:  默认=0 行,  =1 列</span><br><span class="line">// random_state=2</span><br></pre></td></tr></table></figure><h3 id="分类别等数量抽样"><a href="#分类别等数量抽样" class="headerlink" title="分类别等数量抽样"></a>分类别等数量抽样</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 降采样 -- 分类抽样</span><br><span class="line">def subSample(df_x, splitAttribute = &quot;Attribute4&quot;):</span><br><span class="line">    </span><br><span class="line">    subsampleNum = min(df_x.groupby(splitAttribute).size())</span><br><span class="line">    print(subsampleNum)</span><br><span class="line">    df_x_sub = df_x.iloc[1:2,:]</span><br><span class="line">    #df_y_sub = df_y.iloc[1:2,:]</span><br><span class="line">    for label in df_x[splitAttribute].unique():</span><br><span class="line">        tmp_x = df_x[df_x[splitAttribute] == label]</span><br><span class="line"></span><br><span class="line">        random_list = random.sample(range(0,len(tmp_x)),subsampleNum )</span><br><span class="line">        df_x_sub = df_x_sub.append(tmp_x.iloc[random_list,:])</span><br><span class="line">        df_y_sub.append(tmp_y.iloc[random_list,:])</span><br><span class="line">    return df_x_sub #, df_y_sub</span><br></pre></td></tr></table></figure><h2 id="2-行的增删改查"><a href="#2-行的增删改查" class="headerlink" title="2. 行的增删改查"></a>2. 行的增删改查</h2><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><blockquote><p>单列</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 末尾增加</span><br><span class="line">   df[&quot;new col&quot;] = None</span><br><span class="line">   </span><br><span class="line">// 指定位置增加，在2列后</span><br><span class="line">   df.insert(2,&apos;city&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>多列</p></blockquote><p>   <code>pd.concat([df, pd.DataFrame(columns=[&quot;C&quot;,&quot;D&quot;])])</code></p><blockquote><p>单行（待验证）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// loc 添加</span><br><span class="line">  df.loc[‘5‘] = [3, 3, 3, 3]</span><br><span class="line">    </span><br><span class="line">// set_value 添加</span><br><span class="line">  df.set_value(‘5‘, df.columns, [3,3,3,3], takeable=False)</span><br></pre></td></tr></table></figure><blockquote><p>多行</p></blockquote><p>多行相当于合并两张表了,可以参考(merge,concat)<a href="https://note.youdao.com/" target="_blank" rel="noopener">方法</a>。</p><p><code>test_ = pd.merge(tmp, data.loc[:,[&quot;customer_id&quot;, &quot;label&quot;]],on=[&#39;customer_id&#39;],how=&#39;left&#39;,copy=False&quot;)</code></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><blockquote><p>列</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// del 方法</span><br><span class="line">   def df[&quot;col_name&quot;]</span><br><span class="line"></span><br><span class="line">//根据列名 drop 方法</span><br><span class="line">   df.drop([&quot;b&quot;, &quot;c&quot;], axis=1,inplace = True)</span><br><span class="line">axis = 1 列</span><br><span class="line">axis = 0 行</span><br><span class="line"></span><br><span class="line">// 根据列号 drop 方法</span><br><span class="line">   df.drop(df.columns[[1,2]], axis=1, inplace=True)</span><br></pre></td></tr></table></figure><blockquote><p>行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 根据索引 删除行</span><br><span class="line">   df = df.drop([1, 2])</span><br><span class="line"></span><br><span class="line">// 根据value 删除行</span><br><span class="line">   df = df[~df[&quot;col&quot;].isin(5,9)</span><br></pre></td></tr></table></figure><blockquote><p>按照条件删除行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.drop(df[df[&quot;order_pay_time&quot;] &lt; pd.to_datetime(&quot;2013-11-12 23:59:44&quot;) ].index)</span><br></pre></td></tr></table></figure><h3 id="修改与查找"><a href="#修改与查找" class="headerlink" title="修改与查找"></a>修改与查找</h3><blockquote><p>单值修改和查找时, 参考选择行列方法。</p><p>多值查找时，</p></blockquote><h4 id="按条件查找"><a href="#按条件查找" class="headerlink" title="按条件查找"></a>按条件查找</h4><p> <code>df_train[( df_train[&quot;row&quot;] == 1) &amp;( == &quot;null&quot;)]</code></p><h4 id="query-查找"><a href="#query-查找" class="headerlink" title="query 查找"></a>query 查找</h4><p> <code>df.query(&#39;(a &lt; b) &amp; (b &lt; c)&#39;)</code></p><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><blockquote><p>单个替换，inplace = True 覆盖源文件</p></blockquote><p>  <code>df.replace(to_replace, value, inplace = True)</code></p><blockquote><p>多值替换—-字典</p></blockquote><p>  <code>df.replace({&quot;A&quot;:&quot;B&quot;,  29:100})</code></p><blockquote><p>按条件替换</p></blockquote><p>  <code>df.where(df &gt; 0, -df, inplace=True)</code></p><h4 id="交换两列的位置"><a href="#交换两列的位置" class="headerlink" title="交换两列的位置"></a>交换两列的位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[[&apos;B&apos;, &apos;A&apos;]] = df[[&apos;A&apos;, &apos;B&apos;]]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pandas-2-索引和选择数据&quot;&gt;&lt;a href=&quot;#pandas-2-索引和选择数据&quot; class=&quot;headerlink&quot; title=&quot;pandas -2 索引和选择数据&quot;&gt;&lt;/a&gt;pandas -2 索引和选择数据&lt;/h1&gt;&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="pandas系列教程" scheme="http://www.elgong.top/categories/pandas%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="pandas" scheme="http://www.elgong.top/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>pandas -1数据结构</title>
    <link href="http://www.elgong.top/2019/07/22/pandas-1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://www.elgong.top/2019/07/22/pandas-1数据结构/</id>
    <published>2019-07-22T01:01:01.000Z</published>
    <updated>2020-02-20T04:41:37.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pandas-1-数据结构"><a href="#pandas-1-数据结构" class="headerlink" title="pandas -1 数据结构"></a>pandas -1 数据结构</h1><blockquote><p>pandas 基本操作都很简单，只是在刚开始学习的过程中，容易忘掉一些API，导致完成一些操作时，总会想着翻翻手册，这一系列博客，是对这些方法进行了梳理，可作为入门学习的参考材料。平时经常翻阅。</p></blockquote><p>“index” (axis=0, default), “columns” (axis=1)</p><h2 id="1-Series"><a href="#1-Series" class="headerlink" title="1. Series"></a>1. Series</h2><blockquote><p>Series 是一个带有 名称 和索引的一维数组。</p></blockquote><h3 id="创建seriex"><a href="#创建seriex" class="headerlink" title="创建seriex"></a>创建seriex</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Series 数组生成，指定数据类型</span><br><span class="line">In:   </span><br><span class="line">    user_age = pd.Series(data=[18, 30, 25, 40], dtype=float)</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">        0    18</span><br><span class="line">        1    30</span><br><span class="line">        2    25</span><br><span class="line">        3    40</span><br><span class="line">        dtype: int64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 增加索引 index</span><br><span class="line">In:   </span><br><span class="line">    user_age.index = [&quot;Tom&quot;, &quot;Bob&quot;, &quot;Mary&quot;, &quot;James&quot;]</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">    Tom      18</span><br><span class="line">    Bob      30</span><br><span class="line">    Mary     25</span><br><span class="line">    James    40</span><br><span class="line">    dtype: int64</span><br><span class="line">    </span><br><span class="line">// 表头</span><br><span class="line">In:</span><br><span class="line">    user_age.index.name(&quot;name&quot;)</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">    name</span><br><span class="line">    Tom      18</span><br><span class="line">    Bob      30</span><br><span class="line">    Mary     25</span><br><span class="line">    James    40</span><br><span class="line">    dtype: int64</span><br></pre></td></tr></table></figure><h3 id="像字典一样使用series"><a href="#像字典一样使用series" class="headerlink" title="像字典一样使用series"></a>像字典一样使用series</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// index 当键值</span><br><span class="line">In: </span><br><span class="line">    user_age[&quot;Tom&quot;]</span><br><span class="line">    user_age.get(&quot;Tom&quot;)</span><br><span class="line"></span><br><span class="line">// 切片-列</span><br><span class="line">In:</span><br><span class="line">    user_age[2:3]</span><br><span class="line">    </span><br><span class="line">// 按条件查找</span><br><span class="line">In:</span><br><span class="line">    user_age[user_age &gt; 30]</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">    name</span><br><span class="line">    James    40.0</span><br><span class="line">    Name: user_age_info, dtype: float64</span><br></pre></td></tr></table></figure><h3 id="像向量一样使用series"><a href="#像向量一样使用series" class="headerlink" title="像向量一样使用series"></a>像向量一样使用series</h3><blockquote><p>可以传递给np方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 整列加减</span><br><span class="line">In:</span><br><span class="line">    user_age + 1</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">    name</span><br><span class="line">    Tom      19.0</span><br><span class="line">    Bob      31.0</span><br><span class="line">    Mary     26.0</span><br><span class="line">    James    41.0</span><br><span class="line">    Name: user_age_info, dtype: float64</span><br></pre></td></tr></table></figure><h2 id="2-DataFrame"><a href="#2-DataFrame" class="headerlink" title="2. DataFrame"></a>2. DataFrame</h2><blockquote><p>DataFrame 是一个带有 名称 和索引的二维数组，像一张Excel表格。</p></blockquote><h3 id="创建DataFrame"><a href="#创建DataFrame" class="headerlink" title="创建DataFrame"></a>创建DataFrame</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// DataFrame 根据字典生成</span><br><span class="line"></span><br><span class="line">In:</span><br><span class="line">    index = pd.Index(data=[&quot;Tom&quot;, &quot;Bob&quot;, &quot;Mary&quot;, &quot;James&quot;], name=&quot;name&quot;)</span><br><span class="line">    </span><br><span class="line">    data = &#123;</span><br><span class="line">        &quot;age&quot;: [18, 30, 40],</span><br><span class="line">        &quot;city&quot;: [&quot;BeiJing&quot;, &quot;ShangHai&quot;, &quot;HangZhou&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    user_info = pd.DataFrame(data=data, index=index)</span><br><span class="line">    user_info</span><br><span class="line"></span><br><span class="line">Out:</span><br><span class="line">    </span><br><span class="line">// DataFrame 根据二维列表生成</span><br><span class="line">In:</span><br><span class="line">    data = [[18, &quot;BeiJing&quot;], </span><br><span class="line">            [30, &quot;ShangHai&quot;], </span><br><span class="line">            [25, &quot;GuangZhou&quot;], </span><br><span class="line">            [40, &quot;ShenZhen&quot;]]</span><br><span class="line">    columns = [&quot;age&quot;, &quot;city&quot;]</span><br><span class="line">    </span><br><span class="line">    user_info = pd.DataFrame(data=data, index=index, columns=columns)</span><br><span class="line">    user_info</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pandas-1-数据结构&quot;&gt;&lt;a href=&quot;#pandas-1-数据结构&quot; class=&quot;headerlink&quot; title=&quot;pandas -1 数据结构&quot;&gt;&lt;/a&gt;pandas -1 数据结构&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;pandas 基本操作
      
    
    </summary>
    
      <category term="pandas系列教程" scheme="http://www.elgong.top/categories/pandas%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="pandas" scheme="http://www.elgong.top/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>评价指标 ROC与AUC</title>
    <link href="http://www.elgong.top/2019/07/20/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87-ROC%E4%B8%8EAUC/"/>
    <id>http://www.elgong.top/2019/07/20/评价指标-ROC与AUC/</id>
    <published>2019-07-20T07:10:00.000Z</published>
    <updated>2020-02-20T06:39:39.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="非均衡分类问题"><a href="#非均衡分类问题" class="headerlink" title="非均衡分类问题"></a>非均衡分类问题</h2><blockquote><p>非均衡分类问题指的是每个类别的错误代价不同。</p><p>比如疾病检测中,有病患者诊断健康的代价，要比健康人诊断成有病（可能性）造成的影响更为严重。</p><p>对于常用的预测模型，通常是有预测的概率值，我们找到一个合适的截断点作为正负类别的界限。显然再不同的任务下，截断点选择是不同的。我们使用Precison 和Recall的新度量指标来针对特定任务下选择合适的截断值。</p></blockquote><div class="table-container"><table><thead><tr><th>真实标签</th><th>预测为正</th><th>预测为反</th></tr></thead><tbody><tr><td>正例</td><td>TP</td><td>FN</td></tr><tr><td>反例</td><td>FP</td><td>TN</td></tr></tbody></table></div><ul><li>Precison(查准率)：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P = TP/(TP+FP)</span><br></pre></td></tr></table></figure><ul><li>Recall(召回率)：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R = TP/(TP+FN)</span><br></pre></td></tr></table></figure><blockquote><p>当正负样本不不均衡,人为修改测试集中的正负比例时, P-R曲线波动很大，但是ROC曲线变化很小。</p></blockquote><h2 id="ROC-曲线"><a href="#ROC-曲线" class="headerlink" title="ROC 曲线"></a>ROC 曲线</h2><blockquote><p>可以研究学习器的泛化性能。</p><h2 id="加图"><a href="#加图" class="headerlink" title="加图"></a>加图</h2><ul><li>横坐标：真阳率，正例被正确预测的概率</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FPR = FP/(TN+FP)</span><br></pre></td></tr></table></figure><ul><li>纵坐标：假阳率，负例被预测错误的概率<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TPR = TP/(TP+FN)</span><br></pre></td></tr></table></figure></li></ul><p><strong>==理解四点一线==</strong>：</p><ul><li>(0, 0):  FP = TP = 0, 所有样本预测为负</li><li>(1, 1):  FP = TP = 1, 所有样本预测为正</li><li>(1, 0):  FP = 1, TP = 0, 所有正样本预测为负</li><li>(0, 1):  FP = 0, TP = 1, 完美预测</li><li>对角线：随机猜测的值。</li></ul><h2 id="AUC值"><a href="#AUC值" class="headerlink" title="AUC值"></a>AUC值</h2><p>AUC(Area under Curve) 被定义为ROC曲线的下侧面积。一般在(0.5~1)之间。</p><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><ol><li><p>几何角度</p><blockquote><p>直接计算曲线下的面积，梯形</p></blockquote></li><li><p>概率角度</p><blockquote><p>任取一对正负样本对，正样本score大于负样本score的概率</p></blockquote></li></ol><h3 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h3><p><a href="http://zhuzhuyule.xyz" target="_blank" rel="noopener">链接</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from sklearn.metrics import roc_curve</span><br><span class="line">from sklearn.metrics import auc</span><br><span class="line">from time import time</span><br><span class="line"></span><br><span class="line"># y:     标签</span><br><span class="line"># pred： 预测值</span><br><span class="line">def myAUC(y, pred):</span><br><span class="line"></span><br><span class="line">    auc = 0.0</span><br><span class="line">    p_list = []  # 正负例的索引</span><br><span class="line">    n_list = []</span><br><span class="line">    for i, y_ in enumerate(y):</span><br><span class="line">        if y_ == 1:</span><br><span class="line">            p_list.append(i)</span><br><span class="line">        else:</span><br><span class="line">            n_list.append(i)</span><br><span class="line">    # 构成p-n对</span><br><span class="line">    p_n = [(i,j) for i in p_list for j in n_list]</span><br><span class="line">    </span><br><span class="line">    pn_len = len(p_n)</span><br><span class="line">    for tup in p_n:</span><br><span class="line">        if pred[tup[0]] &gt; pred[tup[1]]:</span><br><span class="line">            auc += 1</span><br><span class="line">        elif pred[tup[0]] == pred[tup[1]]:</span><br><span class="line">            auc += 0.5</span><br><span class="line">    auc = auc/pn_len</span><br><span class="line">    return auc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 产生一组数据</span><br><span class="line">y = np.array([1,0,0,0,1,0,1,0,])</span><br><span class="line">pred = np.array([0.9, 0.8, 0.3, 0.1,0.4,0.9,0.66,0.7])</span><br><span class="line"></span><br><span class="line">## sklearn 结果</span><br><span class="line">fpr, tpr, thresholds = roc_curve(y, pred, pos_label=1)</span><br><span class="line"></span><br><span class="line">tim = time()</span><br><span class="line">print(&quot;sklearn AUC:&quot;,auc(fpr, tpr))</span><br><span class="line">print(&quot;sklearn AUC time:&quot;, time()-tim)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## myAUC 结果</span><br><span class="line">tim = time()</span><br><span class="line">print(&quot;\nmyAUC:&quot;,myAUC(y,pred))</span><br><span class="line">print(&quot;myAUC time:&quot;, time()-tim)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;非均衡分类问题&quot;&gt;&lt;a href=&quot;#非均衡分类问题&quot; class=&quot;headerlink&quot; title=&quot;非均衡分类问题&quot;&gt;&lt;/a&gt;非均衡分类问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;非均衡分类问题指的是每个类别的错误代价不同。&lt;/p&gt;
&lt;p&gt;比如疾病检测中
      
    
    </summary>
    
      <category term="机器学习方法" scheme="http://www.elgong.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="ROC" scheme="http://www.elgong.top/tags/ROC/"/>
    
  </entry>
  
</feed>
