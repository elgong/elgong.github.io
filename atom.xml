<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>elgong&#39;s Home.</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.elgong.top/"/>
  <updated>2020-03-28T04:24:01.401Z</updated>
  <id>http://www.elgong.top/</id>
  
  <author>
    <name>elgong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>版本控制-git</title>
    <link href="http://www.elgong.top/2020/03/28/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-git/"/>
    <id>http://www.elgong.top/2020/03/28/版本控制-git/</id>
    <published>2020-03-28T04:17:11.000Z</published>
    <updated>2020-03-28T04:24:01.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-git-的作用"><a href="#1-git-的作用" class="headerlink" title="1. git 的作用"></a>1. git 的作用</h1><ul><li>版本控制</li><li>协同开发</li></ul><h1 id="2-文件的状态"><a href="#2-文件的状态" class="headerlink" title="2. 文件的状态"></a>2. 文件的状态</h1><ul><li>untracked  (新建的文件)</li><li>unmodified  （提交后进入仓库的文件与当前文件相同，即没修过）</li><li>modified  (commit 之前)</li><li>staged  （commit 之后）</li></ul><h1 id="3-一般使用流程"><a href="#3-一般使用流程" class="headerlink" title="3. 一般使用流程"></a>3. 一般使用流程</h1><h4 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h4><ul><li><code>git init</code></li></ul><h4 id="变更的文件加入暂存区"><a href="#变更的文件加入暂存区" class="headerlink" title="变更的文件加入暂存区"></a>变更的文件加入暂存区</h4><ul><li><code>git add .</code></li></ul><h4 id="提交变更"><a href="#提交变更" class="headerlink" title="提交变更"></a>提交变更</h4><ul><li><code>git commit -m</code></li></ul><h4 id="查看commit日志-并返回某一次提交的版本"><a href="#查看commit日志-并返回某一次提交的版本" class="headerlink" title="查看commit日志, 并返回某一次提交的版本"></a>查看commit日志, 并返回某一次提交的版本</h4><ul><li><code>git log</code>   (### 弹出commit id)</li><li><code>git reset 7hdadsu2qe21e921821e --hard</code></li><li>如果想恢复最新的   <code>git  relog</code></li></ul><h4 id="从暂存区-移除某些文件（add-的文件有多余）"><a href="#从暂存区-移除某些文件（add-的文件有多余）" class="headerlink" title="从暂存区 移除某些文件（add 的文件有多余）"></a>从暂存区 移除某些文件（add 的文件有多余）</h4><ul><li><code>git reset &lt;fileName&gt;</code></li></ul><h1 id="4-分支合作管理"><a href="#4-分支合作管理" class="headerlink" title="4. 分支合作管理"></a>4. 分支合作管理</h1><ul><li>创建分支<ul><li><code>git checkout -b &lt;分支name&gt; &lt;template继承的commit,默认当前&gt;</code></li></ul></li><li>切换分支<ul><li><code>git checkout master</code></li></ul></li><li>查看所有分支<ul><li><code>git branch</code></li></ul></li><li>合并分支的变更（合并到当前master）<ul><li><code>git meger  branch-2</code></li><li>有冲突时，会提示======</li></ul></li></ul><h1 id="5-remote-仓库的使用"><a href="#5-remote-仓库的使用" class="headerlink" title="5. remote 仓库的使用"></a>5. remote 仓库的使用</h1><ul><li><p>下载远端仓库到本地</p><ul><li><code>git clone  ......git</code></li></ul></li><li><p>创建本地的分支</p><ul><li><code>git checkout -b local-A</code></li></ul></li><li><p>在远端仓库设置分支(第一次需要)</p><ul><li><code>git push -set-upstream origin local-A</code></li></ul></li><li><p>提交本地分支到远端</p><ul><li><code>git push</code></li></ul></li><li><p>第一次拉取远端仓库的分支，到本地</p><ul><li><code>git fetch</code>    </li><li><code>git checkout -b &lt;name&gt;</code>origin<code>&lt;template继承的commit,默认当前&gt;</code></li></ul></li><li><p>以后再从远端更新本地</p><ul><li><code>git pull</code> （自动fetch + merge）  </li></ul></li></ul><h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><ul><li><code>git merge</code></li><li><code>git pull</code></li><li><code>git fetch</code></li><li><code>git rebase</code> （版本合并时。。）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-git-的作用&quot;&gt;&lt;a href=&quot;#1-git-的作用&quot; class=&quot;headerlink&quot; title=&quot;1. git 的作用&quot;&gt;&lt;/a&gt;1. git 的作用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;版本控制&lt;/li&gt;
&lt;li&gt;协同开发&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 
      
    
    </summary>
    
      <category term="git" scheme="http://www.elgong.top/categories/git/"/>
    
    
      <category term="版本控制" scheme="http://www.elgong.top/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java集合-目录</title>
    <link href="http://www.elgong.top/2020/01/01/Java-%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84/"/>
    <id>http://www.elgong.top/2020/01/01/Java-集合结构/</id>
    <published>2020-01-01T08:10:40.000Z</published>
    <updated>2020-02-20T04:41:37.804Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/01/01/Java-集合结构/集合.png" alt="logo"></p><p>Java 集合类都在java.util包中，提供了如可变长数组，集合，队列，堆栈，链表等数据结构。<br>宏观上看整个结构可以分为两大部分： 属于单列集合Collection 接口和带映射的多列集合的Map接口。</p><ul><li><p><a href="www.elgong.top"><strong>Collection</strong></a> 接口：集合的基本操作和属性</p><ul><li><p><strong>List</strong> 接口：有序列表</p><ul><li><a href="www.elgong.top"><strong>ArrayList</strong></a>：  可变长的数组。 </li><li><a href="www.elgong.top"><strong>LinkedList</strong></a>： 双端队列的链表结构。 </li></ul></li><li><p><strong>Set</strong> 接口： 不重复元素的集合</p><ul><li><a href="www.elgong.top"><strong>HashSet</strong></a>： HashMap 实现的，无序。</li><li><a href="www.elgong.top"><strong>TreeSet</strong></a>：  HashMTree 实现的，有序。</li></ul></li><li><strong>Queue</strong> 接口： <ul><li><strong>Deque</strong> 接口：  <a href="www.elgong.top"><strong>LinkedList</strong></a></li></ul></li></ul></li><li><p><a href="http://zhuzhuyule.xyz" target="_blank" rel="noopener"><strong>Map</strong></a> 接口：key-value键值对的映射接口</p><ul><li><a href="http://zhuzhuyule.xyz" target="_blank" rel="noopener"><strong>HashMap</strong></a>：<em>数组+链表</em> 组成的哈希表，无序。</li><li><a href="http://zhuzhuyule.xyz" target="_blank" rel="noopener"><strong>TreeMap</strong></a>：基于 <em>红黑树的排序顺序</em> 存储键/值对，有序。</li><li><a href="http://zhuzhuyule.xyz" target="_blank" rel="noopener"><strong>Hashtable</strong></a>： HashMap类很相似，支持同步。</li></ul></li></ul><p><strong>两个工具类</strong>：</p><ul><li><strong>Arrays</strong></li><li><strong>Collections</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2020/01/01/Java-集合结构/集合.png&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;
&lt;p&gt;Java 集合类都在java.util包中，提供了如可变长数组，集合，队列，堆栈，链表等数据结构。&lt;br&gt;宏观上看整个结构可以分为两大部分： 属于单列集合C
      
    
    </summary>
    
      <category term="Java基础" scheme="http://www.elgong.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java集合" scheme="http://www.elgong.top/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础学习笔记</title>
    <link href="http://www.elgong.top/2019/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.elgong.top/2019/12/16/计算机基础学习笔记/</id>
    <published>2019-12-16T05:47:07.000Z</published>
    <updated>2020-03-23T06:07:04.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Computer-Basics-Notes-Links"><a href="#Computer-Basics-Notes-Links" class="headerlink" title="Computer-Basics-Notes-Links"></a>Computer-Basics-Notes-Links</h1><p><a href="https://github.com/elgong/Computer-Basics-Notes-Links" target="_blank" rel="noopener">github地址</a></p><h1 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h1><blockquote><p>我在学习计算机基础的过程中整理了一部分笔记，但都比较零散，有些稍微连贯的内容已经整理为博客，而大部分还没来得及整理成md格式，我先整理出链接。为了尽可能的清晰展示笔记脉络，下文将分门别类的列出，有需要请自取。<br>笔记内容大部分都是参考了网上的博客以及书籍，整理笔记的习惯也是刚刚养成的，从开始整理笔记后，发现自己对于做过的东西，能够随着笔记很快的回忆起来，遇到一些问题能够快速从笔记里找到答案也是比较舒服的。笔记是用有道云分享的，我未来仍然会继续梳理这些笔记，如果有任何的错误或者意见，麻烦您联系我哈。</p></blockquote><h2 id="1-计算机基础篇"><a href="#1-计算机基础篇" class="headerlink" title="1.计算机基础篇"></a>1.计算机基础篇</h2><blockquote><p>基础部分是一些语言相关的知识点。</p></blockquote><h3 id="1-1-Java-相关"><a href="#1-1-Java-相关" class="headerlink" title="1.1 Java 相关"></a>1.1 Java 相关</h3><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p><a href="http://note.youdao.com/noteshare?id=f869167b77cb73b67478290ffdcf45bc&amp;sub=06694CB1F00B45CBA1D4BD1A4B62320C" target="_blank" rel="noopener">Java面向对象-多态</a></p><h4 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h4><p><a href="http://note.youdao.com/noteshare?id=def11ef6e833a11434137d6fec1c834a&amp;sub=DD0083BFCFE14839A721700413B41F38" target="_blank" rel="noopener">java.lang.Object 类</a></p><p><a href="http://note.youdao.com/noteshare?id=fb941f5b4a01adf474496df328542a91&amp;sub=02C7EDC387984E3BADE744B9280EA1E6" target="_blank" rel="noopener">java.lang.Integer等基本类型包装类</a></p><h4 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h4><p><a href="http://note.youdao.com/noteshare?id=7bdd684a91766f6b448e5328f1fed251&amp;sub=0DEE02584D22485EACF337D5F846ACCE0" target="_blank" rel="noopener">接口和抽象类的概念</a></p><p><a href="http://note.youdao.com/noteshare?id=eb3b5e1f37828c301015c1fcc48b2ee9&amp;sub=B77DF9D467AE48948C63CEE6D7B51FB5" target="_blank" rel="noopener">java.io.Serializable接口</a></p><p><a href="http://note.youdao.com/noteshare?id=af26732dc5f501e490a3f57c6b46333c&amp;sub=1E9132AF928342728B68D66845201D05" target="_blank" rel="noopener">java.lang.AbstractStringBuilder</a></p><p><a href="http://note.youdao.com/noteshare?id=62429dcbeb51676d855b0c46d89ea67b&amp;sub=7D9CC78E517B46A19C567A567DDA0C1E" target="_blank" rel="noopener">java.lang.CharSequence接口</a></p><p><a href="http://note.youdao.com/noteshare?id=4309c54f9e557075dc953a25a1e9aea4&amp;sub=4AF6A4102AD6494F884069B5F75DB663" target="_blank" rel="noopener">java.lang.Comparable 接口</a></p><p><a href="http://note.youdao.com/noteshare?id=d7525d979bbcfac0ad602e0f90124a39&amp;sub=9B8E20EC1E924C988EB9DEC3C059FE4F" target="_blank" rel="noopener">java.lang.Iterable 接口</a></p><h4 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h4><p><a href="http://note.youdao.com/noteshare?id=3f13ce83c60473cb2d03ac7d500b3771&amp;sub=77608E57EC404A3D925D5BADFABA9F0C" target="_blank" rel="noopener">Java集合的结构</a></p><p><a href="http://note.youdao.com/noteshare?id=8d5718ecf80ea7c1cd144c848afb556f&amp;sub=D12BF9FEA9B54873871F5BDC532FB46A" target="_blank" rel="noopener">java.util.Arrays工具类</a></p><p><a href="http://note.youdao.com/noteshare?id=55f2b8f2004cc365aa3200283f918642&amp;sub=373C38673F3D4233869F2FA181CF6C77" target="_blank" rel="noopener">java.util.Collections 工具类</a></p><p><a href="http://note.youdao.com/noteshare?id=2d1b0ca8f6ee80acab26bac64e65752b&amp;sub=BC00717F11EC48DBAA3187C99E27FB67" target="_blank" rel="noopener">集合类之间的转换</a></p><h4 id="Collection"><a href="#Collection" class="headerlink" title="##### Collection"></a>##### Collection</h4><p><a href="http://note.youdao.com/noteshare?id=cf4402932c37eeda65d2cb48b771fa85&amp;sub=38A358238D644B009E8D35E85BC3958A" target="_blank" rel="noopener">java.util.Collection 接口</a></p><p><a href="http://note.youdao.com/noteshare?id=35066dabdc8838cbf4a81a6064d3a278&amp;sub=B08F3371DAF94E0A8577E14A355948F7" target="_blank" rel="noopener">java.util.List 接口</a></p><p><a href="http://note.youdao.com/noteshare?id=ac00534071924ed6812c3087ff89522d&amp;sub=7CF204D01C2846469F874ABE719F122E" target="_blank" rel="noopener">java.util.ArrayList 类</a></p><p><a href="http://note.youdao.com/noteshare?id=24e53ad8811d97e37ae725caef30e87c&amp;sub=3580B9F523B14B9A8346594FAB7428B7" target="_blank" rel="noopener">java.util.LinkedList 类</a></p><p><a href="http://note.youdao.com/noteshare?id=3fefcc71bac40f731582cda7de9680a9&amp;sub=FD48F85901CA48C2A1FDBFB356072932" target="_blank" rel="noopener">java.util.Vector类-线程安全</a></p><p><a href="http://note.youdao.com/noteshare?id=7ca967ab85ba51315d576614e4debb88&amp;sub=D7FB8F63F9524697A2B6C92EBC997759" target="_blank" rel="noopener">java.util.Stack类-线程安全</a></p><p><a href="http://note.youdao.com/noteshare?id=e69b12c5f34e8999a63f901e66cf6349&amp;sub=378BBC5185DD4901949BA8D6CC586117" target="_blank" rel="noopener">java.util.Queue 接口</a></p><p><a href="http://note.youdao.com/noteshare?id=70bcfde9362d131a6cc9769df7c6a195&amp;sub=4CCDF46A03F64701B726C3B5B17EE5C7" target="_blank" rel="noopener">java.util.Deque 接口</a></p><p><a href="http://note.youdao.com/noteshare?id=a8e52263383bbff56bba83c4437e62a5&amp;sub=273730F39B6345348B400731471932CD" target="_blank" rel="noopener">java.util.ArrayDeque 类</a></p><p><a href="http://note.youdao.com/noteshare?id=d5807c6cbb3dfcd1c6a6fa2587f2a53a&amp;sub=8DB19EF833FF477C8241702AB6C728D4" target="_blank" rel="noopener">java.util.PriorityQueue 类</a></p><p><a href="http://note.youdao.com/noteshare?id=78367406564a757c47fbb5fd74ab4118&amp;sub=CD2FAD0FE2EE433EAFEB76285A06D389" target="_blank" rel="noopener">java.util.Set 接口</a></p><p><a href="http://note.youdao.com/noteshare?id=473ccb760a498a837a6fca3373b1f6d1&amp;sub=EF96DCB65AD1431BBCFBB52F21896643" target="_blank" rel="noopener">java.util.HashSet 类</a></p><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p><a href="http://note.youdao.com/noteshare?id=8066dded44e4cba4a621fe78ed94c4a9&amp;sub=B9652D8B6D7940FFB5C92A5106BCC277" target="_blank" rel="noopener">java.util.Map 接口</a></p><p><a href="http://note.youdao.com/noteshare?id=de517d176afdc4e3d0c9887c437bee17&amp;sub=459B4CAF65FF4D67BFBE91DCED6E050E" target="_blank" rel="noopener">java.util.TreeMap 类</a></p><p><a href="http://note.youdao.com/noteshare?id=791e29ca757ab1dedb8f80d872c940b1&amp;sub=70D9B6BA82AF4889ACAD0A52F18C456D" target="_blank" rel="noopener">java.util.HashMap 类</a></p><p><a href="http://note.youdao.com/noteshare?id=473ccb760a498a837a6fca3373b1f6d1&amp;sub=EF96DCB65AD1431BBCFBB52F21896643" target="_blank" rel="noopener">java.util.HashSet 类</a></p><h4 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h4><p><a href="http://note.youdao.com/noteshare?id=658c32dde4ecf6c8525649914d0f8560&amp;sub=FF09583558E14D2BA25680647013CBA3" target="_blank" rel="noopener">标准步骤：</a></p><p><a href="http://note.youdao.com/noteshare?id=3dec994dd95a401eed7aabdfb1c5c15f&amp;sub=CAB6771BB0F044F895A705B8AB7514BC" target="_blank" rel="noopener">针对oj系统中的输入问题</a></p><p><a href="http://note.youdao.com/noteshare?id=1a496522d91fa47b4f3132aa97228ab7&amp;sub=CD032B0A9E714FE9ABB2BE05B49CEE75" target="_blank" rel="noopener">java IO之AutoCloseable接口</a></p><h4 id="多线程与并发"><a href="#多线程与并发" class="headerlink" title="多线程与并发"></a>多线程与并发</h4><p><a href="http://note.youdao.com/noteshare?id=b7407e24b468fd58df564afcbf749183&amp;sub=954EE84618B44B6FAFE4931E4F691873" target="_blank" rel="noopener">synchronized 锁的JVM中实现原理-偏向</a></p><p><a href="http://note.youdao.com/noteshare?id=0f69c79fd2c666de113882fd3ac72abf&amp;sub=61118765FB1F4B85B048C652460A5768" target="_blank" rel="noopener">线程的创建</a></p><p><a href="http://note.youdao.com/noteshare?id=49735f35157748a107270cb85fbb867c&amp;sub=0D34816A0AA24981B0B61EB87A64C8D4" target="_blank" rel="noopener">线程间的通信</a></p><p><a href="http://note.youdao.com/noteshare?id=12aac80f35ab764277a810af76852cb2&amp;sub=4A4D685F065F46B9B60D9703CEE04D29" target="_blank" rel="noopener">线程的生命周期</a></p><p><a href="http://note.youdao.com/noteshare?id=8d401fdafcc6c5712042fa06f6e3850b&amp;sub=96CD2BBFE5914F089493A803A5B7D020" target="_blank" rel="noopener">对象和变量的并发访问（可见性，原子性</a></p><p><a href="http://note.youdao.com/noteshare?id=ed1aa8d1cf7688f52c1598735165a2dc&amp;sub=15233B8FCFFB4E11AC6167CE4BF4077E" target="_blank" rel="noopener">java.util.concurrent.locks包 </a></p><p><a href="http://note.youdao.com/noteshare?id=291668d9a729451d6c913b3137c9640f&amp;sub=B28DDF08EC1F4457BFF740A9D8869FE5" target="_blank" rel="noopener">J.U.C多线程1-Executor 框架的梳理</a></p><p><a href="http://note.youdao.com/noteshare?id=5b0658b7d6383586ef61f9c80ef3d249&amp;sub=CE01D9FD424D45BCA78F88E1A0149C0D" target="_blank" rel="noopener">J.U.C多线程2-ThreadPoolExecutor线程</a></p><p><a href="http://note.youdao.com/noteshare?id=cb9e9ac4838bfdbb7e23f67711f2a84a&amp;sub=859FFFFB9E664A18BB2DBE355F094405" target="_blank" rel="noopener">实现BlockingQueue接口的阻塞队列</a></p><p><a href="http://note.youdao.com/noteshare?id=19714d2d692039c32ebba2ee3e4829e0&amp;sub=2F7585F44D7E4DBE84E9487A24766668" target="_blank" rel="noopener">J.U.C多线程3-CAS比较和交换 </a></p><p><a href="http://note.youdao.com/noteshare?id=6a89441511d69a3bced7209ba47b736b&amp;sub=4A1DC26FB09D4E0C9D6086E37FDEAD6B" target="_blank" rel="noopener">J.U.C多线程3-AQS 同步器框架的梳理</a></p><p><a href="http://note.youdao.com/noteshare?id=4ef9100e71f2628636a4bff9b73fe882&amp;sub=7998ABD160384F36A606B72FB7493232" target="_blank" rel="noopener">J.U.C多线程4-AQS框架的应用</a></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><a href="http://note.youdao.com/noteshare?id=d30458d5aac2da6b78824e51dbd982a5&amp;sub=1C451DD2DB6F4481AB58D42E0AA63C44" target="_blank" rel="noopener">泛型（泛型接口、泛型类、泛型方法）</a></p><p><a href="http://note.youdao.com/noteshare?id=d7092de3662bbf7b0d73b15313fbab0f&amp;sub=95A433A8DC2A4E6FBCF8B54D4767BC40" target="_blank" rel="noopener">字符串类型-String,StringBuilder..</a></p><p><a href="http://note.youdao.com/noteshare?id=9b7abb4a2896be59b9ed6629d028a5c6&amp;sub=4C6D630F214D45DCA01450F1907C6266" target="_blank" rel="noopener">java 编码规范- google</a></p><p><a href="http://note.youdao.com/noteshare?id=a3af60be0ecf53e817c4954ab4b3f2dd&amp;sub=80F0D1E1017E4522B63882A48BE17CF2" target="_blank" rel="noopener">Java8- Lambda 表达式</a></p><p><a href="http://note.youdao.com/noteshare?id=29117a52793f44078077602c6f47252f&amp;sub=9B5D88DF10A94DCD968EA4C8263241C9" target="_blank" rel="noopener">动手实现ArrayList</a></p><p><a href="http://note.youdao.com/noteshare?id=893e0088e06c4e3cd1073a6abeb7bda4&amp;sub=AE4EBC77232149368BEFD526D435B452" target="_blank" rel="noopener">java 知识点梳理</a></p><p><a href="http://note.youdao.com/noteshare?id=2b866c01ebed8c2f6594e3357ae349be&amp;sub=AA305E3F95724374B5A3C5D96D654270" target="_blank" rel="noopener">Java 刷题遇到的问题</a></p><p><a href="http://note.youdao.com/noteshare?id=7c544d8a0a428eb5c142c36e771c5fac&amp;sub=1DE4594384FD444F9C705D73C3A26556" target="_blank" rel="noopener">基本数据类型and 初始化</a></p><h4 id="jvm-虚拟机"><a href="#jvm-虚拟机" class="headerlink" title="jvm 虚拟机"></a>jvm 虚拟机</h4><p><a href="http://note.youdao.com/noteshare?id=4be4640b0d30a46e8e4936fca48fc4da&amp;sub=E4ACF7E445F4469FB7C49A184325AA3A" target="_blank" rel="noopener">jvm1-内存模型-运行时数据区</a></p><p><a href="http://note.youdao.com/noteshare?id=044b5c8d572a50aa43f7476075feacd6&amp;sub=CB5ACEE22D7C4B119E920A983456E348" target="_blank" rel="noopener">jvm2-类加载机制</a></p><p><a href="http://note.youdao.com/noteshare?id=38a77fc1b5541c7443a42bb8936ad699&amp;sub=AC6273A6423A45D49DF9D7BA2C02D087" target="_blank" rel="noopener">jvm3-对象的创建过程</a></p><p><a href="http://note.youdao.com/noteshare?id=85b9df0570061425d77cd09d542758a3&amp;sub=C25619379B2547F5A492FB6900FA53F9" target="_blank" rel="noopener">jvm4-垃圾回收机制 </a></p><p><a href="http://note.youdao.com/noteshare?id=3f927397764ecb9a72e25d53d1a8447e&amp;sub=DB8BF7AF904E4224A287A4B22D114460" target="_blank" rel="noopener">自定义类加载器实现热部署，热替换</a></p><h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><p><a href="http://note.youdao.com/noteshare?id=6f70c51df350a1da3b7353b5f0876ba1&amp;sub=A890AA4181A64A17B14D21040C1A9724" target="_blank" rel="noopener">反射</a></p><p><a href="http://note.youdao.com/noteshare?id=cfb346b9be695d57572367fd3143531e&amp;sub=DE178E988586406F87227AC75BD725CE" target="_blank" rel="noopener">Java 动态代理</a></p><h3 id="1-2-数据库相关"><a href="#1-2-数据库相关" class="headerlink" title="1.2 数据库相关"></a>1.2 数据库相关</h3><h4 id="数据库的安装"><a href="#数据库的安装" class="headerlink" title="数据库的安装"></a>数据库的安装</h4><p><a href="http://note.youdao.com/noteshare?id=eec529b536dfe09cbbb2d2305a9cec2c&amp;sub=DB98C14DBC15458ABE1B8461CD4C6988" target="_blank" rel="noopener">windwos 环境中 mysql 数据库安装</a></p><p><a href="http://note.youdao.com/noteshare?id=32e1a61698644f735e5ae33a0d285bee&amp;sub=WEB845b970c5cb400fcf42e04843dbd70af" target="_blank" rel="noopener">ubuntu 环境中 mysql 安装</a></p><h4 id="学习笔记-1"><a href="#学习笔记-1" class="headerlink" title="学习笔记"></a>学习笔记</h4><p><a href="http://note.youdao.com/noteshare?id=c98cc599b42b416ea2bd0aec7fd11fff&amp;sub=833E6D40B97E4F2F98EFD56C010FE4C7" target="_blank" rel="noopener">JDBC 使用</a></p><p><a href="http://note.youdao.com/noteshare?id=71dd174ad72a6cca26ae011637d4a705&amp;sub=E3BE9112006D4380953846BA1E446964" target="_blank" rel="noopener">mysql必知必会</a></p><p><a href="http://note.youdao.com/noteshare?id=4d74a6536781f195ffb428a0aa74fabe&amp;sub=9A407FE68AB54120B18950BEE5500BAF" target="_blank" rel="noopener">数据库-三大范式</a></p><p><a href="http://note.youdao.com/noteshare?id=78c16d370ba2bf4d06fd1d253072d582&amp;sub=6B15DEFDC24B4353A5820B68A5FB2C05" target="_blank" rel="noopener">数据库ER图基础</a></p><p><a href="http://note.youdao.com/noteshare?id=f0c534778c8fde528be10f4ffdb2c03b&amp;sub=336222838CDC4F249C1210E24D3701AD" target="_blank" rel="noopener">mysql必知必会1-DDL数据定义语言</a></p><p><a href="http://note.youdao.com/noteshare?id=360395368205af6b9cd43b67c17200af&amp;sub=3BAEE4ACEA0F4FC2A40AB4DC39965766" target="_blank" rel="noopener">mysql必知必会2-DML数据操作语句</a></p><p><a href="http://note.youdao.com/noteshare?id=3a8535b5bdf8fbe6b46b85a8f6ab707e&amp;sub=0C9D47245F604624A95E1982D45157F2" target="_blank" rel="noopener">mysql必知必会3-TCL事务控制语言</a></p><p><a href="http://note.youdao.com/noteshare?id=5a66c81500067c3bafc11fb31cc56cd6&amp;sub=6ADA92683A36438EB254D18AE729A6FA" target="_blank" rel="noopener">mysql必知必会4-数据类型和约束</a></p><p><a href="http://note.youdao.com/noteshare?id=8b1f73787548684951c21dea07576331&amp;sub=E95C55AAF40F4378B7A14176911B4B81" target="_blank" rel="noopener">mysql必知必会5-视图</a></p><p><a href="http://note.youdao.com/noteshare?id=d71e1773bdfb453b885ec8280980823e&amp;sub=B0AFAE28DCC94DF09AE25F420927921E" target="_blank" rel="noopener">mysql必知必会6-变量，存储过程，函数….</a></p><p><a href="http://note.youdao.com/noteshare?id=71dd174ad72a6cca26ae011637d4a705&amp;sub=E3BE9112006D4380953846BA1E446964" target="_blank" rel="noopener">mysql必知必会7</a></p><p>(<a href="http://note.youdao.com/noteshare?id=79d83c8dcc01b75a80003dceb059f72b&amp;sub=FE5D2429B49241419E96AD94536EB55C" target="_blank" rel="noopener">http://note.youdao.com/noteshare?id=79d83c8dcc01b75a80003dceb059f72b&amp;sub=FE5D2429B49241419E96AD94536EB55C</a>)</p><p><a href="http://note.youdao.com/noteshare?id=003c0cce526f2a71945614993d250377&amp;sub=56317DB968F04FE3BCC0D482D083C877" target="_blank" rel="noopener">索引优化1-索引的概念 </a></p><p><a href="http://note.youdao.com/noteshare?id=a527e1fa83cc6b429814c2f8710b891c&amp;sub=9B9BDA5A138144B5A5A5E5C4BE6CE1D1" target="_blank" rel="noopener">索引优化2-Mysql索引的底层实现 </a></p><p><a href="http://note.youdao.com/noteshare?id=f35d29b727ca3a228bfad4aac0a9e9e6&amp;sub=53F88FCDB69547E895DAD25A7D402035" target="_blank" rel="noopener">索引优化3- explain 查看执行计划 </a></p><p><a href="http://note.youdao.com/noteshare?id=a83b6505ac7dbb6b3c69afd1860b8ccb&amp;sub=C419B2D7DA254E589E0F449A60544A1C" target="_blank" rel="noopener">Sql语句优化-查询截取分析 </a></p><p><a href="http://note.youdao.com/noteshare?id=f8935a502a43186c1c821ad33ccc2c6d&amp;sub=5D286DE5F8304B8BA7290255DBF15C0C" target="_blank" rel="noopener">mysql-数据库锁的机制和原理 </a></p><h3 id="1-3-计算机网络相关"><a href="#1-3-计算机网络相关" class="headerlink" title="1.3 计算机网络相关"></a>1.3 计算机网络相关</h3><p><a href="http://note.youdao.com/noteshare?id=92e3adba9198d367e976bcc3f772d149&amp;sub=7F7B0D8B9F3E4D7996815384809C35EA" target="_blank" rel="noopener">互联网协议入门1-模型分层</a></p><p><a href="http://note.youdao.com/noteshare?id=8c41ad2717d4deee47f83841e49d755b&amp;sub=C0C042EE387F4A0096F427CE6F391887" target="_blank" rel="noopener">互联网协议入门2-访问网页的过程</a></p><p><a href="http://note.youdao.com/noteshare?id=e7f3f660c5df2335b7eccb7be89ce514&amp;sub=A775AFCC161A4388859120A340BDC6CB" target="_blank" rel="noopener">互联网协议入门3-TCP协议详细内容（传?..</a></p><p><a href="http://note.youdao.com/noteshare?id=71031b3ed61c6e8bd302a8577f6c396f&amp;sub=0F5DF1F408844E7184F3A6BB5F868F89" target="_blank" rel="noopener">互联网协议入门4-Http协议（应用层）.n…</a></p><h3 id="1-4-Python-相关"><a href="#1-4-Python-相关" class="headerlink" title="1.4 Python 相关"></a>1.4 Python 相关</h3><p><a href="http://note.youdao.com/noteshare?id=398da3b52370f6976e9a67cb3be4cd24&amp;sub=WEBf9be5147ccbf73c569b46bb2a5ffe942" target="_blank" rel="noopener">Anaconda 使用</a></p><p><a href="http://note.youdao.com/noteshare?id=a813207158a22cfa902dbeba640bdf87&amp;sub=E61484FE7B0D4D999DF1A462FA780049" target="_blank" rel="noopener">python 性能优化</a></p><p><a href="http://note.youdao.com/noteshare?id=dde4ed2eb6eea6c45926d251689e3d4e&amp;sub=4A1EA0D89E634DEC9DD294C13012EFCA" target="_blank" rel="noopener">python 内存管理</a></p><p><a href="http://note.youdao.com/noteshare?id=9146e0886cac1bdaec8cce2e5081cfe0&amp;sub=060F7616DF954602BB641EC52D0F6110" target="_blank" rel="noopener">python 包管理</a></p><p><a href="http://note.youdao.com/noteshare?id=3724fe43398de6c5fbd75dd8c452987e&amp;sub=7837405EB49045FF8C22156022261A94" target="_blank" rel="noopener">知识积累</a></p><p><a href="http://note.youdao.com/noteshare?id=bfbf2eb0c5bccf64974fe260e1bdf131&amp;sub=A8906CE9DF0E47F19377CD49BF2DFA6F" target="_blank" rel="noopener">python 数据模型</a></p><p><a href="http://note.youdao.com/noteshare?id=0f7309f661031855b1e257072ceab9b9&amp;sub=E6CAEE5B6F7043779DF1F3A95923DC0F" target="_blank" rel="noopener">Set 集合  交并差运算</a></p><h4 id="pandas-包"><a href="#pandas-包" class="headerlink" title="pandas 包"></a>pandas 包</h4><p><a href="http://note.youdao.com/noteshare?id=f191fc11a263f303532d40c02c1f2161&amp;sub=3F6F9858E4DA4B7A9245F66557B15AB4" target="_blank" rel="noopener">pandas</a></p><p><a href="http://note.youdao.com/noteshare?id=57496ba2051b12d778ac17612d871354&amp;sub=62AE7AB578AF4B3A9D630676179C8CA0" target="_blank" rel="noopener">pandas-5缺失值处理</a></p><p><a href="http://note.youdao.com/noteshare?id=7b8a86d71c5321171292fa000666efc8&amp;sub=A1102303D97F4E2D836A588F4882C5E2" target="_blank" rel="noopener">pandas-2索引和选择数据</a></p><p><a href="http://note.youdao.com/noteshare?id=02c6e6a9916d2f600153fa5402395c29&amp;sub=0CF2D73FB22140A29F3838CF6EF299B9" target="_blank" rel="noopener">pandas-分层和多级索引</a></p><p><a href="http://note.youdao.com/noteshare?id=f16646b876ddb2c5ec482e316ca881dd&amp;sub=8024BDCE94B4455FA20514234C7233C0" target="_blank" rel="noopener">pandas-6重复值处理</a></p><p><a href="http://note.youdao.com/noteshare?id=5210591266c5f2472eab6bdb0e1adc7e&amp;sub=7B85239BB0C74343830F3EBBC34F43A0" target="_blank" rel="noopener">pandas-7时间处理</a></p><p><a href="http://note.youdao.com/noteshare?id=b8d6c15c3d603261cee9b6771732c5a5&amp;sub=WEB9f17e5d4ecb0520c9c27c8145f3450dc" target="_blank" rel="noopener">pandas-4分组与聚合</a></p><p><a href="http://note.youdao.com/noteshare?id=64c2febf14a2e0f96bcbc868375500b9&amp;sub=0B21232330E442118F68ADFB44DECA6E" target="_blank" rel="noopener">pandas-1数据结构</a></p><h3 id="1-5-数据结构与算法相关"><a href="#1-5-数据结构与算法相关" class="headerlink" title="1.5 数据结构与算法相关"></a>1.5 数据结构与算法相关</h3><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p><a href="http://note.youdao.com/noteshare?id=77d45fd3df6dc9821a505972246afc67&amp;sub=CBBC8BE4E72147248464A2C136D8A893" target="_blank" rel="noopener">链表入门-单链表</a></p><p><a href="http://note.youdao.com/noteshare?id=2038af6c36c144a0005d3f7cb7cbd6e1&amp;sub=19BC0DEA04654C51970F77E363746D36" target="_blank" rel="noopener">双向链表</a></p><h4 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h4><p>[树结构1-二叉树的种类 </p><p>](<a href="http://note.youdao.com/noteshare?id=3d87798249099424c8f688932e054d34&amp;sub=962de575938af485eb5896712a3fa88bhttp://note.youdao.com/noteshare?id=3d87798249099424c8f688932e054d34&amp;sub=962de575938af485eb5896712a3fa88b" target="_blank" rel="noopener">http://note.youdao.com/noteshare?id=3d87798249099424c8f688932e054d34&amp;sub=962de575938af485eb5896712a3fa88bhttp://note.youdao.com/noteshare?id=3d87798249099424c8f688932e054d34&amp;sub=962de575938af485eb5896712a3fa88b</a>)</p><p><a href="http://note.youdao.com/noteshare?id=a93bf51802eb22ed23e7f01baeecdfd9&amp;sub=C2561C42F8354E2787F3F58DC19CC2F5" target="_blank" rel="noopener">树结构2-二叉树的四种遍历</a></p><p><a href="http://note.youdao.com/noteshare?id=6595e3f3a04494d53c79ac4f14156b45&amp;sub=36364C54AB334D5B85B1871D6758FFF7" target="_blank" rel="noopener">树结构3- 二叉排序树 </a></p><p><a href="http://note.youdao.com/noteshare?id=ff1c7f5f5c5439a5bcf29746bafacd8e&amp;sub=524DD42459CF4A43AB7CD89A74D83BAB" target="_blank" rel="noopener">树结构4- 完全二叉树-堆排序 </a></p><p><a href="http://note.youdao.com/noteshare?id=28a1554677d3108539d237ed2dbfb3a9&amp;sub=6917ECACABFC4BE99B0840940E1492C3" target="_blank" rel="noopener">树结构5-红黑树 </a></p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p><a href="http://note.youdao.com/noteshare?id=32bb87989cc88c68f94b697a2309e577&amp;sub=CB4F1BAE4B48482B895E4B334EC920B7" target="_blank" rel="noopener">栈 - Stack</a></p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p><a href="http://note.youdao.com/noteshare?id=2bf63868f3e17320b15a68783a6f1d89&amp;sub=35032594A3AB441EB7DB3344B71213EF" target="_blank" rel="noopener">动态规划-DP</a></p><p><a href="http://note.youdao.com/noteshare?id=47da45a5509c7f21f5905c65ec87c12d&amp;sub=E525698B083343B382EFC767181A2755" target="_blank" rel="noopener">DFS和回溯算法- 暴力搜索的优化方案</a></p><h4 id="一般算法"><a href="#一般算法" class="headerlink" title="一般算法"></a>一般算法</h4><p><a href="http://note.youdao.com/noteshare?id=6139197ff7cc443d83b73f578ced01d2&amp;sub=3671B7672DA341359DF0C57DAA5114E3" target="_blank" rel="noopener">二分查找</a></p><p><a href="http://note.youdao.com/noteshare?id=417cd36012151f1465f6b179a68c2559&amp;sub=39B0B9975CC34C589CCCF7A4A619E921" target="_blank" rel="noopener">最大公约数与最小公倍数</a></p><p><a href="http://note.youdao.com/noteshare?id=b9bb5b1c7a7f968392ca087beb53a288&amp;sub=7AC07884471A4FFBAC433400CC8DD668" target="_blank" rel="noopener">素数和合数</a></p><p><a href="http://note.youdao.com/noteshare?id=900f90e3d481dcabbd5ce22df8452e4b&amp;sub=2A9F48EDC9824721A63091F213AE84DF" target="_blank" rel="noopener">排序算法-Java版</a></p><h3 id="1-6-设计模式"><a href="#1-6-设计模式" class="headerlink" title="1.6 设计模式"></a>1.6 设计模式</h3><p><a href="http://note.youdao.com/noteshare?id=9b725da8bd83d6d2fa6628449036fa76&amp;sub=61D7D7C472CC4F6FA40978D2EEE3F253" target="_blank" rel="noopener">单例模式</a></p><p><a href="http://note.youdao.com/noteshare?id=3258d6710e66d885a3a213d45eea14be&amp;sub=9E8B81697FD248EDBAAB8B203ACDD4B9" target="_blank" rel="noopener">汇总 </a></p><h2 id="2-计算机提高篇"><a href="#2-计算机提高篇" class="headerlink" title="2 计算机提高篇"></a>2 计算机提高篇</h2><blockquote><p>提高篇是一些具体的学习方向，我学的比较杂。</p></blockquote><h3 id="2-1-机器学习与数据挖掘"><a href="#2-1-机器学习与数据挖掘" class="headerlink" title="2.1 机器学习与数据挖掘"></a>2.1 机器学习与数据挖掘</h3><p><a href="http://note.youdao.com/noteshare?id=a2a581480ef2d48c22c8972e2c1289ea&amp;sub=WEBe5a19e45418f24614a27d5c871dbeef6" target="_blank" rel="noopener">特征工程中的问题</a></p><h4 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h4><p><a href="http://note.youdao.com/noteshare?id=72d77f019bd4fc8cde5d77f1479213a3&amp;sub=3A0C8DB3DE554ED5B70179B18DEBDB6F" target="_blank" rel="noopener">决策树-1基本概念</a></p><p><a href="http://note.youdao.com/noteshare?id=6b4b7d196688d64889da3563eb4b194d&amp;sub=E48B826F34CB41769382CA5DD11DE54F" target="_blank" rel="noopener">决策树-2 ID3算法</a></p><p><a href="http://note.youdao.com/noteshare?id=51ba5d9d9611ae2284c2612d5f38b721&amp;sub=C40D67A492D4428EB698D146897932F2" target="_blank" rel="noopener">决策树-3 CART分类回归树</a></p><p><a href="http://note.youdao.com/noteshare?id=8fd42b53e1a611131199f17d399820c7&amp;sub=F7FA6EBCE1CC4A95875DD83B2CF9C551" target="_blank" rel="noopener">CART 分类回归树</a></p><p><a href="http://note.youdao.com/noteshare?id=d5d006e5d1680bb1b93f6cdc68973b60&amp;sub=C12A5DC3350C49CA8862D51287908CE4" target="_blank" rel="noopener">sklearn 决策树使用技巧</a></p><p><a href="http://note.youdao.com/noteshare?id=3a209c356ed655acacf08699cef27150&amp;sub=E0880A97A8264449BD714025A98BFE52" target="_blank" rel="noopener">sklearn整理-决策树</a></p><h4 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h4><p><a href="http://note.youdao.com/noteshare?id=d1d1a974ade3ab72cd8ff9fbab061e78&amp;sub=6C8F11DB78FA417AA9F4D0DA30351077" target="_blank" rel="noopener">常见的神经网络</a></p><h4 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h4><p><a href="http://note.youdao.com/noteshare?id=fb4b442794aac472bdd7663b026a2dab&amp;sub=939B2AAEB6F94E32ABAD4A54B8AF1358" target="_blank" rel="noopener">集成学习提升算法-Adaboost</a></p><p><a href="http://note.youdao.com/noteshare?id=eb03f9b12281363b052e0ed071833b13&amp;sub=WEBb2a9d589fb05754f76c2b2af09a826c1" target="_blank" rel="noopener">XGBoost -python package introduction</a></p><p><a href="http://note.youdao.com/noteshare?id=2039180d0a9ad5b39339c93e8c70040d&amp;sub=9C48D93E6A1E4C1186E6F37EF222F528" target="_blank" rel="noopener">梯度提升树-GBDT</a></p><p><a href="http://note.youdao.com/noteshare?id=e4ac54bae64eb94641594ad5f4a2cd6d&amp;sub=8232CAC65C0A4FDC9EDED033B6A4770F" target="_blank" rel="noopener">sklearn整理-集成学习-随机森林</a></p><h4 id="模型评价"><a href="#模型评价" class="headerlink" title="模型评价"></a>模型评价</h4><p><a href="http://note.youdao.com/noteshare?id=c76dbbe346dbd32a62cd4303f7bf4864&amp;sub=753D4CFE21084BA78B0506697A415A0C" target="_blank" rel="noopener">ROC与AUC</a></p><p><a href="http://note.youdao.com/noteshare?id=030f5d8884e6a0914891ebf2289318fa&amp;sub=28D75EDB51044316AB154021B0EB6BEA" target="_blank" rel="noopener">机器学习的方差与偏差</a></p><h4 id="参与的一些竞赛"><a href="#参与的一些竞赛" class="headerlink" title="参与的一些竞赛"></a>参与的一些竞赛</h4><p><a href="http://note.youdao.com/noteshare?id=1d8176b82fc84b0a3906fbd53979041c&amp;sub=305B25CE269F45DCA311DBE8C20DAF67" target="_blank" rel="noopener">ali-新人实战赛o2o优惠券使用预测</a></p><p><a href="http://note.youdao.com/noteshare?id=5b2fa1c8320743190649812b394b3ed5&amp;sub=27291314B2C74B09ABF8619277EE8A5E" target="_blank" rel="noopener">ccf-2019</a></p><p><a href="http://note.youdao.com/noteshare?id=52c517d38463d99b24672f0195ecabfe&amp;sub=WEBf24a84a951b3b16a0685ed029a28b960" target="_blank" rel="noopener">dc-2019-商品购买转化率预测</a></p><p><a href="http://note.youdao.com/noteshare?id=2fd9687a7cb8c10210bf738536dd8021&amp;sub=AE7E1B49101546F093C7C2B993A736A3" target="_blank" rel="noopener">竞赛提升方法-tricks</a></p><p><a href="http://note.youdao.com/noteshare?id=f43a977d8705582da02c202f295dadcc&amp;sub=74C22A94ABB74B309807A886F50A5863" target="_blank" rel="noopener">sklearn 脑图</a></p><h3 id="2-2-大数据与Hadoop"><a href="#2-2-大数据与Hadoop" class="headerlink" title="2.2 大数据与Hadoop"></a>2.2 大数据与Hadoop</h3><h4 id="多台机器的分布式环境安装"><a href="#多台机器的分布式环境安装" class="headerlink" title="多台机器的分布式环境安装"></a>多台机器的分布式环境安装</h4><p><a href="http://note.youdao.com/noteshare?id=e284c332fb9766d6487d925c4381ae22&amp;sub=E4980D34F8A347DC9C1E2C23C5A48D17" target="_blank" rel="noopener">1.hadoop分布式集群安装</a></p><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p><a href="http://note.youdao.com/noteshare?id=773c4878eaec8cc266c5074691a3d780&amp;sub=68CE094D754C46CDA96C8CFA00401DF2" target="_blank" rel="noopener">Hadoop RPC</a></p><h4 id="mapreduce-实验"><a href="#mapreduce-实验" class="headerlink" title="mapreduce 实验"></a>mapreduce 实验</h4><p><a href="http://note.youdao.com/noteshare?id=710757567d678841cb43e891531c63b9&amp;sub=BA97FAC420754425A2FE07E67D6B6EAD" target="_blank" rel="noopener">实验1.  多表关联</a></p><p><a href="http://note.youdao.com/noteshare?id=7c251c3514764eb58fdad72de78bf6a5&amp;sub=FF9F53C4D1A04E008FA61A85A9CE0F01" target="_blank" rel="noopener">实验2.  最高温度统计</a></p><p><a href="http://note.youdao.com/noteshare?id=226bf0abd5e44ed6eae69f5250024bcf&amp;sub=5EE9A40650BB4AD2A661C65DFBC57FC5" target="_blank" rel="noopener">实验3.  单表关联</a></p><h3 id="2-3-VUE"><a href="#2-3-VUE" class="headerlink" title="2.3 VUE"></a>2.3 VUE</h3><h4 id="VUE-安装"><a href="#VUE-安装" class="headerlink" title="VUE 安装"></a>VUE 安装</h4><p><a href="http://note.youdao.com/noteshare?id=c60a733187bef04fa0404429eb2d1f30&amp;sub=3F4FE35DF8E349A395F8C4C19AA7BBE4" target="_blank" rel="noopener">开发环境搭建</a></p><h3 id="2-4-Spring-框架"><a href="#2-4-Spring-框架" class="headerlink" title="2.4 Spring 框架"></a>2.4 Spring 框架</h3><p><a href="http://note.youdao.com/noteshare?id=7181c4a539cade23a864c8e970b05833&amp;sub=771654DC28474896BAB711DD289A052C" target="_blank" rel="noopener">Spring-1控制反转（IOC）和依赖注入</a></p><p><a href="http://note.youdao.com/noteshare?id=32da7b7e487b45fd4fde7906fb9436a1&amp;sub=BAF8F0AE43DB42B399AC14B01FE74689" target="_blank" rel="noopener">Spring-2AOP 面向切面编程-基于动态代</a></p><p><a href="http://note.youdao.com/noteshare?id=2caa6adcf719adaba44ad57fcad131e4&amp;sub=8E30EF145E8A4972867B5476DF2DD607" target="_blank" rel="noopener">Spring-3事务管理Transaction Manager</a></p><h2 id="3-工具使用"><a href="#3-工具使用" class="headerlink" title="3. 工具使用"></a>3. 工具使用</h2><p><a href="http://note.youdao.com/noteshare?id=82f292615812b23fec6c7ce9fcc35ec4&amp;sub=6FC7D088767948388F03769F13A2C971" target="_blank" rel="noopener">vscode 使用记录</a></p><h2 id="4-收藏的书籍"><a href="#4-收藏的书籍" class="headerlink" title="4. 收藏的书籍"></a>4. 收藏的书籍</h2><p><a href="http://note.youdao.com/noteshare?id=57e1d26f1f078dc70a5b18392b29a841" target="_blank" rel="noopener">书籍收藏</a></p><p><a href="http://note.youdao.com/noteshare?id=57e1d26f1f078dc70a5b18392b29a841" target="_blank" rel="noopener">http://note.youdao.com/noteshare?id=57e1d26f1f078dc70a5b18392b29a841</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Computer-Basics-Notes-Links&quot;&gt;&lt;a href=&quot;#Computer-Basics-Notes-Links&quot; class=&quot;headerlink&quot; title=&quot;Computer-Basics-Notes-Links&quot;&gt;&lt;/a&gt;Compu
      
    
    </summary>
    
      <category term="计算机基础梳理" scheme="http://www.elgong.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/"/>
    
    
      <category term="学习笔记" scheme="http://www.elgong.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>决策树2-ID3算法</title>
    <link href="http://www.elgong.top/2019/09/12/%E5%86%B3%E7%AD%96%E6%A0%912-ID3%E7%AE%97%E6%B3%95/"/>
    <id>http://www.elgong.top/2019/09/12/决策树2-ID3算法/</id>
    <published>2019-09-12T11:04:01.000Z</published>
    <updated>2020-02-20T04:41:37.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="决策树-2-ID3算法"><a href="#决策树-2-ID3算法" class="headerlink" title="决策树-2 ID3算法"></a>决策树-2 ID3算法</h1><blockquote><p>决策树-1基本概念中已经提到了ID3算法，这篇博客再梳理一遍，算法描述部分搬运了统计学习方法的内容，更详细内容可以参考这本书。</p></blockquote><h3 id="ID3-算法的思路"><a href="#ID3-算法的思路" class="headerlink" title="ID3 算法的思路"></a>ID3 算法的思路</h3><ul><li>输入：训练集 <code>D</code>, 特征集 <code>A</code>， 阈值 <code>ε</code>；</li><li>分叉：最优属性划分依据是<font color="#FF0000"> 最大信息增益；</font> </li><li>结束条件：用完所有特征，特征信息增益很小，树的深度超过限制；</li><li>返回：一颗树<code>T</code>。</li></ul><h3 id="ID3-算法描述"><a href="#ID3-算法描述" class="headerlink" title="ID3 算法描述"></a>ID3 算法描述</h3><blockquote><p>这里的描述可作为编程实现时的指导，树的建立过程是递归实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ID3Tree</span><span class="params">(D, A，ε )</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>  D 的实例属于同类别 K ||  特征集 A 特征空:</span><br><span class="line">    </span><br><span class="line">        <span class="number">1.</span> 决策树 T为单结点树</span><br><span class="line">        <span class="number">2.</span> 标记类别 K (数量最多的类别)</span><br><span class="line">        <span class="keyword">return</span>  T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="number">1.</span> 计算所有特征相对于 D 的信息增益</span><br><span class="line">        <span class="number">2.</span> 找到信息增益最大特征 Amax</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> Amax  小于 阈值 ε:</span><br><span class="line">            <span class="number">1.</span> 决策树 T为单结点树</span><br><span class="line">            <span class="number">2.</span> 标记类别 K (数量最多的类别)</span><br><span class="line">            <span class="keyword">return</span>  T</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            依照特征 Amax 的每一个取值 ai，划分数据集Di, 并且标记Di类别，构建子节点</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 递归</span></span><br><span class="line">            对每个结点Di，以Di为训练集， A-Amax为特征集，递归调用 ID3Tree()</span><br><span class="line">            <span class="keyword">return</span> 由结点和子结点构成的树</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;决策树-2-ID3算法&quot;&gt;&lt;a href=&quot;#决策树-2-ID3算法&quot; class=&quot;headerlink&quot; title=&quot;决策树-2 ID3算法&quot;&gt;&lt;/a&gt;决策树-2 ID3算法&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;决策树-1基本概念中已经提到了ID3算法，
      
    
    </summary>
    
      <category term="机器学习方法" scheme="http://www.elgong.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="ID3" scheme="http://www.elgong.top/tags/ID3/"/>
    
  </entry>
  
  <entry>
    <title>决策树3-CART分类回归树</title>
    <link href="http://www.elgong.top/2019/09/12/%E5%86%B3%E7%AD%96%E6%A0%913-CART%E5%88%86%E7%B1%BB%E5%9B%9E%E5%BD%92%E6%A0%91/"/>
    <id>http://www.elgong.top/2019/09/12/决策树3-CART分类回归树/</id>
    <published>2019-09-12T10:58:19.000Z</published>
    <updated>2020-02-20T04:41:37.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CART-分类回归树"><a href="#CART-分类回归树" class="headerlink" title="CART-分类回归树"></a>CART-分类回归树</h1><h3 id="CART-算法的思路"><a href="#CART-算法的思路" class="headerlink" title="CART 算法的思路"></a>CART 算法的思路</h3><blockquote><p>特征选择：最优属性划分依据是<font color="#FF0000"> 基尼系数（分类）/平方误差（回归）；</font> </p><p>CART 树是二叉树结构。</p></blockquote><p>主要就两步骤：</p><ol><li>树的生成 </li><li>树的剪枝</li></ol><h3 id="分类树"><a href="#分类树" class="headerlink" title="分类树"></a>分类树</h3><blockquote><p>分类树与ID3, C4.5的流程一致。</p></blockquote><h3 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h3><blockquote><p>回归树选择最佳划分属性和划分点时的依据是 <code>平方误差</code>。</p></blockquote><p>一张图即可理解。</p><p><img src="/2019/09/12/决策树3-CART分类回归树/CART.png" alt="logo"></p><p>与分类树的主要区别是选择最佳属性的评价指标变了。根据最小化均方误差的原则选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CART-分类回归树&quot;&gt;&lt;a href=&quot;#CART-分类回归树&quot; class=&quot;headerlink&quot; title=&quot;CART-分类回归树&quot;&gt;&lt;/a&gt;CART-分类回归树&lt;/h1&gt;&lt;h3 id=&quot;CART-算法的思路&quot;&gt;&lt;a href=&quot;#CART-算法的思路&quot;
      
    
    </summary>
    
      <category term="机器学习方法" scheme="http://www.elgong.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="CART树" scheme="http://www.elgong.top/tags/CART%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>pandas-8分层和多级索引</title>
    <link href="http://www.elgong.top/2019/08/13/pandas-%E5%88%86%E5%B1%82%E5%92%8C%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95/"/>
    <id>http://www.elgong.top/2019/08/13/pandas-分层和多级索引/</id>
    <published>2019-08-13T02:54:12.000Z</published>
    <updated>2020-02-20T04:41:37.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pandas-8-分层和多级索引"><a href="#pandas-8-分层和多级索引" class="headerlink" title="pandas -8 分层和多级索引"></a>pandas -8 分层和多级索引</h1><blockquote><p>Multi-level indexing. 在 “<a href="http://www.elgong.top/2019/07/25/pandas-%E7%B4%A2%E5%BC%95%E5%92%8C%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE/">pandas -2 索引和选择数据</a>” 一节中, 已经提到了如何选择行列元素, 而Series 和 Dataframe 是低维度的数据结构，对于更高维度的数据，可以通过分层和多级索引来实现。</p></blockquote><h2 id="分层索引的创建"><a href="#分层索引的创建" class="headerlink" title="分层索引的创建"></a>分层索引的创建</h2><blockquote><p>创建分层索引的方式有很多, 这里直接摘抄自官方的文档，可以通过元组，列表，Dataframe, arrays 等方式生成分层索引。</p><p>同时要知道，通过 groupby 分组操作之后得到的也是这种分层结构。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    //  1. 元组</span><br><span class="line">In: </span><br><span class="line"></span><br><span class="line">    arrays = [[&apos;bar&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;baz&apos;, &apos;foo&apos;, &apos;foo&apos;,&apos;qux&apos;, &apos;qux&apos;], [&apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;]]</span><br><span class="line">    tuples = list(zip(*arrays))</span><br><span class="line">Out: </span><br><span class="line">    [(&apos;bar&apos;, &apos;one&apos;),</span><br><span class="line">     (&apos;bar&apos;, &apos;two&apos;),</span><br><span class="line">     (&apos;baz&apos;, &apos;one&apos;),</span><br><span class="line">     (&apos;baz&apos;, &apos;two&apos;),</span><br><span class="line">     (&apos;foo&apos;, &apos;one&apos;),</span><br><span class="line">     (&apos;foo&apos;, &apos;two&apos;),</span><br><span class="line">     (&apos;qux&apos;, &apos;one&apos;),</span><br><span class="line">     (&apos;qux&apos;, &apos;two&apos;)]</span><br><span class="line"></span><br><span class="line">In:</span><br><span class="line">    index = pd.MultiIndex.from_tuples(tuples, names=[&apos;first&apos;, &apos;second&apos;])</span><br><span class="line">    df = pd.Series(np.random.randn(8), index=index)</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">    first  second</span><br><span class="line">    bar    one       0.469112</span><br><span class="line">           two      -0.282863</span><br><span class="line">    baz    one      -1.509059</span><br><span class="line">           two      -1.135632</span><br><span class="line">    foo    one       1.212112</span><br><span class="line">           two      -0.173215</span><br><span class="line">    qux    one       0.119209</span><br><span class="line">           two      -1.044236</span><br><span class="line">    dtype: float64</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 2. dataftame</span><br><span class="line">    </span><br><span class="line">    index = pd.MultiIndex.from_frame(df)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 3. arrays</span><br><span class="line">    </span><br><span class="line">In: </span><br><span class="line">    arrays = [np.array([&apos;bar&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;baz&apos;, &apos;foo&apos;, &apos;foo&apos;, &apos;qux&apos;, &apos;qux&apos;]),</span><br><span class="line">              np.array([&apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;])]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     s = pd.Series(np.random.randn(8), index=arrays)</span><br></pre></td></tr></table></figure><h2 id="从DataFrame-产生-MultiIndex"><a href="#从DataFrame-产生-MultiIndex" class="headerlink" title="从DataFrame 产生 MultiIndex"></a>从DataFrame 产生 MultiIndex</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = df.set_index([&apos;col1&apos;,&apos;col2&apos;])</span><br></pre></td></tr></table></figure><h2 id="MultiIndex-转化成-列"><a href="#MultiIndex-转化成-列" class="headerlink" title="MultiIndex 转化成 列"></a>MultiIndex 转化成 列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = df.reset_index()</span><br></pre></td></tr></table></figure><h2 id="选择不同层"><a href="#选择不同层" class="headerlink" title="选择不同层"></a>选择不同层</h2><blockquote><p>查看不同层的索引值。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In:</span><br><span class="line">    index.get_level_values(0)</span><br><span class="line">    </span><br><span class="line">    index.get_level_values(&quot;name&quot;)</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">    Index([&apos;bar&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;baz&apos;, &apos;foo&apos;, &apos;foo&apos;, &apos;qux&apos;, &apos;qux&apos;], dtype=&apos;object&apos;, name=&apos;first&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>根据不同层索引</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df[&quot;bar&quot;]</span><br><span class="line">df[&quot;one&quot;]</span><br><span class="line">df[&quot;bar&quot;][&quot;one&quot;]</span><br><span class="line"></span><br><span class="line">// 元组</span><br><span class="line">df.loc[(&apos;bar&apos;, &apos;two&apos;)]</span><br></pre></td></tr></table></figure><font color="0xff111">  注意, 切片时不会改变 多层索引。 </font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pandas-8-分层和多级索引&quot;&gt;&lt;a href=&quot;#pandas-8-分层和多级索引&quot; class=&quot;headerlink&quot; title=&quot;pandas -8 分层和多级索引&quot;&gt;&lt;/a&gt;pandas -8 分层和多级索引&lt;/h1&gt;&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="pandas系列教程" scheme="http://www.elgong.top/categories/pandas%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="pandas-MultiIndex" scheme="http://www.elgong.top/tags/pandas-MultiIndex/"/>
    
  </entry>
  
  <entry>
    <title>mysql-索引篇2-索引的底层实现</title>
    <link href="http://www.elgong.top/2019/08/12/mysql-%E7%B4%A2%E5%BC%95%E7%AF%872-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.elgong.top/2019/08/12/mysql-索引篇2-索引的底层实现/</id>
    <published>2019-08-12T03:02:57.000Z</published>
    <updated>2020-04-11T03:09:33.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、常用的索引底层结构有哪些？"><a href="#一、常用的索引底层结构有哪些？" class="headerlink" title="一、常用的索引底层结构有哪些？"></a>一、常用的索引底层结构有哪些？</h1><p>==<strong>索引是一种排序的，便于查找的数据结构。</strong>==</p><p>下面是一些常见数据结构的概念，具体每种类型的详细特点，再去看别的文档吧。</p><h2 id="1-二叉查找树："><a href="#1-二叉查找树：" class="headerlink" title="1. 二叉查找树："></a><strong>1. 二叉查找树：</strong></h2><p>​        左子树的键值小于根的键值，右子树的键值大于根的键值。</p><h2 id="2-AVL-树："><a href="#2-AVL-树：" class="headerlink" title="2. AVL 树："></a><strong>2. AVL 树：</strong></h2><p>​       平衡二叉树（AVL 树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为 1。</p><h2 id="3-红黑树："><a href="#3-红黑树：" class="headerlink" title="3. 红黑树："></a><strong>3. 红黑树：</strong></h2><p>​      每个节点都带有颜色属性的二叉查找树。</p><h2 id="4-平衡多路查找树（M阶的-B树）："><a href="#4-平衡多路查找树（M阶的-B树）：" class="headerlink" title="4. 平衡多路查找树（M阶的 B树）："></a><strong>4. 平衡多路查找树（M阶的 B树）：</strong></h2><h2 id="为磁盘等外存储设备设计的一种平衡查找树。"><a href="#为磁盘等外存储设备设计的一种平衡查找树。" class="headerlink" title="为磁盘等外存储设备设计的一种平衡查找树。"></a><strong>为磁盘等外存储设备设计的一种平衡查找树。</strong></h2><ul><li>每个节点最多有<strong>m-1个关键字</strong>（可以存有的键值对）。</li><li>根节点最少可以只有1个<strong>关键字</strong>。</li><li>非根节点至少有m/2个<strong>关键字</strong>。</li><li>每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li><li>所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。</li><li>==<strong>每个节点都存有索引和数据，也就是对应的key和value。</strong>==</li><li>==<strong>数据库中的节点 value 其实是指针。。</strong>==</li></ul><h2 id="5-B-树："><a href="#5-B-树：" class="headerlink" title="5. B+树："></a><strong>5. B+树：</strong></h2><p>B+树其实和B树是非常相似的，我们首先看看<strong>相同点</strong>。</p><ul><li>根节点至少一个元素</li><li>非根节点元素范围：m/2 &lt;= k &lt;= m-1</li></ul><p><strong>不同点</strong>：</p><ul><li>B+树有两种类型的节点：==<strong>内部节点不存储数据，只存储索引，数据都存储在叶子节点。</strong>==</li><li>内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。<strong>叶子结点中的记录也按照key的大小排列</strong>。</li><li>每个叶子结点都存有相邻叶子结点的指针，<strong>叶子结点本身依关键字的大小自小而大顺序链接。</strong></li><li><strong>父节点存有右孩子的第一个元素的索引</strong>。</li></ul><p><img src="https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/35C585A0A1CA45A48325427D3856F495/25313" alt="img"></p><h1 id="二、Mysql-的两种存储引擎的索引"><a href="#二、Mysql-的两种存储引擎的索引" class="headerlink" title="二、Mysql 的两种存储引擎的索引"></a>二、Mysql 的两种存储引擎的索引</h1><p>文档主要介绍 MyISAM 和 InnoDB 两个存储引擎的索引实现方式。 两者均使用的B+ 树实现的索引。</p><h2 id="2-1-InnoDB索引实现"><a href="#2-1-InnoDB索引实现" class="headerlink" title="2.1 InnoDB索引实现"></a><strong>2.1 InnoDB索引实现</strong></h2><h3 id="1）主键索引（聚簇索引，B-树）："><a href="#1）主键索引（聚簇索引，B-树）：" class="headerlink" title="1）主键索引（聚簇索引，B+树）："></a><strong>1）主键索引（聚簇索引，B+树）：</strong></h3><p>   <strong>主键默认采用聚簇索引</strong>（聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致），且一张表只允许存在一个聚簇索引。</p><p>​        ==<strong>聚簇索引的叶子节点就是数据节点（存放完整的行数据）</strong>==</p><p>​        ==<strong>非聚簇索引</strong>的叶子节点保存<strong>非完整行的数据</strong>（只有对应的键值数据） + <strong>书签</strong>（主键的聚集索引的索引值）==</p><p>​        叶子节点是<strong>数据页(默认16K)</strong>。==每个数据页上存放的是完整的行记录。B+ 树将 叶子页加载到内存后，再去查找对应数据行。==</p><p>​        非叶子节点、存放的仅仅是键值及指向数据页的偏移量</p><p><strong>聚集索引的好处：</strong></p><ul><li>对于<strong>主键的排序查找非常的快</strong>（因为其叶子节点是用双向链表链接的）</li><li><p>对于<strong>主键的范围查找非常的快</strong>（因为通过叶子节点的上层中间节点，就可以得到叶结点的范围值）</p><p> <strong>在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构</strong>，**这棵树的叶节点data域保存了完整的数据记录。索引的key是数据表的主键（primary key），因此InnoDB表数据文件本身就是主索引。</p></li></ul><p><img src="https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/0C52AD61056947BFB3ADB363A745E21E/25366" alt="img"></p><p><strong>InnoDB存储引擎的最小存储单元是页(16K)</strong>，页可以用于存放数据也可以用于存放键值+指针, <strong>在InnoDB中B+树高度一般为1-3层</strong>，<strong>它就能满足千万级的数据存储</strong>。在查找数据时一次页的查找代表一次IO，所以通过<strong>主键索引查询通常只需要1-3次IO操作即可查找到数据</strong>。</p><p><strong>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有）</strong>，如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><h3 id="2）InnoDB的辅助索引（非聚簇索引，B-树-B树）"><a href="#2）InnoDB的辅助索引（非聚簇索引，B-树-B树）" class="headerlink" title="2）InnoDB的辅助索引（非聚簇索引，B+树/ B树）"></a><strong>2）InnoDB的辅助索引（非聚簇索引，B+树/ B树）</strong></h3><p><strong>B+树：</strong></p><p><strong>非聚簇索引</strong>的叶子节点保存<strong>非完整行的数据</strong>（只有对应的键值数据） + <strong>书签</strong>（主键的聚集索引的索引值）</p><p><strong>二级索引使用非聚簇索引。</strong></p><p><strong>通过二级索引查询首先，查到是主键值和对应的数据字段，如果查询的字段更多，InnoDB再根据查到的主键值通过主键索引找到相应的数据块。</strong>（ 这个流程叫 <strong>回表</strong>）</p><p><strong>B树：覆盖索引用到的。</strong></p><p>InnoDB 表是基于<strong>聚簇索引</strong>建立的。因此InnoDB 的索引能提供一种非常快速的主键查找性能。它的辅助索引（Secondary Index， 也就是非主键索引）也会包含主键列，所以，如果主键定义的比较大，其他索引也将很大。如果想在表上定义 、很多索引，则<strong>争取尽量把主键定义得小一些</strong>。InnoDB 不会压缩索引。</p><p>   文字符的ASCII码作为比较准则。<strong>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录</strong>。</p><p><img src="https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/FD856A9A723440D296A95C46A86E1431/25390" alt="img"></p><p><strong>1、为什么不建议使用过长的字段作为主键？</strong></p><p><strong>因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。</strong></p><p><strong>2、用非单调的字段作为主键在InnoDB中不是个好主意？</strong></p><p><strong>因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效。</strong></p><h2 id="2-2-MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。"><a href="#2-2-MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。" class="headerlink" title="2.2  MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。"></a><strong>2.2  MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</strong></h2><p>MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</p><h3 id="1）主键索引（非聚簇索引，B-树）："><a href="#1）主键索引（非聚簇索引，B-树）：" class="headerlink" title="1）主键索引（非聚簇索引，B+树）："></a><strong>1）主键索引（非聚簇索引，B+树）：</strong></h3><p>MyISAM引擎使用B+Tree作为索引结构，<strong>叶节点的data域存放的是数据记录的地址</strong>。下图是MyISAM主键索引的原理图：</p><p><img src="https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/B431C4572E464F8B9E410C3F74685439/25416" alt="img"></p><h3 id="2）辅助索引（Secondary-key）"><a href="#2）辅助索引（Secondary-key）" class="headerlink" title="2）辅助索引（Secondary key）"></a><strong>2）辅助索引（Secondary key）</strong></h3><p><strong>在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求</strong> <strong>key是唯一</strong>，而辅助索引的key可以重复。</p><p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，<strong>MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</strong></p><p>MyISAM的索引方式也叫做“<strong>非聚簇</strong>”的，之所以这么称呼是为了与InnoDB的聚簇索引区分。</p><h1 id="三、为什么说B-树比B树更适合数据库索引？"><a href="#三、为什么说B-树比B树更适合数据库索引？" class="headerlink" title="三、为什么说B+树比B树更适合数据库索引？"></a>三、为什么说B+树比B树更适合数据库索引？</h1><p><strong>1、 B+树的磁盘读写代价更低</strong>：B+树的内部节点并没有指向关键字具体信息的指针，因此<strong>其内部节点相对B树更小</strong>，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，<strong>一次性读入内存的需要查找的关键字也就越多</strong>，相对IO读写次数就降低了。<strong>（B 树 非叶子节点中还包含了数据指针，所以占空间大）</strong></p><p><strong>2、B+树的查询效率更加稳定（数据都存在叶子节点，路径都是从根到叶子的路径，一般3次以下的IO读取，等于树的高度）</strong></p><p>B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少），指针少的情况下要保存大量数据，<strong>只能增加树的高度，导致IO操作变多</strong>，查询性能变低；</p><p><strong>3、由于B+树的数据都存储在叶子结点中，非叶子点均为索引，**</strong>方便全盘扫描和范围查找。**</p><p>但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，<strong>需要进行一次中序遍历按序来扫</strong>，所以<strong>B+树更加适合在区间查询的情况</strong>，所以通常B+树用于数据库索引。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、常用的索引底层结构有哪些？&quot;&gt;&lt;a href=&quot;#一、常用的索引底层结构有哪些？&quot; class=&quot;headerlink&quot; title=&quot;一、常用的索引底层结构有哪些？&quot;&gt;&lt;/a&gt;一、常用的索引底层结构有哪些？&lt;/h1&gt;&lt;p&gt;==&lt;strong&gt;索引是一种排序的
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.elgong.top/categories/mysql/"/>
    
    
      <category term="数据库索引" scheme="http://www.elgong.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql-索引篇1-索引的概念</title>
    <link href="http://www.elgong.top/2019/08/11/mysql-%E7%B4%A2%E5%BC%95%E7%AF%871-%E7%B4%A2%E5%BC%95%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>http://www.elgong.top/2019/08/11/mysql-索引篇1-索引的概念/</id>
    <published>2019-08-11T02:46:16.000Z</published>
    <updated>2020-04-11T03:02:11.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、索引的概念"><a href="#一、索引的概念" class="headerlink" title="一、索引的概念"></a><strong>一、索引的概念</strong></h1><h2 id="1-1-索引的作用"><a href="#1-1-索引的作用" class="headerlink" title="1.1 索引的作用"></a>1.1 索引的作用</h2><h2 id="1-2-索引的分类（还不清楚到底怎么归类）"><a href="#1-2-索引的分类（还不清楚到底怎么归类）" class="headerlink" title="1.2 索引的分类（还不清楚到底怎么归类）**"></a>1.2 索引的分类（还不清楚到底怎么归类）**</h2><p><strong>查看有哪些索引：</strong>   <code>SHOW   index;</code></p><p><strong>聚簇索引（主键索引)</strong>    <strong>每张表只能有一个</strong>，<strong>数据和索引在同一个文件</strong></p><p>​        按照每张表的主键构造一颗B+树，同时叶子节点中存放的即为整张表的记录数据。</p><p><strong>辅助索引（二级索引）</strong>: <strong>叶子节点并不包含行记录的全部数据</strong></p><p>​       非主键索引，叶子节点=键值+书签（行的索引值）</p><p><strong>覆盖索引：</strong> <strong>（extra 提示using index）</strong></p><p>​       InnoDB存储引擎支持覆盖索引，即从<strong>辅助索引中就可以得到查询的记录</strong>，而不需要查询聚集索引中的记录了（不需要回表操作）。</p><p>​       覆盖索引并不适用于任意的索引类型，<strong>索引必须存储列的值</strong>，所以<font color="red"><big><strong>不需要回表操作。</strong></big></font></p><p>MySQL只能使用B-树.</p><p><strong>联合索引：</strong></p><p>​        联合索引也是一棵<strong>B+树，其键值数量大于等于2。键值都是排序的</strong>，通过叶子节点可以逻辑上顺序的读出所有数据。</p><p><strong>单值索引：</strong> 一个索引只包含单个列</p><p><strong>多值索引、复合索引</strong>（<strong>组合索引</strong>）: 即一个索包含多个列</p><p><strong>复合索引</strong>只会对与创建索引时的排序顺序完全相同或相反的 order by语句进行优化</p><p><strong>唯一索引</strong>: 索引唯一，但可以null， 声明unique关键字时,会为其字段自动添加唯一索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 单值索引 </span><br><span class="line">#外部创建 </span><br><span class="line">CREATE INDEX [indexname]ON t1(colname); </span><br><span class="line"></span><br><span class="line">#创建表的时候创建 </span><br><span class="line">CREATE TABLE mytable(   ID INT NOT NULL,    username VARCHAR(16) NOT NULL,   INDEX [indexName] (username(length))   );  </span><br><span class="line"></span><br><span class="line">#alter语句添加 </span><br><span class="line">ALTER table tableName ADD INDEX indexName(columnName)  </span><br><span class="line"></span><br><span class="line">// 复合索引 </span><br><span class="line">CREATE INDEX idx_c1_c2_c3ON tablename(c1,c2,c3)</span><br></pre></td></tr></table></figure><p><img src="https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/35ED850E7CCF446C903DD2A0AED7AABE/18916" alt="img"></p><h2 id="1-3-创建"><a href="#1-3-创建" class="headerlink" title="1.3 创建"></a><strong>1.3 创建</strong></h2><p><img src="https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/5FAAFB8FB8BD43CC8F2CD5853ED88350/18908" alt="img"></p><h2 id="1-4-什么时候该创建索引？"><a href="#1-4-什么时候该创建索引？" class="headerlink" title="1.4 什么时候该创建索引？"></a><strong>1.4 什么时候该创建索引？</strong></h2><p><img src="https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/7C97A4A5F692496686ED1CB7890E0543/18901" alt="img"></p><p><strong>不该创建？</strong></p><p><img src="https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/ADE489407E394B16856C9B839E2416DE/18902" alt="img"></p><p>对于最长使用的查询，可以针对性的建立索引来优化速度。</p><p>join查询在有索引条件下</p><p>　　驱动表有索引不会使用到索引</p><p>　　被驱动表建立索引会使用到索引</p><h1 id="二、性能分析和优化策略"><a href="#二、性能分析和优化策略" class="headerlink" title="二、性能分析和优化策略"></a><strong>二、性能分析和优化策略</strong></h1><p><img src="https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/20D9F3FA33FF41E2AB5EAB6EA9D24A25/18895" alt="img"></p><p><img src="https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/7AC131346BED4F13AA046DA87FEFC40C/18894" alt="img"></p><p><img src="https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/61AED2EF4E4D4DEB8D33DEBCBFD93175/18857" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、索引的概念&quot;&gt;&lt;a href=&quot;#一、索引的概念&quot; class=&quot;headerlink&quot; title=&quot;一、索引的概念&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、索引的概念&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;1-1-索引的作用&quot;&gt;&lt;a href=&quot;#1-1-索引的
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.elgong.top/categories/mysql/"/>
    
    
      <category term="数据库索引" scheme="http://www.elgong.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>pandas-6重复值处理</title>
    <link href="http://www.elgong.top/2019/08/09/pandas-%E9%87%8D%E5%A4%8D%E5%80%BC%E5%A4%84%E7%90%86/"/>
    <id>http://www.elgong.top/2019/08/09/pandas-重复值处理/</id>
    <published>2019-08-09T07:26:52.000Z</published>
    <updated>2020-02-20T04:41:37.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pandas-6-重复值处理"><a href="#pandas-6-重复值处理" class="headerlink" title="pandas -6 重复值处理"></a>pandas -6 重复值处理</h1><blockquote><p>如果你想找到或者删除 <code>DataFrame</code>中重复的行, 可以使用 <code>duplicated</code> 和 <code>drop_duplicates</code></p></blockquote><h2 id="查找重复值"><a href="#查找重复值" class="headerlink" title="查找重复值"></a>查找重复值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">example:</span><br><span class="line">        col1  col2     c</span><br><span class="line">    0    one   x   -1.067137</span><br><span class="line">    1    one   y    0.309500</span><br><span class="line">    2    two   x   -0.211056</span><br><span class="line">    3    two   y   -1.842023</span><br><span class="line">    4    two   x   -0.390820</span><br><span class="line">    5  three   x   -1.964475</span><br><span class="line">    6   four   x    1.298329</span><br><span class="line">In:</span><br><span class="line">    // 单列</span><br><span class="line">    df.duplicated(&quot;col1&quot;, keep=&quot;first&quot;)</span><br><span class="line">    </span><br><span class="line">    // 多列</span><br><span class="line">    // df.duplicated([&quot;col1&quot;, &quot;col2&quot;], keep=&quot;first&quot;)</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">    0    False</span><br><span class="line">    1     True</span><br><span class="line">    2    False</span><br><span class="line">    3     True</span><br><span class="line">    4     True</span><br><span class="line">    5    False</span><br><span class="line">    6    False</span><br><span class="line">    dtype: bool</span><br><span class="line">    </span><br><span class="line">    // 默认 keep = &quot;first&quot;,第一次出现的不算重复，返回False</span><br><span class="line">    // keep = &quot;last&quot;, 最后出现的不算重复</span><br><span class="line">    // keep = False, 重复值均返回 True</span><br></pre></td></tr></table></figure><h2 id="删除重复值"><a href="#删除重复值" class="headerlink" title="删除重复值"></a>删除重复值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In:</span><br><span class="line">    df.drop_duplicates(&apos;col1&apos;)</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">        col1  col2    c</span><br><span class="line">    0    one   x    -1.067137</span><br><span class="line">    2    two   x    -0.211056</span><br><span class="line">    5  three   x    -1.964475</span><br><span class="line">    6   four   x     1.298329</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pandas-6-重复值处理&quot;&gt;&lt;a href=&quot;#pandas-6-重复值处理&quot; class=&quot;headerlink&quot; title=&quot;pandas -6 重复值处理&quot;&gt;&lt;/a&gt;pandas -6 重复值处理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;如果你想找到或
      
    
    </summary>
    
      <category term="pandas系列教程" scheme="http://www.elgong.top/categories/pandas%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="pandas" scheme="http://www.elgong.top/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>pandas-5缺失值处理</title>
    <link href="http://www.elgong.top/2019/08/09/pandas-%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%A4%84%E7%90%86/"/>
    <id>http://www.elgong.top/2019/08/09/pandas-缺失值处理/</id>
    <published>2019-08-09T01:33:30.000Z</published>
    <updated>2020-02-20T04:41:37.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pandas-5-缺失值处理"><a href="#pandas-5-缺失值处理" class="headerlink" title="pandas -5 缺失值处理"></a>pandas -5 缺失值处理</h1><blockquote><p>统计数据中存在缺失值是十分常见的问题, 而对于缺失值的处理，是数据挖掘的一个重要环节。pandas 有一系列的方法处理缺失值。</p></blockquote><h2 id="缺失值的类型"><a href="#缺失值的类型" class="headerlink" title="缺失值的类型"></a>缺失值的类型</h2><p>判断方法只记住万能的 <code>pd.isnull</code> 即可。</p><blockquote><p>数值</p></blockquote><pre><code>  pd.isna  pd.isnull  np.isnan</code></pre><blockquote><p>字符串</p></blockquote><pre><code>  pd.isna  pd.isnull</code></pre><blockquote><p>时间</p></blockquote><pre><code>  pd.isna  pd.isnull  np.isnat</code></pre><h2 id="缺失值的统计"><a href="#缺失值的统计" class="headerlink" title="缺失值的统计"></a>缺失值的统计</h2><pre><code>  df.isnull().sum()</code></pre><h2 id="丢掉缺失值"><a href="#丢掉缺失值" class="headerlink" title="丢掉缺失值"></a>丢掉缺失值</h2><pre><code>  // 某列有缺失值, 删除  df[ pd.isnull(df[&quot;columns&quot;])]  // Series   df.columns.dropna()  // DataFrame  // axis: axis=0 （默认）表示操作行，axis=1 表示操作列;  // how : any 表示一行/列有任意元素为空时即丢弃，all 一行/列所有值都为空时才丢弃。  // subset: 参数表示删除时只考虑的索引或列名。  // thresh: 比如 thresh=3，会在一行/列中至少有 3 个非空值时将其保留。  df.dropna(axis=0, how=&quot;any&quot;, subset=[&quot;city&quot;, &quot;sex&quot;])</code></pre><h2 id="填充缺失值"><a href="#填充缺失值" class="headerlink" title="填充缺失值"></a>填充缺失值</h2><blockquote><p>数据量少的情况下，直接丢掉不可取，可以适当补充数据。</p></blockquote><pre><code>   // 前值填充 ffill     后值填充  bfill   df.columns.fillna(method = &quot;ffill&quot;)   // 实值填充   df.fillna(0)   // 均值填充   df[&quot;columns&quot;].fillna(df[&quot;columns&quot;].mean(), inplace=True)   // 众数   mode()[0]   // 中位数   median()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pandas-5-缺失值处理&quot;&gt;&lt;a href=&quot;#pandas-5-缺失值处理&quot; class=&quot;headerlink&quot; title=&quot;pandas -5 缺失值处理&quot;&gt;&lt;/a&gt;pandas -5 缺失值处理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;统计数据中存在
      
    
    </summary>
    
      <category term="pandas系列教程" scheme="http://www.elgong.top/categories/pandas%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="pandas" scheme="http://www.elgong.top/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>pandas-7时间&amp;日期处理</title>
    <link href="http://www.elgong.top/2019/08/06/pandas-%E6%97%B6%E9%97%B4-%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/"/>
    <id>http://www.elgong.top/2019/08/06/pandas-时间-日期处理/</id>
    <published>2019-08-06T00:42:00.000Z</published>
    <updated>2020-02-20T04:41:37.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pandas-7-时间-amp-日期处理"><a href="#pandas-7-时间-amp-日期处理" class="headerlink" title="pandas -7 时间&amp;日期处理"></a>pandas -7 时间&amp;日期处理</h1><h2 id="pandas-常出现的时间格式"><a href="#pandas-常出现的时间格式" class="headerlink" title="pandas 常出现的时间格式"></a>pandas 常出现的时间格式</h2><ul><li>字符串类型 <code>object</code></li></ul><blockquote><p>一般是字符串类型，pandas 储存string时 使用 narray， 每一个object 是一个指针</p></blockquote><ul><li>datetime 类型 <code>datetime64</code></li></ul><ul><li>timedelta 类型</li></ul><blockquote><p>表示时间差的数据类型</p></blockquote><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ol><li><code>object</code> 2 <code>datetime</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 方法1</span><br><span class="line">df[1] = pd.to_datetime(df[1], format=&apos;%d.%m.%Y&apos;)</span><br><span class="line"></span><br><span class="line"># 指定format，速度会加快很多。</span><br><span class="line"></span><br><span class="line">// 方法2</span><br><span class="line">dateStr = &quot;2019-02-03&quot;</span><br><span class="line"></span><br><span class="line">myDate = datetime.strptime(dateStr, &quot;&quot;%Y-%m-%d&quot;&quot;)</span><br></pre></td></tr></table></figure><ol><li><code>datetime</code> 2 <code>object</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df[&quot;time_list&quot;] = df[&quot;time_list&quot;].strftime(&quot;%Y-%m-%d&quot;)</span><br><span class="line"></span><br><span class="line">// Y 2019</span><br><span class="line">// y  19</span><br></pre></td></tr></table></figure><h2 id="datetime-相关操作"><a href="#datetime-相关操作" class="headerlink" title="datetime 相关操作"></a>datetime 相关操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 查看列元素的年，月，日，星期（整数型）</span><br><span class="line">df[&quot;time&quot;].dt.year</span><br><span class="line">df[&quot;time&quot;].dt.month</span><br><span class="line">df[&quot;time&quot;].dt.day</span><br><span class="line">df[&quot;time&quot;].dt.weekday  # 星期一是0</span><br><span class="line"></span><br><span class="line">// 一年中的第几天,第几周</span><br><span class="line">df[&quot;time&quot;].dt.dayofyear</span><br><span class="line">df[&quot;time&quot;].dt.weekofyear</span><br><span class="line">// 查看列元素 某年的数据数量</span><br><span class="line">df[df[&quot;time&quot;].dt.year == 2019].shape</span><br></pre></td></tr></table></figure><h2 id="时间运算"><a href="#时间运算" class="headerlink" title="时间运算"></a>时间运算</h2><ol><li>计算时间差</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 计算时间差， 结果为timedelta</span><br><span class="line">df[&quot;时间差&quot;] = df[&quot;时间1&quot;] - df[&quot;时间2&quot;]</span><br><span class="line"></span><br><span class="line">// 转换成 天数差</span><br><span class="line">df[&quot;时间差&quot;].days</span><br></pre></td></tr></table></figure><ol><li>计算未来日期</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// N天后的日期</span><br><span class="line">// 天  days,   时 hours， 周 weeks</span><br><span class="line">df[&quot;时间&quot;] = df[&quot;时间1&quot;] - timedelta(days=10)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pandas-7-时间-amp-日期处理&quot;&gt;&lt;a href=&quot;#pandas-7-时间-amp-日期处理&quot; class=&quot;headerlink&quot; title=&quot;pandas -7 时间&amp;amp;日期处理&quot;&gt;&lt;/a&gt;pandas -7 时间&amp;amp;日期处理&lt;/h1
      
    
    </summary>
    
      <category term="pandas系列教程" scheme="http://www.elgong.top/categories/pandas%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="pandas" scheme="http://www.elgong.top/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>机器学习模型的偏差与方差</title>
    <link href="http://www.elgong.top/2019/08/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%81%8F%E5%B7%AE%E4%B8%8E%E6%96%B9%E5%B7%AE/"/>
    <id>http://www.elgong.top/2019/08/01/机器学习模型的偏差与方差/</id>
    <published>2019-08-01T08:43:19.000Z</published>
    <updated>2020-02-20T04:41:37.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习的方差与偏差"><a href="#机器学习的方差与偏差" class="headerlink" title="机器学习的方差与偏差"></a>机器学习的方差与偏差</h1><blockquote><p>方差与偏差，总是迷迷糊糊的，每次看了就会，过了就忘。今天看到一个非常棒的解释，迫不及待马上整理下来了。</p></blockquote><h2 id="机器学习的目标函数"><a href="#机器学习的目标函数" class="headerlink" title="机器学习的目标函数"></a>机器学习的目标函数</h2><p>机器学习模型学习的是数据集的条件概率分布，得到一个决策函数。整个学习过程围绕着最小化（或者最大化）目标函数进行优化参数，目标函数的通常形式的定义是：</p><pre><code>Obj = L(θ) + λΩ(θ)</code></pre><p><code>L(θ)</code> 是损失函数，衡量模型对训练集拟合程度的好坏(对应偏差)；</p><p><code>Ω(θ)</code> 是正则项，是衡量模型的复杂程度（对应方差）；</p><font color="#FF0000"> 目标函数定义为损失函数和正则项两部分，是为了平衡模型的偏差和方差（Bias Variance Trade-off）。</font> <h2 id="偏差与学习器"><a href="#偏差与学习器" class="headerlink" title="偏差与学习器"></a>偏差与学习器</h2><blockquote><p>偏差描述了 <font color="#FF0000">学习器的拟合能力</font> （对训练集的）。</p></blockquote><p>学习器在训练集表现越好，损失越低，则模型的偏差越小。</p><h2 id="方差与学习器"><a href="#方差与学习器" class="headerlink" title="方差与学习器"></a>方差与学习器</h2><blockquote><p>方差描述了 <font color="#FF0000"> 学习器的泛化能力</font>(对测试集)。</p></blockquote><p>学习器在测试集表现越好，则模型的方差越低。</p><h2 id="偏差与方差之间的关系"><a href="#偏差与方差之间的关系" class="headerlink" title="偏差与方差之间的关系"></a>偏差与方差之间的关系</h2><blockquote><p>我们最想要的是低偏差，低方差的模型，然而现实很难达到两者都极致的低。有时候需要用提高偏差来降低方差，毕竟模型的泛化能力十分重要。</p></blockquote><p>当损失函数达到极小值，模型对训练集的拟合达到了最佳效果，==对应着低偏差==，而这种情况下，往往对训练集的特点学的过于细微，而缺乏泛化能力。</p><p>根据 ==奥坎姆剃刀原则==, 同样准确率，模型越简单越好，所以通过正则化等方式，削弱模型的拟合能力，降低过拟合的风险。通过提高偏差，来主动降低方差。</p><p>最终我们要平衡方差与偏差，从而得到一个合理的模型。</p><p><img src="/2019/08/01/机器学习模型的偏差与方差/biasvariance.png" alt="biasvariance"></p><h2 id="调整方差与偏差的方法"><a href="#调整方差与偏差的方法" class="headerlink" title="调整方差与偏差的方法"></a>调整方差与偏差的方法</h2><p>待补充。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习的方差与偏差&quot;&gt;&lt;a href=&quot;#机器学习的方差与偏差&quot; class=&quot;headerlink&quot; title=&quot;机器学习的方差与偏差&quot;&gt;&lt;/a&gt;机器学习的方差与偏差&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;方差与偏差，总是迷迷糊糊的，每次看了就会，过了就忘
      
    
    </summary>
    
      <category term="机器学习方法" scheme="http://www.elgong.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="方差与偏差" scheme="http://www.elgong.top/tags/%E6%96%B9%E5%B7%AE%E4%B8%8E%E5%81%8F%E5%B7%AE/"/>
    
  </entry>
  
  <entry>
    <title>XGBoost</title>
    <link href="http://www.elgong.top/2019/07/30/XGBoost/"/>
    <id>http://www.elgong.top/2019/07/30/XGBoost/</id>
    <published>2019-07-30T14:02:00.000Z</published>
    <updated>2020-02-20T04:41:37.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xgboost-学习笔记"><a href="#xgboost-学习笔记" class="headerlink" title="xgboost 学习笔记"></a>xgboost 学习笔记</h1><blockquote><p>主要内容均来自官方文档，官方文档是英文版，所以简单的翻译了一下，方便日后查看。<br><a href="https://xgboost.readthedocs.io/en/latest/python/python_intro.html" target="_blank" rel="noopener">详细内容见官方手册</a></p><h2 id="安装-XGBoost"><a href="#安装-XGBoost" class="headerlink" title="安装 XGBoost"></a>安装 XGBoost</h2></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu -python3:</span><br><span class="line">    pip3 install xgboost</span><br><span class="line"> </span><br><span class="line">导入:</span><br><span class="line">    import xgboost as xgb</span><br></pre></td></tr></table></figure><h2 id="数据接口"><a href="#数据接口" class="headerlink" title="数据接口"></a>数据接口</h2><p><code>XGBoost</code> 可以从以下结构中加载数据：</p><ul><li>LibSVM text format file</li><li>CSV</li><li>Numpy 2D array</li><li>Scipy 2D sparse array</li><li>Pandas</li><li>XGBoost binary buffer file.</li></ul><p>加载的数据都放在 <code>DMatrix</code>对象中，下面是具体加载的过程演示：</p><ul><li><p>LibSVM text format file</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dtrain = xgb.DMatrix(<span class="string">'train.svm.txt'</span>)</span><br><span class="line">dtest = xgb.DMatrix(<span class="string">'test.svm.buffer'</span>)</span><br></pre></td></tr></table></figure></li><li><p>CSV</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 需要指定标签所在的列</span><br><span class="line">dtrain = xgb.DMatrix(<span class="string">'train.csv?format=csv&amp;label_column=0'</span>)</span><br><span class="line">dtest = xgb.DMatrix(<span class="string">'test.csv?format=csv&amp;label_column=0'</span>)</span><br></pre></td></tr></table></figure></li></ul><font color="#FF0000">  XGBoost 不支持种类特征，需要先加载为Numpy数组，然后进行 `one-hot` 编码;推荐使用pandas 加载数据.</font> <ul><li><p>Numpy</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.rand(<span class="number">5</span>, <span class="number">10</span>)  <span class="comment"># 5个样本，每个样本10个特征</span></span><br><span class="line">label = np.random.randint(<span class="number">2</span>, size=<span class="number">5</span>)  <span class="comment"># 二值标签</span></span><br><span class="line"></span><br><span class="line">dtrain = xgb.DMatrix(data, label=label)</span><br></pre></td></tr></table></figure></li><li><p>Scipy</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">csr = scipy.sparse.csr_matrix((dat, (row, col)))</span><br><span class="line">dtrain = xgb.DMatrix(csr)</span><br></pre></td></tr></table></figure></li><li><p>Pandas</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = pandas.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">4</span>,<span class="number">3</span>)), columns=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line">label = pandas.DataFrame(np.random.randint(<span class="number">2</span>, size=<span class="number">4</span>))</span><br><span class="line">dtrain = xgb.DMatrix(data, label=label)</span><br></pre></td></tr></table></figure></li><li><p>保存为 XGBoost 二进制文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dtrain = xgb.DMatrix(<span class="string">'train.svm.txt'</span>)</span><br><span class="line">dtrain.save_binary(<span class="string">'train.buffer'</span>)</span><br></pre></td></tr></table></figure></li><li><p>缺失值处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dtrain = xgb.DMatrix(data, label=label, missing=<span class="number">-999.0</span>)</span><br></pre></td></tr></table></figure></li><li><p>样本权重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = np.random.rand(5, 1)</span><br><span class="line">dtrain = xgb.DMatrix(data, label=label, missing=-999.0, weight=w)</span><br></pre></td></tr></table></figure></li></ul><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><blockquote><p>XGBoost 可以通过列表或者字典来设置参数，例如：</p></blockquote><ul><li><p>Booster 参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">param = &#123;<span class="string">'max_depth'</span>: <span class="number">2</span>, <span class="string">'eta'</span>: <span class="number">1</span>, <span class="string">'objective'</span>: <span class="string">'binary:logistic'</span>&#125;</span><br><span class="line">param[<span class="string">'nthread'</span>] = <span class="number">4</span></span><br><span class="line">param[<span class="string">'eval_metric'</span>] = <span class="string">'auc'</span></span><br></pre></td></tr></table></figure></li><li><p>指定多个评估指标</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">param[<span class="string">'eval_metric'</span>] = [<span class="string">'auc'</span>, <span class="string">'ams@0'</span>]</span><br></pre></td></tr></table></figure></li><li><p>指定验证集来监视性能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evallist = [(dtest, <span class="string">'eval'</span>), (dtrain, <span class="string">'train'</span>)]</span><br></pre></td></tr></table></figure></li></ul><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><ul><li><p>模型训练</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num_round = 10</span><br><span class="line">bst = xgb.train(param, dtrain, num_round, evallist)</span><br></pre></td></tr></table></figure></li><li><p>模型保存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bst.save_model(<span class="string">'0001.model'</span>)</span><br></pre></td></tr></table></figure></li><li><p>保存模型和特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dump model</span></span><br><span class="line">bst.dump_model(<span class="string">'dump.raw.txt'</span>)</span><br><span class="line"><span class="comment"># dump model with feature map</span></span><br><span class="line">bst.dump_model(<span class="string">'dump.raw.txt'</span>, <span class="string">'featmap.txt'</span>)</span><br></pre></td></tr></table></figure></li><li><p>模型加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bst = xgb.Booster(&#123;&apos;nthread&apos;: 4&#125;)  # init model</span><br><span class="line">bst.load_model(&apos;model.bin&apos;)  # load data</span><br></pre></td></tr></table></figure></li></ul><h2 id="早停"><a href="#早停" class="headerlink" title="早停"></a>早停</h2><blockquote><p>如果你有验证集，则可以使用早停机制来寻找最佳的 <code>num_round</code>, 需要将 验证集传入 <code>evals</code>,如果传入多个，则使用最后一个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train(..., evals=evals, early_stopping_rounds=10)</span><br></pre></td></tr></table></figure></p></blockquote><p>如果模型在 <code>early_stopping_rounds</code>次，监控的参数 <code>param[&#39;eval_metric&#39;]</code> 都没有提升，则会停止训练，<code>train</code> 返回的是最后一次训练的模型，而不是最佳模型，最佳模型可以通过一下方式找到：</p><ul><li><code>bst.best_score</code></li><li><code>bst.best_iteration</code></li><li><code>bst.best_ntree_limit</code>  # 使用最佳模型</li></ul><p>同样的，监控多个参数时，最后一个参数起早停的作用。</p><h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><p>已经训练好的模型，或者已经加载的模型可以拿来预测新数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.rand(7, 10)</span><br><span class="line">dtest = xgb.DMatrix(data)</span><br><span class="line">ypred = bst.predict(dtest)</span><br></pre></td></tr></table></figure></p><p>使用最佳的迭代次数的模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ypred = bst.predict(dtest, ntree_limit=bst.best_ntree_limit)</span><br></pre></td></tr></table></figure></p><h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><p>你可以使用绘图模块来画出树结构：</p><ul><li>绘制参数重要性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xgb.plot_importance(bst)</span><br></pre></td></tr></table></figure><ul><li>绘制目标树</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xgb.plot_tree(bst, num_trees=2)</span><br></pre></td></tr></table></figure><ul><li>Ipython 中绘制树</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xgb.to_graphviz(bst, num_trees=2)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;xgboost-学习笔记&quot;&gt;&lt;a href=&quot;#xgboost-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;xgboost 学习笔记&quot;&gt;&lt;/a&gt;xgboost 学习笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;主要内容均来自官方文档，官方文档是
      
    
    </summary>
    
      <category term="XGBoost" scheme="http://www.elgong.top/categories/XGBoost/"/>
    
    
      <category term="XGBoost" scheme="http://www.elgong.top/tags/XGBoost/"/>
    
  </entry>
  
  <entry>
    <title>pandas-2索引和选择数据</title>
    <link href="http://www.elgong.top/2019/07/25/pandas-2%E7%B4%A2%E5%BC%95%E5%92%8C%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE/"/>
    <id>http://www.elgong.top/2019/07/25/pandas-2索引和选择数据/</id>
    <published>2019-07-24T23:01:01.000Z</published>
    <updated>2020-02-20T04:41:37.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pandas-2-索引和选择数据"><a href="#pandas-2-索引和选择数据" class="headerlink" title="pandas -2 索引和选择数据"></a>pandas -2 索引和选择数据</h1><blockquote><p>对于一种数据结构,最基本的操作就应该是增删改查了。</p></blockquote><h2 id="1-行列选择"><a href="#1-行列选择" class="headerlink" title="1. 行列选择"></a>1. 行列选择</h2><p>行选择和列选择有许多方法，很容易记混，常用的要记住。<br>主要方法有三种： <code>iloc</code>, <code>loc</code>, <code>[]</code></p><h3 id="行选择"><a href="#行选择" class="headerlink" title="行选择"></a>行选择</h3><ul><li><p>切片 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 切片</span><br><span class="line">df[a:b]</span><br><span class="line"></span><br><span class="line">// 隔1行选择</span><br><span class="line">df[::2]</span><br></pre></td></tr></table></figure></li><li><p>指定位置</p><p><code>df.iloc[1, 1]</code></p><p><code>df.iloc[1:10, 2:3]</code></p><p><code>df.iloc[1:10][&#39;Price&#39;]</code></p></li><li><p>指定索引</p><p><code>df.loc[&quot;index1&quot;, &quot;index2&quot;]</code></p></li><li><p>按照条件查找</p><p><code>df[( df[&quot;row2&quot;] == 1) &amp; (df[&quot;row2&quot;] == &quot;null&quot;)]</code></p><p><code>df.loc[( df[&quot;row2&quot;] == 1) &amp; (df[&quot;row2&quot;] == &quot;null&quot;)]</code></p></li><li><p>根据列的多个值,选择行</p><p><code>List = [1,2,3,4,5]</code><br><code>train[train[&quot;customer_id&quot;].isin(List)]</code></p></li></ul><h3 id="列选择"><a href="#列选择" class="headerlink" title="列选择"></a>列选择</h3><ul><li><p>通过列标签选择单列</p><p>  <code>df[&quot;price&quot;]</code></p></li><li><p>通过列标签选择多列</p><p> <code>df[[&quot;price&quot;, &quot;time&quot;]]</code></p></li><li><p>通过列索引,选择前3列</p><p><code>df.iloc[:, :3]</code> </p></li></ul><h3 id="行列选择"><a href="#行列选择" class="headerlink" title="行列选择"></a>行列选择</h3><p>  <code>df.loc[&quot;index1&quot; : &quot;index2&quot;,  [&quot;price&quot;]]</code></p><p>  <code>df.iloc[a:b][&#39;Price&#39;]</code></p><h3 id="随机采样行或者列"><a href="#随机采样行或者列" class="headerlink" title="随机采样行或者列"></a>随机采样行或者列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s.sample(frac=0.5)</span><br><span class="line">// 参数</span><br><span class="line">// 默认选择行，n = 行数，  frac = 比例</span><br><span class="line">// replace: 默认False 无放回采样</span><br><span class="line">// weights: 样本采样权重</span><br><span class="line">// axis:  默认=0 行,  =1 列</span><br><span class="line">// random_state=2</span><br></pre></td></tr></table></figure><h3 id="分类别等数量抽样"><a href="#分类别等数量抽样" class="headerlink" title="分类别等数量抽样"></a>分类别等数量抽样</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 降采样 -- 分类抽样</span><br><span class="line">def subSample(df_x, splitAttribute = &quot;Attribute4&quot;):</span><br><span class="line">    </span><br><span class="line">    subsampleNum = min(df_x.groupby(splitAttribute).size())</span><br><span class="line">    print(subsampleNum)</span><br><span class="line">    df_x_sub = df_x.iloc[1:2,:]</span><br><span class="line">    #df_y_sub = df_y.iloc[1:2,:]</span><br><span class="line">    for label in df_x[splitAttribute].unique():</span><br><span class="line">        tmp_x = df_x[df_x[splitAttribute] == label]</span><br><span class="line"></span><br><span class="line">        random_list = random.sample(range(0,len(tmp_x)),subsampleNum )</span><br><span class="line">        df_x_sub = df_x_sub.append(tmp_x.iloc[random_list,:])</span><br><span class="line">        df_y_sub.append(tmp_y.iloc[random_list,:])</span><br><span class="line">    return df_x_sub #, df_y_sub</span><br></pre></td></tr></table></figure><h2 id="2-行的增删改查"><a href="#2-行的增删改查" class="headerlink" title="2. 行的增删改查"></a>2. 行的增删改查</h2><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><blockquote><p>单列</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 末尾增加</span><br><span class="line">   df[&quot;new col&quot;] = None</span><br><span class="line">   </span><br><span class="line">// 指定位置增加，在2列后</span><br><span class="line">   df.insert(2,&apos;city&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>多列</p></blockquote><p>   <code>pd.concat([df, pd.DataFrame(columns=[&quot;C&quot;,&quot;D&quot;])])</code></p><blockquote><p>单行（待验证）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// loc 添加</span><br><span class="line">  df.loc[‘5‘] = [3, 3, 3, 3]</span><br><span class="line">    </span><br><span class="line">// set_value 添加</span><br><span class="line">  df.set_value(‘5‘, df.columns, [3,3,3,3], takeable=False)</span><br></pre></td></tr></table></figure><blockquote><p>多行</p></blockquote><p>多行相当于合并两张表了,可以参考(merge,concat)<a href="https://note.youdao.com/" target="_blank" rel="noopener">方法</a>。</p><p><code>test_ = pd.merge(tmp, data.loc[:,[&quot;customer_id&quot;, &quot;label&quot;]],on=[&#39;customer_id&#39;],how=&#39;left&#39;,copy=False&quot;)</code></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><blockquote><p>列</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// del 方法</span><br><span class="line">   def df[&quot;col_name&quot;]</span><br><span class="line"></span><br><span class="line">//根据列名 drop 方法</span><br><span class="line">   df.drop([&quot;b&quot;, &quot;c&quot;], axis=1,inplace = True)</span><br><span class="line">axis = 1 列</span><br><span class="line">axis = 0 行</span><br><span class="line"></span><br><span class="line">// 根据列号 drop 方法</span><br><span class="line">   df.drop(df.columns[[1,2]], axis=1, inplace=True)</span><br></pre></td></tr></table></figure><blockquote><p>行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 根据索引 删除行</span><br><span class="line">   df = df.drop([1, 2])</span><br><span class="line"></span><br><span class="line">// 根据value 删除行</span><br><span class="line">   df = df[~df[&quot;col&quot;].isin(5,9)</span><br></pre></td></tr></table></figure><blockquote><p>按照条件删除行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.drop(df[df[&quot;order_pay_time&quot;] &lt; pd.to_datetime(&quot;2013-11-12 23:59:44&quot;) ].index)</span><br></pre></td></tr></table></figure><h3 id="修改与查找"><a href="#修改与查找" class="headerlink" title="修改与查找"></a>修改与查找</h3><blockquote><p>单值修改和查找时, 参考选择行列方法。</p><p>多值查找时，</p></blockquote><h4 id="按条件查找"><a href="#按条件查找" class="headerlink" title="按条件查找"></a>按条件查找</h4><p> <code>df_train[( df_train[&quot;row&quot;] == 1) &amp;( == &quot;null&quot;)]</code></p><h4 id="query-查找"><a href="#query-查找" class="headerlink" title="query 查找"></a>query 查找</h4><p> <code>df.query(&#39;(a &lt; b) &amp; (b &lt; c)&#39;)</code></p><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><blockquote><p>单个替换，inplace = True 覆盖源文件</p></blockquote><p>  <code>df.replace(to_replace, value, inplace = True)</code></p><blockquote><p>多值替换—-字典</p></blockquote><p>  <code>df.replace({&quot;A&quot;:&quot;B&quot;,  29:100})</code></p><blockquote><p>按条件替换</p></blockquote><p>  <code>df.where(df &gt; 0, -df, inplace=True)</code></p><h4 id="交换两列的位置"><a href="#交换两列的位置" class="headerlink" title="交换两列的位置"></a>交换两列的位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[[&apos;B&apos;, &apos;A&apos;]] = df[[&apos;A&apos;, &apos;B&apos;]]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pandas-2-索引和选择数据&quot;&gt;&lt;a href=&quot;#pandas-2-索引和选择数据&quot; class=&quot;headerlink&quot; title=&quot;pandas -2 索引和选择数据&quot;&gt;&lt;/a&gt;pandas -2 索引和选择数据&lt;/h1&gt;&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="pandas系列教程" scheme="http://www.elgong.top/categories/pandas%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="pandas" scheme="http://www.elgong.top/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>pandas -1数据结构</title>
    <link href="http://www.elgong.top/2019/07/22/pandas-1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://www.elgong.top/2019/07/22/pandas-1数据结构/</id>
    <published>2019-07-22T01:01:01.000Z</published>
    <updated>2020-02-20T04:41:37.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pandas-1-数据结构"><a href="#pandas-1-数据结构" class="headerlink" title="pandas -1 数据结构"></a>pandas -1 数据结构</h1><blockquote><p>pandas 基本操作都很简单，只是在刚开始学习的过程中，容易忘掉一些API，导致完成一些操作时，总会想着翻翻手册，这一系列博客，是对这些方法进行了梳理，可作为入门学习的参考材料。平时经常翻阅。</p></blockquote><p>“index” (axis=0, default), “columns” (axis=1)</p><h2 id="1-Series"><a href="#1-Series" class="headerlink" title="1. Series"></a>1. Series</h2><blockquote><p>Series 是一个带有 名称 和索引的一维数组。</p></blockquote><h3 id="创建seriex"><a href="#创建seriex" class="headerlink" title="创建seriex"></a>创建seriex</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Series 数组生成，指定数据类型</span><br><span class="line">In:   </span><br><span class="line">    user_age = pd.Series(data=[18, 30, 25, 40], dtype=float)</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">        0    18</span><br><span class="line">        1    30</span><br><span class="line">        2    25</span><br><span class="line">        3    40</span><br><span class="line">        dtype: int64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 增加索引 index</span><br><span class="line">In:   </span><br><span class="line">    user_age.index = [&quot;Tom&quot;, &quot;Bob&quot;, &quot;Mary&quot;, &quot;James&quot;]</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">    Tom      18</span><br><span class="line">    Bob      30</span><br><span class="line">    Mary     25</span><br><span class="line">    James    40</span><br><span class="line">    dtype: int64</span><br><span class="line">    </span><br><span class="line">// 表头</span><br><span class="line">In:</span><br><span class="line">    user_age.index.name(&quot;name&quot;)</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">    name</span><br><span class="line">    Tom      18</span><br><span class="line">    Bob      30</span><br><span class="line">    Mary     25</span><br><span class="line">    James    40</span><br><span class="line">    dtype: int64</span><br></pre></td></tr></table></figure><h3 id="像字典一样使用series"><a href="#像字典一样使用series" class="headerlink" title="像字典一样使用series"></a>像字典一样使用series</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// index 当键值</span><br><span class="line">In: </span><br><span class="line">    user_age[&quot;Tom&quot;]</span><br><span class="line">    user_age.get(&quot;Tom&quot;)</span><br><span class="line"></span><br><span class="line">// 切片-列</span><br><span class="line">In:</span><br><span class="line">    user_age[2:3]</span><br><span class="line">    </span><br><span class="line">// 按条件查找</span><br><span class="line">In:</span><br><span class="line">    user_age[user_age &gt; 30]</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">    name</span><br><span class="line">    James    40.0</span><br><span class="line">    Name: user_age_info, dtype: float64</span><br></pre></td></tr></table></figure><h3 id="像向量一样使用series"><a href="#像向量一样使用series" class="headerlink" title="像向量一样使用series"></a>像向量一样使用series</h3><blockquote><p>可以传递给np方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 整列加减</span><br><span class="line">In:</span><br><span class="line">    user_age + 1</span><br><span class="line">    </span><br><span class="line">Out:</span><br><span class="line">    name</span><br><span class="line">    Tom      19.0</span><br><span class="line">    Bob      31.0</span><br><span class="line">    Mary     26.0</span><br><span class="line">    James    41.0</span><br><span class="line">    Name: user_age_info, dtype: float64</span><br></pre></td></tr></table></figure><h2 id="2-DataFrame"><a href="#2-DataFrame" class="headerlink" title="2. DataFrame"></a>2. DataFrame</h2><blockquote><p>DataFrame 是一个带有 名称 和索引的二维数组，像一张Excel表格。</p></blockquote><h3 id="创建DataFrame"><a href="#创建DataFrame" class="headerlink" title="创建DataFrame"></a>创建DataFrame</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// DataFrame 根据字典生成</span><br><span class="line"></span><br><span class="line">In:</span><br><span class="line">    index = pd.Index(data=[&quot;Tom&quot;, &quot;Bob&quot;, &quot;Mary&quot;, &quot;James&quot;], name=&quot;name&quot;)</span><br><span class="line">    </span><br><span class="line">    data = &#123;</span><br><span class="line">        &quot;age&quot;: [18, 30, 40],</span><br><span class="line">        &quot;city&quot;: [&quot;BeiJing&quot;, &quot;ShangHai&quot;, &quot;HangZhou&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    user_info = pd.DataFrame(data=data, index=index)</span><br><span class="line">    user_info</span><br><span class="line"></span><br><span class="line">Out:</span><br><span class="line">    </span><br><span class="line">// DataFrame 根据二维列表生成</span><br><span class="line">In:</span><br><span class="line">    data = [[18, &quot;BeiJing&quot;], </span><br><span class="line">            [30, &quot;ShangHai&quot;], </span><br><span class="line">            [25, &quot;GuangZhou&quot;], </span><br><span class="line">            [40, &quot;ShenZhen&quot;]]</span><br><span class="line">    columns = [&quot;age&quot;, &quot;city&quot;]</span><br><span class="line">    </span><br><span class="line">    user_info = pd.DataFrame(data=data, index=index, columns=columns)</span><br><span class="line">    user_info</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pandas-1-数据结构&quot;&gt;&lt;a href=&quot;#pandas-1-数据结构&quot; class=&quot;headerlink&quot; title=&quot;pandas -1 数据结构&quot;&gt;&lt;/a&gt;pandas -1 数据结构&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;pandas 基本操作
      
    
    </summary>
    
      <category term="pandas系列教程" scheme="http://www.elgong.top/categories/pandas%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="pandas" scheme="http://www.elgong.top/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>评价指标 ROC与AUC</title>
    <link href="http://www.elgong.top/2019/07/20/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87-ROC%E4%B8%8EAUC/"/>
    <id>http://www.elgong.top/2019/07/20/评价指标-ROC与AUC/</id>
    <published>2019-07-20T07:10:00.000Z</published>
    <updated>2020-02-20T06:39:39.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="非均衡分类问题"><a href="#非均衡分类问题" class="headerlink" title="非均衡分类问题"></a>非均衡分类问题</h2><blockquote><p>非均衡分类问题指的是每个类别的错误代价不同。</p><p>比如疾病检测中,有病患者诊断健康的代价，要比健康人诊断成有病（可能性）造成的影响更为严重。</p><p>对于常用的预测模型，通常是有预测的概率值，我们找到一个合适的截断点作为正负类别的界限。显然再不同的任务下，截断点选择是不同的。我们使用Precison 和Recall的新度量指标来针对特定任务下选择合适的截断值。</p></blockquote><div class="table-container"><table><thead><tr><th>真实标签</th><th>预测为正</th><th>预测为反</th></tr></thead><tbody><tr><td>正例</td><td>TP</td><td>FN</td></tr><tr><td>反例</td><td>FP</td><td>TN</td></tr></tbody></table></div><ul><li>Precison(查准率)：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P = TP/(TP+FP)</span><br></pre></td></tr></table></figure><ul><li>Recall(召回率)：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R = TP/(TP+FN)</span><br></pre></td></tr></table></figure><blockquote><p>当正负样本不不均衡,人为修改测试集中的正负比例时, P-R曲线波动很大，但是ROC曲线变化很小。</p></blockquote><h2 id="ROC-曲线"><a href="#ROC-曲线" class="headerlink" title="ROC 曲线"></a>ROC 曲线</h2><blockquote><p>可以研究学习器的泛化性能。</p><h2 id="加图"><a href="#加图" class="headerlink" title="加图"></a>加图</h2><ul><li>横坐标：真阳率，正例被正确预测的概率</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FPR = FP/(TN+FP)</span><br></pre></td></tr></table></figure><ul><li>纵坐标：假阳率，负例被预测错误的概率<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TPR = TP/(TP+FN)</span><br></pre></td></tr></table></figure></li></ul><p><strong>==理解四点一线==</strong>：</p><ul><li>(0, 0):  FP = TP = 0, 所有样本预测为负</li><li>(1, 1):  FP = TP = 1, 所有样本预测为正</li><li>(1, 0):  FP = 1, TP = 0, 所有正样本预测为负</li><li>(0, 1):  FP = 0, TP = 1, 完美预测</li><li>对角线：随机猜测的值。</li></ul><h2 id="AUC值"><a href="#AUC值" class="headerlink" title="AUC值"></a>AUC值</h2><p>AUC(Area under Curve) 被定义为ROC曲线的下侧面积。一般在(0.5~1)之间。</p><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><ol><li><p>几何角度</p><blockquote><p>直接计算曲线下的面积，梯形</p></blockquote></li><li><p>概率角度</p><blockquote><p>任取一对正负样本对，正样本score大于负样本score的概率</p></blockquote></li></ol><h3 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h3><p><a href="http://zhuzhuyule.xyz" target="_blank" rel="noopener">链接</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from sklearn.metrics import roc_curve</span><br><span class="line">from sklearn.metrics import auc</span><br><span class="line">from time import time</span><br><span class="line"></span><br><span class="line"># y:     标签</span><br><span class="line"># pred： 预测值</span><br><span class="line">def myAUC(y, pred):</span><br><span class="line"></span><br><span class="line">    auc = 0.0</span><br><span class="line">    p_list = []  # 正负例的索引</span><br><span class="line">    n_list = []</span><br><span class="line">    for i, y_ in enumerate(y):</span><br><span class="line">        if y_ == 1:</span><br><span class="line">            p_list.append(i)</span><br><span class="line">        else:</span><br><span class="line">            n_list.append(i)</span><br><span class="line">    # 构成p-n对</span><br><span class="line">    p_n = [(i,j) for i in p_list for j in n_list]</span><br><span class="line">    </span><br><span class="line">    pn_len = len(p_n)</span><br><span class="line">    for tup in p_n:</span><br><span class="line">        if pred[tup[0]] &gt; pred[tup[1]]:</span><br><span class="line">            auc += 1</span><br><span class="line">        elif pred[tup[0]] == pred[tup[1]]:</span><br><span class="line">            auc += 0.5</span><br><span class="line">    auc = auc/pn_len</span><br><span class="line">    return auc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 产生一组数据</span><br><span class="line">y = np.array([1,0,0,0,1,0,1,0,])</span><br><span class="line">pred = np.array([0.9, 0.8, 0.3, 0.1,0.4,0.9,0.66,0.7])</span><br><span class="line"></span><br><span class="line">## sklearn 结果</span><br><span class="line">fpr, tpr, thresholds = roc_curve(y, pred, pos_label=1)</span><br><span class="line"></span><br><span class="line">tim = time()</span><br><span class="line">print(&quot;sklearn AUC:&quot;,auc(fpr, tpr))</span><br><span class="line">print(&quot;sklearn AUC time:&quot;, time()-tim)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## myAUC 结果</span><br><span class="line">tim = time()</span><br><span class="line">print(&quot;\nmyAUC:&quot;,myAUC(y,pred))</span><br><span class="line">print(&quot;myAUC time:&quot;, time()-tim)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;非均衡分类问题&quot;&gt;&lt;a href=&quot;#非均衡分类问题&quot; class=&quot;headerlink&quot; title=&quot;非均衡分类问题&quot;&gt;&lt;/a&gt;非均衡分类问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;非均衡分类问题指的是每个类别的错误代价不同。&lt;/p&gt;
&lt;p&gt;比如疾病检测中
      
    
    </summary>
    
      <category term="机器学习方法" scheme="http://www.elgong.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="ROC" scheme="http://www.elgong.top/tags/ROC/"/>
    
  </entry>
  
  <entry>
    <title>集成学习提升算法-Adaboost</title>
    <link href="http://www.elgong.top/2019/06/25/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0-Adaboost/"/>
    <id>http://www.elgong.top/2019/06/25/集成学习-Adaboost/</id>
    <published>2019-06-25T10:57:01.000Z</published>
    <updated>2020-02-20T06:39:10.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Adaboost-算法原理及推导"><a href="#Adaboost-算法原理及推导" class="headerlink" title="Adaboost 算法原理及推导"></a>Adaboost 算法原理及推导</h1><blockquote><p>Adaboost 是Boosting算法的代表。Boosting可将许多弱学习器组合达到强学习器的效果。</p><p>Adaboost 是通过提升错分数据的权重值来改善模型的不足。<br>其主要的流程是：</p><ol><li>先训练一个基学习器；</li><li>根据基学习器的表现，改变样本的分布，使得错误分类的样本得到更多的关注；</li><li>改变分布后的样本再训练新的基学习器，如此迭代；</li><li>加权组合这些基学习器。</li></ol></blockquote><h2 id="一、Adaboost算法原理"><a href="#一、Adaboost算法原理" class="headerlink" title="一、Adaboost算法原理"></a>一、Adaboost算法原理</h2><blockquote><p>“Adaptive Boosting”（自适应增强）</p></blockquote><p>Adaboost算法中，每个样本有对应的权重D,每个基分类器也有对应的权重α，然后是下边的三步骤：</p><pre><code>Step1：初始化训练集的权重；</code></pre><blockquote><p>如果有N个样本，则每一个训练样本最开始时都被赋予相同的权重：1/N。</p></blockquote><pre><code>迭代：Step2： 改变样本分布，训练基学习器；</code></pre><blockquote><p>错分的样本权重D会增加；准确率高的分类器的权重α会更大；</p></blockquote><pre><code>Step3: 加权组合弱学习器。</code></pre><h2 id="二、Adaboost算法推导"><a href="#二、Adaboost算法推导" class="headerlink" title="二、Adaboost算法推导"></a>二、Adaboost算法推导</h2><p>给定训练集</p><script type="math/tex; mode=display">T=\{(x 1, y 1),(x 2, y 2) \ldots(\mathrm{xN}, y \mathrm{N})\}</script><p>其中，</p><script type="math/tex; mode=display">y_{i} \in\{-1,1\}</script><p>步骤1：初始化训练集的权重D。每个训练样本的初始权重w相同，均为1/N,</p><script type="math/tex; mode=display">D_{1}=\left(w_{11}, w_{12} \cdots w_{1 i} \cdots, w_{1 N}\right)</script><script type="math/tex; mode=display">w_{1 i}=\frac{1}{N}, i=1,2, \cdots, N</script><p>步骤2：训练基学习器，改变训练样本分布，迭代训练新的学习器。<br>用m=1,2…M 代表迭代的轮数，每轮产生的学习器为 <script type="math/tex">h_{m}(x)</script></p><ul><li>计算学习器 <script type="math/tex">h_{m}(x)</script> 在训练数据集上的分类错误率 <script type="math/tex">E_{t}</script> (误差的权值和):</li></ul><script type="math/tex; mode=display">E_{t}=P\left(G_{m}(x) \neq y_{i}\right)</script><script type="math/tex; mode=display">=\sum_{i=1}^{N} w_{m i} I\left(G_{m}\left(x_{i}\right) \neq y_{i}\right)</script><ul><li><p>计算学习器 <script type="math/tex">h_{m}(x)</script> 的权重α：</p><script type="math/tex; mode=display">\alpha_{m}=\frac{1}{2} \ln \frac{\left(1-E_{m}\right)}{E_{m}}</script></li><li><p>更新训练集样本权重。</p></li></ul><script type="math/tex; mode=display">D_{m+1}=\left(w_{m+1,1}, w_{m+1,2} \cdots w_{m+1, i} \cdots, w_{m+1, N}\right)</script><script type="math/tex; mode=display">w_{m+1, i}=\frac{w_{m i}}{Z_{m}} \exp \left(-\alpha_{m} y_{i} G_{m}\left(x_{i}\right)\right), i=1,2, \cdots, N</script><p>这里的 <script type="math/tex">Z_{m}</script> 时规范化因子:</p><script type="math/tex; mode=display">Z_{m}=\sum_{i=1}^{N} w_{m i} \exp \left(-\alpha_{m} y_{i} G_{m}\left(x_{i}\right)\right)</script><ul><li>迭代训练学习器</li></ul><p>步骤3：加权组合弱学习器。</p><script type="math/tex; mode=display">f(x)=\sum_{m=1}^{M} \alpha_{m} h_{m}(x)</script><script type="math/tex; mode=display">H(x)=\operatorname{sign}(f(x))=\operatorname{sign}\left(\sum_{m=1}^{M} \alpha_{m} h_{m}(x)\right)</script><h2 id="三、Adaboost算法解释"><a href="#三、Adaboost算法解释" class="headerlink" title="三、Adaboost算法解释"></a>三、Adaboost算法解释</h2><blockquote><p>模型为加法模型(基函数的线性组合),损失函数为指数函数,学习算法是前想分布算法的二类分类学习法.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Adaboost-算法原理及推导&quot;&gt;&lt;a href=&quot;#Adaboost-算法原理及推导&quot; class=&quot;headerlink&quot; title=&quot;Adaboost 算法原理及推导&quot;&gt;&lt;/a&gt;Adaboost 算法原理及推导&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;A
      
    
    </summary>
    
      <category term="机器学习方法" scheme="http://www.elgong.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="集成学习" scheme="http://www.elgong.top/tags/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>逻辑回归</title>
    <link href="http://www.elgong.top/2019/04/27/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <id>http://www.elgong.top/2019/04/27/逻辑回归/</id>
    <published>2019-04-27T05:01:43.000Z</published>
    <updated>2020-02-20T06:39:32.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>逻辑回归就是西瓜书里的对数几率回归，名为回归，实际则是分类算法。其实质是利用线性回归模型的预测结果来逼近真实标记的对数几率。</p><p>一句话概括就是:</p><font color="red"> 逻辑回归假设数据服从 **伯努利分布** ,通过 **极大化似然函数** 的方法，运用 **梯度下降** 来求解参数，来达到将数据二分类的目的。</font></blockquote><h2 id="线性模型如何处理二分类问题？"><a href="#线性模型如何处理二分类问题？" class="headerlink" title="线性模型如何处理二分类问题？"></a>线性模型如何处理二分类问题？</h2><blockquote><p>在处理二分类任务时，我们希望模型能预测样本属于某类别的概率[0, 1]，或者直接输出类别的标签{0, 1}。 线性模型不能直接来完成这项任务，因为其输出是一个实际值，范围也不一定在0~1之间，无法体现我们所想要的概率或者标签。</p></blockquote><script type="math/tex; mode=display">y=\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}+b</script><p>因此，我们需要找到一种能把线性模型输出映射到 <strong>概率</strong> 或者 <strong>标签</strong> 的方法；</p><ul><li><p>如何转化为标签？</p><p>  单位阶跃函数</p></li><li><p>如何转化为概率？</p><p>  sigmoid函数 (二分类): 将无穷范围的值限制在(0, 1)之间</p><p>  softmax函数（多分类）: 所有类别概率和为1</p></li></ul><p><img src="/2019/04/27/逻辑回归/sigmoid.png" alt="logo"></p><p>由于单位阶跃函数存在跳跃点，在跳跃点不可导，想选择梯度下降法来优化时，只能选择sigmoid函数了。</p><h2 id="逻辑回归模型"><a href="#逻辑回归模型" class="headerlink" title="逻辑回归模型"></a>逻辑回归模型</h2><blockquote><p>逻辑回归就是这样的一个过程：面对一个分类问题，建立代价函数，然后通过优化方<br>法迭代求解出最优的模型参数，然后测试验证我们这个求解的模型的好坏。</p></blockquote><h3 id="逻辑回归的优缺点"><a href="#逻辑回归的优缺点" class="headerlink" title="逻辑回归的优缺点"></a>逻辑回归的优缺点</h3><ul><li><p>优点 </p><ul><li><p>速度快，适合二分类问题</p></li><li><p>简单易于理解，直接看到各个特征的权重</p></li><li><p>能容易地更新模型吸收新的数据</p></li></ul></li></ul><ul><li><p>缺点</p><ul><li>对数据和场景的适应能力有局限性，不如决策树算法适应性那么强</li></ul></li></ul><h3 id="逻辑回归的用途"><a href="#逻辑回归的用途" class="headerlink" title="逻辑回归的用途"></a>逻辑回归的用途</h3><ul><li><strong>寻找主要影响因素</strong>：  通过学习到的权重值，得到不同因素对结果的影响力大小</li></ul><ul><li><strong>预测</strong>：  预测事件发生的概率</li></ul><h3 id="建模常规步骤"><a href="#建模常规步骤" class="headerlink" title="建模常规步骤"></a>建模常规步骤</h3><ul><li>寻找 <code>h 函数</code>（预测函数）</li></ul><ul><li>构造 <code>J 函数</code> (损失函数)</li></ul><ul><li>利用梯度下降等方法最小化  <code>J 函数</code>，并求取参数</li></ul><h3 id="LR基本模型"><a href="#LR基本模型" class="headerlink" title="LR基本模型"></a>LR基本模型</h3><p>以下就是逻辑回归的基本模型：</p><script type="math/tex; mode=display">y=\frac{1}{1+e^{-z}}</script><script type="math/tex; mode=display">z=w^{\top} x+b</script><p>取倒数</p><script type="math/tex; mode=display">\frac{1}{y}=1+e^{-z}</script><p>取对数</p><script type="math/tex; mode=display">\ln \left(\frac{1}{y}-1\right)=-z</script><script type="math/tex; mode=display">\ln \frac{y}{1-y}=\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}+b</script><p>ln(y/(1-y)) 就是对数几率</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>线性模型常用的目标函数 <code>均方误差</code> 用在逻辑回归模型是非凸函数，非凸函数通过梯度下降法容易陷入局部最小值，因此需要想办法找到代价函数，且代价函数为凸函数。</p><h3 id="极大似然法定义代价函数"><a href="#极大似然法定义代价函数" class="headerlink" title="极大似然法定义代价函数"></a>极大似然法定义代价函数</h3><p>这里通过极大似然估计的方法来定义目标函数：</p><blockquote><p><strong>极大似然估计</strong>： 这里想了很久才算有点理解，之前就一直卡在这里。。极大似然估计就是可以利用已知数据来推测出产生这些数据的最可能的环境条件。</p><p>举个栗子，当我们扔硬币时，出现的可能性有两个，要么正面朝上（事件A），要么反面朝上(事件B)，假设出现某事件的可能性只与硬币的 <code>质量分布θ</code> 有关系，假设我们做了n组实验（A出现m次），这样能得到两种情况的概率 P(A), P(B),我们要推测出 <code>质量分布θ</code> 是多少，也就是 <code>参数估计</code> ,即 <code>质量分布θ</code> 是多少时，才最可能出现当前实验的结果。抛硬币的事件服从二项分布，那么给定了一组实验的情况下，似然函数是(似然函数与概率值相等)：</p><script type="math/tex; mode=display">L\left(\theta ; x_{1}, \ldots, x_{n}\right)=f\left(x_{1}, \ldots, x_{n} ; \theta\right)=\prod_{i=1}^{n} P\left(X=x_{i}\right)=\theta^{m}(1-\theta)^{n-m}</script><p>假设一个数据集<code>Cn</code>,标签<code>y∈{0,1}</code>，预测值<code>Θ</code>,模型参数为<code>w</code>则似然函数可以写作:</p><script type="math/tex; mode=display">P\left( \theta _{\left( x_i \right)}|w \right) =\prod_{n=1}^N{\theta}_{xi}^{yi}\cdot \left( 1-\theta _{\left( x_i \right)} \right) ^{1-y_i}</script></blockquote><p>取对数简化运算:</p><script type="math/tex; mode=display">\mathrm{L}(\mathrm{w}, \mathrm{b})=\sum_{i=1}^{N}\left[y_{i} \log \left(\emptyset\left(x_{i}\right)\right)+\left(1-y_{i}\right) \log \left(1-\emptyset\left(x_{i}\right)\right)\right]</script><p>实际代价函数的样子:</p><script type="math/tex; mode=display">\mathrm{J}(\mathrm{w}, \mathrm{b})=-\frac{1}{N} \mathrm{L}(\mathrm{w}, \mathrm{b})=-\frac{1}{N} \sum_{i=1}^{N}\left[y_{i} \log \left(\emptyset\left(x_{i}\right)\right)+\left(1-y_{i}\right) \log \left(1-\emptyset\left(x_{i}\right)\right)\right]</script><p>取对数之后的公式很符合理想的代价函数，当实际标签与预测结果相同，则代价为0，而相反时，会随着差值越大，损失越大。</p><p>因为</p><script type="math/tex; mode=display">\operatorname{logit}(\mathrm{p})=\log \frac{p}{1-p}</script><script type="math/tex; mode=display">\log \frac{P(Y=1 | X)}{1-P(Y=1 | X)}=w \cdot x+b</script><p>带入后继续化简</p><script type="math/tex; mode=display">\mathrm{L}(\mathrm{w}, \mathrm{b})=\sum_{i=1}^{N}\left[y_{i}\left(\mathrm{w} \cdot x_{i}+\mathrm{b}\right)-\log \left(1+e^{\mathrm{w} \cdot x_{i}+b}\right)\right]</script><h3 id="直观解释"><a href="#直观解释" class="headerlink" title="直观解释"></a>直观解释</h3><p>直观上理解，代价函数就是分类错误的惩罚，那么当y=1时，prediction 越小时，损失应越大；y=0时prediction 越大时，损失应越小。</p><script type="math/tex; mode=display">\operatorname{cost}=\left\{\begin{aligned}-\log (\hat{p}), & \text { if } y=1 \\-\log (1-\hat{p}), & \text { if } y=0 \end{aligned}\right.</script><h2 id="通过梯度下降来最小化代价函数"><a href="#通过梯度下降来最小化代价函数" class="headerlink" title="通过梯度下降来最小化代价函数"></a>通过梯度下降来最小化代价函数</h2><p>因为我们找到的代价函数是凸函数，所以可以尝试用梯度下降来找到合适的参数w，b：</p><script type="math/tex; mode=display">\mathrm{w} :=\mathrm{w}-\alpha \frac{\partial J(w, b)}{\partial w}</script><script type="math/tex; mode=display">\mathrm{b} :=\mathrm{b}-\alpha \frac{\partial J(w, b)}{\partial b}</script><p>偏导求解过程：</p><p>对w求偏导</p><script type="math/tex; mode=display">\frac{\partial J(w, b)}{\partial w}=-\frac{1}{N} \sum_{i=1}^{N}\left[y_{i} \frac{1}{\partial\left(x_{i}\right)}-\left(1-y_{i}\right) \frac{1}{1-\emptyset\left(x_{i}\right)}\right] \frac{\partial \emptyset\left(x_{i}\right)}{\partial w}</script><script type="math/tex; mode=display">=-\frac{1}{N} \sum_{i=1}^{N}\left[y_{i} \frac{1}{\emptyset\left(x_{i}\right)}-\left(1-y_{i}\right) \frac{1}{1-\emptyset\left(x_{i}\right)}\right] \sigma\left(x_{i}\right)\left(1-\emptyset\left(x_{i}\right)\right) \cdot x_{i}</script><script type="math/tex; mode=display">=-\frac{1}{N} \Sigma_{i=1}^{N}\left(y_{i}-\emptyset\left(x_{i}\right)\right) \cdot x_{i^{*}}</script><p>对b求偏导</p><script type="math/tex; mode=display">\frac{\partial J(w, b)}{\partial b}=-\frac{1}{N} \sum_{i=1}^{N}\left[y_{i} \frac{1}{\emptyset\left(x_{i}\right)}-\left(1-y_{i}\right) \frac{1}{1-\emptyset\left(x_{i}\right)}\right] \frac{\partial \emptyset\left(x_{i}\right)}{\partial b}</script><script type="math/tex; mode=display">=-\frac{1}{N} \sum_{i=1}^{N}\left[y_{i} \frac{1}{\emptyset\left(x_{i}\right)}-\left(1-y_{i}\right) \frac{1}{1-\emptyset\left(x_{i}\right)}\right] \wp\left(x_{i}\right)\left(1-\emptyset\left(x_{i}\right)\right)</script><script type="math/tex; mode=display">=-\frac{1}{N} \Sigma_{i=1}^{N}\left(y_{i}-\emptyset\left(x_{i}\right)\right)</script><p>带入公式后，得到最终推导的结果：</p><script type="math/tex; mode=display">\mathrm{w} :=\mathrm{w}+\alpha \frac{1}{N} \sum_{i=1}^{N}\left(y_{i}-\emptyset\left(x_{i}\right)\right) \cdot x_{i}</script><script type="math/tex; mode=display">\mathrm{b} :=\mathrm{b}+\alpha \frac{1}{N} \sum_{i=1}^{N}\left(y_{i}-\emptyset\left(x_{i}\right)\right)</script><font color="red"> 通过以上公式可以看出，逻辑回归的梯度与 `sigmoid` 本身无关，只与 `y` 和`x`和 `w` 有关系。</font><h2 id="进一步提高泛化能力"><a href="#进一步提高泛化能力" class="headerlink" title="进一步提高泛化能力"></a>进一步提高泛化能力</h2><blockquote><p>影响模型泛化能力的主因素是 <code>过拟合</code>, 过拟合问题比较容易理解，这里就不贴图了。下面分析一下产生过拟合的原因和解决办法。</p></blockquote><h3 id="过拟合产生的原因有哪些？"><a href="#过拟合产生的原因有哪些？" class="headerlink" title="过拟合产生的原因有哪些？"></a>过拟合产生的原因有哪些？</h3><p><strong>过多的特征</strong></p><h3 id="怎么解决过拟合？"><a href="#怎么解决过拟合？" class="headerlink" title="怎么解决过拟合？"></a>怎么解决过拟合？</h3><ol><li><p>减少特征数量</p><p> 减少特征数量会导致部分信息丢失。</p></li><li><p>正则化</p><p> 保留所有的特征，并且减小参数的大小。</p></li></ol><h3 id="正则化方法"><a href="#正则化方法" class="headerlink" title="正则化方法"></a>正则化方法</h3><p><strong>在代价函数上增加一个惩罚项</strong>，<font color="red">惩罚项应该是模型复杂度的单调递增函数，模型越复杂，惩罚项越大。 </font></p><p>回归问题中，取<strong>平方损失</strong>（L2 范数），或者L1范数</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2 m} \sum_{i=1}^{n}\left(\mathrm{h}_{\theta}\left(\mathrm{x}_{i}\right)-y_{i}\right)^{2}+\lambda \sum_{j=1}^{n} \theta_{j}^{2}</script><p>这里的lambda 系数：</p><p> 如果它的值很大，说明对模型的复杂度惩罚大，对拟合数据的损失惩罚小，这样它就不会过分拟合数据，在训练数据上的偏差较大，在未知数据上的方差较小，但是可能出现欠拟合的现象；</p><p> 如果它的值很小，说明比较注重对训练数据的拟合，在训练数据上的偏差会小，但是可能会导致过拟合。</p><p>加入正则化后的参数更新：</p><script type="math/tex; mode=display">\theta_{j} :=\theta_{j}-\frac{\alpha}{m} \sum_{i=1}^{m}\left(h_{\theta}\left(x_{i}\right)-y_{i}\right) x_{i}^{j}-\frac{\lambda}{m} \theta_{j}</script><h2 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h2><p>空</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://irwenqiang.iteye.com/blog/1552680&quot;该部分参考这里&quot;" target="_blank" rel="noopener">极大似然估计</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;逻辑回归就是西瓜书里的对数几率回归，名为回归，实际则是分类算法。其实质是利用线性回归模型的预测结果来逼近真实标记的对数几率。&lt;/p&gt;
&lt;p&gt;一句话概括就是:&lt;/p&gt;
&lt;font color=&quot;red&quot;&gt; 
逻辑回归假设数据服从 **伯努利分布** 
      
    
    </summary>
    
      <category term="机器学习方法" scheme="http://www.elgong.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="逻辑回归" scheme="http://www.elgong.top/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>决策树1-基本概念</title>
    <link href="http://www.elgong.top/2019/04/20/%E5%86%B3%E7%AD%96%E6%A0%91-1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://www.elgong.top/2019/04/20/决策树-1基本概念/</id>
    <published>2019-04-20T10:09:10.000Z</published>
    <updated>2020-02-20T06:39:22.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="决策树1-基本概念"><a href="#决策树1-基本概念" class="headerlink" title="决策树1- 基本概念"></a>决策树1- 基本概念</h1><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p><img src="/2019/04/20/决策树-1基本概念/tree.png" alt="logo"></p><p>上图来自西瓜书，是决策树的一种树形。生成决策树的过程，不断的<strong>根据样本的属性( 样本的某个特征 )划分样本子集</strong>。每个结点选择当前最优的属性作为划分依据，将样本集合不断的划分成更小的子集合，直到子集合中样本类别一致时或者没有可以划分的属性值时，则停止划分，标记为叶结点(叶节点代表一个类别)。</p><p>简单的介绍一下决策树的组成元素:</p><ol><li>根节点:  所有的训练样本</li><li>内部节点:   对应某一个划分属性</li><li>叶节点：   对应某一种决策结果</li><li>判定测试序列：   某个样本在节点中传递的路径</li></ol><p>所有节点都包含着不同数量的样本。</p><blockquote><p>以上是分类树的例子，决策树也可以用作回归任务，如CART算法。决策树是GBDT,Xgboost等更高级结构的基础，所以尽量要掌握决策树的原理。</p></blockquote><h2 id="决策树算法的基本流程"><a href="#决策树算法的基本流程" class="headerlink" title="决策树算法的基本流程"></a>决策树算法的基本流程</h2><p>假设有一个数据集，其中的每个样本有多种特征，每个特征有不同的取值。通过这个数据集来生成一个决策树的一般流程可以归纳为:</p><ul><li>特征选择</li></ul><blockquote><p>特征选择就是决策树分叉时，依据新节点的”纯度”，选择最优的划分属性;</p></blockquote><ul><li>决策树生成</li></ul><blockquote><p>树不断的分叉，直到样本的属性用光，或者树的深度达到了预定值，则结束分叉;</p></blockquote><ul><li>剪枝</li></ul><blockquote><p>如果一直树杈分下去，一定能够使得所有的样本都正确的归类，但这样会产生对训练集的过拟合，泛化能力变差，可以通过剪枝操作来改善泛化能力。</p></blockquote><p>通过这三步，就可以生成一颗决策树了。下面来学习一下具体怎么进行特征的选择和剪枝。</p><h2 id="如何选择最优的划分属性-分类树"><a href="#如何选择最优的划分属性-分类树" class="headerlink" title="如何选择最优的划分属性(分类树)?"></a>如何选择最优的划分属性(分类树)?</h2><blockquote><p>决策树不断分叉的原因，是尽可能的让不同类别的样本划分到不同的节点，同类别的样本划分到同一个节点。而选择最优的划分属性（特征）的过程，相当于是遍历计算出所有特征的结果，找到能使分叉后子集合最 “纯” 的特征，就是最优的划分属性了。<br>所以，该如何定义 “纯” ，需要借助信息论中 “信息熵” 的概念了。</p></blockquote><p><strong>熵</strong> :  表示随机变量不确定性的度量,也就是混乱程度的一种度量。</p><p>假定数据集 <code>D</code> 中第 <code>K</code> 类样本所占的比例为 <script type="math/tex">p_{k}</script>,则信息熵定义为:</p><script type="math/tex; mode=display">\operatorname{Ent}(D)=-\sum_{k=1}^{N} p_{k} \log _{2} p_{k}</script><p>数据集包含的<font color="#FF0000">类别越少时越纯，<code>Ent(D)</code>也越小。</font> </p><h3 id="法1-信息增益"><a href="#法1-信息增益" class="headerlink" title="法1: 信息增益"></a>法1: 信息增益</h3><p>==ID3算法用到信息增益==</p><blockquote><p>直白的讲就是决策树分叉前的信息熵减去分叉后的信息熵。</p><p>信息增益最大的特征就是最佳划分属性。</p></blockquote><p>假定分叉前样本集 <code>D</code> 中的特征 <code>a</code> 有 <code>V</code>个可能的取值 <script type="math/tex">\left\{a^{1}, a^{2}, \ldots, a^{V}\right\}</script> ,当选择 <code>a</code> 做划分属性时，会分<code>V</code>个节点，每个节点上的子样本集合为 <script type="math/tex">D^{v}</script>,同时为不同节点赋权重(按照样本的比例)，于是信息增益为: </p><script type="math/tex; mode=display">\operatorname{Gain}(D, a)=\operatorname{Ent}(D)-\sum_{v=1}^{V} \frac{\left|D^{v}\right|}{|D|} \operatorname{Ent}\left(D^{v}\right)</script><p>减数部分也叫<font color="#FF0000"> 条件熵 </font></p><font color="#FF0000">缺点:</font> 分叉时偏好取值较多的属性。<font color="#FF0000">原因分析:</font><ol><li>取值多的特征，样本更分散，所有得到的新节点”纯度” 趋于更高，熵更低，而划分前的增益不变的情况下，该特征增益更大。</li><li>比如，当特征的可能取值数量正好等于样本数量，那条件熵几乎为0，该特征一定会被选择。</li></ol><h3 id="法2-信息增益率"><a href="#法2-信息增益率" class="headerlink" title="法2: 信息增益率"></a>法2: 信息增益率</h3><p>==C4.5算法用到信息增率==</p><blockquote><p>相当于在法1基础上，增加了惩罚系数，可取值越多，系数越大。</p></blockquote><script type="math/tex; mode=display">Gain\_ratio\left( D,a \right) =\frac{Gain\left( D,a \right)}{IV\left( a \right)}</script><script type="math/tex; mode=display">\mathrm{IV}(a)=-\sum_{v=1}^{V} \frac{\left|D^{v}\right|}{|D|} \log _{2} \frac{\left|D^{v}\right|}{|D|}</script><p><code>IV(a)</code> 是属性 <code>a</code> 的 “固有值”，内部属性。</p><p><font color="#FF0000">缺点:</font> 分叉时偏好取值较少的属性。</p><h3 id="法3：基尼指数"><a href="#法3：基尼指数" class="headerlink" title="法3：基尼指数"></a>法3：基尼指数</h3><p>==CART决策树算法用到基尼指数==</p><blockquote><p>反应从节点样本集合中随机抽取两个样本，类别不一致的概率。CART决策树默认为二叉树。</p></blockquote><p>基尼值的定义:</p><script type="math/tex; mode=display">\operatorname{Gini}(D)=\sum_{k=1}^{|y|} \sum_{k^{\prime}=k} p_{k} p_{k^{\prime}}</script><script type="math/tex; mode=display">=\sum_{k=1}^{|y|} p_{k}\left(1-P_{k}\right)</script><script type="math/tex; mode=display">=1-\sum_{k=1}^{|\mathcal{Y}|} p_{k}^{2}</script><p>选择特征 <code>A</code> 的情况下，针对 <code>A</code> 所有可能取值 <code>a</code>, 分别计算基尼指数：</p><script type="math/tex; mode=display">Gini\_index\left( D,a \right) =\sum_{v=1}^V{\frac{\left| D^v \right|}{|D|}}\text{}Gini\left( D^v \right)</script><p>选择基尼指数最小的特征和切分点，作为最优划分属性。</p><p>三种决策树模型：</p><div class="table-container"><table><thead><tr><th>算法</th><th>特征选择标准</th></tr></thead><tbody><tr><td>ID3</td><td>信息增益</td></tr><tr><td>C4.5</td><td>信息增益率</td></tr><tr><td>CART</td><td>基尼指数</td></tr></tbody></table></div><h2 id="对抗过拟合-—-剪枝处理"><a href="#对抗过拟合-—-剪枝处理" class="headerlink" title="对抗过拟合 — 剪枝处理"></a>对抗过拟合 — 剪枝处理</h2><blockquote><p>分支太多，容易过拟合，泛化能力变差。所以要适当剪枝，常用方法是<strong>预剪枝</strong>和<strong>后剪枝</strong></p><p>剪枝操作包括的点也很多，这里只是简单描述一下，详细的参考未来的博客。<a href="www.elgong.top">www.elgong.top</a></p></blockquote><h3 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h3><ol><li>预剪枝是在决策树生成的过程中，对每个结点在划分前先估计，根据划分前后验证集的精度，来决定是否划分；</li></ol><ol><li>只能估计当前结点可划分性，不能预测到未来节点划分的必要性，是贪心算法；</li></ol><ol><li>容易造成欠拟合。</li></ol><h3 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h3><ol><li>先生成完整的树，再从叶结点往回计算，根据验证集精度是否提升决定是否剪枝；</li></ol><ol><li>泛化能力往往优于预剪枝，欠拟合风险小；</li></ol><ol><li>时间开销大。</li></ol><h2 id="属性为连续值时？"><a href="#属性为连续值时？" class="headerlink" title="属性为连续值时？"></a>属性为连续值时？</h2><blockquote><p>C4.5 算法采用二分法将连续值离散化</p><p>与离散属性不同，连续的属性可以在后代节点中再次使用</p></blockquote><h2 id="当数据中含有缺失值时？"><a href="#当数据中含有缺失值时？" class="headerlink" title="当数据中含有缺失值时？"></a>当数据中含有缺失值时？</h2><p>处理方法：</p><p>通过无缺失数据计算出三个参数：</p><ol><li>无缺失样本占总样本比例 </li><li>无缺失样中 <code>K类别</code> 占比 <code>pk</code></li><li>无缺失样本中 <code>v 属性</code>样本占比 <code>rv</code></li></ol><p>对单样本增加一个权值 <code>Wx</code>, 无缺失样本的<code>Wx = 1</code>，  有缺失样本的<code>Wx = rv*Wx</code>。</p><p>在计算分支时，<strong>同一样本以不同的概率划分到不同的子节点中</strong></p><ul><li>当样本的属性已知：则把该样本划分进对应的子节点，权值=1；</li></ul><ul><li>当样本的该属性缺失：则把该样本同时划入所有的子节点，样本权值需要更新为`Wx = rv*Wx。</li></ul><h2 id="决策树的优缺点"><a href="#决策树的优缺点" class="headerlink" title="决策树的优缺点"></a>决策树的优缺点</h2><p>==优点==：</p><ul><li>便于理解和可视化；</li><li>训练需要的数据少，不需要对数据进行规范化；</li><li>可同时处理数值型，类别型数据；</li><li>是白盒模型，可解释；</li></ul><p>==缺点==：</p><ul><li>容易产生过于复杂的模型 -&gt; 泛化能力差 （剪枝，限制叶节点所需要的最小样本数，最大深度）</li><li>决策树不稳定，微小变化会产生不同的树（集成多棵树可以缓解）</li><li>难学NP问题（启发式学习）</li><li>异或，奇偶，很难被学习到</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;决策树1-基本概念&quot;&gt;&lt;a href=&quot;#决策树1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;决策树1- 基本概念&quot;&gt;&lt;/a&gt;决策树1- 基本概念&lt;/h1&gt;&lt;h2 id=&quot;决策树&quot;&gt;&lt;a href=&quot;#决策树&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="机器学习方法" scheme="http://www.elgong.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="决策树" scheme="http://www.elgong.top/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机类加载机制</title>
    <link href="http://www.elgong.top/2019/04/14/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.elgong.top/2019/04/14/虚拟机类加载机制/</id>
    <published>2019-04-14T06:11:58.000Z</published>
    <updated>2020-02-20T06:58:27.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><blockquote><p>绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来。</p></blockquote><ul><li>静态绑定</li></ul><blockquote><p>前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现java当中的方法只有<code>final，static，private和构造方法</code> 是前期绑定的。</p></blockquote><ul><li>动态绑定</li></ul><blockquote><p>运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。</p></blockquote><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：<strong>加载、验证、准备、解析、初始化、使用和卸载</strong> 七个阶段，前五个阶段属于类加载的过程。这是开始顺序，每个阶段可能交错。</p><h3 id="step1：加载"><a href="#step1：加载" class="headerlink" title="step1：加载"></a>step1：加载</h3><h4 id="加载阶段，虚拟机完成的任务："><a href="#加载阶段，虚拟机完成的任务：" class="headerlink" title="加载阶段，虚拟机完成的任务："></a>加载阶段，虚拟机完成的任务：</h4><ul><li>通过一个类的全限定名来获取起定义的二进制字节流。</li></ul><blockquote><p>二进制字节流来源： Class文件，Jar包、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等；</p></blockquote><ul><li>将该字节流的静态存储结构转换为方法区的运行时数据结构。</li></ul><ul><li>在Java堆中声称一个代表这个类的 java.lang.Class对象，作为对方法区中这些对象的入口。</li></ul><h4 id="三种主要的类加载器？"><a href="#三种主要的类加载器？" class="headerlink" title="三种主要的类加载器？"></a>三种主要的类加载器？</h4><blockquote><p> 类加载机制采用了委托模式。 类加载器与类本身一同确定这个类在Java 虚拟机中的唯一性。</p></blockquote><ol><li>启动类加载器 <em>Bootstrap ClassLoader</em></li></ol><blockquote><p>该加载器由C++实现，不属于类，负责加载 <code>/JDK/JRE/lib/rt.jar</code>，主要加载 JVM 工作需要的类；</p></blockquote><ol><li>扩展类加载器 <em>Extension ClassLoader</em><blockquote><p>Bootstrp loader 加载 ExtClassLoader,<br> 该加载器由sun.misc.Launcher$ExtClassLoader 实现，它负责加载`/JDK\JRE\lib\ext目录中的类，自己的类打包jar放入也可以；</p></blockquote></li><li><p>应用程序类加载器 <em>Application ClassLoader</em></p><blockquote><p>Bootstrp loader加载完ExtClassLoader后，就会加载AppClassLoader,并且将AppClassLoader的父加载器指定为 ExtClassLoader， 负责加载classpath所指定的位置的类。</p></blockquote></li><li><p>自定义类加载器</p></li></ol><blockquote><p>如果要自定义类加载器，需要继承 <code>应用程序类加载器</code></p></blockquote><h4 id="三者如何协调工作？"><a href="#三者如何协调工作？" class="headerlink" title="三者如何协调工作？"></a>三者如何协调工作？</h4><p>类加载机制采用了委托模式。启动类加载器加载其他类加载器，当需要加载类时，<strong>优先父类加载器工作</strong>。</p><blockquote><p>  双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p></blockquote><h3 id="step2：验证"><a href="#step2：验证" class="headerlink" title="step2：验证"></a>step2：验证</h3><h4 id="验证的目的？"><a href="#验证的目的？" class="headerlink" title="验证的目的？"></a>验证的目的？</h4><p>保证<code>class 文件</code>的字节流符号JVM 虚拟机的要求，不危害虚拟机自身安全。虽然 Java 源码编译不会产生如数组越界之类的错误，但<code>class 文件</code>可以被编辑。</p><h4 id="都需要哪些验证？"><a href="#都需要哪些验证？" class="headerlink" title="都需要哪些验证？"></a>都需要哪些验证？</h4><ul><li>文件格式验证</li></ul><blockquote><p><strong>验证字节流是否符合 <code>class文件规范</code></strong>（如开头是否为魔数<code>0xCAFEBABE</code>， 主次版本号是否可以被当前虚拟机处理等）</p></blockquote><ul><li>元数据验证</li></ul><blockquote><p><strong> 验证字节码描述的信息是否符合Java 语言规范</strong>（如类的继承实现是否符合语法规范）</p><ul><li>字节码验证</li></ul><p>该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</p></blockquote><ul><li>符号引用验证</li></ul><blockquote><p>发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。</p></blockquote><h3 id="step3：-准备"><a href="#step3：-准备" class="headerlink" title="step3： 准备"></a>step3： 准备</h3><p> 准备阶段是正式为<strong>类变量</strong>（静态变量）分配内存并设置类变量初始值的阶段，<strong>这些内存都将在方法区中分配</strong>。注意的是：</p><ol><li>只为类变量分配内存；</li></ol><ol><li>static 类变量初始值为默认初始值，而不是程序中的值；</li></ol><pre><code>public static int value = 3；  // 实际初始值为0</code></pre><ol><li><p>同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值；</p><p> public static final int value = 3；  // 实际初始值为3</p></li></ol><h3 id="step4：-解析"><a href="#step4：-解析" class="headerlink" title="step4： 解析"></a>step4： 解析</h3><blockquote><p>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。</p><p> 解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。</p></blockquote><h3 id="step5：-初始化"><a href="#step5：-初始化" class="headerlink" title="step5： 初始化"></a>step5： 初始化</h3><blockquote><p>真正开始执行类中定义的Java程序代码,初始化阶段是执行类构造器<clinit>()方法的过程。</clinit></p></blockquote><p>类构造器 <code>&lt;clinit&gt;()</code> 执行规则：</p><ol><li>按照在源文件中出现的顺序收集<code>类变量</code> 和 <code>静态语句块 static{ }</code>;</li><li>静态语句块中只能访问定义在之前的变量，而在块后定义的变量只能被赋值，但不能被访问；</li><li>优先构造父类；</li><li>父类中的 <code>静态语句块 static{ }</code> 优先于子类中的变量赋值操作；</li><li>不是必须的，当类或者接口中没有静态语句块或者没有变量赋值，则可以不生成<code>&lt;clinit&gt;()</code>；</li></ol><h2 id="双亲委派被破坏-3种情况下"><a href="#双亲委派被破坏-3种情况下" class="headerlink" title="双亲委派被破坏 3种情况下"></a>双亲委派被破坏 3种情况下</h2><ul><li>第一次： JDK1.2之前还没有双亲委派，但是有用户自定义类加载器（通过<code>loadClass（）</code>加载），为了兼容老版本，设计者添加了 <code>protected findClass()</code>，直接调用用户<code>loadClass（）</code>方法；</li></ul><ul><li><p>第二次：原则上 <strong>越基础的类由越上层的加载器进行加载</strong>,但是有些情况下基础类需要调用用户的代码。如<strong>JNDI, JDBC，JCE,JAXB，JBI</strong>,这时候引入了<code>线程上下文加载器</code>；</p></li><li><p>第三次：“代码热替换”和“模块热部署”出现，希望程序中的功能模块像键盘鼠标一样直接更换，而不是重启。<strong>OSGi</strong> 是这个标准化模块，具体还没看。。。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;虚拟机类加载机制&quot;&gt;&lt;a href=&quot;#虚拟机类加载机制&quot; class=&quot;headerlink&quot; title=&quot;虚拟机类加载机制&quot;&gt;&lt;/a&gt;虚拟机类加载机制&lt;/h1&gt;&lt;h2 id=&quot;绑定&quot;&gt;&lt;a href=&quot;#绑定&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="深入理解Java 虚拟机" scheme="http://www.elgong.top/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="Java类加载机制" scheme="http://www.elgong.top/tags/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
</feed>
