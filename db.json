{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"themes/next/source/baidu_verify_oo3AHvvCK7.html","path":"baidu_verify_oo3AHvvCK7.html","modified":1,"renderable":1},{"_id":"themes/next/source/google1bfaee946527fc4a.html","path":"google1bfaee946527fc4a.html","modified":1,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/love.js","path":"js/love.js","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/love.js","path":"js/src/love.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/LICENSE","path":"lib/needsharebutton/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/README.md","path":"lib/needsharebutton/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"3d80c81638dc40478d251e1deab3820104ce8789","modified":1582173697797},{"_id":"source/baidu_verify_oo3AHvvCK7.html","hash":"303f274f65b6bc92de6bce1b222fb819abbc432d","modified":1582173697834},{"_id":"source/google1bfaee946527fc4a.html","hash":"12f5515e76f58eef28153a53898a8c922e268d76","modified":1582173697835},{"_id":"source/robots.txt","hash":"a05b35a4ee0eea6e94f0d1721fd090cbf097b20a","modified":1582173697836},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1582173697908},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1582173697907},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1582173697908},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1582173697912},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1582173697912},{"_id":"themes/next/.gitignore","hash":"ee0b13c268cc8695d3883a5da84930af02d4ed08","modified":1582173697911},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1582173697913},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1582173697914},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1582173697913},{"_id":"themes/next/README.cn.md","hash":"23e92a2599725db2f8dbd524fbef2087c6d11c7b","modified":1582173697915},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1582173697915},{"_id":"themes/next/package.json","hash":"3963ad558a24c78a3fd4ef23cf5f73f421854627","modified":1582173697980},{"_id":"themes/next/_config.yml","hash":"c1702c7ab5a3a807bf4efd0b4377e401ea8ec922","modified":1583929425465},{"_id":"themes/next/README.md","hash":"50abff86ffe4113051a409c1ed9261195d2aead0","modified":1582173697916},{"_id":"themes/next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1582173697917},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1582173697918},{"_id":"source/_posts/C-梳理笔记.md","hash":"a94647eb981d3f26aa6cf20f91e5b5d1d09245b8","modified":1582173697800},{"_id":"source/_posts/Bloom-Filter-布隆过滤器.md","hash":"3eb0e711da085e57e749f5647e116a8b7df047c7","modified":1589559254913},{"_id":"source/_posts/Deep-Residual-Learning-for-Image-Recognition.md","hash":"e3870d55a8e9bd2113004bb6de8674a562a51057","modified":1582173697801},{"_id":"source/_posts/Java-向上转型-向下转型.md","hash":"8dfba0e30e63013ac3b919543142fc28a9efa711","modified":1587527849854},{"_id":"source/_posts/Java-集合结构.md","hash":"289dd308408f92ddf22c6a2e9f27278095aa7d12","modified":1582173697804},{"_id":"source/_posts/Network-in-Network.md","hash":"e98f72fefa80f2ee4a18f48ec5591510b349fb2f","modified":1582180790127},{"_id":"source/_posts/XGBoost.md","hash":"b7811b7e3637f28e63de0fdacbc0a5d9c9dcd704","modified":1582173697810},{"_id":"source/_posts/git使用.md","hash":"7f1f7e1eef8e5be433942ae1c884339c194bb2d3","modified":1582173697811},{"_id":"source/_posts/mysql-必知必会1-数据定义语言DDL.md","hash":"56d4eb9c3c16273fa3304ba7b9f84b05688c1ad9","modified":1586575269948},{"_id":"source/_posts/mysql-必知必会2-数据操作语言DML.md","hash":"e5368016e08d0ae8e8ba222d80c3f102c0aeac30","modified":1586576027274},{"_id":"source/_posts/mysql-必知必会7-综合内容.md","hash":"12dd78db41220c11850dcae5ff01d6ccb7eebf84","modified":1586578115915},{"_id":"source/_posts/mysql-索引篇1-索引的概念.md","hash":"80ad9a4d774b2d69f256afe67578eda4be47a841","modified":1586574131179},{"_id":"source/_posts/mysql-索引篇2-索引的底层实现.md","hash":"bd4a6b74c0058d1429498df654ff6d920d4e7f7e","modified":1586574573206},{"_id":"source/_posts/pandas-1数据结构.md","hash":"67f964cb60bf661d2b8c2dacdf31b20be31adb98","modified":1582173697812},{"_id":"source/_posts/pandas-2索引和选择数据.md","hash":"eb57633b33bc47d14773c51c186ecfc4d6f95e13","modified":1582173697812},{"_id":"source/_posts/pandas-分层和多级索引.md","hash":"10a0942f65bab6f6921197219a3cdda033ed4f59","modified":1582173697813},{"_id":"source/_posts/pandas-时间-日期处理.md","hash":"534b394cd4332e0788f85d791bbc32748a4ec4bf","modified":1582173697814},{"_id":"source/_posts/pandas-缺失值处理.md","hash":"7a37aabe5fbf9d6a8eeba810d6e43b288f888266","modified":1582173697814},{"_id":"source/_posts/redis学习-Jedis-使用.md","hash":"3202183f215813ca4c4006bec0cec4bc1af9fc7e","modified":1589559517101},{"_id":"source/_posts/pandas-重复值处理.md","hash":"8a08dc54ba875a837d3f6b37c646aabfd658c5d6","modified":1582173697815},{"_id":"source/_posts/redis学习-redis的价值.md","hash":"4370d110dde9e9ea4554d7073c49131d93e880f3","modified":1589558898775},{"_id":"source/_posts/redis学习-缓存设计中要提前考虑的事情.md","hash":"4b21e90574391d96a9ecd51603c30a9761274340","modified":1589559450654},{"_id":"source/_posts/redis学习-常用API.md","hash":"b9054d8049247e81afee5bd70fe98dba168404a4","modified":1589559353124},{"_id":"source/_posts/决策树2-ID3算法.md","hash":"6c00480e9215a9e33df10b458cecc7ddeeab6e46","modified":1582173697817},{"_id":"source/_posts/决策树3-CART分类回归树.md","hash":"bd88b65f404b6239131e8503bc2ba5e1b96d3c7a","modified":1582173697818},{"_id":"source/_posts/将博客搬至CSDN.md","hash":"d36228f930f574d1b92ce423184b9cbfeb725811","modified":1587529347029},{"_id":"source/_posts/机器学习模型的偏差与方差.md","hash":"ac80a47e3ea5ae345fe7eb673d0233eee171cfa7","modified":1582173697825},{"_id":"source/_posts/决策树-1基本概念.md","hash":"eef1e348204c9beb22bf2166e90af22581006fb5","modified":1582180762185},{"_id":"source/_posts/欢迎来我的小屋.md","hash":"38cc1fa98bc35d407db3ab262a5d336eeff86646","modified":1587362327469},{"_id":"source/_posts/华为软挑.md","hash":"d74c6c6bf2887dcae1b67b5e2a512df6e73da31b","modified":1582173697820},{"_id":"source/_posts/版本控制-git.md","hash":"025e73f9be434688b60d7eadfd2a478e3607e50c","modified":1585369441401},{"_id":"source/_posts/蓄水池抽样算法.md","hash":"475f6ed5721fa78991a9d8c52941fca885659487","modified":1587433950680},{"_id":"source/_posts/虚拟机类加载机制.md","hash":"da6f244a697848ebaace4b7e6d6332ae4ccd974c","modified":1582181907793},{"_id":"source/_posts/计算机基础学习笔记.md","hash":"aee0aa9aacca283435380d84e5af5333a84092be","modified":1587436892215},{"_id":"source/_posts/评价指标-ROC与AUC.md","hash":"024bb8a8820da7effc08992032d59a05f880022c","modified":1582180779048},{"_id":"source/_posts/逻辑回归.md","hash":"5682cce45cce8625b05df16557bdbeed7d15b3c2","modified":1582180772963},{"_id":"source/_posts/集成学习-Adaboost.md","hash":"ca620d474795b361acee9327353862e18407dbf4","modified":1582180750549},{"_id":"source/about/index.md","hash":"c6143a439da4ad92a2c6e487c67bdb4a8fd2695a","modified":1582173697833},{"_id":"source/categories/index.md","hash":"f793ab61c3f03e58c74db3f278d8a3575b5fa613","modified":1582173697834},{"_id":"source/tags/index.md","hash":"2a77955e0063f1cc7435b780bc76a549844ff7e9","modified":1582173697837},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1582173697909},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"a0a82dbfabdef9a9d7c17a08ceebfb4052d98d81","modified":1582173697909},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1228506a940114288d61812bfe60c045a0abeac1","modified":1582173697910},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1582173697911},{"_id":"themes/next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1582173697981},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1582173697982},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1582173697919},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1582173697919},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1582173697920},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1582173697920},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1582173697921},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1582173697923},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1582173697921},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1582173697923},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1582173697924},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1582173697924},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1582173697925},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1582173697926},{"_id":"themes/next/languages/zh-Hans.yml","hash":"66b9b42f143c3cb2f782a94abd4c4cbd5fd7f55f","modified":1582173697926},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1582173697927},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1582173697927},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1582173697922},{"_id":"themes/next/layout/_layout.swig","hash":"2ca6162aa84db966729f48680ddd8bf667748141","modified":1583486984678},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1582173697976},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1582173697976},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1582173697977},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1582173697979},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1582173697977},{"_id":"themes/next/source/baidu_verify_oo3AHvvCK7.html","hash":"c7a5d65b658f4c7be1dc2702a86138ee7b9ed6ff","modified":1582173697989},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1582173697978},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1582173697979},{"_id":"themes/next/source/google1bfaee946527fc4a.html","hash":"12f5515e76f58eef28153a53898a8c922e268d76","modified":1582173698066},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1582173698176},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1582173698177},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1582173698178},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582173698066},{"_id":"source/_posts/Deep-Residual-Learning-for-Image-Recognition/resnet1.png","hash":"56e71e5ae901cc533f289e2f88f425e182924701","modified":1582173697802},{"_id":"source/_posts/Network-in-Network/nerworkInNetwork1.png","hash":"139cf459a66b7a31924cf8951c3fd01660319b19","modified":1582173697809},{"_id":"source/_posts/决策树-1基本概念/tree.png","hash":"b657e72f62236d975809681103d06325f2ae4a03","modified":1582173697817},{"_id":"source/_posts/机器学习模型的偏差与方差/biasvariance.png","hash":"34d619dd4750bd282e700da634d2b9ae6eb4a17b","modified":1582173697826},{"_id":"source/_posts/逻辑回归/cost.png","hash":"fef1f81317aea942b7616a1afc70e8a01b17b5e6","modified":1582173697830},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1582173697983},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1582173697983},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1582173697984},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1582173697985},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1582173697985},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1582173697986},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1582173697987},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1582173697986},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1582173697988},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1582173697947},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1582173697928},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"160ad02e1e0227d18a9270bfddfc9e59b4cb69c7","modified":1583140611702},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1582173697947},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1582173697951},{"_id":"themes/next/layout/_macro/my-copyright.swig","hash":"6b2005cb8bd6b7dfdfa8efd3ad50760f22019b0f","modified":1582173697931},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1582173697932},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1582173697931},{"_id":"themes/next/layout/_macro/post.swig","hash":"368709167c68f503221062ff31094d6531bded73","modified":1582173697933},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1582173697933},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"52c8d17ab69b9218aebc40a02562b5355a4c3fa7","modified":1583140110425},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4adc65a602d1276615da3b887dcbf2ac68e7382b","modified":1582173697935},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1582173697934},{"_id":"themes/next/layout/_partials/footer.swig","hash":"23da79bffdd6df6bf162396b0c0efdba775114da","modified":1582173697936},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1582173697939},{"_id":"themes/next/layout/_partials/head.swig","hash":"3d1cc5fb8b210ec09df68be0b653e3bd9841a32c","modified":1582173697936},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1582173697938},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1582173697940},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1582173697967},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1582173697940},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1582173697968},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1582173697968},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1582173697969},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1582173697970},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1582173697970},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1582173697969},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1582173698065},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1582173698067},{"_id":"themes/next/source/js/love.js","hash":"d4fdbd1262e5388c1ea82661420c0a0f2b743344","modified":1582173698079},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1582173698068},{"_id":"themes/next/source/images/avatar.jpg","hash":"d4e05f2955ca83ecdcd86304d998fb97ebcbe5ca","modified":1582535841044},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1582173698069},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1582173698070},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1582173698072},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1582173698071},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1582173698074},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1582173698073},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1582173698073},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1582173698072},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1582173698074},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1582173698075},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1582173698075},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1582173698076},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1582173698078},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1582173698077},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1582173698077},{"_id":"source/_posts/Deep-Residual-Learning-for-Image-Recognition/resnet2.png","hash":"7e08d7c3ddcc720fe424c1b1ed5c365164c89d35","modified":1582173697803},{"_id":"source/_posts/Network-in-Network/nerworkInNetwork2.png","hash":"5c49d49b5b4cb70e62446a97df515f3623ebba98","modified":1582173697810},{"_id":"source/_posts/决策树3-CART分类回归树/CART.png","hash":"fd35f6022f7045179efc9e4965ce759134b6d454","modified":1582173697819},{"_id":"source/_posts/逻辑回归/sigmoid.png","hash":"0c2ba4e2c5f9e3914a2584175f809af150dbe8db","modified":1582173697831},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582173697950},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582173697950},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582173698063},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582173698064},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582173698044},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582173698043},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582173698045},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1582173697948},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1582173697949},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1582173697951},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1582173697937},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"d8d021fb96fd195824758666aa535dc90fa08b67","modified":1583928192023},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1582173697942},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1582173697943},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1582173697943},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1582173697961},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1582173697962},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1582173697965},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1582173697963},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1582173697963},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1582173697965},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1582173697967},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1582173697964},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1582173697952},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1582173697953},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1582173697955},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1582173697953},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"3a196ba8ec2b25b36e2f01d1f557f653dd85daf7","modified":1583928578123},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1582173697955},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"766d46e331c02877be7c037aa2cdb8334e918a7a","modified":1583929840927},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1582173697957},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1582173697956},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1582173697956},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1582173697957},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1582173697958},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1582173697958},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1582173697959},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1582173697944},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1582173697945},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1582173697945},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1582173697946},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1582173697975},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1582173697973},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1582173697974},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1582173697974},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1582173698042},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1582173698062},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1582173698062},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1582173698063},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1582173698064},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1582173698043},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1582173698044},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1582173698045},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1582173698080},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1582173698080},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1582173698081},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1582173698081},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1582173698082},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1582173698085},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1582173698088},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1582173698083},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1582173698089},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1582173698086},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1582173698089},{"_id":"themes/next/source/js/src/love.js","hash":"d4fdbd1262e5388c1ea82661420c0a0f2b743344","modified":1582173698084},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1582173698099},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1582173698106},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1582173698122},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1582173698120},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1582173698108},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1582173698121},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1582173698121},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1582173698141},{"_id":"themes/next/source/lib/needsharebutton/LICENSE","hash":"336611e76f0638d3d8aeca6b1b97138d2a07523f","modified":1582173698148},{"_id":"themes/next/source/lib/needsharebutton/README.md","hash":"b9c3545046609fc6310458cf6c5d004ee2c69c4e","modified":1582173698148},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"f98253ddd8b345a6826b05139911be12c70bcc0c","modified":1582173698149},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"ef80f26e3ae6fc59ecdbc1294c50636de9280018","modified":1582173698150},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1582173698125},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1582173698124},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1582173698126},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1582173698127},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1582173698126},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1582173698161},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1582173698162},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1582173698163},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1582173698144},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1582173698143},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1582173698144},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1582173698145},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1582173698146},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1582173698143},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1582173698171},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1582173698171},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1582173698174},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1582173698175},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1582173698152},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1582173698176},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1582173698151},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1582173698152},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1582173698153},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1582173698153},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1582173698154},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1582173698156},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1582173698155},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1582173698157},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1582173698157},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1582173698156},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1582173698155},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1582173698158},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1582173698159},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1582173698142},{"_id":"source/_posts/Java-集合结构/集合.png","hash":"0ccafbb4438d01303dc08f57329b139d477140a2","modified":1582173697807},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1582173697973},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1582173697972},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1582173697992},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1582173698037},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1582173697990},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1582173697992},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1582173697991},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1582173697991},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1582173698003},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1582173698021},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1582173698038},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1582173698039},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1582173698039},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1582173698040},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1582173698040},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1582173698041},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1582173698054},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e695e58f714129ca292c2e54cd62c251aca7f7fe","modified":1582173698055},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1582173698055},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1582173698046},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1582173698054},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1582173698056},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1582173698058},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1582173698059},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1582173698061},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1582173698047},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1582173698058},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1582173698059},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1582173698060},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1582173698049},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1582173698049},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1582173698048},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1582173698050},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1582173698050},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1582173698051},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1582173698087},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1582173698095},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1582173698097},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1582173698098},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1582173698123},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1582173698123},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1582173698109},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1582173698111},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1582173698112},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1582173698110},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1582173698111},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1582173698113},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1582173698118},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1582173698119},{"_id":"themes/next/source/lib/needsharebutton/.github/stale.yml","hash":"dbd5e6bf89b76ad1f2b081578b239c7ae32755af","modified":1582173698147},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1582173698118},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1582173698129},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1582173698129},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1582173698128},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1582173698169},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1582173698170},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1582173698096},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1582173698140},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1582173698173},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1582173697994},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1582173697995},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1582173697996},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1582173697997},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1582173697998},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1582173697995},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1582173697996},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1582173697998},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1582173698000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1582173698000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1582173698001},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1582173698001},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1582173697999},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1582173698002},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1582173698005},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1582173698007},{"_id":"themes/next/source/css/_common/components/post/my-post-copyright.styl","hash":"e954bf95842945b196bbb0de7b8098950a780129","modified":1582173698004},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1582173698007},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1582173698009},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1582173698006},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1582173698008},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1582173698011},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1582173698009},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1582173698010},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1582173698012},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1582173698012},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1582173698013},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1582173698013},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1582173698010},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1582173698015},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1582173698015},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1582173698016},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1582173698016},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1582173698017},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1582173698018},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"439f112487afa53da823b53f569d6ebd19deaaca","modified":1582173698014},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1582173698018},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1582173698019},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1582173698020},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1582173698024},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1582173698019},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1582173698025},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1582173698023},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1582173698029},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1582173698026},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1582173698027},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1582173698031},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1582173698028},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1582173698031},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1582173698029},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1582173698033},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1582173698025},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1582173698032},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1582173698035},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1582173698036},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1582173698034},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1582173698030},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1582173698034},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1582173698036},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1582173698052},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1582173698053},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1582173698057},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1582173698092},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1582173698092},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1582173698094},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1582173698094},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1582173698093},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1582173698115},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1582173698114},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1582173698113},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1582173698116},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1582173698115},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1582173698117},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1582173698134},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1582173698131},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1582173698139},{"_id":"source/_posts/华为软挑/huawei.jpg","hash":"48a7fba1a2a8aa453e6431f56f4fc68ad13657c8","modified":1582173697824},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1582173698138},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1582173698105},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1582173698167},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1582173698136},{"_id":"public/baidu_verify_oo3AHvvCK7.html","hash":"c7a5d65b658f4c7be1dc2702a86138ee7b9ed6ff","modified":1589559553776},{"_id":"public/google1bfaee946527fc4a.html","hash":"8ba55190696064cc3e6089dd25bd3f26c5d017ed","modified":1589559553777},{"_id":"public/baidusitemap.xml","hash":"6cfad54c547a040197a4fe910069706f86f8d2db","modified":1589559553781},{"_id":"public/atom.xml","hash":"4df7ac95135207a62da4e589ef338588ca50bcb4","modified":1589559553857},{"_id":"public/sitemap.xml","hash":"dc1a2fb244bba5428f906c452d5d61df0dc7674b","modified":1589559553857},{"_id":"public/search.xml","hash":"552bd851cb47d784daa8a9f4d1e98fb0f86d494e","modified":1589559553857},{"_id":"public/tags/index.html","hash":"392f7e2d1de147ae2fe094f2e9c2974a7e4a64e1","modified":1589559554897},{"_id":"public/about/index.html","hash":"ca52487427c0d5018956972c4dbbfd270d62aff2","modified":1589559554897},{"_id":"public/2020/04/22/将博客搬至CSDN/index.html","hash":"d84dd77904145c9a78a3514671f5e1e6358d06ea","modified":1589559554904},{"_id":"public/2020/05/12/redis学习-redis的价值/index.html","hash":"9bed708fc9e8bd7583bd92dec459af503d42c51e","modified":1589559554904},{"_id":"public/2020/04/22/Java-向上转型-向下转型/index.html","hash":"f0ea8fe7f4fd6ae6f52c13872fd461b62847f8de","modified":1589559554904},{"_id":"public/categories/index.html","hash":"a7905c79d01f598b8cc6e3065705a186e9ca984c","modified":1589559554905},{"_id":"public/2020/04/11/mysql-必知必会7-综合内容/index.html","hash":"aec83249b9f3a0cd866730f911da3e6d9401bcf6","modified":1589559554905},{"_id":"public/2020/04/11/mysql-必知必会2-数据操作语言DML/index.html","hash":"a1bcca70cea529a679d6b13337e8642bed10f5c5","modified":1589559554905},{"_id":"public/2020/01/01/Java-集合结构/index.html","hash":"996302f3474834d255dd256493bdf5a8a1f64c63","modified":1589559554905},{"_id":"public/2020/04/11/mysql-必知必会1-数据定义语言DDL/index.html","hash":"de201d503c93680f800a3195f76c5f2f143e42f2","modified":1589559554905},{"_id":"public/2020/04/19/蓄水池抽样算法/index.html","hash":"c8a4cc056647b0e26e52778729b0eceadc875212","modified":1589559554905},{"_id":"public/2019/09/12/决策树3-CART分类回归树/index.html","hash":"9fd887fb4f37980377ac99dec14090d773a86bd3","modified":1589559554906},{"_id":"public/2019/09/12/决策树2-ID3算法/index.html","hash":"287d4b0387ffa8d92bc1f5f4bdbcd4e6ccdb14b8","modified":1589559554906},{"_id":"public/2020/03/28/版本控制-git/index.html","hash":"115b98618e6f37c705e690709faed9764fe38430","modified":1589559554906},{"_id":"public/2019/12/16/计算机基础学习笔记/index.html","hash":"2ef948f3d132e6a319fd50df616fc3652f6e7e3c","modified":1589559554906},{"_id":"public/2019/08/13/pandas-分层和多级索引/index.html","hash":"488aff1e420bcf2c69ba9e995900036cd3996c75","modified":1589559554906},{"_id":"public/2019/08/11/mysql-索引篇1-索引的概念/index.html","hash":"c7fc65fae84a5c584c34d86cc8faa7b7116f0100","modified":1589559554906},{"_id":"public/2019/08/12/mysql-索引篇2-索引的底层实现/index.html","hash":"438967e4f3b569c1726cb4d91a56d218c3e4b11f","modified":1589559554907},{"_id":"public/2019/08/01/机器学习模型的偏差与方差/index.html","hash":"44f9c45f96acbcca0cf76d7963937d24e2aaf3c5","modified":1589559554907},{"_id":"public/2019/08/09/pandas-重复值处理/index.html","hash":"6748851af99146600d31edb93ff90466b3a5990f","modified":1589559554907},{"_id":"public/2019/08/06/pandas-时间-日期处理/index.html","hash":"0d9c5f906e20fef7f5dc1a56dc3d9ee18c7ed79e","modified":1589559554907},{"_id":"public/2019/08/09/pandas-缺失值处理/index.html","hash":"8404bcd9c6c5e3a7c9a074291d4c195ffd2a8f37","modified":1589559554907},{"_id":"public/2019/07/30/XGBoost/index.html","hash":"543b5be2fd12a153c2689d19e3f992d141e5657e","modified":1589559554907},{"_id":"public/2019/07/25/pandas-2索引和选择数据/index.html","hash":"9aead0d7ea182c7c15b0f7847b21b66fd3e55405","modified":1589559554907},{"_id":"public/2019/07/22/pandas-1数据结构/index.html","hash":"45298bde0ba02b8f379e572a36ec8aa121ffa407","modified":1589559554908},{"_id":"public/2019/07/20/评价指标-ROC与AUC/index.html","hash":"9605aa6b8d682063a6da807231df5427ddf8ed90","modified":1589559554908},{"_id":"public/2019/06/25/集成学习-Adaboost/index.html","hash":"2434589f5cbb8d52ce96d4ea4652783f448c7d18","modified":1589559554908},{"_id":"public/2019/04/27/逻辑回归/index.html","hash":"ae0c2b3d4dddc8923cb869bdf734e9276b8184d1","modified":1589559554908},{"_id":"public/2019/04/20/决策树-1基本概念/index.html","hash":"323320f170b0035ad7545e5c6cf13af72ebcc6e1","modified":1589559554908},{"_id":"public/2019/04/14/虚拟机类加载机制/index.html","hash":"092651ab06cc7f0739cc8fbca44b0408a93729f1","modified":1589559554908},{"_id":"public/2019/04/01/华为软挑/index.html","hash":"4295e3b7aa313ce255fc049386b4057bcbf1a568","modified":1589559554908},{"_id":"public/2019/01/25/Deep-Residual-Learning-for-Image-Recognition/index.html","hash":"8bcde1b9b31deb679025c17d729b88d2d5c7f712","modified":1589559554908},{"_id":"public/2019/01/24/Network-in-Network/index.html","hash":"ff2ee0bbb117a90b93d2ffea1997c45882d7c01a","modified":1589559554909},{"_id":"public/2019/01/20/C-梳理笔记/index.html","hash":"42b4570ec3e7dcc1be4638197180169600b5ee36","modified":1589559554909},{"_id":"public/2019/01/19/git使用/index.html","hash":"d486df9e36a4c320415487f0da2db01598afc546","modified":1589559554909},{"_id":"public/2019/01/18/欢迎来我的小屋/index.html","hash":"f65da0b8d0a10af2698718211156402ce19e3d80","modified":1589559554909},{"_id":"public/categories/C/index.html","hash":"574e23b8ceb1bc3a5fc6108b150597900f35a034","modified":1589559554909},{"_id":"public/categories/计算机视觉论文阅读/index.html","hash":"2fa4363b213d9b7489b0574ea17709a5d85043ee","modified":1589559554909},{"_id":"public/categories/Java多态/index.html","hash":"c01be3a5a40108c58062d4aa8349f998884d6e43","modified":1589559554909},{"_id":"public/categories/算法与数据结构/index.html","hash":"c8a2d78cc073be24a9e7eb3171116253e6c805cd","modified":1589559554909},{"_id":"public/categories/XGBoost/index.html","hash":"61b484ee5caca00f27c881c8cb76bc7462b01057","modified":1589559554910},{"_id":"public/categories/git/index.html","hash":"4d7e9fa18c82529b5906afd81bee196d4e4a445d","modified":1589559554910},{"_id":"public/categories/Java基础/index.html","hash":"75769b9851a6e0edd8adc2c9ec977979d3a81951","modified":1589559554910},{"_id":"public/categories/mysql/index.html","hash":"1f9807dc485c0c2a2ffc690820cd7b84848d5f54","modified":1589559554910},{"_id":"public/categories/pandas系列教程/index.html","hash":"175e4d815156ebb5828faa523e1741103fe23cec","modified":1589559554910},{"_id":"public/categories/缓存中间件/index.html","hash":"475999e626a77b04a30ba1c1a923cb33b044939f","modified":1589559554910},{"_id":"public/categories/机器学习方法/index.html","hash":"bfd54a474fe2b81bf95260886580d49f095285dd","modified":1589559554910},{"_id":"public/categories/闲聊/index.html","hash":"0038893b7a54db9b23fe79646110813b554b67d5","modified":1589559554910},{"_id":"public/categories/竞赛/index.html","hash":"3b95f49aa21c644e2cf58508ca99098df381f057","modified":1589559554911},{"_id":"public/categories/深入理解Java-虚拟机/index.html","hash":"be86eb924a683eeef8d0c8777521737b384dad66","modified":1589559554913},{"_id":"public/categories/计算机基础梳理/index.html","hash":"8b888de9d855edbb992ad69ab1d3e19f638aab13","modified":1589559554913},{"_id":"public/archives/index.html","hash":"206516a4ae128124366b6f82d1da275b1313dd9e","modified":1589559554913},{"_id":"public/archives/page/2/index.html","hash":"4eca3210f130d480c3f79d4706c0293779890a57","modified":1589559554914},{"_id":"public/archives/page/3/index.html","hash":"14041ebbcba7124f8733843df7d5064fa604f0a0","modified":1589559554914},{"_id":"public/archives/page/4/index.html","hash":"74679b33984dd2c7d42f7ef1f16a9ccefe5bcc7c","modified":1589559554914},{"_id":"public/archives/2019/index.html","hash":"12ae0dfc5a775bf21259ce56c43fa7d58f019b08","modified":1589559554914},{"_id":"public/archives/2019/page/2/index.html","hash":"f74322e837e76f09c1220b02b6fc567584022c01","modified":1589559554914},{"_id":"public/archives/2019/page/3/index.html","hash":"65c9fa0a423697833525375b42010241820ea2bc","modified":1589559554915},{"_id":"public/archives/2019/01/index.html","hash":"aca21eb93eb4f7f04a0ce434b5661dc2ed647572","modified":1589559554915},{"_id":"public/archives/2019/04/index.html","hash":"c60e26f6f7640c3f294e5d0cd0531dbdbf7b1c66","modified":1589559554915},{"_id":"public/archives/2019/06/index.html","hash":"47f0fe01754f80ad7de48a41df2a50601ab1d04e","modified":1589559554915},{"_id":"public/archives/2019/07/index.html","hash":"3d05c9e236967d19440ebf138e4b6fb24911df53","modified":1589559554916},{"_id":"public/archives/2019/08/index.html","hash":"2f97f69ba67bb3c01fa5984ed4caa7b0c13c9f8d","modified":1589559554916},{"_id":"public/archives/2019/09/index.html","hash":"4b89000657e96c026806a43dba70e2dba4e06d40","modified":1589559554916},{"_id":"public/archives/2019/12/index.html","hash":"12e2ab9d7e65adecdc0a1b7afbd1434d41215077","modified":1589559554916},{"_id":"public/archives/2020/index.html","hash":"dd7bcbbcf739528caebc11e4a0c1e05f4ae9e908","modified":1589559554916},{"_id":"public/archives/2020/01/index.html","hash":"23d3bd34ff334e827dfdb84fb70574827ad99de1","modified":1589559554916},{"_id":"public/archives/2020/03/index.html","hash":"bf4b554ffd75698bb017a4f8fbbcc61217a49e05","modified":1589559554917},{"_id":"public/archives/2020/04/index.html","hash":"42e50060c5f1cb65052fb763133181c947e13995","modified":1589559554918},{"_id":"public/archives/2020/05/index.html","hash":"fdcd585f432d3dd12eb141180dd3605a70f6b98f","modified":1589559554918},{"_id":"public/index.html","hash":"68b44e71929fed321b1f71a491763e477da9eee4","modified":1589559554919},{"_id":"public/page/2/index.html","hash":"93d5f5946ad2c4c195a13ae52c9208cbd427cede","modified":1589559554919},{"_id":"public/page/3/index.html","hash":"2052ce131b5b4e64e45401014776760ce4293df6","modified":1589559554919},{"_id":"public/page/4/index.html","hash":"dd2b459c9b58a9111c434855c61fb55a61ec4341","modified":1589559554920},{"_id":"public/tags/C/index.html","hash":"1ace99e3eb5e7655cceddfd2a37abb6e75b9c364","modified":1589559554920},{"_id":"public/tags/深度学习论文/index.html","hash":"aa7e280ac1dd2ad0a1338822f85317976041a1f1","modified":1589559554920},{"_id":"public/tags/向上转型-向下转型/index.html","hash":"988b51fde02beec9305a47bd3ffab505c56517f9","modified":1589559554920},{"_id":"public/tags/XGBoost/index.html","hash":"ce5d57262c5ef2407d41128a3b549999076a3805","modified":1589559554920},{"_id":"public/tags/git/index.html","hash":"6f7752cb106d2bf0468e4e3020c8ec8311619787","modified":1589559554920},{"_id":"public/tags/Java集合/index.html","hash":"75bf77b8990f23b0a84a7874ffd5f758242ff215","modified":1589559554921},{"_id":"public/tags/mysql-必知必会系列/index.html","hash":"00fdb546b76eb2b01f156a7be9875f92d8628bbb","modified":1589559554921},{"_id":"public/tags/数据库索引/index.html","hash":"16a57faa7889d13f7ac25953a15e69a6a2a867b9","modified":1589559554921},{"_id":"public/tags/pandas/index.html","hash":"00d3ecea133a2409dd12a8bb58d12513987f699d","modified":1589559554921},{"_id":"public/tags/redis/index.html","hash":"cbdbde7c15056e7d1328d4757cda8071c654c8ee","modified":1589559554921},{"_id":"public/tags/pandas-MultiIndex/index.html","hash":"8878d4a1c4e0ffaf4e4c18c7de5e1c0384978b8f","modified":1589559554921},{"_id":"public/tags/ID3/index.html","hash":"262c6d5276d6d2dbc5c3ea7643f09527c75a9f33","modified":1589559554922},{"_id":"public/tags/CART树/index.html","hash":"68f5c71be66c92f015fa59bbb87d44679dd6a591","modified":1589559554922},{"_id":"public/tags/闲聊/index.html","hash":"73c1e1732721e1f0c8e5bf5f35243182a171d282","modified":1589559554922},{"_id":"public/tags/方差与偏差/index.html","hash":"04f6191e99dbfd03acf6db4b2c951e9e8a64efba","modified":1589559554922},{"_id":"public/tags/决策树/index.html","hash":"2489677050a8fca83b890850828f343458844790","modified":1589559554922},{"_id":"public/tags/华为软挑初赛/index.html","hash":"d98b212ca0797100dd8c1285755d4c029c90e107","modified":1589559554922},{"_id":"public/tags/蓄水池抽样算法-海量数据随机采样/index.html","hash":"eacc5bac346e84cd08ad21d3dd8b08d2866ec6b9","modified":1589559554923},{"_id":"public/tags/ROC/index.html","hash":"587ac5d8afdfaaac693c5bfd80a03b73520708e5","modified":1589559554923},{"_id":"public/tags/Java类加载机制/index.html","hash":"c23835f0e5e0bbfcaabc5452677b06c2819e7ac7","modified":1589559554923},{"_id":"public/tags/学习笔记/index.html","hash":"e470b3967b2d47df312f3365e7e4781351618530","modified":1589559554923},{"_id":"public/tags/版本控制/index.html","hash":"6c27ec2794e08506b67a85a513d1dd62dcd2d3cb","modified":1589559554923},{"_id":"public/tags/集成学习/index.html","hash":"ecd797621a5cfa5c2b93d7fe02a23f1b159b5d3c","modified":1589559554923},{"_id":"public/tags/逻辑回归/index.html","hash":"be008b4e8f00f7c00c581710728b8ce407badff7","modified":1589559554923},{"_id":"public/2020/05/16/redis学习-Jedis-使用/index.html","hash":"9225ff3199179fa8de9216e12083854be1fe0d07","modified":1589559554939},{"_id":"public/2020/05/16/redis学习-缓存设计中要提前考虑的事情/index.html","hash":"95a618755c39ad698cd303692bd161dd4535d4cb","modified":1589559554939},{"_id":"public/2020/05/16/redis学习-常用API/index.html","hash":"b65981fb81ac24313c4ee84e0807503883b0d2fe","modified":1589559554939},{"_id":"public/2020/05/16/Bloom-Filter-布隆过滤器/index.html","hash":"adc06654f06512732594ebe45eb25b43f6b16093","modified":1589559554939},{"_id":"public/archives/2020/page/2/index.html","hash":"b7a27b6f95952f5247d201759aa1034c67a3db6e","modified":1589559554939},{"_id":"public/tags/布隆过滤器/index.html","hash":"d252178b566a97e2dc7729f3843b4f169d074594","modified":1589559554939},{"_id":"public/tags/redis-jedis/index.html","hash":"badab4786ee69fb9a764fbe868ea68cbb67ee937","modified":1589559554940},{"_id":"public/tags/redis-缓存雪崩，-缓存穿透，-缓存击穿/index.html","hash":"4070b83aa148665e0bacefe5eece9829734f9208","modified":1589559554940},{"_id":"public/robots.txt","hash":"a05b35a4ee0eea6e94f0d1721fd090cbf097b20a","modified":1589559554954},{"_id":"public/CNAME","hash":"3d80c81638dc40478d251e1deab3820104ce8789","modified":1589559554954},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1589559554954},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1589559554955},{"_id":"public/images/avatar.jpg","hash":"d4e05f2955ca83ecdcd86304d998fb97ebcbe5ca","modified":1589559554955},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1589559554955},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1589559554958},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1589559554958},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1589559554959},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1589559554959},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1589559554959},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1589559554959},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1589559554959},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1589559554960},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1589559554960},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1589559554960},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1589559554960},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1589559554960},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1589559554960},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1589559554960},{"_id":"public/lib/needsharebutton/LICENSE","hash":"336611e76f0638d3d8aeca6b1b97138d2a07523f","modified":1589559554961},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1589559554961},{"_id":"public/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1589559554961},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1589559554961},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1589559554961},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1589559554961},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1589559554961},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1589559554962},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1589559554962},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1589559554962},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1589559554962},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1589559554962},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1589559554962},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1589559554962},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1589559554962},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1589559554962},{"_id":"public/2019/08/01/机器学习模型的偏差与方差/biasvariance.png","hash":"34d619dd4750bd282e700da634d2b9ae6eb4a17b","modified":1589559554963},{"_id":"public/2019/04/20/决策树-1基本概念/tree.png","hash":"b657e72f62236d975809681103d06325f2ae4a03","modified":1589559554963},{"_id":"public/2019/01/25/Deep-Residual-Learning-for-Image-Recognition/resnet2.png","hash":"7e08d7c3ddcc720fe424c1b1ed5c365164c89d35","modified":1589559554963},{"_id":"public/2019/01/24/Network-in-Network/nerworkInNetwork1.png","hash":"139cf459a66b7a31924cf8951c3fd01660319b19","modified":1589559554963},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1589559556301},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1589559556314},{"_id":"public/2019/09/12/决策树3-CART分类回归树/CART.png","hash":"fd35f6022f7045179efc9e4965ce759134b6d454","modified":1589559556319},{"_id":"public/2019/01/25/Deep-Residual-Learning-for-Image-Recognition/resnet1.png","hash":"56e71e5ae901cc533f289e2f88f425e182924701","modified":1589559556319},{"_id":"public/2019/04/27/逻辑回归/sigmoid.png","hash":"0c2ba4e2c5f9e3914a2584175f809af150dbe8db","modified":1589559556320},{"_id":"public/2019/01/24/Network-in-Network/nerworkInNetwork2.png","hash":"5c49d49b5b4cb70e62446a97df515f3623ebba98","modified":1589559556320},{"_id":"public/2019/04/27/逻辑回归/cost.png","hash":"fef1f81317aea942b7616a1afc70e8a01b17b5e6","modified":1589559556320},{"_id":"public/js/love.js","hash":"26d97a907cb239fda30ab966fb1ec318bf3e24bd","modified":1589559556345},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1589559556345},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1589559556345},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1589559556345},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1589559556346},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1589559556347},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1589559556347},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1589559556347},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1589559556347},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1589559556347},{"_id":"public/js/src/love.js","hash":"26d97a907cb239fda30ab966fb1ec318bf3e24bd","modified":1589559556348},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1589559556348},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1589559556348},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1589559556348},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1589559556348},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1589559556349},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1589559556349},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1589559556350},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1589559556350},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1589559556350},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1589559556350},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1589559556351},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1589559556351},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1589559556351},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1589559556351},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1589559556351},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1589559556351},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1589559556351},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1589559556351},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1589559556352},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1589559556352},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1589559556352},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1589559556352},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1589559556352},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1589559556352},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1589559556352},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1589559556352},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1589559556353},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1589559556353},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1589559556353},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1589559556353},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1589559556353},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1589559556365},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1589559556365},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1589559556365},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1589559556365},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1589559556365},{"_id":"public/lib/fastclick/README.html","hash":"c07b353b4efa132290ec4479102a55d80ac6d300","modified":1589559556366},{"_id":"public/lib/needsharebutton/README.html","hash":"a02a3905ce9ab80b2c5e68d99ad98a9f3ce315cc","modified":1589559556366},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"06811ca2f722dead021493457f27cdc264ef928d","modified":1589559556366},{"_id":"public/lib/jquery_lazyload/README.html","hash":"a08fccd381c8fdb70ba8974b208254c5ba23a95f","modified":1589559556366},{"_id":"public/css/main.css","hash":"162005b2a88886fc778ae8c840f0ff6c176bf7bf","modified":1589559556366},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"f151bb5ba4a2cd334061bac27a1a155969b62cdb","modified":1589559556366},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"75dee2bb4796ca66693831d769d9a105eed8c290","modified":1589559556366},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1589559556367},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1589559556367},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1589559556367},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1589559556368},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1589559556368},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1589559556368},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1589559556368},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1589559556368},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1589559556368},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1589559556368},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1589559556368},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1589559556369},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1589559556369},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1589559556369},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1589559556369},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1589559556369},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1589559556369},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1589559556370},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1589559556370},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1589559556370},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1589559556387},{"_id":"public/2020/01/01/Java-集合结构/集合.png","hash":"0ccafbb4438d01303dc08f57329b139d477140a2","modified":1589559556408},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1589559556427},{"_id":"public/2019/04/01/华为软挑/huawei.jpg","hash":"48a7fba1a2a8aa453e6431f56f4fc68ad13657c8","modified":1589559556428}],"Category":[{"name":"C++","_id":"cka8ephbx0006t8plfq91dogj"},{"name":"计算机视觉论文阅读","_id":"cka8ephcs000ct8plb9jcy8lw"},{"name":"Java多态","_id":"cka8ephd8000it8plqi64mcm1"},{"name":"算法与数据结构","_id":"cka8ephdj000pt8pljx2yotmg"},{"name":"XGBoost","_id":"cka8ephdt000wt8pldr1u1syu"},{"name":"git","_id":"cka8ephe10013t8pldtexa45a"},{"name":"Java基础","_id":"cka8epheg0019t8ple0z6oexy"},{"name":"mysql","_id":"cka8epher001ft8pleljtu0jc"},{"name":"pandas系列教程","_id":"cka8ephg70028t8pl5dhzxou0"},{"name":"缓存中间件","_id":"cka8ephhk0033t8plnrtbg82a"},{"name":"机器学习方法","_id":"cka8ephi4003nt8plan6o0prd"},{"name":"闲聊","_id":"cka8ephij003vt8pl0vkuwfgq"},{"name":"竞赛","_id":"cka8ephj40046t8plybj6mtg5"},{"name":"深入理解Java 虚拟机","_id":"cka8ephjh004et8pl4cf9vs0h"},{"name":"计算机基础梳理","_id":"cka8ephjq004mt8plhbv1l4t2"}],"Data":[],"Page":[{"layout":"false","_content":"google-site-verification: google1bfaee946527fc4a.html","source":"google1bfaee946527fc4a.html","raw":"layout: false\n---\ngoogle-site-verification: google1bfaee946527fc4a.html","date":"2020-02-20T04:41:37.835Z","updated":"2020-02-20T04:41:37.835Z","path":"google1bfaee946527fc4a.html","title":"","comments":1,"_id":"cka8epgx80000t8pleqzkqgm2","content":"google-site-verification: google1bfaee946527fc4a.html","site":{"data":{}},"excerpt":"","more":"google-site-verification: google1bfaee946527fc4a.html"},{"layout":"false","_content":"oo3AHvvCK7","source":"baidu_verify_oo3AHvvCK7.html","raw":"layout: false\n---\noo3AHvvCK7","date":"2020-02-20T04:41:37.834Z","updated":"2020-02-20T04:41:37.834Z","path":"baidu_verify_oo3AHvvCK7.html","title":"","comments":1,"_id":"cka8epgxc0001t8plr86lmolw","content":"oo3AHvvCK7","site":{"data":{}},"excerpt":"","more":"oo3AHvvCK7"},{"title":"about","date":"2019-01-24T05:42:12.000Z","_content":"\n关于我。。","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-01-24 13:42:12\n---\n\n关于我。。","updated":"2020-02-20T04:41:37.833Z","path":"about/index.html","comments":1,"layout":"page","_id":"cka8ephbk0003t8pl73zirw7a","content":"<p>关于我。。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>关于我。。</p>\n"},{"title":"文章分类","date":"2019-01-18T02:11:26.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2019-01-18 10:11:26\ntype: \"categories\"\n---\n","updated":"2020-02-20T04:41:37.834Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cka8ephbs0005t8plahok6uts","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2019-01-18T02:13:35.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-01-18 10:13:35\ntype: \"tags\" #新添加的内容\n---\n","updated":"2020-02-20T04:41:37.837Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cka8ephc50009t8pl5eugf7r1","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"C++梳理笔记","date":"2019-01-20T12:30:39.000Z","copyright":null,"password":123456,"top":null,"_content":"\n<font color=\"red\"><big>测试内容</big></font>\n\n\n~~删除线~~\n\n[链接](http://zhuzhuyule.xyz)\n\n![logo](图片测试！/test.jpg)\n\n# C++学习笔记\n\n## **类型转换：**\n\n1. 隐式转换： 低类型转换为高类型\n\n       浮点数（直接舍掉小数，不四舍五入） + 整数\n\n2. 显式转换：\n\n    \tint **(**z**) = (**int**)** z **= static_cast\\<**int**\\> (**z**)**\n\n。。。\n\n### **数据的输入和输出：信息的流动**\n\n 1. 输入：\n\n 2. 输出：\n\n 3. 流类库的操纵符：\n\n### **程序控制：**\n\n\t\tif, while, for, do-while , break, continue, { switch,case,default } ;\n1. do-while:\n\n\t    do 语句      // 先执行一次\n\t    while(表达式)；\n\n2. for的范围，遍历容器：\n\n\n### **自定义类型：**\n\n* 类型别名： \n\n\n  1. typedef double Area, V;\n\n  2. using Area = double\n\n\n\n\n* 枚举类型： 有限的个数\n\n　　　　不限定作用域： enum 类型名 { 变量值列表}\n\n　　　　限定作用域：\n\n　　　注：枚举元素是常量，不能赋值\n\n　　　　　枚举元素有默认值，默认0,1,2,3,4，声明时可以另外指定\n\n　　　　　可以进行关系运算\n\n* auto类型 和decltyoe类型\n\t\t\n\t\t    decltype( float( i )) j = 2;   // j值是2，类型是float;\n\t\t\n\t\t    auto m = 2.5;  // m 为float;\n\n* 结构体( C语言中的)： struct\n\n\t\t\tstruct MyTimeStruct{   //定义 结构体类型\n\t\t\t    unsigned int year,mouth,day,hour,min,sec;\n\t\t\t};\n\n\n\n## **函数： 可重用的功能模块（定义和调用）**\n\n### **函数定义：**\n\n　　形参不占用空间，调用时分配；\n\n### **函数调用：**\n\n　　调用前要函数声明： int sum**(** int a**,** int b**);**\n\n　　1. 函数的嵌套调用：\n\n　　2. 函数的递归调用： 直接或者间接调用自身\n\n计算n!\n\n\t\tunsigned int fac( unsigned int n){\n\t\t    if (n == 0) return 1;\n\t\t    return fac( n - 1) * n;\n\t\t}\n\n汉诺塔\n\n\t\t分析：\n\t\t1.\tA 上的n-1个盘子移动到B上（借助C）;\n\t\t2.\tA上剩下的盘子移动到C上；\n\t\t3.\tB上的n-1个盘子移动到C上（借助A）\n\t\tvoid move(char src, char obj)\n\t\t{\n\t\t    cout << src << \"--->>>\" << obj << endl;\n\t\t}\n\t\t\n\t\tvoid hanoi(int n, char src, char medium, char obj)\n\t\t{\n\t\t    if(n == 1)\n\t\t        move(src, obj);\n\t\t    else{\n\t\t        hanoi(n-1, src, obj, medium);\n\t\t        move(src, obj);\n\t\t        hanoi(n-1, medium, src, obj);\n\t\t    }\n\t\t}\n\n\n### **函数的参数：**\n\n1. 形参不占用空间，调用时分配；\n\n2. 计算结果返回多个（利用引用）\n\n3. 多个参数时，从后开始传\n\n### **引用类型（&）：** 必须初始化，该类型不可改变，是其他变量的别名\n\t\n\t\tint i, j;\n\t\tint & ri = i;  // 定义int引用类型变量 ri, 初始化为i的引用\n\n\n### **含有可变参数的函数：（两种方法）**\n\n1. 所有实参类型相同：`initializer_list<int> li; //类模板, 都是常量`\n\n2. 具体看第九章\n\n3. 类型不同：\n\n### **内联函数（inline）： **用函数体内的语句，替换函数调用表达式，编译时完成，类似 #define\n\n声明： `inline int calArea(int a){  }`\n\n要求： 1. 不能有循环，switch语句 2. 定义在调用之前 3. 不能有异常接口声明\n\n###  constexpr 函数：（常量表达式函数）\n\n\n### **带默认参数的函数：**\n\n\t\tint getVa(int length, int weight = 2)\n\n### **函数的重载：**（C++多态性的重要机制，编译过程中实现）\n\n函数体同名，参数类型不同/参数个数不同\n\n\t\tint add(int x, int y);\n\n\t\tfloat add(float x, float y);\n\n\t\tfloat add(float x, float y, float z);\n\n\n### **C++系统函数：**\n\n\t\t#include <cmath>\n\t\t\t|_\n\t\t\t|_\n\t\t#include <cstdlib>\n\t\t\t|_\n\t\t\t|_\n\t\t#include <cstdio>\n\t\t\t|_\n\t\t\t|_\n\t\t#include <ctime>\n\t\t\t|_\n\t\t\t|_\n\n\n\n## **类和对象**\n\n类：构建对象的蓝图，\n\n对象：由类创建，含有数据和方法\n\n封装：对数据和操作数据的方法的组合绑定\n\n继承：在已有类基础上，形成新的类\n\n多态：\n\n构造函数：定义对象时，通过构造函数初始化\n\n析构函数：删除对象时，通过析构函数释放资源\n\n### ** 类和对象的定义：**\n\n定义类：\n\n\t\tclass {  //类名称 \n\t\t    public:\n\t\t        // 公有成员,外部接口\n\t\t    private:\n\t\t        // 私有成员\n\t\t    protected:\n\t\t        int hour = 0; // 类内初始化\n\t\t        // 保护型成员\n\t\t}\n\n\n注意：不指定类型，默认为私有；\n\n### **成员函数：**\n\t\t\n\t\t|_ 内联成员函数： 类内声明或者inline关键字\n\n\t\t|_类外实现：void 类名称::成员函数名称（）{ }\n\n### **构造函数：**\n\n-  在创建对象时，自动调用来初始化数据\n\n-  与类名相同\n\n-  构造函数有初始化列表\n\n-  格式 类名（string s, lei i）：s(初始值)，i(初始值){ }；\n\n### **委托构造函数：**一个构造函数 通过另一个构造函数 初始化\n\n### **复制构造函数：**\n\n用途：\n\n-   用存在的对象 去初始化新对象 （通过引用旧的对象）\n\n-   函数f的形参是类的对象，调用f时，将用实参对象初始化形参对象\n\n-   函数g的返回值是类的对象，用return的对象来在主调函数中初始化一个无名对象\n\n### **析构函数：**生存期结束，删除清理工作，不能有return，不能有参数\n\n\t    class 类名{\n\n\t    public:\n\t        类名（形参）； // 构造函数\n\t        类名（const 类名& 旧对象名）；  // 复制构造函数 =delete是不生成\n\t\t\t~ 类名（）；\n\t    }\n\n\n>   注：未声明时，编译器自己生成一个默认的\n\n### **前向引用声明：**两个类相互引用时，某个类在引用之前就声明\n\n\t    class A;  //前向引用声明，只是一个标识符，不是万能的\n\t    class B{\n\t    public:\n\t        void A(B b);\n\t    }\n\n\t    class A{\n\t    public：\n\t        void B（A a）;\n\t    }\n\n\n### **结构体：**特殊的类，默认是公有的，可以有函数成员\n\n\t    //公有成员\n\t        int a;\n\t    protected:\n\t        int b;\n\t    private:\n\t        int c;\n\t    };\n\n\n### **联合体：**\n\n目的：存储空间的共用，成员不能同时有效，比如某人语文课成绩，只有一种可能；\n\t\t\n\t\tunion Mark{ // 成绩的联合体， 只有一个成立\n\t\t    char grade;  //等级类的成绩\n\t\t    bool pass;  // 是否通过的成绩\n\t\tint percent;  //百分制成绩  }\n\n### **枚举类：**\n\nenum class 枚举类型名： 底层类型（int）**{** 枚举列表 **};**\n\n    //默认 int\n\n优势：\n\n-   强制作用域 --必须在枚举类 枚举类型名：：枚举值，不同枚举类可以有同名值了\n\n-   转换限制 --枚举对象不能与整型 隐式转换\n\n-   底层类型 --可以指定\n\n\n## **数据共享和保护：**\n\n### **作用域分类：**\n\n函数原型作用域：\n\n- 形参的范围在（）内，所以不需要名字也行，int area( int );\n\n局部作用域\n\n- 函数{ }内\n\n- if、for、while { }内\n\n类作用域： 类外访问类的成员\n\n- 静态成员：通过 对象名.成员名 访问\n\n- 非静态成员：\n\n- 文件作用域\n\n- 命名空间作用域： 10章\n\n### **对象的生存期：**\n\n静态生存期： 整个程序结束后消失\n\n- 函数内的静态对象， 用static ，全局寿命，只局部可见\n\n动态生存期：\n\n- 离开作用域后消失\n\n- 下次进函数重新生成对象\n\n### **类的静态数据成员：**\n\n- static 声明\n\n- 为该类所有对象共享，具有静态生存期\n\n- 必须在类外定义和初始化，类内声明，用：：指明所属于的类\n\n比如记录 类产生了多少对象；opencv中的Mat对象好像用到了？？？？\n\n\t\tclass base{   \n\t\t    public :   \n\t\t           static   int   _num;//声明   \n\t\t};   \n\t\tint  base::_num=0;  //真正定义  \n\n\n### **类的友元：**\n\n- 破坏数据封装和数据隐藏的机制\n\n- 尽量不用\n\n### ** 友元函数：**\n\n- 类声明中由关键字 friend 修饰说明的非成员函数\n\n- 可以在其函数体内访问对象的private,protected成员\n\n- 但必须通过对象名：：访问，函数参数为类的引用\n-   \n### ** 友元类：**\n\n\t\tclass A{\n\t\t    friend B;\n\t\t  public:\n\t\t    void display(){\n\t\t        count << x << enld;\n\t\t    }\n\t\t  private:\n\t\t    int x;\n\t\t}\n\t\t\n\t\tclass B{\n\t\t  public:\n\t\t    void set(int i);\n\t\t    void display();\n\t\t  private:\n\t\t    A a;\n\t\t}\n\t\t\n\t\tvoid B::set(int i){\n\t\t    a.x = i;   // B类中改变 A类私有值\n\t\t}\n\t\tvoid B::display(){\n\t\t    a.display()\n\t\t}\n\n\n### **共享数据的保护：**\n\n#**常类型：**const\n\n常对象：必须初始化，不可更新\n\n\t\tclass A{\n\t\t}\n\t\tA const a; // a是常对象\n\n\n常成员：(不可以放在构造函数体内复制，可以在初始化列表中)\n\n\t\tA：：A(int i):a(i){ }\n\n- 常数据成员：const修饰的\n\n- 静态常数据成员： static const int b;\n\n- 常函数成员（用来处理常对象的函数）\n\n    - 不更新对象的数据成员\n\n    - 声明和实现都带const\n\n\n\t\t\tclass A{\n\t\t\t    void f（int a）const;\n\t\t\t}\n\t\t\tvoid A::f(int a) const{  \n\t\t\t}; // f是常对象函数, 处理常对象\n\n\n- 常引用：不可更新\n\n　　　引用是双向传递的，避免修改原值的方法就是常引用；\n\n         const A& a;\n\n- 常数组：\n\n- 常指针：\n\n### **多文件结构和预编译命令：**\n\n- .h 系统使用\n\n- .hpp 个人使用(类的声明,函数的声明)\n\n- .cpp (类的实现，函数的实现)\n\n   ![](media/f5d645ed218d5fa3e753f771b72310fc.png)\n\n### **外部变量：**\n\n文件作用域中定义的变量默认是外部变量，其他文件使用前，extern声明\n\n将变量和函数限制在编译单元内：namespcae:\n\n\t\tnamespace{ //匿名的命名空间，外部不可调用任何东西\n\t\t    int i;\n\t\t    void fun(){\n\t\t        i++;\n\t\t    }\n\t\t}\n\n\n### **预编译命令：**\n\n\t\t#include< >  标准方式搜索，从系统目录include\n\n\n\t\t#include”” 先当前目录搜索，没有再标准搜索\n\n\n\t\t#define \n\n\n\t\t#undef 删除有#define的宏\n\n\t\t#if 表达式  // 条件编译指令\n\t\t---\n\t\t#else\n\t\t---\n\t\t#endif \n\n\n\t\t#ifndef 标识符\n\t\t---\n\t\t#else  \n\t\t---\n\t\t#endif\n\n\n\n## **数组，指针与字符串：**\n\n### **数组：**\n\n定义： `int arr**[**m**][**n**]**…;`\n\n　　注：二维数组中 arr[1] 第二行首地址\n\n### **数组作为函数参数：**\n\n　　数组名做参数： 形参，实参都是数组名，传入的是地址\n\n### **对象数组：**\n\n　　定义：类名 数组名[对象元素个数]\n\n　　访问：数组名[下标].成员名\n\n### **基于范围的for循环：**c++11,自动遍历整个容器\n\n\t  for( auto x : 容器){ } for( auto &x : 容器){ }\n\n注意：\n\n- auto &x是元素引用，auto x是元素的副本\n\n- auto推导出的类型是容器中的值类型\n\n- ：冒号后的表达式只执行一次\n\n### **指针：**\n\n### **定义：**\n\n\t\tstatic int i;\n\t\t\n\t\tstatic int * p = &I;\n\n### **指针的初始化和赋值：**\n\n### **指针的算术运算，关系运算：**\n\n### **指针数组：**\n\n        类名  *p[2];\n\n### **指向数组的指针：**\n\n        int **p; 指向二维数组的指针\n\n### **指针与函数：**\n\n- 指针做参数：大批量数据提高效率\n\n- 指针类型的函数：返回类型是指针\n\n\t\tint * function(int i){return 全局或者静态的 }；// 不能返回非静态局部变量\n\n-  指向函数的指针：实现函数回调的功能\n\n>   定义： 数据类型 (\\*f)(参数表);\n\n>   数据类型：返回值\n\n-   对象指针：\n\n>   定义： 类名 \\*对象指针名 = & 对象；\n\n>   访问对象： 对象指针名-\\>成员名\n\n（\\*对象指针名）.成员名\n\n- this 指针：成员函数的一个隐士参数，初始化为对象的地址，不可改变\n\n- 隐含于类的每个非静态成员函数中\n\n- 指出成员函数所操作的当前的对象\n\n- \\*this 是当前对象地址\n\n### **动态内存分配：**\n\nnew** 类型名 **(**初始化列表**) // 返回首字节地址\n\ndelete 指针p //p一直在，删除的只是p指向的对象申请的空间\n\n动态数组：\nnew 类型名[数组长度]\n\ndelete[] 数组首地址p指针\n\n### **智能指针：**C++11\n\n### **内存管理**\n\n-   unique_ptr:\n\n    -   不允许多个指针共享资源，标准库中move可以转移指针，但原来指针会失效\n\n-   shared_ptr:\n\n    -   多指针共享\n\n-   weak_ptr:\n\n    -   可复制共享\n\n>   Vector对象：类模板\n\n优势：\n\n-   封装任何形式的动态数组，自动创建，删除\n\n-   下标越界检查\n\n定义： vector <元素类型> object（长度）\n\n- `object.begin()  object.end()  object.size()`\n\n- auto 遍历vector `for(auto e: object);`\n\n### **对象的复制和移动：**\n\n-   浅层复制和深层复制：复制对象用到复制构造函数，默认的复制构造只传递了指针，两个变量指向同一块内存，释放其中一个，再释放第二个会出错；\n\n    -   浅层：实现对象间数据一一对应的复制，但两个对象指向同一内存\n\n    -   深层：当对象成员是指针类型，应该对指针所指对象进行复制。\n\n>   类名**::**类名**(**const 类名**&** v**){**\n\n>   size **=** v**.**size**;**\n\n>   data_ptr **= new** Ponit**[**size**];**\n\n>   **for(**int i**=**0**;** i **\\<** size**; ++**i**){**\n\n>   data_ptr**[**i**] =** v**.**data_ptr**[**i**];**\n\n>   **}**\n\n>   **}**\n\n-   移动构造：C++11,省去了构造和删除临时对象的过程\n\n    ![](media/8c3092d99bcdba78edeb2d8123270ffe.png)\n\n>   class_name**(**class_name **&&**old**)::**xptr**(**old**.**xptr**){**\n\n>   n**.**xptr **= NULL;** // 原来的指针清空\n\n>   **}**\n\n### **C风格字符串：**字符数组\n\n### **string类：**\n\n常用构造函数：\n\n-   string(); //默认构造，长度为0\n\n    -   string s1**;**\n\n-   string(const char \\*s) //指针s所指向的字符串常量初始化该对象\n\t\n\t\tstring s2 = “abc”;\n\t\t\n\t\tstring(const string &rhs) //复制构造函数\n\t\t\n\t\tstring s3 = s2;\n\n访问：下标访问\n\n整行字符串的输入： cin 被空格隔开\n\ngetline(cin,s2); //包含\\#include\\<string\\>\n\ngetline(cin,s2,’,’);\n\n\n## **继承和派生：** 充分利用原有的\n\n继承：保持已有类的特征来构造新类\n\n派生：在已有类基础上新增自己的特性\n\n基类：父类\n\n派生类：子类\n\n直接基类和间接基类\n\n单继承：\n\n\tclass 派生类名：继承方式 基类名{  //继承方式，\n\t    成员声明；//新增成员的声明\n\t}\n\n\n多继承：\n\n\tclass 派生类名：继承方式1 基类1，继承方式2 基类2{\n    \t成员声明；\n\t}\n\n\n### **继承的方式：**\n\n控制：派生类对基类成员的访问权限\n\n-   公有继承 public\n\n>   基类中的pubilc和protected访问属性在派生类中不变\n\n>   基类的pravate不可被对象直接访问\n\n-   私有继承 ：内部可以访问基类的公有和保护成员，但是其对象不再可以访问\n\n-   保护继承 ：基类的公有和保护，到这都成了保护成员，类内可以访问，但对象不能\n\n派生类的构成：\n\n-   吸收基类成员\n\n-   改造基类成员\n\n    -   增加同名成员，基类成员被覆盖（重新定义继承的成员函数必须用虚函数）\n\n-   添加新成员\n\n### **类型转换：**\n\n基类和派生类之间：\n  \n派生类的对象可以隐含转换为基类对象；\n\n派生类的对象可以初始化基类的引用；\n\n派生类的指针可以隐含转换为基类的指针；\n\n### **派生类的构造函数：**\n\n默认情况下，基类的构造函数不被继承，派生类需要自己构造\n\nc++11，using语句继承基类构造函数\n\n### **派生类的复制构造函数：**\n\n### **派生类的析构函数：**\n\n### **虚基类：**\n\n## **多态性**\n\n### **运算符重载：**\n\n\t//双目运算符\n\t函数类型 operator 运算符（参数）  \n\t{\n\t    // 参数个数 = 原操作数个数 - 1\n\t}\n\t//前置单目运算符，返回引用所以可以当左值\n\t函数类型 & operator ++（无参数）  \n\t{\n\t    return * this;\n\t}\n\t//后置单目运算符，\n\t函数类型 operator ++（参数为int类型）  \n\t{\n\t    old = *this;\n\t    ++(*this);  //调用的前置\n\t    return old;\n\t}\n\n\n-   重载为非成员函数：\n\n1.  列出所有操作数\n\n2.  至少有一个自定义类型参数\n\n3.  后置单目运算，参数要增加int,但不用写形参名\n\n4.  要操作某类对象的私有成员，则可声明为该类的友元函数\n\n### **虚函数：**virtual改造基类成员，实现动态绑定；必须是非静态成员\n\n>   原理：编译时先不确定和哪个类的成员对应，在程序运行时刻，再对应；\n\n\t#include <iostream>\n\tusing namespace std;\n\tclass Base1{\n\tpublic:\n\t    virtual void display() const; //虚函数，不要用内联\n\t};\n\n\tvoid Base1::display() const{\n\t    cout << \"Base1 \" << endl;\n\t}\n\t\n\tclass Base2:public Base1{\n\tpublic:\n\t    virtual void display() const;\n\t}\n\tvoid Base2::display() const{\n\t    cout << \"Base2\" << endl;\n\t}\n\n\n### **虚析构函数：**打算通过基类指针调用某一个对象的析构函数（执行delete）\n\n### **虚表和动态绑定：**\n\n>   虚表：\n\n-   每个多态类都有虚表；\n\n-   存放各个数函数的入口地址；\n\n-   每个对象有指向当前类的虚表的指针（虚指针vptr）；\n\n>   动态绑定：\n\n-   构造函数为对象的虚指针赋值\n\n### **抽象类：**含有纯虚函数的类,不能直接定义对象\n\n>   纯虚函数：\n\n>   基类中声明的虚函数，在基类中没有定义具体的操作，要求在派生类中根据实际需求完\n\n>   成自己的版本：\n\n\tvirtual 函数类型 函数名**(**参数名**) =** 0**;**\n\n### **override 和 final :**C++11\n\noverride声明的函数，必须在基类中找到原型；\n\nfinal 不允许继承或者覆盖；\n\n\n## **模板**\n\n### **函数魔板：**整数和浮点数求绝对值，需要多次重载函数，但是用函数模板，只需要设计通用功能；\n\ntemplate\\<模板参数表\\> // 类型：class或者typename 常量：\n\n函数定义\n\n\ttemplate<typename T>\n\tT abs(T x){\n\t    return x<0?-x:x;\n\t}\n\n\n### **类模板：**\n\n\ttemplate<模板参数表>\n\tclass 类名{\n\t    类成员声明;\n\t}\n\n\t//类成员定义\n\ttemplate <模板参数表>\n\t类型名  类名<模板参数标识符列表> :: 函数名(参数表)\n\t{\n\n\t}\n\n\n### **线性群体：**按位置顺序有序排列\n\n直接访问：\n\n数组类模板：\n\n索引访问：\n\n顺序访问：\n\n链表类和结点类模板：\n\n单链表：每个结点包括数据和指针，只有一个指向后续结点的称为单链表；\n\n![](media/9167a427f849e864c5d630d0c0bc3163.png)\n\n单链表结点类模板：\n\n\ttemplate <class T>\n\tclass Node{\n\t\tprivate:\n\t    \tNode<T> *next;\n\t\tpublic:\n\t    \tT data; \n\t    \tNode(const T&item,Node<T>* next = 0);  //构造函数\n\t    void insertAfter(Node<T> *p); //插入\n\t    Node<T> *deleteAfter();  //删除\n\t    Node<T> *nextNode() const; \n\t}\n\t\n\ttemplate <class T>\n\tvoid Node<T>::insertAfter(Node<T> *p){  // *p是要插入的结点\n\t// p节点的指针指向当前节点的后续结点\n\t    p->next = next; // next是原链表待插入位置的结点的指针\n\t    next = p;  \n\t}\n\ttemplate <class T>\n\tNode<T> *deleteAfter(){\n\t    Node<T> * tempPtr = next;\n\t    if (next == NULL)  //判断是否是删除最后的元素\n\t        return 0;\n\t    next = tempPtr = next;\n\t    return tempPtr;\n\t}\n\n\n>   插入：\n\n![](media/85d072d9c8a8366378b00b9af8ca4920.png)\n\n>   头插法：可以当队列\n\n>   尾插法：栈\n\n>   删除：\n\n![](media/ffdd5c0226d2a3f9a7833379eb0ebf90.png)\n\n待查询：\n\nexplicit关键字\n\n构造函数 explicit可以抑制内置类型隐式转换\n\n\n## **泛型设计**\n\n基本概念：\n\n编写不依赖具体数据类型的程序，通用的；\n\nSTL简介：(Standard Template Library)\n\nC++ string类库入门：\n\n    #include <iostream>\n\n    #include <string>\n\n    using namespace std;\n\n    int main()\n    {\n\n        // 构造函数：\n\t    string str1 = \"Yesterday\";\n\t\n\t    string str2(\"Today\");\n\t\n\t    string str3(\"Hello\",2); //取c风格字符串 长度为 2 作为初值，即\"He\"\n\t\n\t    string str4(str1, 6); // 始于位置6开始的字符串，即\"day\"\n\t\n\t    string str5(str1,6,1); // 始于6，长度1，即\"d\"\n\t\n\t\tstring str6(1,'a'); //6个'a'\n\t\t\n\t\t// 赋值，交换\n\t\tstr1.assign(\"hahahaha\"); //重新赋值\n\t\t\n\t\tswap(str1,str2); //交换两个字符串内容 str1=\"Today\" str2=\"hahahaha\"\n\t\t\n\t\t// 追加\n\t\tstr1 += \" we\"; // += 可追加 string对象，字符串，字符\n\t\t\n\t\tstr1.append(\" ar\"); // append 可追加 string对象，字符串\n\t\t\n\t\tstr1.push_back('e'); //push_back 只能追加字符 str1 = \"Today we are\"\n\n\t\t// 插入\n\t\tstr1.insert(0,\" family\"); //str1 = \"Today we are family\"\n\t\t\n\t\t// 删除\n\t\tstr1.erase(2,1); //第2个位置开始， len = 1 个字符\n\n\t\tstr1.clear(); //删除全部\n\t\t\n\t\t// 访问字符串\n\t\tstring s = \"asdfgh\";\n\t\t\n\t\tcout << s[1]; // 's'\n\t\t\n\t\tcout << s.at(2); // 'd'\n\t\t\n\t\t// 查找\n\t\tint position = s.find('f',0); // 从0开始查找第一次出现‘f’的坐标\n\t\t\n\t\t// 替换\n\t\ts.replace(s.find('f'),3,\"ZZZ\"); //替换find的位置处\n\t\t3个字符串为 “ZZZ”\n\t\t\n\t\t// 分割\n\t\tgetchar();\n\t\t\n\t\treturn 0;\n\n\t}\n","source":"_posts/C-梳理笔记.md","raw":"---\ntitle: C++梳理笔记\ndate: 2019-01-20 20:30:39\ncategories: C++\ntags: C++\ncopyright: \npassword: 123456\ntop:\n---\n\n<font color=\"red\"><big>测试内容</big></font>\n\n\n~~删除线~~\n\n[链接](http://zhuzhuyule.xyz)\n\n![logo](图片测试！/test.jpg)\n\n# C++学习笔记\n\n## **类型转换：**\n\n1. 隐式转换： 低类型转换为高类型\n\n       浮点数（直接舍掉小数，不四舍五入） + 整数\n\n2. 显式转换：\n\n    \tint **(**z**) = (**int**)** z **= static_cast\\<**int**\\> (**z**)**\n\n。。。\n\n### **数据的输入和输出：信息的流动**\n\n 1. 输入：\n\n 2. 输出：\n\n 3. 流类库的操纵符：\n\n### **程序控制：**\n\n\t\tif, while, for, do-while , break, continue, { switch,case,default } ;\n1. do-while:\n\n\t    do 语句      // 先执行一次\n\t    while(表达式)；\n\n2. for的范围，遍历容器：\n\n\n### **自定义类型：**\n\n* 类型别名： \n\n\n  1. typedef double Area, V;\n\n  2. using Area = double\n\n\n\n\n* 枚举类型： 有限的个数\n\n　　　　不限定作用域： enum 类型名 { 变量值列表}\n\n　　　　限定作用域：\n\n　　　注：枚举元素是常量，不能赋值\n\n　　　　　枚举元素有默认值，默认0,1,2,3,4，声明时可以另外指定\n\n　　　　　可以进行关系运算\n\n* auto类型 和decltyoe类型\n\t\t\n\t\t    decltype( float( i )) j = 2;   // j值是2，类型是float;\n\t\t\n\t\t    auto m = 2.5;  // m 为float;\n\n* 结构体( C语言中的)： struct\n\n\t\t\tstruct MyTimeStruct{   //定义 结构体类型\n\t\t\t    unsigned int year,mouth,day,hour,min,sec;\n\t\t\t};\n\n\n\n## **函数： 可重用的功能模块（定义和调用）**\n\n### **函数定义：**\n\n　　形参不占用空间，调用时分配；\n\n### **函数调用：**\n\n　　调用前要函数声明： int sum**(** int a**,** int b**);**\n\n　　1. 函数的嵌套调用：\n\n　　2. 函数的递归调用： 直接或者间接调用自身\n\n计算n!\n\n\t\tunsigned int fac( unsigned int n){\n\t\t    if (n == 0) return 1;\n\t\t    return fac( n - 1) * n;\n\t\t}\n\n汉诺塔\n\n\t\t分析：\n\t\t1.\tA 上的n-1个盘子移动到B上（借助C）;\n\t\t2.\tA上剩下的盘子移动到C上；\n\t\t3.\tB上的n-1个盘子移动到C上（借助A）\n\t\tvoid move(char src, char obj)\n\t\t{\n\t\t    cout << src << \"--->>>\" << obj << endl;\n\t\t}\n\t\t\n\t\tvoid hanoi(int n, char src, char medium, char obj)\n\t\t{\n\t\t    if(n == 1)\n\t\t        move(src, obj);\n\t\t    else{\n\t\t        hanoi(n-1, src, obj, medium);\n\t\t        move(src, obj);\n\t\t        hanoi(n-1, medium, src, obj);\n\t\t    }\n\t\t}\n\n\n### **函数的参数：**\n\n1. 形参不占用空间，调用时分配；\n\n2. 计算结果返回多个（利用引用）\n\n3. 多个参数时，从后开始传\n\n### **引用类型（&）：** 必须初始化，该类型不可改变，是其他变量的别名\n\t\n\t\tint i, j;\n\t\tint & ri = i;  // 定义int引用类型变量 ri, 初始化为i的引用\n\n\n### **含有可变参数的函数：（两种方法）**\n\n1. 所有实参类型相同：`initializer_list<int> li; //类模板, 都是常量`\n\n2. 具体看第九章\n\n3. 类型不同：\n\n### **内联函数（inline）： **用函数体内的语句，替换函数调用表达式，编译时完成，类似 #define\n\n声明： `inline int calArea(int a){  }`\n\n要求： 1. 不能有循环，switch语句 2. 定义在调用之前 3. 不能有异常接口声明\n\n###  constexpr 函数：（常量表达式函数）\n\n\n### **带默认参数的函数：**\n\n\t\tint getVa(int length, int weight = 2)\n\n### **函数的重载：**（C++多态性的重要机制，编译过程中实现）\n\n函数体同名，参数类型不同/参数个数不同\n\n\t\tint add(int x, int y);\n\n\t\tfloat add(float x, float y);\n\n\t\tfloat add(float x, float y, float z);\n\n\n### **C++系统函数：**\n\n\t\t#include <cmath>\n\t\t\t|_\n\t\t\t|_\n\t\t#include <cstdlib>\n\t\t\t|_\n\t\t\t|_\n\t\t#include <cstdio>\n\t\t\t|_\n\t\t\t|_\n\t\t#include <ctime>\n\t\t\t|_\n\t\t\t|_\n\n\n\n## **类和对象**\n\n类：构建对象的蓝图，\n\n对象：由类创建，含有数据和方法\n\n封装：对数据和操作数据的方法的组合绑定\n\n继承：在已有类基础上，形成新的类\n\n多态：\n\n构造函数：定义对象时，通过构造函数初始化\n\n析构函数：删除对象时，通过析构函数释放资源\n\n### ** 类和对象的定义：**\n\n定义类：\n\n\t\tclass {  //类名称 \n\t\t    public:\n\t\t        // 公有成员,外部接口\n\t\t    private:\n\t\t        // 私有成员\n\t\t    protected:\n\t\t        int hour = 0; // 类内初始化\n\t\t        // 保护型成员\n\t\t}\n\n\n注意：不指定类型，默认为私有；\n\n### **成员函数：**\n\t\t\n\t\t|_ 内联成员函数： 类内声明或者inline关键字\n\n\t\t|_类外实现：void 类名称::成员函数名称（）{ }\n\n### **构造函数：**\n\n-  在创建对象时，自动调用来初始化数据\n\n-  与类名相同\n\n-  构造函数有初始化列表\n\n-  格式 类名（string s, lei i）：s(初始值)，i(初始值){ }；\n\n### **委托构造函数：**一个构造函数 通过另一个构造函数 初始化\n\n### **复制构造函数：**\n\n用途：\n\n-   用存在的对象 去初始化新对象 （通过引用旧的对象）\n\n-   函数f的形参是类的对象，调用f时，将用实参对象初始化形参对象\n\n-   函数g的返回值是类的对象，用return的对象来在主调函数中初始化一个无名对象\n\n### **析构函数：**生存期结束，删除清理工作，不能有return，不能有参数\n\n\t    class 类名{\n\n\t    public:\n\t        类名（形参）； // 构造函数\n\t        类名（const 类名& 旧对象名）；  // 复制构造函数 =delete是不生成\n\t\t\t~ 类名（）；\n\t    }\n\n\n>   注：未声明时，编译器自己生成一个默认的\n\n### **前向引用声明：**两个类相互引用时，某个类在引用之前就声明\n\n\t    class A;  //前向引用声明，只是一个标识符，不是万能的\n\t    class B{\n\t    public:\n\t        void A(B b);\n\t    }\n\n\t    class A{\n\t    public：\n\t        void B（A a）;\n\t    }\n\n\n### **结构体：**特殊的类，默认是公有的，可以有函数成员\n\n\t    //公有成员\n\t        int a;\n\t    protected:\n\t        int b;\n\t    private:\n\t        int c;\n\t    };\n\n\n### **联合体：**\n\n目的：存储空间的共用，成员不能同时有效，比如某人语文课成绩，只有一种可能；\n\t\t\n\t\tunion Mark{ // 成绩的联合体， 只有一个成立\n\t\t    char grade;  //等级类的成绩\n\t\t    bool pass;  // 是否通过的成绩\n\t\tint percent;  //百分制成绩  }\n\n### **枚举类：**\n\nenum class 枚举类型名： 底层类型（int）**{** 枚举列表 **};**\n\n    //默认 int\n\n优势：\n\n-   强制作用域 --必须在枚举类 枚举类型名：：枚举值，不同枚举类可以有同名值了\n\n-   转换限制 --枚举对象不能与整型 隐式转换\n\n-   底层类型 --可以指定\n\n\n## **数据共享和保护：**\n\n### **作用域分类：**\n\n函数原型作用域：\n\n- 形参的范围在（）内，所以不需要名字也行，int area( int );\n\n局部作用域\n\n- 函数{ }内\n\n- if、for、while { }内\n\n类作用域： 类外访问类的成员\n\n- 静态成员：通过 对象名.成员名 访问\n\n- 非静态成员：\n\n- 文件作用域\n\n- 命名空间作用域： 10章\n\n### **对象的生存期：**\n\n静态生存期： 整个程序结束后消失\n\n- 函数内的静态对象， 用static ，全局寿命，只局部可见\n\n动态生存期：\n\n- 离开作用域后消失\n\n- 下次进函数重新生成对象\n\n### **类的静态数据成员：**\n\n- static 声明\n\n- 为该类所有对象共享，具有静态生存期\n\n- 必须在类外定义和初始化，类内声明，用：：指明所属于的类\n\n比如记录 类产生了多少对象；opencv中的Mat对象好像用到了？？？？\n\n\t\tclass base{   \n\t\t    public :   \n\t\t           static   int   _num;//声明   \n\t\t};   \n\t\tint  base::_num=0;  //真正定义  \n\n\n### **类的友元：**\n\n- 破坏数据封装和数据隐藏的机制\n\n- 尽量不用\n\n### ** 友元函数：**\n\n- 类声明中由关键字 friend 修饰说明的非成员函数\n\n- 可以在其函数体内访问对象的private,protected成员\n\n- 但必须通过对象名：：访问，函数参数为类的引用\n-   \n### ** 友元类：**\n\n\t\tclass A{\n\t\t    friend B;\n\t\t  public:\n\t\t    void display(){\n\t\t        count << x << enld;\n\t\t    }\n\t\t  private:\n\t\t    int x;\n\t\t}\n\t\t\n\t\tclass B{\n\t\t  public:\n\t\t    void set(int i);\n\t\t    void display();\n\t\t  private:\n\t\t    A a;\n\t\t}\n\t\t\n\t\tvoid B::set(int i){\n\t\t    a.x = i;   // B类中改变 A类私有值\n\t\t}\n\t\tvoid B::display(){\n\t\t    a.display()\n\t\t}\n\n\n### **共享数据的保护：**\n\n#**常类型：**const\n\n常对象：必须初始化，不可更新\n\n\t\tclass A{\n\t\t}\n\t\tA const a; // a是常对象\n\n\n常成员：(不可以放在构造函数体内复制，可以在初始化列表中)\n\n\t\tA：：A(int i):a(i){ }\n\n- 常数据成员：const修饰的\n\n- 静态常数据成员： static const int b;\n\n- 常函数成员（用来处理常对象的函数）\n\n    - 不更新对象的数据成员\n\n    - 声明和实现都带const\n\n\n\t\t\tclass A{\n\t\t\t    void f（int a）const;\n\t\t\t}\n\t\t\tvoid A::f(int a) const{  \n\t\t\t}; // f是常对象函数, 处理常对象\n\n\n- 常引用：不可更新\n\n　　　引用是双向传递的，避免修改原值的方法就是常引用；\n\n         const A& a;\n\n- 常数组：\n\n- 常指针：\n\n### **多文件结构和预编译命令：**\n\n- .h 系统使用\n\n- .hpp 个人使用(类的声明,函数的声明)\n\n- .cpp (类的实现，函数的实现)\n\n   ![](media/f5d645ed218d5fa3e753f771b72310fc.png)\n\n### **外部变量：**\n\n文件作用域中定义的变量默认是外部变量，其他文件使用前，extern声明\n\n将变量和函数限制在编译单元内：namespcae:\n\n\t\tnamespace{ //匿名的命名空间，外部不可调用任何东西\n\t\t    int i;\n\t\t    void fun(){\n\t\t        i++;\n\t\t    }\n\t\t}\n\n\n### **预编译命令：**\n\n\t\t#include< >  标准方式搜索，从系统目录include\n\n\n\t\t#include”” 先当前目录搜索，没有再标准搜索\n\n\n\t\t#define \n\n\n\t\t#undef 删除有#define的宏\n\n\t\t#if 表达式  // 条件编译指令\n\t\t---\n\t\t#else\n\t\t---\n\t\t#endif \n\n\n\t\t#ifndef 标识符\n\t\t---\n\t\t#else  \n\t\t---\n\t\t#endif\n\n\n\n## **数组，指针与字符串：**\n\n### **数组：**\n\n定义： `int arr**[**m**][**n**]**…;`\n\n　　注：二维数组中 arr[1] 第二行首地址\n\n### **数组作为函数参数：**\n\n　　数组名做参数： 形参，实参都是数组名，传入的是地址\n\n### **对象数组：**\n\n　　定义：类名 数组名[对象元素个数]\n\n　　访问：数组名[下标].成员名\n\n### **基于范围的for循环：**c++11,自动遍历整个容器\n\n\t  for( auto x : 容器){ } for( auto &x : 容器){ }\n\n注意：\n\n- auto &x是元素引用，auto x是元素的副本\n\n- auto推导出的类型是容器中的值类型\n\n- ：冒号后的表达式只执行一次\n\n### **指针：**\n\n### **定义：**\n\n\t\tstatic int i;\n\t\t\n\t\tstatic int * p = &I;\n\n### **指针的初始化和赋值：**\n\n### **指针的算术运算，关系运算：**\n\n### **指针数组：**\n\n        类名  *p[2];\n\n### **指向数组的指针：**\n\n        int **p; 指向二维数组的指针\n\n### **指针与函数：**\n\n- 指针做参数：大批量数据提高效率\n\n- 指针类型的函数：返回类型是指针\n\n\t\tint * function(int i){return 全局或者静态的 }；// 不能返回非静态局部变量\n\n-  指向函数的指针：实现函数回调的功能\n\n>   定义： 数据类型 (\\*f)(参数表);\n\n>   数据类型：返回值\n\n-   对象指针：\n\n>   定义： 类名 \\*对象指针名 = & 对象；\n\n>   访问对象： 对象指针名-\\>成员名\n\n（\\*对象指针名）.成员名\n\n- this 指针：成员函数的一个隐士参数，初始化为对象的地址，不可改变\n\n- 隐含于类的每个非静态成员函数中\n\n- 指出成员函数所操作的当前的对象\n\n- \\*this 是当前对象地址\n\n### **动态内存分配：**\n\nnew** 类型名 **(**初始化列表**) // 返回首字节地址\n\ndelete 指针p //p一直在，删除的只是p指向的对象申请的空间\n\n动态数组：\nnew 类型名[数组长度]\n\ndelete[] 数组首地址p指针\n\n### **智能指针：**C++11\n\n### **内存管理**\n\n-   unique_ptr:\n\n    -   不允许多个指针共享资源，标准库中move可以转移指针，但原来指针会失效\n\n-   shared_ptr:\n\n    -   多指针共享\n\n-   weak_ptr:\n\n    -   可复制共享\n\n>   Vector对象：类模板\n\n优势：\n\n-   封装任何形式的动态数组，自动创建，删除\n\n-   下标越界检查\n\n定义： vector <元素类型> object（长度）\n\n- `object.begin()  object.end()  object.size()`\n\n- auto 遍历vector `for(auto e: object);`\n\n### **对象的复制和移动：**\n\n-   浅层复制和深层复制：复制对象用到复制构造函数，默认的复制构造只传递了指针，两个变量指向同一块内存，释放其中一个，再释放第二个会出错；\n\n    -   浅层：实现对象间数据一一对应的复制，但两个对象指向同一内存\n\n    -   深层：当对象成员是指针类型，应该对指针所指对象进行复制。\n\n>   类名**::**类名**(**const 类名**&** v**){**\n\n>   size **=** v**.**size**;**\n\n>   data_ptr **= new** Ponit**[**size**];**\n\n>   **for(**int i**=**0**;** i **\\<** size**; ++**i**){**\n\n>   data_ptr**[**i**] =** v**.**data_ptr**[**i**];**\n\n>   **}**\n\n>   **}**\n\n-   移动构造：C++11,省去了构造和删除临时对象的过程\n\n    ![](media/8c3092d99bcdba78edeb2d8123270ffe.png)\n\n>   class_name**(**class_name **&&**old**)::**xptr**(**old**.**xptr**){**\n\n>   n**.**xptr **= NULL;** // 原来的指针清空\n\n>   **}**\n\n### **C风格字符串：**字符数组\n\n### **string类：**\n\n常用构造函数：\n\n-   string(); //默认构造，长度为0\n\n    -   string s1**;**\n\n-   string(const char \\*s) //指针s所指向的字符串常量初始化该对象\n\t\n\t\tstring s2 = “abc”;\n\t\t\n\t\tstring(const string &rhs) //复制构造函数\n\t\t\n\t\tstring s3 = s2;\n\n访问：下标访问\n\n整行字符串的输入： cin 被空格隔开\n\ngetline(cin,s2); //包含\\#include\\<string\\>\n\ngetline(cin,s2,’,’);\n\n\n## **继承和派生：** 充分利用原有的\n\n继承：保持已有类的特征来构造新类\n\n派生：在已有类基础上新增自己的特性\n\n基类：父类\n\n派生类：子类\n\n直接基类和间接基类\n\n单继承：\n\n\tclass 派生类名：继承方式 基类名{  //继承方式，\n\t    成员声明；//新增成员的声明\n\t}\n\n\n多继承：\n\n\tclass 派生类名：继承方式1 基类1，继承方式2 基类2{\n    \t成员声明；\n\t}\n\n\n### **继承的方式：**\n\n控制：派生类对基类成员的访问权限\n\n-   公有继承 public\n\n>   基类中的pubilc和protected访问属性在派生类中不变\n\n>   基类的pravate不可被对象直接访问\n\n-   私有继承 ：内部可以访问基类的公有和保护成员，但是其对象不再可以访问\n\n-   保护继承 ：基类的公有和保护，到这都成了保护成员，类内可以访问，但对象不能\n\n派生类的构成：\n\n-   吸收基类成员\n\n-   改造基类成员\n\n    -   增加同名成员，基类成员被覆盖（重新定义继承的成员函数必须用虚函数）\n\n-   添加新成员\n\n### **类型转换：**\n\n基类和派生类之间：\n  \n派生类的对象可以隐含转换为基类对象；\n\n派生类的对象可以初始化基类的引用；\n\n派生类的指针可以隐含转换为基类的指针；\n\n### **派生类的构造函数：**\n\n默认情况下，基类的构造函数不被继承，派生类需要自己构造\n\nc++11，using语句继承基类构造函数\n\n### **派生类的复制构造函数：**\n\n### **派生类的析构函数：**\n\n### **虚基类：**\n\n## **多态性**\n\n### **运算符重载：**\n\n\t//双目运算符\n\t函数类型 operator 运算符（参数）  \n\t{\n\t    // 参数个数 = 原操作数个数 - 1\n\t}\n\t//前置单目运算符，返回引用所以可以当左值\n\t函数类型 & operator ++（无参数）  \n\t{\n\t    return * this;\n\t}\n\t//后置单目运算符，\n\t函数类型 operator ++（参数为int类型）  \n\t{\n\t    old = *this;\n\t    ++(*this);  //调用的前置\n\t    return old;\n\t}\n\n\n-   重载为非成员函数：\n\n1.  列出所有操作数\n\n2.  至少有一个自定义类型参数\n\n3.  后置单目运算，参数要增加int,但不用写形参名\n\n4.  要操作某类对象的私有成员，则可声明为该类的友元函数\n\n### **虚函数：**virtual改造基类成员，实现动态绑定；必须是非静态成员\n\n>   原理：编译时先不确定和哪个类的成员对应，在程序运行时刻，再对应；\n\n\t#include <iostream>\n\tusing namespace std;\n\tclass Base1{\n\tpublic:\n\t    virtual void display() const; //虚函数，不要用内联\n\t};\n\n\tvoid Base1::display() const{\n\t    cout << \"Base1 \" << endl;\n\t}\n\t\n\tclass Base2:public Base1{\n\tpublic:\n\t    virtual void display() const;\n\t}\n\tvoid Base2::display() const{\n\t    cout << \"Base2\" << endl;\n\t}\n\n\n### **虚析构函数：**打算通过基类指针调用某一个对象的析构函数（执行delete）\n\n### **虚表和动态绑定：**\n\n>   虚表：\n\n-   每个多态类都有虚表；\n\n-   存放各个数函数的入口地址；\n\n-   每个对象有指向当前类的虚表的指针（虚指针vptr）；\n\n>   动态绑定：\n\n-   构造函数为对象的虚指针赋值\n\n### **抽象类：**含有纯虚函数的类,不能直接定义对象\n\n>   纯虚函数：\n\n>   基类中声明的虚函数，在基类中没有定义具体的操作，要求在派生类中根据实际需求完\n\n>   成自己的版本：\n\n\tvirtual 函数类型 函数名**(**参数名**) =** 0**;**\n\n### **override 和 final :**C++11\n\noverride声明的函数，必须在基类中找到原型；\n\nfinal 不允许继承或者覆盖；\n\n\n## **模板**\n\n### **函数魔板：**整数和浮点数求绝对值，需要多次重载函数，但是用函数模板，只需要设计通用功能；\n\ntemplate\\<模板参数表\\> // 类型：class或者typename 常量：\n\n函数定义\n\n\ttemplate<typename T>\n\tT abs(T x){\n\t    return x<0?-x:x;\n\t}\n\n\n### **类模板：**\n\n\ttemplate<模板参数表>\n\tclass 类名{\n\t    类成员声明;\n\t}\n\n\t//类成员定义\n\ttemplate <模板参数表>\n\t类型名  类名<模板参数标识符列表> :: 函数名(参数表)\n\t{\n\n\t}\n\n\n### **线性群体：**按位置顺序有序排列\n\n直接访问：\n\n数组类模板：\n\n索引访问：\n\n顺序访问：\n\n链表类和结点类模板：\n\n单链表：每个结点包括数据和指针，只有一个指向后续结点的称为单链表；\n\n![](media/9167a427f849e864c5d630d0c0bc3163.png)\n\n单链表结点类模板：\n\n\ttemplate <class T>\n\tclass Node{\n\t\tprivate:\n\t    \tNode<T> *next;\n\t\tpublic:\n\t    \tT data; \n\t    \tNode(const T&item,Node<T>* next = 0);  //构造函数\n\t    void insertAfter(Node<T> *p); //插入\n\t    Node<T> *deleteAfter();  //删除\n\t    Node<T> *nextNode() const; \n\t}\n\t\n\ttemplate <class T>\n\tvoid Node<T>::insertAfter(Node<T> *p){  // *p是要插入的结点\n\t// p节点的指针指向当前节点的后续结点\n\t    p->next = next; // next是原链表待插入位置的结点的指针\n\t    next = p;  \n\t}\n\ttemplate <class T>\n\tNode<T> *deleteAfter(){\n\t    Node<T> * tempPtr = next;\n\t    if (next == NULL)  //判断是否是删除最后的元素\n\t        return 0;\n\t    next = tempPtr = next;\n\t    return tempPtr;\n\t}\n\n\n>   插入：\n\n![](media/85d072d9c8a8366378b00b9af8ca4920.png)\n\n>   头插法：可以当队列\n\n>   尾插法：栈\n\n>   删除：\n\n![](media/ffdd5c0226d2a3f9a7833379eb0ebf90.png)\n\n待查询：\n\nexplicit关键字\n\n构造函数 explicit可以抑制内置类型隐式转换\n\n\n## **泛型设计**\n\n基本概念：\n\n编写不依赖具体数据类型的程序，通用的；\n\nSTL简介：(Standard Template Library)\n\nC++ string类库入门：\n\n    #include <iostream>\n\n    #include <string>\n\n    using namespace std;\n\n    int main()\n    {\n\n        // 构造函数：\n\t    string str1 = \"Yesterday\";\n\t\n\t    string str2(\"Today\");\n\t\n\t    string str3(\"Hello\",2); //取c风格字符串 长度为 2 作为初值，即\"He\"\n\t\n\t    string str4(str1, 6); // 始于位置6开始的字符串，即\"day\"\n\t\n\t    string str5(str1,6,1); // 始于6，长度1，即\"d\"\n\t\n\t\tstring str6(1,'a'); //6个'a'\n\t\t\n\t\t// 赋值，交换\n\t\tstr1.assign(\"hahahaha\"); //重新赋值\n\t\t\n\t\tswap(str1,str2); //交换两个字符串内容 str1=\"Today\" str2=\"hahahaha\"\n\t\t\n\t\t// 追加\n\t\tstr1 += \" we\"; // += 可追加 string对象，字符串，字符\n\t\t\n\t\tstr1.append(\" ar\"); // append 可追加 string对象，字符串\n\t\t\n\t\tstr1.push_back('e'); //push_back 只能追加字符 str1 = \"Today we are\"\n\n\t\t// 插入\n\t\tstr1.insert(0,\" family\"); //str1 = \"Today we are family\"\n\t\t\n\t\t// 删除\n\t\tstr1.erase(2,1); //第2个位置开始， len = 1 个字符\n\n\t\tstr1.clear(); //删除全部\n\t\t\n\t\t// 访问字符串\n\t\tstring s = \"asdfgh\";\n\t\t\n\t\tcout << s[1]; // 's'\n\t\t\n\t\tcout << s.at(2); // 'd'\n\t\t\n\t\t// 查找\n\t\tint position = s.find('f',0); // 从0开始查找第一次出现‘f’的坐标\n\t\t\n\t\t// 替换\n\t\ts.replace(s.find('f'),3,\"ZZZ\"); //替换find的位置处\n\t\t3个字符串为 “ZZZ”\n\t\t\n\t\t// 分割\n\t\tgetchar();\n\t\t\n\t\treturn 0;\n\n\t}\n","slug":"C-梳理笔记","published":1,"updated":"2020-02-20T04:41:37.800Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephb30002t8pl9ih83xod","content":"<font color=\"red\"><big>测试内容</big></font>\n\n\n<p><del>删除线</del></p>\n<p><a href=\"http://zhuzhuyule.xyz\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<p><img src=\"/2019/01/20/C-梳理笔记/test.jpg\" alt=\"logo\"></p>\n<h1 id=\"C-学习笔记\"><a href=\"#C-学习笔记\" class=\"headerlink\" title=\"C++学习笔记\"></a>C++学习笔记</h1><h2 id=\"类型转换：\"><a href=\"#类型转换：\" class=\"headerlink\" title=\"类型转换：\"></a><strong>类型转换：</strong></h2><ol>\n<li><p>隐式转换： 低类型转换为高类型</p>\n<pre><code>浮点数（直接舍掉小数，不四舍五入） + 整数\n</code></pre></li>\n<li><p>显式转换：</p>\n<pre><code> int **(**z**) = (**int**)** z **= static_cast\\&lt;**int**\\&gt; (**z**)**\n</code></pre></li>\n</ol>\n<p>。。。</p>\n<h3 id=\"数据的输入和输出：信息的流动\"><a href=\"#数据的输入和输出：信息的流动\" class=\"headerlink\" title=\"数据的输入和输出：信息的流动\"></a><strong>数据的输入和输出：信息的流动</strong></h3><ol>\n<li><p>输入：</p>\n</li>\n<li><p>输出：</p>\n</li>\n<li><p>流类库的操纵符：</p>\n</li>\n</ol>\n<h3 id=\"程序控制：\"><a href=\"#程序控制：\" class=\"headerlink\" title=\"程序控制：\"></a><strong>程序控制：</strong></h3><pre><code>    if, while, for, do-while , break, continue, { switch,case,default } ;\n</code></pre><ol>\n<li><p>do-while:</p>\n<pre><code> do 语句      // 先执行一次\n while(表达式)；\n</code></pre></li>\n<li><p>for的范围，遍历容器：</p>\n</li>\n</ol>\n<h3 id=\"自定义类型：\"><a href=\"#自定义类型：\" class=\"headerlink\" title=\"自定义类型：\"></a><strong>自定义类型：</strong></h3><ul>\n<li>类型别名： </li>\n</ul>\n<ol>\n<li><p>typedef double Area, V;</p>\n</li>\n<li><p>using Area = double</p>\n</li>\n</ol>\n<ul>\n<li>枚举类型： 有限的个数</li>\n</ul>\n<p>　　　　不限定作用域： enum 类型名 { 变量值列表}</p>\n<p>　　　　限定作用域：</p>\n<p>　　　注：枚举元素是常量，不能赋值</p>\n<p>　　　　　枚举元素有默认值，默认0,1,2,3,4，声明时可以另外指定</p>\n<p>　　　　　可以进行关系运算</p>\n<ul>\n<li><p>auto类型 和decltyoe类型</p>\n<pre><code>      decltype( float( i )) j = 2;   // j值是2，类型是float;\n\n      auto m = 2.5;  // m 为float;\n</code></pre></li>\n<li><p>结构体( C语言中的)： struct</p>\n<pre><code>      struct MyTimeStruct{   //定义 结构体类型\n          unsigned int year,mouth,day,hour,min,sec;\n      };\n</code></pre></li>\n</ul>\n<h2 id=\"函数：-可重用的功能模块（定义和调用）\"><a href=\"#函数：-可重用的功能模块（定义和调用）\" class=\"headerlink\" title=\"函数： 可重用的功能模块（定义和调用）\"></a><strong>函数： 可重用的功能模块（定义和调用）</strong></h2><h3 id=\"函数定义：\"><a href=\"#函数定义：\" class=\"headerlink\" title=\"函数定义：\"></a><strong>函数定义：</strong></h3><p>　　形参不占用空间，调用时分配；</p>\n<h3 id=\"函数调用：\"><a href=\"#函数调用：\" class=\"headerlink\" title=\"函数调用：\"></a><strong>函数调用：</strong></h3><p>　　调用前要函数声明： int sum<strong>(</strong> int a<strong>,</strong> int b<strong>);</strong></p>\n<p>　　1. 函数的嵌套调用：</p>\n<p>　　2. 函数的递归调用： 直接或者间接调用自身</p>\n<p>计算n!</p>\n<pre><code>    unsigned int fac( unsigned int n){\n        if (n == 0) return 1;\n        return fac( n - 1) * n;\n    }\n</code></pre><p>汉诺塔</p>\n<pre><code>    分析：\n    1.    A 上的n-1个盘子移动到B上（借助C）;\n    2.    A上剩下的盘子移动到C上；\n    3.    B上的n-1个盘子移动到C上（借助A）\n    void move(char src, char obj)\n    {\n        cout &lt;&lt; src &lt;&lt; &quot;---&gt;&gt;&gt;&quot; &lt;&lt; obj &lt;&lt; endl;\n    }\n\n    void hanoi(int n, char src, char medium, char obj)\n    {\n        if(n == 1)\n            move(src, obj);\n        else{\n            hanoi(n-1, src, obj, medium);\n            move(src, obj);\n            hanoi(n-1, medium, src, obj);\n        }\n    }\n</code></pre><h3 id=\"函数的参数：\"><a href=\"#函数的参数：\" class=\"headerlink\" title=\"函数的参数：\"></a><strong>函数的参数：</strong></h3><ol>\n<li><p>形参不占用空间，调用时分配；</p>\n</li>\n<li><p>计算结果返回多个（利用引用）</p>\n</li>\n<li><p>多个参数时，从后开始传</p>\n</li>\n</ol>\n<h3 id=\"引用类型（-amp-）：-必须初始化，该类型不可改变，是其他变量的别名\"><a href=\"#引用类型（-amp-）：-必须初始化，该类型不可改变，是其他变量的别名\" class=\"headerlink\" title=\"引用类型（&amp;）： 必须初始化，该类型不可改变，是其他变量的别名\"></a><strong>引用类型（&amp;）：</strong> 必须初始化，该类型不可改变，是其他变量的别名</h3><pre><code>    int i, j;\n    int &amp; ri = i;  // 定义int引用类型变量 ri, 初始化为i的引用\n</code></pre><h3 id=\"含有可变参数的函数：（两种方法）\"><a href=\"#含有可变参数的函数：（两种方法）\" class=\"headerlink\" title=\"含有可变参数的函数：（两种方法）\"></a><strong>含有可变参数的函数：（两种方法）</strong></h3><ol>\n<li><p>所有实参类型相同：<code>initializer_list&lt;int&gt; li; //类模板, 都是常量</code></p>\n</li>\n<li><p>具体看第九章</p>\n</li>\n<li><p>类型不同：</p>\n</li>\n</ol>\n<h3 id=\"内联函数（inline）：-用函数体内的语句，替换函数调用表达式，编译时完成，类似-define\"><a href=\"#内联函数（inline）：-用函数体内的语句，替换函数调用表达式，编译时完成，类似-define\" class=\"headerlink\" title=\"内联函数（inline）： 用函数体内的语句，替换函数调用表达式，编译时完成，类似 #define\"></a><strong>内联函数（inline）： </strong>用函数体内的语句，替换函数调用表达式，编译时完成，类似 #define</h3><p>声明： <code>inline int calArea(int a){  }</code></p>\n<p>要求： 1. 不能有循环，switch语句 2. 定义在调用之前 3. 不能有异常接口声明</p>\n<h3 id=\"constexpr-函数：（常量表达式函数）\"><a href=\"#constexpr-函数：（常量表达式函数）\" class=\"headerlink\" title=\"constexpr 函数：（常量表达式函数）\"></a>constexpr 函数：（常量表达式函数）</h3><h3 id=\"带默认参数的函数：\"><a href=\"#带默认参数的函数：\" class=\"headerlink\" title=\"带默认参数的函数：\"></a><strong>带默认参数的函数：</strong></h3><pre><code>    int getVa(int length, int weight = 2)\n</code></pre><h3 id=\"函数的重载：（C-多态性的重要机制，编译过程中实现）\"><a href=\"#函数的重载：（C-多态性的重要机制，编译过程中实现）\" class=\"headerlink\" title=\"函数的重载：（C++多态性的重要机制，编译过程中实现）\"></a><strong>函数的重载：</strong>（C++多态性的重要机制，编译过程中实现）</h3><p>函数体同名，参数类型不同/参数个数不同</p>\n<pre><code>    int add(int x, int y);\n\n    float add(float x, float y);\n\n    float add(float x, float y, float z);\n</code></pre><h3 id=\"C-系统函数：\"><a href=\"#C-系统函数：\" class=\"headerlink\" title=\"C++系统函数：\"></a><strong>C++系统函数：</strong></h3><pre><code>    #include &lt;cmath&gt;\n        |_\n        |_\n    #include &lt;cstdlib&gt;\n        |_\n        |_\n    #include &lt;cstdio&gt;\n        |_\n        |_\n    #include &lt;ctime&gt;\n        |_\n        |_\n</code></pre><h2 id=\"类和对象\"><a href=\"#类和对象\" class=\"headerlink\" title=\"类和对象\"></a><strong>类和对象</strong></h2><p>类：构建对象的蓝图，</p>\n<p>对象：由类创建，含有数据和方法</p>\n<p>封装：对数据和操作数据的方法的组合绑定</p>\n<p>继承：在已有类基础上，形成新的类</p>\n<p>多态：</p>\n<p>构造函数：定义对象时，通过构造函数初始化</p>\n<p>析构函数：删除对象时，通过析构函数释放资源</p>\n<h3 id=\"类和对象的定义：\"><a href=\"#类和对象的定义：\" class=\"headerlink\" title=\" 类和对象的定义：\"></a><strong> 类和对象的定义：</strong></h3><p>定义类：</p>\n<pre><code>    class {  //类名称 \n        public:\n            // 公有成员,外部接口\n        private:\n            // 私有成员\n        protected:\n            int hour = 0; // 类内初始化\n            // 保护型成员\n    }\n</code></pre><p>注意：不指定类型，默认为私有；</p>\n<h3 id=\"成员函数：\"><a href=\"#成员函数：\" class=\"headerlink\" title=\"成员函数：\"></a><strong>成员函数：</strong></h3><pre><code>    |_ 内联成员函数： 类内声明或者inline关键字\n\n    |_类外实现：void 类名称::成员函数名称（）{ }\n</code></pre><h3 id=\"构造函数：\"><a href=\"#构造函数：\" class=\"headerlink\" title=\"构造函数：\"></a><strong>构造函数：</strong></h3><ul>\n<li><p>在创建对象时，自动调用来初始化数据</p>\n</li>\n<li><p>与类名相同</p>\n</li>\n<li><p>构造函数有初始化列表</p>\n</li>\n<li><p>格式 类名（string s, lei i）：s(初始值)，i(初始值){ }；</p>\n</li>\n</ul>\n<h3 id=\"委托构造函数：一个构造函数-通过另一个构造函数-初始化\"><a href=\"#委托构造函数：一个构造函数-通过另一个构造函数-初始化\" class=\"headerlink\" title=\"委托构造函数：一个构造函数 通过另一个构造函数 初始化\"></a><strong>委托构造函数：</strong>一个构造函数 通过另一个构造函数 初始化</h3><h3 id=\"复制构造函数：\"><a href=\"#复制构造函数：\" class=\"headerlink\" title=\"复制构造函数：\"></a><strong>复制构造函数：</strong></h3><p>用途：</p>\n<ul>\n<li><p>用存在的对象 去初始化新对象 （通过引用旧的对象）</p>\n</li>\n<li><p>函数f的形参是类的对象，调用f时，将用实参对象初始化形参对象</p>\n</li>\n<li><p>函数g的返回值是类的对象，用return的对象来在主调函数中初始化一个无名对象</p>\n</li>\n</ul>\n<h3 id=\"析构函数：生存期结束，删除清理工作，不能有return，不能有参数\"><a href=\"#析构函数：生存期结束，删除清理工作，不能有return，不能有参数\" class=\"headerlink\" title=\"析构函数：生存期结束，删除清理工作，不能有return，不能有参数\"></a><strong>析构函数：</strong>生存期结束，删除清理工作，不能有return，不能有参数</h3><pre><code>    class 类名{\n\n    public:\n        类名（形参）； // 构造函数\n        类名（const 类名&amp; 旧对象名）；  // 复制构造函数 =delete是不生成\n        ~ 类名（）；\n    }\n</code></pre><blockquote>\n<p>  注：未声明时，编译器自己生成一个默认的</p>\n</blockquote>\n<h3 id=\"前向引用声明：两个类相互引用时，某个类在引用之前就声明\"><a href=\"#前向引用声明：两个类相互引用时，某个类在引用之前就声明\" class=\"headerlink\" title=\"前向引用声明：两个类相互引用时，某个类在引用之前就声明\"></a><strong>前向引用声明：</strong>两个类相互引用时，某个类在引用之前就声明</h3><pre><code>    class A;  //前向引用声明，只是一个标识符，不是万能的\n    class B{\n    public:\n        void A(B b);\n    }\n\n    class A{\n    public：\n        void B（A a）;\n    }\n</code></pre><h3 id=\"结构体：特殊的类，默认是公有的，可以有函数成员\"><a href=\"#结构体：特殊的类，默认是公有的，可以有函数成员\" class=\"headerlink\" title=\"结构体：特殊的类，默认是公有的，可以有函数成员\"></a><strong>结构体：</strong>特殊的类，默认是公有的，可以有函数成员</h3><pre><code>    //公有成员\n        int a;\n    protected:\n        int b;\n    private:\n        int c;\n    };\n</code></pre><h3 id=\"联合体：\"><a href=\"#联合体：\" class=\"headerlink\" title=\"联合体：\"></a><strong>联合体：</strong></h3><p>目的：存储空间的共用，成员不能同时有效，比如某人语文课成绩，只有一种可能；</p>\n<pre><code>    union Mark{ // 成绩的联合体， 只有一个成立\n        char grade;  //等级类的成绩\n        bool pass;  // 是否通过的成绩\n    int percent;  //百分制成绩  }\n</code></pre><h3 id=\"枚举类：\"><a href=\"#枚举类：\" class=\"headerlink\" title=\"枚举类：\"></a><strong>枚举类：</strong></h3><p>enum class 枚举类型名： 底层类型（int）<strong>{</strong> 枚举列表 <strong>};</strong></p>\n<pre><code>//默认 int\n</code></pre><p>优势：</p>\n<ul>\n<li><p>强制作用域 —必须在枚举类 枚举类型名：：枚举值，不同枚举类可以有同名值了</p>\n</li>\n<li><p>转换限制 —枚举对象不能与整型 隐式转换</p>\n</li>\n<li><p>底层类型 —可以指定</p>\n</li>\n</ul>\n<h2 id=\"数据共享和保护：\"><a href=\"#数据共享和保护：\" class=\"headerlink\" title=\"数据共享和保护：\"></a><strong>数据共享和保护：</strong></h2><h3 id=\"作用域分类：\"><a href=\"#作用域分类：\" class=\"headerlink\" title=\"作用域分类：\"></a><strong>作用域分类：</strong></h3><p>函数原型作用域：</p>\n<ul>\n<li>形参的范围在（）内，所以不需要名字也行，int area( int );</li>\n</ul>\n<p>局部作用域</p>\n<ul>\n<li><p>函数{ }内</p>\n</li>\n<li><p>if、for、while { }内</p>\n</li>\n</ul>\n<p>类作用域： 类外访问类的成员</p>\n<ul>\n<li><p>静态成员：通过 对象名.成员名 访问</p>\n</li>\n<li><p>非静态成员：</p>\n</li>\n<li><p>文件作用域</p>\n</li>\n<li><p>命名空间作用域： 10章</p>\n</li>\n</ul>\n<h3 id=\"对象的生存期：\"><a href=\"#对象的生存期：\" class=\"headerlink\" title=\"对象的生存期：\"></a><strong>对象的生存期：</strong></h3><p>静态生存期： 整个程序结束后消失</p>\n<ul>\n<li>函数内的静态对象， 用static ，全局寿命，只局部可见</li>\n</ul>\n<p>动态生存期：</p>\n<ul>\n<li><p>离开作用域后消失</p>\n</li>\n<li><p>下次进函数重新生成对象</p>\n</li>\n</ul>\n<h3 id=\"类的静态数据成员：\"><a href=\"#类的静态数据成员：\" class=\"headerlink\" title=\"类的静态数据成员：\"></a><strong>类的静态数据成员：</strong></h3><ul>\n<li><p>static 声明</p>\n</li>\n<li><p>为该类所有对象共享，具有静态生存期</p>\n</li>\n<li><p>必须在类外定义和初始化，类内声明，用：：指明所属于的类</p>\n</li>\n</ul>\n<p>比如记录 类产生了多少对象；opencv中的Mat对象好像用到了？？？？</p>\n<pre><code>    class base{   \n        public :   \n               static   int   _num;//声明   \n    };   \n    int  base::_num=0;  //真正定义  \n</code></pre><h3 id=\"类的友元：\"><a href=\"#类的友元：\" class=\"headerlink\" title=\"类的友元：\"></a><strong>类的友元：</strong></h3><ul>\n<li><p>破坏数据封装和数据隐藏的机制</p>\n</li>\n<li><p>尽量不用</p>\n</li>\n</ul>\n<h3 id=\"友元函数：\"><a href=\"#友元函数：\" class=\"headerlink\" title=\" 友元函数：\"></a><strong> 友元函数：</strong></h3><ul>\n<li><p>类声明中由关键字 friend 修饰说明的非成员函数</p>\n</li>\n<li><p>可以在其函数体内访问对象的private,protected成员</p>\n</li>\n<li><p>但必须通过对象名：：访问，函数参数为类的引用</p>\n</li>\n<li><h3 id=\"友元类：\"><a href=\"#友元类：\" class=\"headerlink\" title=\" 友元类：\"></a><strong> 友元类：</strong></h3><pre><code>class A{\n    friend B;\n  public:\n    void display(){\n        count &lt;&lt; x &lt;&lt; enld;\n    }\n  private:\n    int x;\n}\n\nclass B{\n  public:\n    void set(int i);\n    void display();\n  private:\n    A a;\n}\n\nvoid B::set(int i){\n    a.x = i;   // B类中改变 A类私有值\n}\nvoid B::display(){\n    a.display()\n}\n</code></pre></li>\n</ul>\n<h3 id=\"共享数据的保护：\"><a href=\"#共享数据的保护：\" class=\"headerlink\" title=\"共享数据的保护：\"></a><strong>共享数据的保护：</strong></h3><h1 id=\"常类型：const\"><a href=\"#常类型：const\" class=\"headerlink\" title=\"常类型：const\"></a><strong>常类型：</strong>const</h1><p>常对象：必须初始化，不可更新</p>\n<pre><code>    class A{\n    }\n    A const a; // a是常对象\n</code></pre><p>常成员：(不可以放在构造函数体内复制，可以在初始化列表中)</p>\n<pre><code>    A：：A(int i):a(i){ }\n</code></pre><ul>\n<li><p>常数据成员：const修饰的</p>\n</li>\n<li><p>静态常数据成员： static const int b;</p>\n</li>\n<li><p>常函数成员（用来处理常对象的函数）</p>\n<ul>\n<li><p>不更新对象的数据成员</p>\n</li>\n<li><p>声明和实现都带const</p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>        class A{\n            void f（int a）const;\n        }\n        void A::f(int a) const{  \n        }; // f是常对象函数, 处理常对象\n</code></pre><ul>\n<li>常引用：不可更新</li>\n</ul>\n<p>　　　引用是双向传递的，避免修改原值的方法就是常引用；</p>\n<pre><code>     const A&amp; a;\n</code></pre><ul>\n<li><p>常数组：</p>\n</li>\n<li><p>常指针：</p>\n</li>\n</ul>\n<h3 id=\"多文件结构和预编译命令：\"><a href=\"#多文件结构和预编译命令：\" class=\"headerlink\" title=\"多文件结构和预编译命令：\"></a><strong>多文件结构和预编译命令：</strong></h3><ul>\n<li><p>.h 系统使用</p>\n</li>\n<li><p>.hpp 个人使用(类的声明,函数的声明)</p>\n</li>\n<li><p>.cpp (类的实现，函数的实现)</p>\n<p> <img src=\"/2019/01/20/C-梳理笔记/f5d645ed218d5fa3e753f771b72310fc.png\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"外部变量：\"><a href=\"#外部变量：\" class=\"headerlink\" title=\"外部变量：\"></a><strong>外部变量：</strong></h3><p>文件作用域中定义的变量默认是外部变量，其他文件使用前，extern声明</p>\n<p>将变量和函数限制在编译单元内：namespcae:</p>\n<pre><code>    namespace{ //匿名的命名空间，外部不可调用任何东西\n        int i;\n        void fun(){\n            i++;\n        }\n    }\n</code></pre><h3 id=\"预编译命令：\"><a href=\"#预编译命令：\" class=\"headerlink\" title=\"预编译命令：\"></a><strong>预编译命令：</strong></h3><pre><code>    #include&lt; &gt;  标准方式搜索，从系统目录include\n\n\n    #include”” 先当前目录搜索，没有再标准搜索\n\n\n    #define \n\n\n    #undef 删除有#define的宏\n\n    #if 表达式  // 条件编译指令\n    ---\n    #else\n    ---\n    #endif \n\n\n    #ifndef 标识符\n    ---\n    #else  \n    ---\n    #endif\n</code></pre><h2 id=\"数组，指针与字符串：\"><a href=\"#数组，指针与字符串：\" class=\"headerlink\" title=\"数组，指针与字符串：\"></a><strong>数组，指针与字符串：</strong></h2><h3 id=\"数组：\"><a href=\"#数组：\" class=\"headerlink\" title=\"数组：\"></a><strong>数组：</strong></h3><p>定义： <code>int arr**[**m**][**n**]**…;</code></p>\n<p>　　注：二维数组中 arr[1] 第二行首地址</p>\n<h3 id=\"数组作为函数参数：\"><a href=\"#数组作为函数参数：\" class=\"headerlink\" title=\"数组作为函数参数：\"></a><strong>数组作为函数参数：</strong></h3><p>　　数组名做参数： 形参，实参都是数组名，传入的是地址</p>\n<h3 id=\"对象数组：\"><a href=\"#对象数组：\" class=\"headerlink\" title=\"对象数组：\"></a><strong>对象数组：</strong></h3><p>　　定义：类名 数组名[对象元素个数]</p>\n<p>　　访问：数组名[下标].成员名</p>\n<h3 id=\"基于范围的for循环：c-11-自动遍历整个容器\"><a href=\"#基于范围的for循环：c-11-自动遍历整个容器\" class=\"headerlink\" title=\"基于范围的for循环：c++11,自动遍历整个容器\"></a><strong>基于范围的for循环：</strong>c++11,自动遍历整个容器</h3><pre><code>  for( auto x : 容器){ } for( auto &amp;x : 容器){ }\n</code></pre><p>注意：</p>\n<ul>\n<li><p>auto &amp;x是元素引用，auto x是元素的副本</p>\n</li>\n<li><p>auto推导出的类型是容器中的值类型</p>\n</li>\n<li><p>：冒号后的表达式只执行一次</p>\n</li>\n</ul>\n<h3 id=\"指针：\"><a href=\"#指针：\" class=\"headerlink\" title=\"指针：\"></a><strong>指针：</strong></h3><h3 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a><strong>定义：</strong></h3><pre><code>    static int i;\n\n    static int * p = &amp;I;\n</code></pre><h3 id=\"指针的初始化和赋值：\"><a href=\"#指针的初始化和赋值：\" class=\"headerlink\" title=\"指针的初始化和赋值：\"></a><strong>指针的初始化和赋值：</strong></h3><h3 id=\"指针的算术运算，关系运算：\"><a href=\"#指针的算术运算，关系运算：\" class=\"headerlink\" title=\"指针的算术运算，关系运算：\"></a><strong>指针的算术运算，关系运算：</strong></h3><h3 id=\"指针数组：\"><a href=\"#指针数组：\" class=\"headerlink\" title=\"指针数组：\"></a><strong>指针数组：</strong></h3><pre><code>    类名  *p[2];\n</code></pre><h3 id=\"指向数组的指针：\"><a href=\"#指向数组的指针：\" class=\"headerlink\" title=\"指向数组的指针：\"></a><strong>指向数组的指针：</strong></h3><pre><code>    int **p; 指向二维数组的指针\n</code></pre><h3 id=\"指针与函数：\"><a href=\"#指针与函数：\" class=\"headerlink\" title=\"指针与函数：\"></a><strong>指针与函数：</strong></h3><ul>\n<li><p>指针做参数：大批量数据提高效率</p>\n</li>\n<li><p>指针类型的函数：返回类型是指针</p>\n<pre><code>  int * function(int i){return 全局或者静态的 }；// 不能返回非静态局部变量\n</code></pre></li>\n<li><p>指向函数的指针：实现函数回调的功能</p>\n</li>\n</ul>\n<blockquote>\n<p>  定义： 数据类型 (*f)(参数表);</p>\n<p>  数据类型：返回值</p>\n</blockquote>\n<ul>\n<li>对象指针：</li>\n</ul>\n<blockquote>\n<p>  定义： 类名 *对象指针名 = &amp; 对象；</p>\n<p>  访问对象： 对象指针名->成员名</p>\n</blockquote>\n<p>（*对象指针名）.成员名</p>\n<ul>\n<li><p>this 指针：成员函数的一个隐士参数，初始化为对象的地址，不可改变</p>\n</li>\n<li><p>隐含于类的每个非静态成员函数中</p>\n</li>\n<li><p>指出成员函数所操作的当前的对象</p>\n</li>\n<li><p>*this 是当前对象地址</p>\n</li>\n</ul>\n<h3 id=\"动态内存分配：\"><a href=\"#动态内存分配：\" class=\"headerlink\" title=\"动态内存分配：\"></a><strong>动态内存分配：</strong></h3><p>new<strong> 类型名 </strong>(<strong>初始化列表</strong>) // 返回首字节地址</p>\n<p>delete 指针p //p一直在，删除的只是p指向的对象申请的空间</p>\n<p>动态数组：<br>new 类型名[数组长度]</p>\n<p>delete[] 数组首地址p指针</p>\n<h3 id=\"智能指针：C-11\"><a href=\"#智能指针：C-11\" class=\"headerlink\" title=\"智能指针：C++11\"></a><strong>智能指针：</strong>C++11</h3><h3 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a><strong>内存管理</strong></h3><ul>\n<li><p>unique_ptr:</p>\n<ul>\n<li>不允许多个指针共享资源，标准库中move可以转移指针，但原来指针会失效</li>\n</ul>\n</li>\n<li><p>shared_ptr:</p>\n<ul>\n<li>多指针共享</li>\n</ul>\n</li>\n<li><p>weak_ptr:</p>\n<ul>\n<li>可复制共享</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>  Vector对象：类模板</p>\n</blockquote>\n<p>优势：</p>\n<ul>\n<li><p>封装任何形式的动态数组，自动创建，删除</p>\n</li>\n<li><p>下标越界检查</p>\n</li>\n</ul>\n<p>定义： vector &lt;元素类型&gt; object（长度）</p>\n<ul>\n<li><p><code>object.begin()  object.end()  object.size()</code></p>\n</li>\n<li><p>auto 遍历vector <code>for(auto e: object);</code></p>\n</li>\n</ul>\n<h3 id=\"对象的复制和移动：\"><a href=\"#对象的复制和移动：\" class=\"headerlink\" title=\"对象的复制和移动：\"></a><strong>对象的复制和移动：</strong></h3><ul>\n<li><p>浅层复制和深层复制：复制对象用到复制构造函数，默认的复制构造只传递了指针，两个变量指向同一块内存，释放其中一个，再释放第二个会出错；</p>\n<ul>\n<li><p>浅层：实现对象间数据一一对应的复制，但两个对象指向同一内存</p>\n</li>\n<li><p>深层：当对象成员是指针类型，应该对指针所指对象进行复制。</p>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>  类名<strong>::</strong>类名<strong>(</strong>const 类名<strong>&amp;</strong> v<strong>){</strong></p>\n<p>  size <strong>=</strong> v<strong>.</strong>size<strong>;</strong></p>\n<p>  data_ptr <strong>= new</strong> Ponit<strong>[</strong>size<strong>];</strong></p>\n<p>  <strong>for(</strong>int i<strong>=</strong>0<strong>;</strong> i <strong>\\&lt;</strong> size<strong>; ++</strong>i<strong>){</strong></p>\n<p>  data_ptr<strong>[</strong>i<strong>] =</strong> v<strong>.</strong>data_ptr<strong>[</strong>i<strong>];</strong></p>\n<p>  <strong>}</strong></p>\n<p>  <strong>}</strong></p>\n</blockquote>\n<ul>\n<li><p>移动构造：C++11,省去了构造和删除临时对象的过程</p>\n<p><img src=\"/2019/01/20/C-梳理笔记/8c3092d99bcdba78edeb2d8123270ffe.png\" alt=\"\"></p>\n</li>\n</ul>\n<blockquote>\n<p>  class_name<strong>(</strong>class_name <strong>&amp;&amp;</strong>old<strong>)::</strong>xptr<strong>(</strong>old<strong>.</strong>xptr<strong>){</strong></p>\n<p>  n<strong>.</strong>xptr <strong>= NULL;</strong> // 原来的指针清空</p>\n<p>  <strong>}</strong></p>\n</blockquote>\n<h3 id=\"C风格字符串：字符数组\"><a href=\"#C风格字符串：字符数组\" class=\"headerlink\" title=\"C风格字符串：字符数组\"></a><strong>C风格字符串：</strong>字符数组</h3><h3 id=\"string类：\"><a href=\"#string类：\" class=\"headerlink\" title=\"string类：\"></a><strong>string类：</strong></h3><p>常用构造函数：</p>\n<ul>\n<li><p>string(); //默认构造，长度为0</p>\n<ul>\n<li>string s1<strong>;</strong></li>\n</ul>\n</li>\n<li><p>string(const char *s) //指针s所指向的字符串常量初始化该对象</p>\n<pre><code>string s2 = “abc”;\n\nstring(const string &amp;rhs) //复制构造函数\n\nstring s3 = s2;\n</code></pre></li>\n</ul>\n<p>访问：下标访问</p>\n<p>整行字符串的输入： cin 被空格隔开</p>\n<p>getline(cin,s2); //包含#include\\<string\\></string\\></p>\n<p>getline(cin,s2,’,’);</p>\n<h2 id=\"继承和派生：-充分利用原有的\"><a href=\"#继承和派生：-充分利用原有的\" class=\"headerlink\" title=\"继承和派生： 充分利用原有的\"></a><strong>继承和派生：</strong> 充分利用原有的</h2><p>继承：保持已有类的特征来构造新类</p>\n<p>派生：在已有类基础上新增自己的特性</p>\n<p>基类：父类</p>\n<p>派生类：子类</p>\n<p>直接基类和间接基类</p>\n<p>单继承：</p>\n<pre><code>class 派生类名：继承方式 基类名{  //继承方式，\n    成员声明；//新增成员的声明\n}\n</code></pre><p>多继承：</p>\n<pre><code>class 派生类名：继承方式1 基类1，继承方式2 基类2{\n    成员声明；\n}\n</code></pre><h3 id=\"继承的方式：\"><a href=\"#继承的方式：\" class=\"headerlink\" title=\"继承的方式：\"></a><strong>继承的方式：</strong></h3><p>控制：派生类对基类成员的访问权限</p>\n<ul>\n<li>公有继承 public</li>\n</ul>\n<blockquote>\n<p>  基类中的pubilc和protected访问属性在派生类中不变</p>\n<p>  基类的pravate不可被对象直接访问</p>\n</blockquote>\n<ul>\n<li><p>私有继承 ：内部可以访问基类的公有和保护成员，但是其对象不再可以访问</p>\n</li>\n<li><p>保护继承 ：基类的公有和保护，到这都成了保护成员，类内可以访问，但对象不能</p>\n</li>\n</ul>\n<p>派生类的构成：</p>\n<ul>\n<li><p>吸收基类成员</p>\n</li>\n<li><p>改造基类成员</p>\n<ul>\n<li>增加同名成员，基类成员被覆盖（重新定义继承的成员函数必须用虚函数）</li>\n</ul>\n</li>\n<li><p>添加新成员</p>\n</li>\n</ul>\n<h3 id=\"类型转换：-1\"><a href=\"#类型转换：-1\" class=\"headerlink\" title=\"类型转换：\"></a><strong>类型转换：</strong></h3><p>基类和派生类之间：</p>\n<p>派生类的对象可以隐含转换为基类对象；</p>\n<p>派生类的对象可以初始化基类的引用；</p>\n<p>派生类的指针可以隐含转换为基类的指针；</p>\n<h3 id=\"派生类的构造函数：\"><a href=\"#派生类的构造函数：\" class=\"headerlink\" title=\"派生类的构造函数：\"></a><strong>派生类的构造函数：</strong></h3><p>默认情况下，基类的构造函数不被继承，派生类需要自己构造</p>\n<p>c++11，using语句继承基类构造函数</p>\n<h3 id=\"派生类的复制构造函数：\"><a href=\"#派生类的复制构造函数：\" class=\"headerlink\" title=\"派生类的复制构造函数：\"></a><strong>派生类的复制构造函数：</strong></h3><h3 id=\"派生类的析构函数：\"><a href=\"#派生类的析构函数：\" class=\"headerlink\" title=\"派生类的析构函数：\"></a><strong>派生类的析构函数：</strong></h3><h3 id=\"虚基类：\"><a href=\"#虚基类：\" class=\"headerlink\" title=\"虚基类：\"></a><strong>虚基类：</strong></h3><h2 id=\"多态性\"><a href=\"#多态性\" class=\"headerlink\" title=\"多态性\"></a><strong>多态性</strong></h2><h3 id=\"运算符重载：\"><a href=\"#运算符重载：\" class=\"headerlink\" title=\"运算符重载：\"></a><strong>运算符重载：</strong></h3><pre><code>//双目运算符\n函数类型 operator 运算符（参数）  \n{\n    // 参数个数 = 原操作数个数 - 1\n}\n//前置单目运算符，返回引用所以可以当左值\n函数类型 &amp; operator ++（无参数）  \n{\n    return * this;\n}\n//后置单目运算符，\n函数类型 operator ++（参数为int类型）  \n{\n    old = *this;\n    ++(*this);  //调用的前置\n    return old;\n}\n</code></pre><ul>\n<li>重载为非成员函数：</li>\n</ul>\n<ol>\n<li><p>列出所有操作数</p>\n</li>\n<li><p>至少有一个自定义类型参数</p>\n</li>\n<li><p>后置单目运算，参数要增加int,但不用写形参名</p>\n</li>\n<li><p>要操作某类对象的私有成员，则可声明为该类的友元函数</p>\n</li>\n</ol>\n<h3 id=\"虚函数：virtual改造基类成员，实现动态绑定；必须是非静态成员\"><a href=\"#虚函数：virtual改造基类成员，实现动态绑定；必须是非静态成员\" class=\"headerlink\" title=\"虚函数：virtual改造基类成员，实现动态绑定；必须是非静态成员\"></a><strong>虚函数：</strong>virtual改造基类成员，实现动态绑定；必须是非静态成员</h3><blockquote>\n<p>  原理：编译时先不确定和哪个类的成员对应，在程序运行时刻，再对应；</p>\n</blockquote>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nclass Base1{\npublic:\n    virtual void display() const; //虚函数，不要用内联\n};\n\nvoid Base1::display() const{\n    cout &lt;&lt; &quot;Base1 &quot; &lt;&lt; endl;\n}\n\nclass Base2:public Base1{\npublic:\n    virtual void display() const;\n}\nvoid Base2::display() const{\n    cout &lt;&lt; &quot;Base2&quot; &lt;&lt; endl;\n}\n</code></pre><h3 id=\"虚析构函数：打算通过基类指针调用某一个对象的析构函数（执行delete）\"><a href=\"#虚析构函数：打算通过基类指针调用某一个对象的析构函数（执行delete）\" class=\"headerlink\" title=\"虚析构函数：打算通过基类指针调用某一个对象的析构函数（执行delete）\"></a><strong>虚析构函数：</strong>打算通过基类指针调用某一个对象的析构函数（执行delete）</h3><h3 id=\"虚表和动态绑定：\"><a href=\"#虚表和动态绑定：\" class=\"headerlink\" title=\"虚表和动态绑定：\"></a><strong>虚表和动态绑定：</strong></h3><blockquote>\n<p>  虚表：</p>\n</blockquote>\n<ul>\n<li><p>每个多态类都有虚表；</p>\n</li>\n<li><p>存放各个数函数的入口地址；</p>\n</li>\n<li><p>每个对象有指向当前类的虚表的指针（虚指针vptr）；</p>\n</li>\n</ul>\n<blockquote>\n<p>  动态绑定：</p>\n</blockquote>\n<ul>\n<li>构造函数为对象的虚指针赋值</li>\n</ul>\n<h3 id=\"抽象类：含有纯虚函数的类-不能直接定义对象\"><a href=\"#抽象类：含有纯虚函数的类-不能直接定义对象\" class=\"headerlink\" title=\"抽象类：含有纯虚函数的类,不能直接定义对象\"></a><strong>抽象类：</strong>含有纯虚函数的类,不能直接定义对象</h3><blockquote>\n<p>  纯虚函数：</p>\n<p>  基类中声明的虚函数，在基类中没有定义具体的操作，要求在派生类中根据实际需求完</p>\n<p>  成自己的版本：</p>\n</blockquote>\n<pre><code>virtual 函数类型 函数名**(**参数名**) =** 0**;**\n</code></pre><h3 id=\"override-和-final-C-11\"><a href=\"#override-和-final-C-11\" class=\"headerlink\" title=\"override 和 final :C++11\"></a><strong>override 和 final :</strong>C++11</h3><p>override声明的函数，必须在基类中找到原型；</p>\n<p>final 不允许继承或者覆盖；</p>\n<h2 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a><strong>模板</strong></h2><h3 id=\"函数魔板：整数和浮点数求绝对值，需要多次重载函数，但是用函数模板，只需要设计通用功能；\"><a href=\"#函数魔板：整数和浮点数求绝对值，需要多次重载函数，但是用函数模板，只需要设计通用功能；\" class=\"headerlink\" title=\"函数魔板：整数和浮点数求绝对值，需要多次重载函数，但是用函数模板，只需要设计通用功能；\"></a><strong>函数魔板：</strong>整数和浮点数求绝对值，需要多次重载函数，但是用函数模板，只需要设计通用功能；</h3><p>template\\&lt;模板参数表> // 类型：class或者typename 常量：</p>\n<p>函数定义</p>\n<pre><code>template&lt;typename T&gt;\nT abs(T x){\n    return x&lt;0?-x:x;\n}\n</code></pre><h3 id=\"类模板：\"><a href=\"#类模板：\" class=\"headerlink\" title=\"类模板：\"></a><strong>类模板：</strong></h3><pre><code>template&lt;模板参数表&gt;\nclass 类名{\n    类成员声明;\n}\n\n//类成员定义\ntemplate &lt;模板参数表&gt;\n类型名  类名&lt;模板参数标识符列表&gt; :: 函数名(参数表)\n{\n\n}\n</code></pre><h3 id=\"线性群体：按位置顺序有序排列\"><a href=\"#线性群体：按位置顺序有序排列\" class=\"headerlink\" title=\"线性群体：按位置顺序有序排列\"></a><strong>线性群体：</strong>按位置顺序有序排列</h3><p>直接访问：</p>\n<p>数组类模板：</p>\n<p>索引访问：</p>\n<p>顺序访问：</p>\n<p>链表类和结点类模板：</p>\n<p>单链表：每个结点包括数据和指针，只有一个指向后续结点的称为单链表；</p>\n<p><img src=\"/2019/01/20/C-梳理笔记/9167a427f849e864c5d630d0c0bc3163.png\" alt=\"\"></p>\n<p>单链表结点类模板：</p>\n<pre><code>template &lt;class T&gt;\nclass Node{\n    private:\n        Node&lt;T&gt; *next;\n    public:\n        T data; \n        Node(const T&amp;item,Node&lt;T&gt;* next = 0);  //构造函数\n    void insertAfter(Node&lt;T&gt; *p); //插入\n    Node&lt;T&gt; *deleteAfter();  //删除\n    Node&lt;T&gt; *nextNode() const; \n}\n\ntemplate &lt;class T&gt;\nvoid Node&lt;T&gt;::insertAfter(Node&lt;T&gt; *p){  // *p是要插入的结点\n// p节点的指针指向当前节点的后续结点\n    p-&gt;next = next; // next是原链表待插入位置的结点的指针\n    next = p;  \n}\ntemplate &lt;class T&gt;\nNode&lt;T&gt; *deleteAfter(){\n    Node&lt;T&gt; * tempPtr = next;\n    if (next == NULL)  //判断是否是删除最后的元素\n        return 0;\n    next = tempPtr = next;\n    return tempPtr;\n}\n</code></pre><blockquote>\n<p>  插入：</p>\n</blockquote>\n<p><img src=\"/2019/01/20/C-梳理笔记/85d072d9c8a8366378b00b9af8ca4920.png\" alt=\"\"></p>\n<blockquote>\n<p>  头插法：可以当队列</p>\n<p>  尾插法：栈</p>\n<p>  删除：</p>\n</blockquote>\n<p><img src=\"/2019/01/20/C-梳理笔记/ffdd5c0226d2a3f9a7833379eb0ebf90.png\" alt=\"\"></p>\n<p>待查询：</p>\n<p>explicit关键字</p>\n<p>构造函数 explicit可以抑制内置类型隐式转换</p>\n<h2 id=\"泛型设计\"><a href=\"#泛型设计\" class=\"headerlink\" title=\"泛型设计\"></a><strong>泛型设计</strong></h2><p>基本概念：</p>\n<p>编写不依赖具体数据类型的程序，通用的；</p>\n<p>STL简介：(Standard Template Library)</p>\n<p>C++ string类库入门：</p>\n<pre><code>#include &lt;iostream&gt;\n\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n\n    // 构造函数：\n    string str1 = &quot;Yesterday&quot;;\n\n    string str2(&quot;Today&quot;);\n\n    string str3(&quot;Hello&quot;,2); //取c风格字符串 长度为 2 作为初值，即&quot;He&quot;\n\n    string str4(str1, 6); // 始于位置6开始的字符串，即&quot;day&quot;\n\n    string str5(str1,6,1); // 始于6，长度1，即&quot;d&quot;\n\n    string str6(1,&#39;a&#39;); //6个&#39;a&#39;\n\n    // 赋值，交换\n    str1.assign(&quot;hahahaha&quot;); //重新赋值\n\n    swap(str1,str2); //交换两个字符串内容 str1=&quot;Today&quot; str2=&quot;hahahaha&quot;\n\n    // 追加\n    str1 += &quot; we&quot;; // += 可追加 string对象，字符串，字符\n\n    str1.append(&quot; ar&quot;); // append 可追加 string对象，字符串\n\n    str1.push_back(&#39;e&#39;); //push_back 只能追加字符 str1 = &quot;Today we are&quot;\n\n    // 插入\n    str1.insert(0,&quot; family&quot;); //str1 = &quot;Today we are family&quot;\n\n    // 删除\n    str1.erase(2,1); //第2个位置开始， len = 1 个字符\n\n    str1.clear(); //删除全部\n\n    // 访问字符串\n    string s = &quot;asdfgh&quot;;\n\n    cout &lt;&lt; s[1]; // &#39;s&#39;\n\n    cout &lt;&lt; s.at(2); // &#39;d&#39;\n\n    // 查找\n    int position = s.find(&#39;f&#39;,0); // 从0开始查找第一次出现‘f’的坐标\n\n    // 替换\n    s.replace(s.find(&#39;f&#39;),3,&quot;ZZZ&quot;); //替换find的位置处\n    3个字符串为 “ZZZ”\n\n    // 分割\n    getchar();\n\n    return 0;\n\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<font color=\"red\"><big>测试内容</big></font>\n\n\n<p><del>删除线</del></p>\n<p><a href=\"http://zhuzhuyule.xyz\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<p><img src=\"/2019/01/20/C-梳理笔记/test.jpg\" alt=\"logo\"></p>\n<h1 id=\"C-学习笔记\"><a href=\"#C-学习笔记\" class=\"headerlink\" title=\"C++学习笔记\"></a>C++学习笔记</h1><h2 id=\"类型转换：\"><a href=\"#类型转换：\" class=\"headerlink\" title=\"类型转换：\"></a><strong>类型转换：</strong></h2><ol>\n<li><p>隐式转换： 低类型转换为高类型</p>\n<pre><code>浮点数（直接舍掉小数，不四舍五入） + 整数\n</code></pre></li>\n<li><p>显式转换：</p>\n<pre><code> int **(**z**) = (**int**)** z **= static_cast\\&lt;**int**\\&gt; (**z**)**\n</code></pre></li>\n</ol>\n<p>。。。</p>\n<h3 id=\"数据的输入和输出：信息的流动\"><a href=\"#数据的输入和输出：信息的流动\" class=\"headerlink\" title=\"数据的输入和输出：信息的流动\"></a><strong>数据的输入和输出：信息的流动</strong></h3><ol>\n<li><p>输入：</p>\n</li>\n<li><p>输出：</p>\n</li>\n<li><p>流类库的操纵符：</p>\n</li>\n</ol>\n<h3 id=\"程序控制：\"><a href=\"#程序控制：\" class=\"headerlink\" title=\"程序控制：\"></a><strong>程序控制：</strong></h3><pre><code>    if, while, for, do-while , break, continue, { switch,case,default } ;\n</code></pre><ol>\n<li><p>do-while:</p>\n<pre><code> do 语句      // 先执行一次\n while(表达式)；\n</code></pre></li>\n<li><p>for的范围，遍历容器：</p>\n</li>\n</ol>\n<h3 id=\"自定义类型：\"><a href=\"#自定义类型：\" class=\"headerlink\" title=\"自定义类型：\"></a><strong>自定义类型：</strong></h3><ul>\n<li>类型别名： </li>\n</ul>\n<ol>\n<li><p>typedef double Area, V;</p>\n</li>\n<li><p>using Area = double</p>\n</li>\n</ol>\n<ul>\n<li>枚举类型： 有限的个数</li>\n</ul>\n<p>　　　　不限定作用域： enum 类型名 { 变量值列表}</p>\n<p>　　　　限定作用域：</p>\n<p>　　　注：枚举元素是常量，不能赋值</p>\n<p>　　　　　枚举元素有默认值，默认0,1,2,3,4，声明时可以另外指定</p>\n<p>　　　　　可以进行关系运算</p>\n<ul>\n<li><p>auto类型 和decltyoe类型</p>\n<pre><code>      decltype( float( i )) j = 2;   // j值是2，类型是float;\n\n      auto m = 2.5;  // m 为float;\n</code></pre></li>\n<li><p>结构体( C语言中的)： struct</p>\n<pre><code>      struct MyTimeStruct{   //定义 结构体类型\n          unsigned int year,mouth,day,hour,min,sec;\n      };\n</code></pre></li>\n</ul>\n<h2 id=\"函数：-可重用的功能模块（定义和调用）\"><a href=\"#函数：-可重用的功能模块（定义和调用）\" class=\"headerlink\" title=\"函数： 可重用的功能模块（定义和调用）\"></a><strong>函数： 可重用的功能模块（定义和调用）</strong></h2><h3 id=\"函数定义：\"><a href=\"#函数定义：\" class=\"headerlink\" title=\"函数定义：\"></a><strong>函数定义：</strong></h3><p>　　形参不占用空间，调用时分配；</p>\n<h3 id=\"函数调用：\"><a href=\"#函数调用：\" class=\"headerlink\" title=\"函数调用：\"></a><strong>函数调用：</strong></h3><p>　　调用前要函数声明： int sum<strong>(</strong> int a<strong>,</strong> int b<strong>);</strong></p>\n<p>　　1. 函数的嵌套调用：</p>\n<p>　　2. 函数的递归调用： 直接或者间接调用自身</p>\n<p>计算n!</p>\n<pre><code>    unsigned int fac( unsigned int n){\n        if (n == 0) return 1;\n        return fac( n - 1) * n;\n    }\n</code></pre><p>汉诺塔</p>\n<pre><code>    分析：\n    1.    A 上的n-1个盘子移动到B上（借助C）;\n    2.    A上剩下的盘子移动到C上；\n    3.    B上的n-1个盘子移动到C上（借助A）\n    void move(char src, char obj)\n    {\n        cout &lt;&lt; src &lt;&lt; &quot;---&gt;&gt;&gt;&quot; &lt;&lt; obj &lt;&lt; endl;\n    }\n\n    void hanoi(int n, char src, char medium, char obj)\n    {\n        if(n == 1)\n            move(src, obj);\n        else{\n            hanoi(n-1, src, obj, medium);\n            move(src, obj);\n            hanoi(n-1, medium, src, obj);\n        }\n    }\n</code></pre><h3 id=\"函数的参数：\"><a href=\"#函数的参数：\" class=\"headerlink\" title=\"函数的参数：\"></a><strong>函数的参数：</strong></h3><ol>\n<li><p>形参不占用空间，调用时分配；</p>\n</li>\n<li><p>计算结果返回多个（利用引用）</p>\n</li>\n<li><p>多个参数时，从后开始传</p>\n</li>\n</ol>\n<h3 id=\"引用类型（-amp-）：-必须初始化，该类型不可改变，是其他变量的别名\"><a href=\"#引用类型（-amp-）：-必须初始化，该类型不可改变，是其他变量的别名\" class=\"headerlink\" title=\"引用类型（&amp;）： 必须初始化，该类型不可改变，是其他变量的别名\"></a><strong>引用类型（&amp;）：</strong> 必须初始化，该类型不可改变，是其他变量的别名</h3><pre><code>    int i, j;\n    int &amp; ri = i;  // 定义int引用类型变量 ri, 初始化为i的引用\n</code></pre><h3 id=\"含有可变参数的函数：（两种方法）\"><a href=\"#含有可变参数的函数：（两种方法）\" class=\"headerlink\" title=\"含有可变参数的函数：（两种方法）\"></a><strong>含有可变参数的函数：（两种方法）</strong></h3><ol>\n<li><p>所有实参类型相同：<code>initializer_list&lt;int&gt; li; //类模板, 都是常量</code></p>\n</li>\n<li><p>具体看第九章</p>\n</li>\n<li><p>类型不同：</p>\n</li>\n</ol>\n<h3 id=\"内联函数（inline）：-用函数体内的语句，替换函数调用表达式，编译时完成，类似-define\"><a href=\"#内联函数（inline）：-用函数体内的语句，替换函数调用表达式，编译时完成，类似-define\" class=\"headerlink\" title=\"内联函数（inline）： 用函数体内的语句，替换函数调用表达式，编译时完成，类似 #define\"></a><strong>内联函数（inline）： </strong>用函数体内的语句，替换函数调用表达式，编译时完成，类似 #define</h3><p>声明： <code>inline int calArea(int a){  }</code></p>\n<p>要求： 1. 不能有循环，switch语句 2. 定义在调用之前 3. 不能有异常接口声明</p>\n<h3 id=\"constexpr-函数：（常量表达式函数）\"><a href=\"#constexpr-函数：（常量表达式函数）\" class=\"headerlink\" title=\"constexpr 函数：（常量表达式函数）\"></a>constexpr 函数：（常量表达式函数）</h3><h3 id=\"带默认参数的函数：\"><a href=\"#带默认参数的函数：\" class=\"headerlink\" title=\"带默认参数的函数：\"></a><strong>带默认参数的函数：</strong></h3><pre><code>    int getVa(int length, int weight = 2)\n</code></pre><h3 id=\"函数的重载：（C-多态性的重要机制，编译过程中实现）\"><a href=\"#函数的重载：（C-多态性的重要机制，编译过程中实现）\" class=\"headerlink\" title=\"函数的重载：（C++多态性的重要机制，编译过程中实现）\"></a><strong>函数的重载：</strong>（C++多态性的重要机制，编译过程中实现）</h3><p>函数体同名，参数类型不同/参数个数不同</p>\n<pre><code>    int add(int x, int y);\n\n    float add(float x, float y);\n\n    float add(float x, float y, float z);\n</code></pre><h3 id=\"C-系统函数：\"><a href=\"#C-系统函数：\" class=\"headerlink\" title=\"C++系统函数：\"></a><strong>C++系统函数：</strong></h3><pre><code>    #include &lt;cmath&gt;\n        |_\n        |_\n    #include &lt;cstdlib&gt;\n        |_\n        |_\n    #include &lt;cstdio&gt;\n        |_\n        |_\n    #include &lt;ctime&gt;\n        |_\n        |_\n</code></pre><h2 id=\"类和对象\"><a href=\"#类和对象\" class=\"headerlink\" title=\"类和对象\"></a><strong>类和对象</strong></h2><p>类：构建对象的蓝图，</p>\n<p>对象：由类创建，含有数据和方法</p>\n<p>封装：对数据和操作数据的方法的组合绑定</p>\n<p>继承：在已有类基础上，形成新的类</p>\n<p>多态：</p>\n<p>构造函数：定义对象时，通过构造函数初始化</p>\n<p>析构函数：删除对象时，通过析构函数释放资源</p>\n<h3 id=\"类和对象的定义：\"><a href=\"#类和对象的定义：\" class=\"headerlink\" title=\" 类和对象的定义：\"></a><strong> 类和对象的定义：</strong></h3><p>定义类：</p>\n<pre><code>    class {  //类名称 \n        public:\n            // 公有成员,外部接口\n        private:\n            // 私有成员\n        protected:\n            int hour = 0; // 类内初始化\n            // 保护型成员\n    }\n</code></pre><p>注意：不指定类型，默认为私有；</p>\n<h3 id=\"成员函数：\"><a href=\"#成员函数：\" class=\"headerlink\" title=\"成员函数：\"></a><strong>成员函数：</strong></h3><pre><code>    |_ 内联成员函数： 类内声明或者inline关键字\n\n    |_类外实现：void 类名称::成员函数名称（）{ }\n</code></pre><h3 id=\"构造函数：\"><a href=\"#构造函数：\" class=\"headerlink\" title=\"构造函数：\"></a><strong>构造函数：</strong></h3><ul>\n<li><p>在创建对象时，自动调用来初始化数据</p>\n</li>\n<li><p>与类名相同</p>\n</li>\n<li><p>构造函数有初始化列表</p>\n</li>\n<li><p>格式 类名（string s, lei i）：s(初始值)，i(初始值){ }；</p>\n</li>\n</ul>\n<h3 id=\"委托构造函数：一个构造函数-通过另一个构造函数-初始化\"><a href=\"#委托构造函数：一个构造函数-通过另一个构造函数-初始化\" class=\"headerlink\" title=\"委托构造函数：一个构造函数 通过另一个构造函数 初始化\"></a><strong>委托构造函数：</strong>一个构造函数 通过另一个构造函数 初始化</h3><h3 id=\"复制构造函数：\"><a href=\"#复制构造函数：\" class=\"headerlink\" title=\"复制构造函数：\"></a><strong>复制构造函数：</strong></h3><p>用途：</p>\n<ul>\n<li><p>用存在的对象 去初始化新对象 （通过引用旧的对象）</p>\n</li>\n<li><p>函数f的形参是类的对象，调用f时，将用实参对象初始化形参对象</p>\n</li>\n<li><p>函数g的返回值是类的对象，用return的对象来在主调函数中初始化一个无名对象</p>\n</li>\n</ul>\n<h3 id=\"析构函数：生存期结束，删除清理工作，不能有return，不能有参数\"><a href=\"#析构函数：生存期结束，删除清理工作，不能有return，不能有参数\" class=\"headerlink\" title=\"析构函数：生存期结束，删除清理工作，不能有return，不能有参数\"></a><strong>析构函数：</strong>生存期结束，删除清理工作，不能有return，不能有参数</h3><pre><code>    class 类名{\n\n    public:\n        类名（形参）； // 构造函数\n        类名（const 类名&amp; 旧对象名）；  // 复制构造函数 =delete是不生成\n        ~ 类名（）；\n    }\n</code></pre><blockquote>\n<p>  注：未声明时，编译器自己生成一个默认的</p>\n</blockquote>\n<h3 id=\"前向引用声明：两个类相互引用时，某个类在引用之前就声明\"><a href=\"#前向引用声明：两个类相互引用时，某个类在引用之前就声明\" class=\"headerlink\" title=\"前向引用声明：两个类相互引用时，某个类在引用之前就声明\"></a><strong>前向引用声明：</strong>两个类相互引用时，某个类在引用之前就声明</h3><pre><code>    class A;  //前向引用声明，只是一个标识符，不是万能的\n    class B{\n    public:\n        void A(B b);\n    }\n\n    class A{\n    public：\n        void B（A a）;\n    }\n</code></pre><h3 id=\"结构体：特殊的类，默认是公有的，可以有函数成员\"><a href=\"#结构体：特殊的类，默认是公有的，可以有函数成员\" class=\"headerlink\" title=\"结构体：特殊的类，默认是公有的，可以有函数成员\"></a><strong>结构体：</strong>特殊的类，默认是公有的，可以有函数成员</h3><pre><code>    //公有成员\n        int a;\n    protected:\n        int b;\n    private:\n        int c;\n    };\n</code></pre><h3 id=\"联合体：\"><a href=\"#联合体：\" class=\"headerlink\" title=\"联合体：\"></a><strong>联合体：</strong></h3><p>目的：存储空间的共用，成员不能同时有效，比如某人语文课成绩，只有一种可能；</p>\n<pre><code>    union Mark{ // 成绩的联合体， 只有一个成立\n        char grade;  //等级类的成绩\n        bool pass;  // 是否通过的成绩\n    int percent;  //百分制成绩  }\n</code></pre><h3 id=\"枚举类：\"><a href=\"#枚举类：\" class=\"headerlink\" title=\"枚举类：\"></a><strong>枚举类：</strong></h3><p>enum class 枚举类型名： 底层类型（int）<strong>{</strong> 枚举列表 <strong>};</strong></p>\n<pre><code>//默认 int\n</code></pre><p>优势：</p>\n<ul>\n<li><p>强制作用域 —必须在枚举类 枚举类型名：：枚举值，不同枚举类可以有同名值了</p>\n</li>\n<li><p>转换限制 —枚举对象不能与整型 隐式转换</p>\n</li>\n<li><p>底层类型 —可以指定</p>\n</li>\n</ul>\n<h2 id=\"数据共享和保护：\"><a href=\"#数据共享和保护：\" class=\"headerlink\" title=\"数据共享和保护：\"></a><strong>数据共享和保护：</strong></h2><h3 id=\"作用域分类：\"><a href=\"#作用域分类：\" class=\"headerlink\" title=\"作用域分类：\"></a><strong>作用域分类：</strong></h3><p>函数原型作用域：</p>\n<ul>\n<li>形参的范围在（）内，所以不需要名字也行，int area( int );</li>\n</ul>\n<p>局部作用域</p>\n<ul>\n<li><p>函数{ }内</p>\n</li>\n<li><p>if、for、while { }内</p>\n</li>\n</ul>\n<p>类作用域： 类外访问类的成员</p>\n<ul>\n<li><p>静态成员：通过 对象名.成员名 访问</p>\n</li>\n<li><p>非静态成员：</p>\n</li>\n<li><p>文件作用域</p>\n</li>\n<li><p>命名空间作用域： 10章</p>\n</li>\n</ul>\n<h3 id=\"对象的生存期：\"><a href=\"#对象的生存期：\" class=\"headerlink\" title=\"对象的生存期：\"></a><strong>对象的生存期：</strong></h3><p>静态生存期： 整个程序结束后消失</p>\n<ul>\n<li>函数内的静态对象， 用static ，全局寿命，只局部可见</li>\n</ul>\n<p>动态生存期：</p>\n<ul>\n<li><p>离开作用域后消失</p>\n</li>\n<li><p>下次进函数重新生成对象</p>\n</li>\n</ul>\n<h3 id=\"类的静态数据成员：\"><a href=\"#类的静态数据成员：\" class=\"headerlink\" title=\"类的静态数据成员：\"></a><strong>类的静态数据成员：</strong></h3><ul>\n<li><p>static 声明</p>\n</li>\n<li><p>为该类所有对象共享，具有静态生存期</p>\n</li>\n<li><p>必须在类外定义和初始化，类内声明，用：：指明所属于的类</p>\n</li>\n</ul>\n<p>比如记录 类产生了多少对象；opencv中的Mat对象好像用到了？？？？</p>\n<pre><code>    class base{   \n        public :   \n               static   int   _num;//声明   \n    };   \n    int  base::_num=0;  //真正定义  \n</code></pre><h3 id=\"类的友元：\"><a href=\"#类的友元：\" class=\"headerlink\" title=\"类的友元：\"></a><strong>类的友元：</strong></h3><ul>\n<li><p>破坏数据封装和数据隐藏的机制</p>\n</li>\n<li><p>尽量不用</p>\n</li>\n</ul>\n<h3 id=\"友元函数：\"><a href=\"#友元函数：\" class=\"headerlink\" title=\" 友元函数：\"></a><strong> 友元函数：</strong></h3><ul>\n<li><p>类声明中由关键字 friend 修饰说明的非成员函数</p>\n</li>\n<li><p>可以在其函数体内访问对象的private,protected成员</p>\n</li>\n<li><p>但必须通过对象名：：访问，函数参数为类的引用</p>\n</li>\n<li><h3 id=\"友元类：\"><a href=\"#友元类：\" class=\"headerlink\" title=\" 友元类：\"></a><strong> 友元类：</strong></h3><pre><code>class A{\n    friend B;\n  public:\n    void display(){\n        count &lt;&lt; x &lt;&lt; enld;\n    }\n  private:\n    int x;\n}\n\nclass B{\n  public:\n    void set(int i);\n    void display();\n  private:\n    A a;\n}\n\nvoid B::set(int i){\n    a.x = i;   // B类中改变 A类私有值\n}\nvoid B::display(){\n    a.display()\n}\n</code></pre></li>\n</ul>\n<h3 id=\"共享数据的保护：\"><a href=\"#共享数据的保护：\" class=\"headerlink\" title=\"共享数据的保护：\"></a><strong>共享数据的保护：</strong></h3><h1 id=\"常类型：const\"><a href=\"#常类型：const\" class=\"headerlink\" title=\"常类型：const\"></a><strong>常类型：</strong>const</h1><p>常对象：必须初始化，不可更新</p>\n<pre><code>    class A{\n    }\n    A const a; // a是常对象\n</code></pre><p>常成员：(不可以放在构造函数体内复制，可以在初始化列表中)</p>\n<pre><code>    A：：A(int i):a(i){ }\n</code></pre><ul>\n<li><p>常数据成员：const修饰的</p>\n</li>\n<li><p>静态常数据成员： static const int b;</p>\n</li>\n<li><p>常函数成员（用来处理常对象的函数）</p>\n<ul>\n<li><p>不更新对象的数据成员</p>\n</li>\n<li><p>声明和实现都带const</p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>        class A{\n            void f（int a）const;\n        }\n        void A::f(int a) const{  \n        }; // f是常对象函数, 处理常对象\n</code></pre><ul>\n<li>常引用：不可更新</li>\n</ul>\n<p>　　　引用是双向传递的，避免修改原值的方法就是常引用；</p>\n<pre><code>     const A&amp; a;\n</code></pre><ul>\n<li><p>常数组：</p>\n</li>\n<li><p>常指针：</p>\n</li>\n</ul>\n<h3 id=\"多文件结构和预编译命令：\"><a href=\"#多文件结构和预编译命令：\" class=\"headerlink\" title=\"多文件结构和预编译命令：\"></a><strong>多文件结构和预编译命令：</strong></h3><ul>\n<li><p>.h 系统使用</p>\n</li>\n<li><p>.hpp 个人使用(类的声明,函数的声明)</p>\n</li>\n<li><p>.cpp (类的实现，函数的实现)</p>\n<p> <img src=\"/2019/01/20/C-梳理笔记/f5d645ed218d5fa3e753f771b72310fc.png\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"外部变量：\"><a href=\"#外部变量：\" class=\"headerlink\" title=\"外部变量：\"></a><strong>外部变量：</strong></h3><p>文件作用域中定义的变量默认是外部变量，其他文件使用前，extern声明</p>\n<p>将变量和函数限制在编译单元内：namespcae:</p>\n<pre><code>    namespace{ //匿名的命名空间，外部不可调用任何东西\n        int i;\n        void fun(){\n            i++;\n        }\n    }\n</code></pre><h3 id=\"预编译命令：\"><a href=\"#预编译命令：\" class=\"headerlink\" title=\"预编译命令：\"></a><strong>预编译命令：</strong></h3><pre><code>    #include&lt; &gt;  标准方式搜索，从系统目录include\n\n\n    #include”” 先当前目录搜索，没有再标准搜索\n\n\n    #define \n\n\n    #undef 删除有#define的宏\n\n    #if 表达式  // 条件编译指令\n    ---\n    #else\n    ---\n    #endif \n\n\n    #ifndef 标识符\n    ---\n    #else  \n    ---\n    #endif\n</code></pre><h2 id=\"数组，指针与字符串：\"><a href=\"#数组，指针与字符串：\" class=\"headerlink\" title=\"数组，指针与字符串：\"></a><strong>数组，指针与字符串：</strong></h2><h3 id=\"数组：\"><a href=\"#数组：\" class=\"headerlink\" title=\"数组：\"></a><strong>数组：</strong></h3><p>定义： <code>int arr**[**m**][**n**]**…;</code></p>\n<p>　　注：二维数组中 arr[1] 第二行首地址</p>\n<h3 id=\"数组作为函数参数：\"><a href=\"#数组作为函数参数：\" class=\"headerlink\" title=\"数组作为函数参数：\"></a><strong>数组作为函数参数：</strong></h3><p>　　数组名做参数： 形参，实参都是数组名，传入的是地址</p>\n<h3 id=\"对象数组：\"><a href=\"#对象数组：\" class=\"headerlink\" title=\"对象数组：\"></a><strong>对象数组：</strong></h3><p>　　定义：类名 数组名[对象元素个数]</p>\n<p>　　访问：数组名[下标].成员名</p>\n<h3 id=\"基于范围的for循环：c-11-自动遍历整个容器\"><a href=\"#基于范围的for循环：c-11-自动遍历整个容器\" class=\"headerlink\" title=\"基于范围的for循环：c++11,自动遍历整个容器\"></a><strong>基于范围的for循环：</strong>c++11,自动遍历整个容器</h3><pre><code>  for( auto x : 容器){ } for( auto &amp;x : 容器){ }\n</code></pre><p>注意：</p>\n<ul>\n<li><p>auto &amp;x是元素引用，auto x是元素的副本</p>\n</li>\n<li><p>auto推导出的类型是容器中的值类型</p>\n</li>\n<li><p>：冒号后的表达式只执行一次</p>\n</li>\n</ul>\n<h3 id=\"指针：\"><a href=\"#指针：\" class=\"headerlink\" title=\"指针：\"></a><strong>指针：</strong></h3><h3 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a><strong>定义：</strong></h3><pre><code>    static int i;\n\n    static int * p = &amp;I;\n</code></pre><h3 id=\"指针的初始化和赋值：\"><a href=\"#指针的初始化和赋值：\" class=\"headerlink\" title=\"指针的初始化和赋值：\"></a><strong>指针的初始化和赋值：</strong></h3><h3 id=\"指针的算术运算，关系运算：\"><a href=\"#指针的算术运算，关系运算：\" class=\"headerlink\" title=\"指针的算术运算，关系运算：\"></a><strong>指针的算术运算，关系运算：</strong></h3><h3 id=\"指针数组：\"><a href=\"#指针数组：\" class=\"headerlink\" title=\"指针数组：\"></a><strong>指针数组：</strong></h3><pre><code>    类名  *p[2];\n</code></pre><h3 id=\"指向数组的指针：\"><a href=\"#指向数组的指针：\" class=\"headerlink\" title=\"指向数组的指针：\"></a><strong>指向数组的指针：</strong></h3><pre><code>    int **p; 指向二维数组的指针\n</code></pre><h3 id=\"指针与函数：\"><a href=\"#指针与函数：\" class=\"headerlink\" title=\"指针与函数：\"></a><strong>指针与函数：</strong></h3><ul>\n<li><p>指针做参数：大批量数据提高效率</p>\n</li>\n<li><p>指针类型的函数：返回类型是指针</p>\n<pre><code>  int * function(int i){return 全局或者静态的 }；// 不能返回非静态局部变量\n</code></pre></li>\n<li><p>指向函数的指针：实现函数回调的功能</p>\n</li>\n</ul>\n<blockquote>\n<p>  定义： 数据类型 (*f)(参数表);</p>\n<p>  数据类型：返回值</p>\n</blockquote>\n<ul>\n<li>对象指针：</li>\n</ul>\n<blockquote>\n<p>  定义： 类名 *对象指针名 = &amp; 对象；</p>\n<p>  访问对象： 对象指针名->成员名</p>\n</blockquote>\n<p>（*对象指针名）.成员名</p>\n<ul>\n<li><p>this 指针：成员函数的一个隐士参数，初始化为对象的地址，不可改变</p>\n</li>\n<li><p>隐含于类的每个非静态成员函数中</p>\n</li>\n<li><p>指出成员函数所操作的当前的对象</p>\n</li>\n<li><p>*this 是当前对象地址</p>\n</li>\n</ul>\n<h3 id=\"动态内存分配：\"><a href=\"#动态内存分配：\" class=\"headerlink\" title=\"动态内存分配：\"></a><strong>动态内存分配：</strong></h3><p>new<strong> 类型名 </strong>(<strong>初始化列表</strong>) // 返回首字节地址</p>\n<p>delete 指针p //p一直在，删除的只是p指向的对象申请的空间</p>\n<p>动态数组：<br>new 类型名[数组长度]</p>\n<p>delete[] 数组首地址p指针</p>\n<h3 id=\"智能指针：C-11\"><a href=\"#智能指针：C-11\" class=\"headerlink\" title=\"智能指针：C++11\"></a><strong>智能指针：</strong>C++11</h3><h3 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a><strong>内存管理</strong></h3><ul>\n<li><p>unique_ptr:</p>\n<ul>\n<li>不允许多个指针共享资源，标准库中move可以转移指针，但原来指针会失效</li>\n</ul>\n</li>\n<li><p>shared_ptr:</p>\n<ul>\n<li>多指针共享</li>\n</ul>\n</li>\n<li><p>weak_ptr:</p>\n<ul>\n<li>可复制共享</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>  Vector对象：类模板</p>\n</blockquote>\n<p>优势：</p>\n<ul>\n<li><p>封装任何形式的动态数组，自动创建，删除</p>\n</li>\n<li><p>下标越界检查</p>\n</li>\n</ul>\n<p>定义： vector &lt;元素类型&gt; object（长度）</p>\n<ul>\n<li><p><code>object.begin()  object.end()  object.size()</code></p>\n</li>\n<li><p>auto 遍历vector <code>for(auto e: object);</code></p>\n</li>\n</ul>\n<h3 id=\"对象的复制和移动：\"><a href=\"#对象的复制和移动：\" class=\"headerlink\" title=\"对象的复制和移动：\"></a><strong>对象的复制和移动：</strong></h3><ul>\n<li><p>浅层复制和深层复制：复制对象用到复制构造函数，默认的复制构造只传递了指针，两个变量指向同一块内存，释放其中一个，再释放第二个会出错；</p>\n<ul>\n<li><p>浅层：实现对象间数据一一对应的复制，但两个对象指向同一内存</p>\n</li>\n<li><p>深层：当对象成员是指针类型，应该对指针所指对象进行复制。</p>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>  类名<strong>::</strong>类名<strong>(</strong>const 类名<strong>&amp;</strong> v<strong>){</strong></p>\n<p>  size <strong>=</strong> v<strong>.</strong>size<strong>;</strong></p>\n<p>  data_ptr <strong>= new</strong> Ponit<strong>[</strong>size<strong>];</strong></p>\n<p>  <strong>for(</strong>int i<strong>=</strong>0<strong>;</strong> i <strong>\\&lt;</strong> size<strong>; ++</strong>i<strong>){</strong></p>\n<p>  data_ptr<strong>[</strong>i<strong>] =</strong> v<strong>.</strong>data_ptr<strong>[</strong>i<strong>];</strong></p>\n<p>  <strong>}</strong></p>\n<p>  <strong>}</strong></p>\n</blockquote>\n<ul>\n<li><p>移动构造：C++11,省去了构造和删除临时对象的过程</p>\n<p><img src=\"/2019/01/20/C-梳理笔记/8c3092d99bcdba78edeb2d8123270ffe.png\" alt=\"\"></p>\n</li>\n</ul>\n<blockquote>\n<p>  class_name<strong>(</strong>class_name <strong>&amp;&amp;</strong>old<strong>)::</strong>xptr<strong>(</strong>old<strong>.</strong>xptr<strong>){</strong></p>\n<p>  n<strong>.</strong>xptr <strong>= NULL;</strong> // 原来的指针清空</p>\n<p>  <strong>}</strong></p>\n</blockquote>\n<h3 id=\"C风格字符串：字符数组\"><a href=\"#C风格字符串：字符数组\" class=\"headerlink\" title=\"C风格字符串：字符数组\"></a><strong>C风格字符串：</strong>字符数组</h3><h3 id=\"string类：\"><a href=\"#string类：\" class=\"headerlink\" title=\"string类：\"></a><strong>string类：</strong></h3><p>常用构造函数：</p>\n<ul>\n<li><p>string(); //默认构造，长度为0</p>\n<ul>\n<li>string s1<strong>;</strong></li>\n</ul>\n</li>\n<li><p>string(const char *s) //指针s所指向的字符串常量初始化该对象</p>\n<pre><code>string s2 = “abc”;\n\nstring(const string &amp;rhs) //复制构造函数\n\nstring s3 = s2;\n</code></pre></li>\n</ul>\n<p>访问：下标访问</p>\n<p>整行字符串的输入： cin 被空格隔开</p>\n<p>getline(cin,s2); //包含#include\\<string\\></string\\></p>\n<p>getline(cin,s2,’,’);</p>\n<h2 id=\"继承和派生：-充分利用原有的\"><a href=\"#继承和派生：-充分利用原有的\" class=\"headerlink\" title=\"继承和派生： 充分利用原有的\"></a><strong>继承和派生：</strong> 充分利用原有的</h2><p>继承：保持已有类的特征来构造新类</p>\n<p>派生：在已有类基础上新增自己的特性</p>\n<p>基类：父类</p>\n<p>派生类：子类</p>\n<p>直接基类和间接基类</p>\n<p>单继承：</p>\n<pre><code>class 派生类名：继承方式 基类名{  //继承方式，\n    成员声明；//新增成员的声明\n}\n</code></pre><p>多继承：</p>\n<pre><code>class 派生类名：继承方式1 基类1，继承方式2 基类2{\n    成员声明；\n}\n</code></pre><h3 id=\"继承的方式：\"><a href=\"#继承的方式：\" class=\"headerlink\" title=\"继承的方式：\"></a><strong>继承的方式：</strong></h3><p>控制：派生类对基类成员的访问权限</p>\n<ul>\n<li>公有继承 public</li>\n</ul>\n<blockquote>\n<p>  基类中的pubilc和protected访问属性在派生类中不变</p>\n<p>  基类的pravate不可被对象直接访问</p>\n</blockquote>\n<ul>\n<li><p>私有继承 ：内部可以访问基类的公有和保护成员，但是其对象不再可以访问</p>\n</li>\n<li><p>保护继承 ：基类的公有和保护，到这都成了保护成员，类内可以访问，但对象不能</p>\n</li>\n</ul>\n<p>派生类的构成：</p>\n<ul>\n<li><p>吸收基类成员</p>\n</li>\n<li><p>改造基类成员</p>\n<ul>\n<li>增加同名成员，基类成员被覆盖（重新定义继承的成员函数必须用虚函数）</li>\n</ul>\n</li>\n<li><p>添加新成员</p>\n</li>\n</ul>\n<h3 id=\"类型转换：-1\"><a href=\"#类型转换：-1\" class=\"headerlink\" title=\"类型转换：\"></a><strong>类型转换：</strong></h3><p>基类和派生类之间：</p>\n<p>派生类的对象可以隐含转换为基类对象；</p>\n<p>派生类的对象可以初始化基类的引用；</p>\n<p>派生类的指针可以隐含转换为基类的指针；</p>\n<h3 id=\"派生类的构造函数：\"><a href=\"#派生类的构造函数：\" class=\"headerlink\" title=\"派生类的构造函数：\"></a><strong>派生类的构造函数：</strong></h3><p>默认情况下，基类的构造函数不被继承，派生类需要自己构造</p>\n<p>c++11，using语句继承基类构造函数</p>\n<h3 id=\"派生类的复制构造函数：\"><a href=\"#派生类的复制构造函数：\" class=\"headerlink\" title=\"派生类的复制构造函数：\"></a><strong>派生类的复制构造函数：</strong></h3><h3 id=\"派生类的析构函数：\"><a href=\"#派生类的析构函数：\" class=\"headerlink\" title=\"派生类的析构函数：\"></a><strong>派生类的析构函数：</strong></h3><h3 id=\"虚基类：\"><a href=\"#虚基类：\" class=\"headerlink\" title=\"虚基类：\"></a><strong>虚基类：</strong></h3><h2 id=\"多态性\"><a href=\"#多态性\" class=\"headerlink\" title=\"多态性\"></a><strong>多态性</strong></h2><h3 id=\"运算符重载：\"><a href=\"#运算符重载：\" class=\"headerlink\" title=\"运算符重载：\"></a><strong>运算符重载：</strong></h3><pre><code>//双目运算符\n函数类型 operator 运算符（参数）  \n{\n    // 参数个数 = 原操作数个数 - 1\n}\n//前置单目运算符，返回引用所以可以当左值\n函数类型 &amp; operator ++（无参数）  \n{\n    return * this;\n}\n//后置单目运算符，\n函数类型 operator ++（参数为int类型）  \n{\n    old = *this;\n    ++(*this);  //调用的前置\n    return old;\n}\n</code></pre><ul>\n<li>重载为非成员函数：</li>\n</ul>\n<ol>\n<li><p>列出所有操作数</p>\n</li>\n<li><p>至少有一个自定义类型参数</p>\n</li>\n<li><p>后置单目运算，参数要增加int,但不用写形参名</p>\n</li>\n<li><p>要操作某类对象的私有成员，则可声明为该类的友元函数</p>\n</li>\n</ol>\n<h3 id=\"虚函数：virtual改造基类成员，实现动态绑定；必须是非静态成员\"><a href=\"#虚函数：virtual改造基类成员，实现动态绑定；必须是非静态成员\" class=\"headerlink\" title=\"虚函数：virtual改造基类成员，实现动态绑定；必须是非静态成员\"></a><strong>虚函数：</strong>virtual改造基类成员，实现动态绑定；必须是非静态成员</h3><blockquote>\n<p>  原理：编译时先不确定和哪个类的成员对应，在程序运行时刻，再对应；</p>\n</blockquote>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nclass Base1{\npublic:\n    virtual void display() const; //虚函数，不要用内联\n};\n\nvoid Base1::display() const{\n    cout &lt;&lt; &quot;Base1 &quot; &lt;&lt; endl;\n}\n\nclass Base2:public Base1{\npublic:\n    virtual void display() const;\n}\nvoid Base2::display() const{\n    cout &lt;&lt; &quot;Base2&quot; &lt;&lt; endl;\n}\n</code></pre><h3 id=\"虚析构函数：打算通过基类指针调用某一个对象的析构函数（执行delete）\"><a href=\"#虚析构函数：打算通过基类指针调用某一个对象的析构函数（执行delete）\" class=\"headerlink\" title=\"虚析构函数：打算通过基类指针调用某一个对象的析构函数（执行delete）\"></a><strong>虚析构函数：</strong>打算通过基类指针调用某一个对象的析构函数（执行delete）</h3><h3 id=\"虚表和动态绑定：\"><a href=\"#虚表和动态绑定：\" class=\"headerlink\" title=\"虚表和动态绑定：\"></a><strong>虚表和动态绑定：</strong></h3><blockquote>\n<p>  虚表：</p>\n</blockquote>\n<ul>\n<li><p>每个多态类都有虚表；</p>\n</li>\n<li><p>存放各个数函数的入口地址；</p>\n</li>\n<li><p>每个对象有指向当前类的虚表的指针（虚指针vptr）；</p>\n</li>\n</ul>\n<blockquote>\n<p>  动态绑定：</p>\n</blockquote>\n<ul>\n<li>构造函数为对象的虚指针赋值</li>\n</ul>\n<h3 id=\"抽象类：含有纯虚函数的类-不能直接定义对象\"><a href=\"#抽象类：含有纯虚函数的类-不能直接定义对象\" class=\"headerlink\" title=\"抽象类：含有纯虚函数的类,不能直接定义对象\"></a><strong>抽象类：</strong>含有纯虚函数的类,不能直接定义对象</h3><blockquote>\n<p>  纯虚函数：</p>\n<p>  基类中声明的虚函数，在基类中没有定义具体的操作，要求在派生类中根据实际需求完</p>\n<p>  成自己的版本：</p>\n</blockquote>\n<pre><code>virtual 函数类型 函数名**(**参数名**) =** 0**;**\n</code></pre><h3 id=\"override-和-final-C-11\"><a href=\"#override-和-final-C-11\" class=\"headerlink\" title=\"override 和 final :C++11\"></a><strong>override 和 final :</strong>C++11</h3><p>override声明的函数，必须在基类中找到原型；</p>\n<p>final 不允许继承或者覆盖；</p>\n<h2 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a><strong>模板</strong></h2><h3 id=\"函数魔板：整数和浮点数求绝对值，需要多次重载函数，但是用函数模板，只需要设计通用功能；\"><a href=\"#函数魔板：整数和浮点数求绝对值，需要多次重载函数，但是用函数模板，只需要设计通用功能；\" class=\"headerlink\" title=\"函数魔板：整数和浮点数求绝对值，需要多次重载函数，但是用函数模板，只需要设计通用功能；\"></a><strong>函数魔板：</strong>整数和浮点数求绝对值，需要多次重载函数，但是用函数模板，只需要设计通用功能；</h3><p>template\\&lt;模板参数表> // 类型：class或者typename 常量：</p>\n<p>函数定义</p>\n<pre><code>template&lt;typename T&gt;\nT abs(T x){\n    return x&lt;0?-x:x;\n}\n</code></pre><h3 id=\"类模板：\"><a href=\"#类模板：\" class=\"headerlink\" title=\"类模板：\"></a><strong>类模板：</strong></h3><pre><code>template&lt;模板参数表&gt;\nclass 类名{\n    类成员声明;\n}\n\n//类成员定义\ntemplate &lt;模板参数表&gt;\n类型名  类名&lt;模板参数标识符列表&gt; :: 函数名(参数表)\n{\n\n}\n</code></pre><h3 id=\"线性群体：按位置顺序有序排列\"><a href=\"#线性群体：按位置顺序有序排列\" class=\"headerlink\" title=\"线性群体：按位置顺序有序排列\"></a><strong>线性群体：</strong>按位置顺序有序排列</h3><p>直接访问：</p>\n<p>数组类模板：</p>\n<p>索引访问：</p>\n<p>顺序访问：</p>\n<p>链表类和结点类模板：</p>\n<p>单链表：每个结点包括数据和指针，只有一个指向后续结点的称为单链表；</p>\n<p><img src=\"/2019/01/20/C-梳理笔记/9167a427f849e864c5d630d0c0bc3163.png\" alt=\"\"></p>\n<p>单链表结点类模板：</p>\n<pre><code>template &lt;class T&gt;\nclass Node{\n    private:\n        Node&lt;T&gt; *next;\n    public:\n        T data; \n        Node(const T&amp;item,Node&lt;T&gt;* next = 0);  //构造函数\n    void insertAfter(Node&lt;T&gt; *p); //插入\n    Node&lt;T&gt; *deleteAfter();  //删除\n    Node&lt;T&gt; *nextNode() const; \n}\n\ntemplate &lt;class T&gt;\nvoid Node&lt;T&gt;::insertAfter(Node&lt;T&gt; *p){  // *p是要插入的结点\n// p节点的指针指向当前节点的后续结点\n    p-&gt;next = next; // next是原链表待插入位置的结点的指针\n    next = p;  \n}\ntemplate &lt;class T&gt;\nNode&lt;T&gt; *deleteAfter(){\n    Node&lt;T&gt; * tempPtr = next;\n    if (next == NULL)  //判断是否是删除最后的元素\n        return 0;\n    next = tempPtr = next;\n    return tempPtr;\n}\n</code></pre><blockquote>\n<p>  插入：</p>\n</blockquote>\n<p><img src=\"/2019/01/20/C-梳理笔记/85d072d9c8a8366378b00b9af8ca4920.png\" alt=\"\"></p>\n<blockquote>\n<p>  头插法：可以当队列</p>\n<p>  尾插法：栈</p>\n<p>  删除：</p>\n</blockquote>\n<p><img src=\"/2019/01/20/C-梳理笔记/ffdd5c0226d2a3f9a7833379eb0ebf90.png\" alt=\"\"></p>\n<p>待查询：</p>\n<p>explicit关键字</p>\n<p>构造函数 explicit可以抑制内置类型隐式转换</p>\n<h2 id=\"泛型设计\"><a href=\"#泛型设计\" class=\"headerlink\" title=\"泛型设计\"></a><strong>泛型设计</strong></h2><p>基本概念：</p>\n<p>编写不依赖具体数据类型的程序，通用的；</p>\n<p>STL简介：(Standard Template Library)</p>\n<p>C++ string类库入门：</p>\n<pre><code>#include &lt;iostream&gt;\n\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n\n    // 构造函数：\n    string str1 = &quot;Yesterday&quot;;\n\n    string str2(&quot;Today&quot;);\n\n    string str3(&quot;Hello&quot;,2); //取c风格字符串 长度为 2 作为初值，即&quot;He&quot;\n\n    string str4(str1, 6); // 始于位置6开始的字符串，即&quot;day&quot;\n\n    string str5(str1,6,1); // 始于6，长度1，即&quot;d&quot;\n\n    string str6(1,&#39;a&#39;); //6个&#39;a&#39;\n\n    // 赋值，交换\n    str1.assign(&quot;hahahaha&quot;); //重新赋值\n\n    swap(str1,str2); //交换两个字符串内容 str1=&quot;Today&quot; str2=&quot;hahahaha&quot;\n\n    // 追加\n    str1 += &quot; we&quot;; // += 可追加 string对象，字符串，字符\n\n    str1.append(&quot; ar&quot;); // append 可追加 string对象，字符串\n\n    str1.push_back(&#39;e&#39;); //push_back 只能追加字符 str1 = &quot;Today we are&quot;\n\n    // 插入\n    str1.insert(0,&quot; family&quot;); //str1 = &quot;Today we are family&quot;\n\n    // 删除\n    str1.erase(2,1); //第2个位置开始， len = 1 个字符\n\n    str1.clear(); //删除全部\n\n    // 访问字符串\n    string s = &quot;asdfgh&quot;;\n\n    cout &lt;&lt; s[1]; // &#39;s&#39;\n\n    cout &lt;&lt; s.at(2); // &#39;d&#39;\n\n    // 查找\n    int position = s.find(&#39;f&#39;,0); // 从0开始查找第一次出现‘f’的坐标\n\n    // 替换\n    s.replace(s.find(&#39;f&#39;),3,&quot;ZZZ&quot;); //替换find的位置处\n    3个字符串为 “ZZZ”\n\n    // 分割\n    getchar();\n\n    return 0;\n\n}\n</code></pre>"},{"title":"Deep Residual Learning for Image Recognition","date":"2019-01-25T14:19:29.000Z","copyright":true,"top":null,"_content":"`2015年` 论文地址：  [https://arxiv.org/pdf/1512.03385.pdf](https://arxiv.org/pdf/1512.03385.pdf\"论文地址\")\n\n## 通常情况下\n\n1. 神经网络层越深，特征的抽象程度越高，模型的表达能力越强，语义信息越丰富；\n2. 同时，网络越深，`退化问题` 越难解决;\n\n## 退化问题是网络加深的障碍\n　　简单的增加深度，会导致 `梯度弥散` 或者 `梯度爆炸` ,可以通过标准初始化和中间层正则化（batchNorm）解决；但是随着继续增加深度，训练集准确率饱和，甚至下降（` 退化问题 `，不属于过拟合）。\n\n![logo](Deep-Residual-Learning-for-Image-Recognition/resnet1.png)\n\n　　神经网络就像一个｀Function Set｀，网络是输入 x 到输出 out 的映射关系 F，`out = F(x)` ，所以网络层越深，这个 `Set` 包含的函数越复杂，那能够拟合的情况就更多（意思是解决的问题就更多），上图是作者在`CIFAR-10` 数据集上的对比实验，56层网络是在20层网络上的重复叠加（最差也应该是前22层的恒等映射），但是较深网络训练集的误差却比浅层网络的误差更大。这不是过拟合了，过深网络出现了 `退化问题`。\n\n## 本文效果（很大程度上解决了退化问题）：\n\n1. 作者在ImageNet上实验了一个152层的残差网络，比VGG深8倍，取得了3.57%的错误率。\n2. 作者通过一系列实验证明了表示的深度（即网络的深度）对很多视觉识别任务都至关重要。仅仅由于使用了非常深的网络，作者就在COCO目标检测数据集上获得了28%的相对提升。\n\n## 本文怎么解决退化问题？\n\n### Resnet 结构分析\n\n#### ResNet 短连接块\n![logo](Deep-Residual-Learning-for-Image-Recognition/resnet2.png)\n作者在《Identity Mapping in Deep Residual Networks 》一文中，推导了为什么短连接更容易训练，也提出了新的短连接块结构。\n#### 为什么 ResNet build block 更容易训练？ \n##### 前向传播中帮助网络中一些层更容易实现恒等映射：\n\n　　***出现了第一幅图的退化问题，这里假设深层网络的后边层都变成了<font color=red >恒等映射 </font>，那网络就退化成了浅层网络***（因为网络很深，所以其中肯定包括了多余的层，这些层会形成<font color=red >恒等映射 </font>关系），原来的直接多个层堆叠的非线性层去直接学习<font color=red> 恒等映射 </font>优化起来复杂，而加了上图的 `短连接`块之后，学习<font color=red> 恒等映射 </font>变容易了。\n##### 反向传播中\n>　　因为网络中存在`恒等映射的短连接通道`，假设不加residual模块的输出为h(x)。x=10,h(x)=11,h(x)简化为线性运算Wh​, Wh明显为1.1，加了redidual模块后，F(x)=1, H(x)=F(x)+x=11，F也简化为线性运算,对应的WF为0.1。当标签中的真实值为12，反向传播的损失为1，而对于F中的参数和h中参数回传的损失实际上是一样大的而且梯度都是x的值，但是对于F的参数就从0.1到1.1扩大了十倍多，而h的参数是从1.1到2.1扩大不到2倍，因此redidual模块会明显减小模块中参数的值从而让网络中的参数对反向传导的损失值有更敏感的响应能力，虽然根本上没有解决回传的损失小得问题，但是却让参数减小，相对而言增加了回传损失的效果，也产生了一定的正则化作用。 \n[https://blog.csdn.net/weixin_43624538/article/details/85049699?from=timeline&isappinstalled=0](https://blog.csdn.net/weixin_43624538/article/details/85049699?from=timeline&isappinstalled=0\"该部分参考这里\")\n\n\n","source":"_posts/Deep-Residual-Learning-for-Image-Recognition.md","raw":"---\ntitle: Deep Residual Learning for Image Recognition\ndate: 2019-01-25 22:19:29\ncategories: 计算机视觉论文阅读\ntags: 深度学习论文\ncopyright: true\ntop:\n---\n`2015年` 论文地址：  [https://arxiv.org/pdf/1512.03385.pdf](https://arxiv.org/pdf/1512.03385.pdf\"论文地址\")\n\n## 通常情况下\n\n1. 神经网络层越深，特征的抽象程度越高，模型的表达能力越强，语义信息越丰富；\n2. 同时，网络越深，`退化问题` 越难解决;\n\n## 退化问题是网络加深的障碍\n　　简单的增加深度，会导致 `梯度弥散` 或者 `梯度爆炸` ,可以通过标准初始化和中间层正则化（batchNorm）解决；但是随着继续增加深度，训练集准确率饱和，甚至下降（` 退化问题 `，不属于过拟合）。\n\n![logo](Deep-Residual-Learning-for-Image-Recognition/resnet1.png)\n\n　　神经网络就像一个｀Function Set｀，网络是输入 x 到输出 out 的映射关系 F，`out = F(x)` ，所以网络层越深，这个 `Set` 包含的函数越复杂，那能够拟合的情况就更多（意思是解决的问题就更多），上图是作者在`CIFAR-10` 数据集上的对比实验，56层网络是在20层网络上的重复叠加（最差也应该是前22层的恒等映射），但是较深网络训练集的误差却比浅层网络的误差更大。这不是过拟合了，过深网络出现了 `退化问题`。\n\n## 本文效果（很大程度上解决了退化问题）：\n\n1. 作者在ImageNet上实验了一个152层的残差网络，比VGG深8倍，取得了3.57%的错误率。\n2. 作者通过一系列实验证明了表示的深度（即网络的深度）对很多视觉识别任务都至关重要。仅仅由于使用了非常深的网络，作者就在COCO目标检测数据集上获得了28%的相对提升。\n\n## 本文怎么解决退化问题？\n\n### Resnet 结构分析\n\n#### ResNet 短连接块\n![logo](Deep-Residual-Learning-for-Image-Recognition/resnet2.png)\n作者在《Identity Mapping in Deep Residual Networks 》一文中，推导了为什么短连接更容易训练，也提出了新的短连接块结构。\n#### 为什么 ResNet build block 更容易训练？ \n##### 前向传播中帮助网络中一些层更容易实现恒等映射：\n\n　　***出现了第一幅图的退化问题，这里假设深层网络的后边层都变成了<font color=red >恒等映射 </font>，那网络就退化成了浅层网络***（因为网络很深，所以其中肯定包括了多余的层，这些层会形成<font color=red >恒等映射 </font>关系），原来的直接多个层堆叠的非线性层去直接学习<font color=red> 恒等映射 </font>优化起来复杂，而加了上图的 `短连接`块之后，学习<font color=red> 恒等映射 </font>变容易了。\n##### 反向传播中\n>　　因为网络中存在`恒等映射的短连接通道`，假设不加residual模块的输出为h(x)。x=10,h(x)=11,h(x)简化为线性运算Wh​, Wh明显为1.1，加了redidual模块后，F(x)=1, H(x)=F(x)+x=11，F也简化为线性运算,对应的WF为0.1。当标签中的真实值为12，反向传播的损失为1，而对于F中的参数和h中参数回传的损失实际上是一样大的而且梯度都是x的值，但是对于F的参数就从0.1到1.1扩大了十倍多，而h的参数是从1.1到2.1扩大不到2倍，因此redidual模块会明显减小模块中参数的值从而让网络中的参数对反向传导的损失值有更敏感的响应能力，虽然根本上没有解决回传的损失小得问题，但是却让参数减小，相对而言增加了回传损失的效果，也产生了一定的正则化作用。 \n[https://blog.csdn.net/weixin_43624538/article/details/85049699?from=timeline&isappinstalled=0](https://blog.csdn.net/weixin_43624538/article/details/85049699?from=timeline&isappinstalled=0\"该部分参考这里\")\n\n\n","slug":"Deep-Residual-Learning-for-Image-Recognition","published":1,"updated":"2020-02-20T04:41:37.801Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephbn0004t8pl558v4eai","content":"<p><code>2015年</code> 论文地址：  <a href=\"https://arxiv.org/pdf/1512.03385.pdf&quot;论文地址&quot;\" target=\"_blank\" rel=\"noopener\">https://arxiv.org/pdf/1512.03385.pdf</a></p>\n<h2 id=\"通常情况下\"><a href=\"#通常情况下\" class=\"headerlink\" title=\"通常情况下\"></a>通常情况下</h2><ol>\n<li>神经网络层越深，特征的抽象程度越高，模型的表达能力越强，语义信息越丰富；</li>\n<li>同时，网络越深，<code>退化问题</code> 越难解决;</li>\n</ol>\n<h2 id=\"退化问题是网络加深的障碍\"><a href=\"#退化问题是网络加深的障碍\" class=\"headerlink\" title=\"退化问题是网络加深的障碍\"></a>退化问题是网络加深的障碍</h2><p>　　简单的增加深度，会导致 <code>梯度弥散</code> 或者 <code>梯度爆炸</code> ,可以通过标准初始化和中间层正则化（batchNorm）解决；但是随着继续增加深度，训练集准确率饱和，甚至下降（<code>退化问题</code>，不属于过拟合）。</p>\n<p><img src=\"/2019/01/25/Deep-Residual-Learning-for-Image-Recognition/resnet1.png\" alt=\"logo\"></p>\n<p>　　神经网络就像一个｀Function Set｀，网络是输入 x 到输出 out 的映射关系 F，<code>out = F(x)</code> ，所以网络层越深，这个 <code>Set</code> 包含的函数越复杂，那能够拟合的情况就更多（意思是解决的问题就更多），上图是作者在<code>CIFAR-10</code> 数据集上的对比实验，56层网络是在20层网络上的重复叠加（最差也应该是前22层的恒等映射），但是较深网络训练集的误差却比浅层网络的误差更大。这不是过拟合了，过深网络出现了 <code>退化问题</code>。</p>\n<h2 id=\"本文效果（很大程度上解决了退化问题）：\"><a href=\"#本文效果（很大程度上解决了退化问题）：\" class=\"headerlink\" title=\"本文效果（很大程度上解决了退化问题）：\"></a>本文效果（很大程度上解决了退化问题）：</h2><ol>\n<li>作者在ImageNet上实验了一个152层的残差网络，比VGG深8倍，取得了3.57%的错误率。</li>\n<li>作者通过一系列实验证明了表示的深度（即网络的深度）对很多视觉识别任务都至关重要。仅仅由于使用了非常深的网络，作者就在COCO目标检测数据集上获得了28%的相对提升。</li>\n</ol>\n<h2 id=\"本文怎么解决退化问题？\"><a href=\"#本文怎么解决退化问题？\" class=\"headerlink\" title=\"本文怎么解决退化问题？\"></a>本文怎么解决退化问题？</h2><h3 id=\"Resnet-结构分析\"><a href=\"#Resnet-结构分析\" class=\"headerlink\" title=\"Resnet 结构分析\"></a>Resnet 结构分析</h3><h4 id=\"ResNet-短连接块\"><a href=\"#ResNet-短连接块\" class=\"headerlink\" title=\"ResNet 短连接块\"></a>ResNet 短连接块</h4><p><img src=\"/2019/01/25/Deep-Residual-Learning-for-Image-Recognition/resnet2.png\" alt=\"logo\"><br>作者在《Identity Mapping in Deep Residual Networks 》一文中，推导了为什么短连接更容易训练，也提出了新的短连接块结构。</p>\n<h4 id=\"为什么-ResNet-build-block-更容易训练？\"><a href=\"#为什么-ResNet-build-block-更容易训练？\" class=\"headerlink\" title=\"为什么 ResNet build block 更容易训练？\"></a>为什么 ResNet build block 更容易训练？</h4><h5 id=\"前向传播中帮助网络中一些层更容易实现恒等映射：\"><a href=\"#前向传播中帮助网络中一些层更容易实现恒等映射：\" class=\"headerlink\" title=\"前向传播中帮助网络中一些层更容易实现恒等映射：\"></a>前向传播中帮助网络中一些层更容易实现恒等映射：</h5><p>　　<strong><em>出现了第一幅图的退化问题，这里假设深层网络的后边层都变成了<font color=\"red\">恒等映射 </font>，那网络就退化成了浅层网络</em></strong>（因为网络很深，所以其中肯定包括了多余的层，这些层会形成<font color=\"red\">恒等映射 </font>关系），原来的直接多个层堆叠的非线性层去直接学习<font color=\"red\"> 恒等映射 </font>优化起来复杂，而加了上图的 <code>短连接</code>块之后，学习<font color=\"red\"> 恒等映射 </font>变容易了。</p>\n<h5 id=\"反向传播中\"><a href=\"#反向传播中\" class=\"headerlink\" title=\"反向传播中\"></a>反向传播中</h5><blockquote>\n<p>　　因为网络中存在<code>恒等映射的短连接通道</code>，假设不加residual模块的输出为h(x)。x=10,h(x)=11,h(x)简化为线性运算Wh​, Wh明显为1.1，加了redidual模块后，F(x)=1, H(x)=F(x)+x=11，F也简化为线性运算,对应的WF为0.1。当标签中的真实值为12，反向传播的损失为1，而对于F中的参数和h中参数回传的损失实际上是一样大的而且梯度都是x的值，但是对于F的参数就从0.1到1.1扩大了十倍多，而h的参数是从1.1到2.1扩大不到2倍，因此redidual模块会明显减小模块中参数的值从而让网络中的参数对反向传导的损失值有更敏感的响应能力，虽然根本上没有解决回传的损失小得问题，但是却让参数减小，相对而言增加了回传损失的效果，也产生了一定的正则化作用。<br><a href=\"https://blog.csdn.net/weixin_43624538/article/details/85049699?from=timeline&amp;isappinstalled=0&quot;该部分参考这里&quot;\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_43624538/article/details/85049699?from=timeline&amp;isappinstalled=0</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p><code>2015年</code> 论文地址：  <a href=\"https://arxiv.org/pdf/1512.03385.pdf&quot;论文地址&quot;\" target=\"_blank\" rel=\"noopener\">https://arxiv.org/pdf/1512.03385.pdf</a></p>\n<h2 id=\"通常情况下\"><a href=\"#通常情况下\" class=\"headerlink\" title=\"通常情况下\"></a>通常情况下</h2><ol>\n<li>神经网络层越深，特征的抽象程度越高，模型的表达能力越强，语义信息越丰富；</li>\n<li>同时，网络越深，<code>退化问题</code> 越难解决;</li>\n</ol>\n<h2 id=\"退化问题是网络加深的障碍\"><a href=\"#退化问题是网络加深的障碍\" class=\"headerlink\" title=\"退化问题是网络加深的障碍\"></a>退化问题是网络加深的障碍</h2><p>　　简单的增加深度，会导致 <code>梯度弥散</code> 或者 <code>梯度爆炸</code> ,可以通过标准初始化和中间层正则化（batchNorm）解决；但是随着继续增加深度，训练集准确率饱和，甚至下降（<code>退化问题</code>，不属于过拟合）。</p>\n<p><img src=\"/2019/01/25/Deep-Residual-Learning-for-Image-Recognition/resnet1.png\" alt=\"logo\"></p>\n<p>　　神经网络就像一个｀Function Set｀，网络是输入 x 到输出 out 的映射关系 F，<code>out = F(x)</code> ，所以网络层越深，这个 <code>Set</code> 包含的函数越复杂，那能够拟合的情况就更多（意思是解决的问题就更多），上图是作者在<code>CIFAR-10</code> 数据集上的对比实验，56层网络是在20层网络上的重复叠加（最差也应该是前22层的恒等映射），但是较深网络训练集的误差却比浅层网络的误差更大。这不是过拟合了，过深网络出现了 <code>退化问题</code>。</p>\n<h2 id=\"本文效果（很大程度上解决了退化问题）：\"><a href=\"#本文效果（很大程度上解决了退化问题）：\" class=\"headerlink\" title=\"本文效果（很大程度上解决了退化问题）：\"></a>本文效果（很大程度上解决了退化问题）：</h2><ol>\n<li>作者在ImageNet上实验了一个152层的残差网络，比VGG深8倍，取得了3.57%的错误率。</li>\n<li>作者通过一系列实验证明了表示的深度（即网络的深度）对很多视觉识别任务都至关重要。仅仅由于使用了非常深的网络，作者就在COCO目标检测数据集上获得了28%的相对提升。</li>\n</ol>\n<h2 id=\"本文怎么解决退化问题？\"><a href=\"#本文怎么解决退化问题？\" class=\"headerlink\" title=\"本文怎么解决退化问题？\"></a>本文怎么解决退化问题？</h2><h3 id=\"Resnet-结构分析\"><a href=\"#Resnet-结构分析\" class=\"headerlink\" title=\"Resnet 结构分析\"></a>Resnet 结构分析</h3><h4 id=\"ResNet-短连接块\"><a href=\"#ResNet-短连接块\" class=\"headerlink\" title=\"ResNet 短连接块\"></a>ResNet 短连接块</h4><p><img src=\"/2019/01/25/Deep-Residual-Learning-for-Image-Recognition/resnet2.png\" alt=\"logo\"><br>作者在《Identity Mapping in Deep Residual Networks 》一文中，推导了为什么短连接更容易训练，也提出了新的短连接块结构。</p>\n<h4 id=\"为什么-ResNet-build-block-更容易训练？\"><a href=\"#为什么-ResNet-build-block-更容易训练？\" class=\"headerlink\" title=\"为什么 ResNet build block 更容易训练？\"></a>为什么 ResNet build block 更容易训练？</h4><h5 id=\"前向传播中帮助网络中一些层更容易实现恒等映射：\"><a href=\"#前向传播中帮助网络中一些层更容易实现恒等映射：\" class=\"headerlink\" title=\"前向传播中帮助网络中一些层更容易实现恒等映射：\"></a>前向传播中帮助网络中一些层更容易实现恒等映射：</h5><p>　　<strong><em>出现了第一幅图的退化问题，这里假设深层网络的后边层都变成了<font color=\"red\">恒等映射 </font>，那网络就退化成了浅层网络</em></strong>（因为网络很深，所以其中肯定包括了多余的层，这些层会形成<font color=\"red\">恒等映射 </font>关系），原来的直接多个层堆叠的非线性层去直接学习<font color=\"red\"> 恒等映射 </font>优化起来复杂，而加了上图的 <code>短连接</code>块之后，学习<font color=\"red\"> 恒等映射 </font>变容易了。</p>\n<h5 id=\"反向传播中\"><a href=\"#反向传播中\" class=\"headerlink\" title=\"反向传播中\"></a>反向传播中</h5><blockquote>\n<p>　　因为网络中存在<code>恒等映射的短连接通道</code>，假设不加residual模块的输出为h(x)。x=10,h(x)=11,h(x)简化为线性运算Wh​, Wh明显为1.1，加了redidual模块后，F(x)=1, H(x)=F(x)+x=11，F也简化为线性运算,对应的WF为0.1。当标签中的真实值为12，反向传播的损失为1，而对于F中的参数和h中参数回传的损失实际上是一样大的而且梯度都是x的值，但是对于F的参数就从0.1到1.1扩大了十倍多，而h的参数是从1.1到2.1扩大不到2倍，因此redidual模块会明显减小模块中参数的值从而让网络中的参数对反向传导的损失值有更敏感的响应能力，虽然根本上没有解决回传的损失小得问题，但是却让参数减小，相对而言增加了回传损失的效果，也产生了一定的正则化作用。<br><a href=\"https://blog.csdn.net/weixin_43624538/article/details/85049699?from=timeline&amp;isappinstalled=0&quot;该部分参考这里&quot;\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_43624538/article/details/85049699?from=timeline&amp;isappinstalled=0</a></p>\n</blockquote>\n"},{"title":"Java 向上转型&向下转型","date":"2020-04-22T03:53:28.000Z","_content":"\n\n\n# 向上转型和向下转型\n\n- **向上转型：**  父类引用 指向子类对象\n\t- 调用效果： 父类的属性  +    <font color=\"red\"><big>父类的方法（未被子类重写）+ 子类的方法 （重写了父类）</big></font>\n-\t**向下转型：**\n\t- 调用效果：子类的属性  +  子类的方法 \n\n\n\n例子如下：\n\n```java\npackage top.elgong.cast;\n\n/* Father.java */\npublic class Father {\n\n    /* 静态类变量 */\n    public static int staticInt = 1;\n    public static String staticStr = \"father static str\";\n\n    /* 实例变量 */\n    public int Int = 2;\n    public  String Str = \"father str\";\n\n    /*  会被子类覆盖的方法  */\n    public void say(){\n        System.out.println(\"被子类覆盖的方法 :say \");\n    }\n\n\n    /*  不被子类覆盖的方法 */\n    public void sayOnlyFather(){\n        System.out.println(\"未被子类覆盖的方法 : sayOnlyFather\");\n    }\n\n\n    /* 私有方法默认为  fianl， 不可被继承， 也不参与转型 */\n    private void sleep(){\n        System.out.println(\" father sleep\");\n    }\n\n}\n\n```\n\n\n```java\npackage top.elgong.cast;\n\n/* Son.java */\npublic class Son extends Father {\n\n    /* 子类的 变量区 */\n    /* 静态变量 */\n    public static int staticInt = 111;\n    public static String staticStr = \"son static str\";\n\n    /* 实例变量 */\n    public int Int = 222;\n    public  String Str = \"son  str\";\n\n    /* 子类独有的变量 */\n    public String strOnlySon = \"str Only Son\";\n\n\n    @Override\n    public void say() {\n        System.out.println(\"子类重写的方法：say\");\n    }\n\n    public void sleep(){\n        System.out.println(\"子类独有的方法： son sleep : \");\n    }\n\n}\n\n```\n\n\n```java\npackage top.elgong.cast;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        System.out.println(\" 向上转型：  \");\n        /* 向上转型 */\n        Father f = new Son();\n\n        System.out.println(f.Int);  // 打印 2\n        System.out.println(f.Str);  // 打印 father  str\n\n\n        f.say();  // 打印 son say :\n        f.sayOnlyFather();  // 打印   father say 2\n\n        /* 向下转型 */\n        System.out.println(\" 向下转型：  \");\n        Son s = (Son)f;\n\n        System.out.println(s.Int);  // 打印   222\n        System.out.println(s.Str);  // 打印   son  str\n        System.out.println(s.strOnlySon);   // 打印   strOnlySon\n\n        s.say();  // 打印  son say : \n\n    }\n}\n\n```\n\n","source":"_posts/Java-向上转型-向下转型.md","raw":"---\ntitle: Java 向上转型&向下转型\ndate: 2020-04-22 11:53:28\ncategories: Java多态\ntags: 向上转型&向下转型\n---\n\n\n\n# 向上转型和向下转型\n\n- **向上转型：**  父类引用 指向子类对象\n\t- 调用效果： 父类的属性  +    <font color=\"red\"><big>父类的方法（未被子类重写）+ 子类的方法 （重写了父类）</big></font>\n-\t**向下转型：**\n\t- 调用效果：子类的属性  +  子类的方法 \n\n\n\n例子如下：\n\n```java\npackage top.elgong.cast;\n\n/* Father.java */\npublic class Father {\n\n    /* 静态类变量 */\n    public static int staticInt = 1;\n    public static String staticStr = \"father static str\";\n\n    /* 实例变量 */\n    public int Int = 2;\n    public  String Str = \"father str\";\n\n    /*  会被子类覆盖的方法  */\n    public void say(){\n        System.out.println(\"被子类覆盖的方法 :say \");\n    }\n\n\n    /*  不被子类覆盖的方法 */\n    public void sayOnlyFather(){\n        System.out.println(\"未被子类覆盖的方法 : sayOnlyFather\");\n    }\n\n\n    /* 私有方法默认为  fianl， 不可被继承， 也不参与转型 */\n    private void sleep(){\n        System.out.println(\" father sleep\");\n    }\n\n}\n\n```\n\n\n```java\npackage top.elgong.cast;\n\n/* Son.java */\npublic class Son extends Father {\n\n    /* 子类的 变量区 */\n    /* 静态变量 */\n    public static int staticInt = 111;\n    public static String staticStr = \"son static str\";\n\n    /* 实例变量 */\n    public int Int = 222;\n    public  String Str = \"son  str\";\n\n    /* 子类独有的变量 */\n    public String strOnlySon = \"str Only Son\";\n\n\n    @Override\n    public void say() {\n        System.out.println(\"子类重写的方法：say\");\n    }\n\n    public void sleep(){\n        System.out.println(\"子类独有的方法： son sleep : \");\n    }\n\n}\n\n```\n\n\n```java\npackage top.elgong.cast;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        System.out.println(\" 向上转型：  \");\n        /* 向上转型 */\n        Father f = new Son();\n\n        System.out.println(f.Int);  // 打印 2\n        System.out.println(f.Str);  // 打印 father  str\n\n\n        f.say();  // 打印 son say :\n        f.sayOnlyFather();  // 打印   father say 2\n\n        /* 向下转型 */\n        System.out.println(\" 向下转型：  \");\n        Son s = (Son)f;\n\n        System.out.println(s.Int);  // 打印   222\n        System.out.println(s.Str);  // 打印   son  str\n        System.out.println(s.strOnlySon);   // 打印   strOnlySon\n\n        s.say();  // 打印  son say : \n\n    }\n}\n\n```\n\n","slug":"Java-向上转型-向下转型","published":1,"updated":"2020-04-22T03:57:29.854Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephc20008t8plgubam41z","content":"<h1 id=\"向上转型和向下转型\"><a href=\"#向上转型和向下转型\" class=\"headerlink\" title=\"向上转型和向下转型\"></a>向上转型和向下转型</h1><ul>\n<li><strong>向上转型：</strong>  父类引用 指向子类对象<ul>\n<li>调用效果： 父类的属性  +    <font color=\"red\"><big>父类的方法（未被子类重写）+ 子类的方法 （重写了父类）</big></font></li>\n</ul>\n</li>\n<li><strong>向下转型：</strong><ul>\n<li>调用效果：子类的属性  +  子类的方法 </li>\n</ul>\n</li>\n</ul>\n<p>例子如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> top.elgong.cast;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Father.java */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 静态类变量 */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> staticInt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String staticStr = <span class=\"string\">\"father static str\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 实例变量 */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> Int = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>  String Str = <span class=\"string\">\"father str\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*  会被子类覆盖的方法  */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"被子类覆盖的方法 :say \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*  不被子类覆盖的方法 */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayOnlyFather</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"未被子类覆盖的方法 : sayOnlyFather\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 私有方法默认为  fianl， 不可被继承， 也不参与转型 */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sleep</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\" father sleep\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> top.elgong.cast;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Son.java */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 子类的 变量区 */</span></span><br><span class=\"line\">    <span class=\"comment\">/* 静态变量 */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> staticInt = <span class=\"number\">111</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String staticStr = <span class=\"string\">\"son static str\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 实例变量 */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> Int = <span class=\"number\">222</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>  String Str = <span class=\"string\">\"son  str\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 子类独有的变量 */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String strOnlySon = <span class=\"string\">\"str Only Son\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"子类重写的方法：say\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sleep</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"子类独有的方法： son sleep : \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> top.elgong.cast;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\" 向上转型：  \"</span>);</span><br><span class=\"line\">        <span class=\"comment\">/* 向上转型 */</span></span><br><span class=\"line\">        Father f = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(f.Int);  <span class=\"comment\">// 打印 2</span></span><br><span class=\"line\">        System.out.println(f.Str);  <span class=\"comment\">// 打印 father  str</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        f.say();  <span class=\"comment\">// 打印 son say :</span></span><br><span class=\"line\">        f.sayOnlyFather();  <span class=\"comment\">// 打印   father say 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* 向下转型 */</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\" 向下转型：  \"</span>);</span><br><span class=\"line\">        Son s = (Son)f;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(s.Int);  <span class=\"comment\">// 打印   222</span></span><br><span class=\"line\">        System.out.println(s.Str);  <span class=\"comment\">// 打印   son  str</span></span><br><span class=\"line\">        System.out.println(s.strOnlySon);   <span class=\"comment\">// 打印   strOnlySon</span></span><br><span class=\"line\"></span><br><span class=\"line\">        s.say();  <span class=\"comment\">// 打印  son say : </span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"向上转型和向下转型\"><a href=\"#向上转型和向下转型\" class=\"headerlink\" title=\"向上转型和向下转型\"></a>向上转型和向下转型</h1><ul>\n<li><strong>向上转型：</strong>  父类引用 指向子类对象<ul>\n<li>调用效果： 父类的属性  +    <font color=\"red\"><big>父类的方法（未被子类重写）+ 子类的方法 （重写了父类）</big></font></li>\n</ul>\n</li>\n<li><strong>向下转型：</strong><ul>\n<li>调用效果：子类的属性  +  子类的方法 </li>\n</ul>\n</li>\n</ul>\n<p>例子如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> top.elgong.cast;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Father.java */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 静态类变量 */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> staticInt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String staticStr = <span class=\"string\">\"father static str\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 实例变量 */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> Int = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>  String Str = <span class=\"string\">\"father str\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*  会被子类覆盖的方法  */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"被子类覆盖的方法 :say \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*  不被子类覆盖的方法 */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayOnlyFather</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"未被子类覆盖的方法 : sayOnlyFather\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 私有方法默认为  fianl， 不可被继承， 也不参与转型 */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sleep</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\" father sleep\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> top.elgong.cast;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Son.java */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 子类的 变量区 */</span></span><br><span class=\"line\">    <span class=\"comment\">/* 静态变量 */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> staticInt = <span class=\"number\">111</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String staticStr = <span class=\"string\">\"son static str\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 实例变量 */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> Int = <span class=\"number\">222</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>  String Str = <span class=\"string\">\"son  str\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 子类独有的变量 */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String strOnlySon = <span class=\"string\">\"str Only Son\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"子类重写的方法：say\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sleep</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"子类独有的方法： son sleep : \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> top.elgong.cast;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\" 向上转型：  \"</span>);</span><br><span class=\"line\">        <span class=\"comment\">/* 向上转型 */</span></span><br><span class=\"line\">        Father f = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(f.Int);  <span class=\"comment\">// 打印 2</span></span><br><span class=\"line\">        System.out.println(f.Str);  <span class=\"comment\">// 打印 father  str</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        f.say();  <span class=\"comment\">// 打印 son say :</span></span><br><span class=\"line\">        f.sayOnlyFather();  <span class=\"comment\">// 打印   father say 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* 向下转型 */</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\" 向下转型：  \"</span>);</span><br><span class=\"line\">        Son s = (Son)f;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(s.Int);  <span class=\"comment\">// 打印   222</span></span><br><span class=\"line\">        System.out.println(s.Str);  <span class=\"comment\">// 打印   son  str</span></span><br><span class=\"line\">        System.out.println(s.strOnlySon);   <span class=\"comment\">// 打印   strOnlySon</span></span><br><span class=\"line\"></span><br><span class=\"line\">        s.say();  <span class=\"comment\">// 打印  son say : </span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Bloom Filter 布隆过滤器","date":"2020-05-15T16:12:25.000Z","_content":"\n[toc] \n\n[toc]\n\n[谷歌开源的Guava的布隆过滤器](https://github.com/google/guava)\n\n# 布隆过滤器是什么？\n\n布隆过滤器由很长的**二进制向量**和一系列**随机映射函数**组成。\n\n布隆过滤器可以用于检索一个元素是否在一个集合中。\n\n它能给出的答案是： ==**一定不存在 /可能存在**==\n\n# 布隆过滤器的应用场景？\n- **提升磁盘查询未命中的效率**\n    - 通过bloom filter 过滤掉一定不存在的数据查询，减少访问磁盘和网络的次数。\n- **redis限流-缓存击穿问题**\n    - redis 缓存前加一层布隆过滤器，应对缓存击穿问题 \n- **海量网页黑名单**\n- **爬虫网址判重系统**\n\n# 布隆过滤器的优缺点?\n\n- **优点**：\n    - 布隆过滤器存储空间和插入/查询时间都是常数 O（k）\n    - 随机映射函数间独立，可以并行计算\n- **缺点**：\n    - 随着存入的元素数量增加，误算率随之增加。\n    - 无法删除，因为不能确定元素是否真的在bitmap中。\n\n# 实现原理\n布隆过滤器是一个很长的二进制向量，配合K 个随机映射函数，主要的操作是两个：\n**插入**和**查找**\n\n**插入时**： 元素通过k 个随机映射函数，得到 k 个索引， 将二进制向量中的对应位置 置1\n\n**查找时**： 元素通过k 个随机映射函数，得到 k 个索引，查看对应位置是否全为1， 如果有0则一定不存在。\n\n## 怎么选择 参数？\n\n假设输入元素的个数为 n，二进制向量的长度为m（也就是布隆过滤器大小），所容忍的误判率p和随机映射函数的个数k。计算公式如下：（小数向上取整）\n\n![image](F6AD6F9EB403400A8E5208E3422A2EBF)\n\n# 实现代码\n\n```\nimport java.util.BitSet;\n\npublic class MyBloomFilter {\n    //2<<25表示32亿个比特位\n    private static final int DEFAULT_SIZE= 2<< 25;\n    private  static  final int[] seeds=new int[]{3,5,7,11,13,19,23,37};\n   \n    //这么大存储在BitSet\n    private BitSet bits=new BitSet(DEFAULT_SIZE);\n    private SimpleHash[] func=new SimpleHash[seeds.length];\n\n    public static void main(String[] args) {\n       \n        //可疑网站\n        String value=\"www.baidu.com\";\n        MyBloomFilter filter=new MyBloomFilter();\n      \n        //加入之前判断一下\n        System.out.println(filter.contains(value));\n        filter.add(value);\n      \n        //加入之后判断一下\n        System.out.println(filter.contains(value));\n    }\n\n    //构造函数\n    public MyBloomFilter(){\n        for(int i=0;i<seeds.length;i++){\n            func[i]=new SimpleHash(DEFAULT_SIZE,seeds[i]);\n        }\n    }\n\n    //添加网站\n    public void add(String value){\n        for (SimpleHash f : func) {\n            bits.set(f.hash(value),true);\n        }\n    }\n\n    //判断可疑网站是否存在\n    public boolean contains(String value){\n        if(value==null){\n            return false;\n        }\n        boolean ret=true;\n        for (SimpleHash f : func) {\n            ret=ret&&bits.get(f.hash(value));\n        }\n        return ret;\n    }\n\n    public static class SimpleHash {\n        private int cap;\n        private int seed;\n        public SimpleHash(int cap,int seed){\n            this.cap=cap;\n            this.seed=seed;\n        }\n        public int hash(String value){\n            int result=0;\n            int len=value.length();\n            for(int i=0;i<len;i++){\n                result=seed*result+value.charAt(i);\n            }\n            return (cap-1)&result;\n        }\n    }\n}\n```","source":"_posts/Bloom-Filter-布隆过滤器.md","raw":"---\ntitle: Bloom Filter 布隆过滤器\ndate: 2020-05-16 00:12:25\ncategories: 算法与数据结构\ntags: 布隆过滤器\n---\n\n[toc] \n\n[toc]\n\n[谷歌开源的Guava的布隆过滤器](https://github.com/google/guava)\n\n# 布隆过滤器是什么？\n\n布隆过滤器由很长的**二进制向量**和一系列**随机映射函数**组成。\n\n布隆过滤器可以用于检索一个元素是否在一个集合中。\n\n它能给出的答案是： ==**一定不存在 /可能存在**==\n\n# 布隆过滤器的应用场景？\n- **提升磁盘查询未命中的效率**\n    - 通过bloom filter 过滤掉一定不存在的数据查询，减少访问磁盘和网络的次数。\n- **redis限流-缓存击穿问题**\n    - redis 缓存前加一层布隆过滤器，应对缓存击穿问题 \n- **海量网页黑名单**\n- **爬虫网址判重系统**\n\n# 布隆过滤器的优缺点?\n\n- **优点**：\n    - 布隆过滤器存储空间和插入/查询时间都是常数 O（k）\n    - 随机映射函数间独立，可以并行计算\n- **缺点**：\n    - 随着存入的元素数量增加，误算率随之增加。\n    - 无法删除，因为不能确定元素是否真的在bitmap中。\n\n# 实现原理\n布隆过滤器是一个很长的二进制向量，配合K 个随机映射函数，主要的操作是两个：\n**插入**和**查找**\n\n**插入时**： 元素通过k 个随机映射函数，得到 k 个索引， 将二进制向量中的对应位置 置1\n\n**查找时**： 元素通过k 个随机映射函数，得到 k 个索引，查看对应位置是否全为1， 如果有0则一定不存在。\n\n## 怎么选择 参数？\n\n假设输入元素的个数为 n，二进制向量的长度为m（也就是布隆过滤器大小），所容忍的误判率p和随机映射函数的个数k。计算公式如下：（小数向上取整）\n\n![image](F6AD6F9EB403400A8E5208E3422A2EBF)\n\n# 实现代码\n\n```\nimport java.util.BitSet;\n\npublic class MyBloomFilter {\n    //2<<25表示32亿个比特位\n    private static final int DEFAULT_SIZE= 2<< 25;\n    private  static  final int[] seeds=new int[]{3,5,7,11,13,19,23,37};\n   \n    //这么大存储在BitSet\n    private BitSet bits=new BitSet(DEFAULT_SIZE);\n    private SimpleHash[] func=new SimpleHash[seeds.length];\n\n    public static void main(String[] args) {\n       \n        //可疑网站\n        String value=\"www.baidu.com\";\n        MyBloomFilter filter=new MyBloomFilter();\n      \n        //加入之前判断一下\n        System.out.println(filter.contains(value));\n        filter.add(value);\n      \n        //加入之后判断一下\n        System.out.println(filter.contains(value));\n    }\n\n    //构造函数\n    public MyBloomFilter(){\n        for(int i=0;i<seeds.length;i++){\n            func[i]=new SimpleHash(DEFAULT_SIZE,seeds[i]);\n        }\n    }\n\n    //添加网站\n    public void add(String value){\n        for (SimpleHash f : func) {\n            bits.set(f.hash(value),true);\n        }\n    }\n\n    //判断可疑网站是否存在\n    public boolean contains(String value){\n        if(value==null){\n            return false;\n        }\n        boolean ret=true;\n        for (SimpleHash f : func) {\n            ret=ret&&bits.get(f.hash(value));\n        }\n        return ret;\n    }\n\n    public static class SimpleHash {\n        private int cap;\n        private int seed;\n        public SimpleHash(int cap,int seed){\n            this.cap=cap;\n            this.seed=seed;\n        }\n        public int hash(String value){\n            int result=0;\n            int len=value.length();\n            for(int i=0;i<len;i++){\n                result=seed*result+value.charAt(i);\n            }\n            return (cap-1)&result;\n        }\n    }\n}\n```","slug":"Bloom-Filter-布隆过滤器","published":1,"updated":"2020-05-15T16:14:14.913Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephcd000at8plsaydsupj","content":"<p>[toc] </p>\n<p>[toc]</p>\n<p><a href=\"https://github.com/google/guava\" target=\"_blank\" rel=\"noopener\">谷歌开源的Guava的布隆过滤器</a></p>\n<h1 id=\"布隆过滤器是什么？\"><a href=\"#布隆过滤器是什么？\" class=\"headerlink\" title=\"布隆过滤器是什么？\"></a>布隆过滤器是什么？</h1><p>布隆过滤器由很长的<strong>二进制向量</strong>和一系列<strong>随机映射函数</strong>组成。</p>\n<p>布隆过滤器可以用于检索一个元素是否在一个集合中。</p>\n<p>它能给出的答案是： ==<strong>一定不存在 /可能存在</strong>==</p>\n<h1 id=\"布隆过滤器的应用场景？\"><a href=\"#布隆过滤器的应用场景？\" class=\"headerlink\" title=\"布隆过滤器的应用场景？\"></a>布隆过滤器的应用场景？</h1><ul>\n<li><strong>提升磁盘查询未命中的效率</strong><ul>\n<li>通过bloom filter 过滤掉一定不存在的数据查询，减少访问磁盘和网络的次数。</li>\n</ul>\n</li>\n<li><strong>redis限流-缓存击穿问题</strong><ul>\n<li>redis 缓存前加一层布隆过滤器，应对缓存击穿问题 </li>\n</ul>\n</li>\n<li><strong>海量网页黑名单</strong></li>\n<li><strong>爬虫网址判重系统</strong></li>\n</ul>\n<h1 id=\"布隆过滤器的优缺点\"><a href=\"#布隆过滤器的优缺点\" class=\"headerlink\" title=\"布隆过滤器的优缺点?\"></a>布隆过滤器的优缺点?</h1><ul>\n<li><strong>优点</strong>：<ul>\n<li>布隆过滤器存储空间和插入/查询时间都是常数 O（k）</li>\n<li>随机映射函数间独立，可以并行计算</li>\n</ul>\n</li>\n<li><strong>缺点</strong>：<ul>\n<li>随着存入的元素数量增加，误算率随之增加。</li>\n<li>无法删除，因为不能确定元素是否真的在bitmap中。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h1><p>布隆过滤器是一个很长的二进制向量，配合K 个随机映射函数，主要的操作是两个：<br><strong>插入</strong>和<strong>查找</strong></p>\n<p><strong>插入时</strong>： 元素通过k 个随机映射函数，得到 k 个索引， 将二进制向量中的对应位置 置1</p>\n<p><strong>查找时</strong>： 元素通过k 个随机映射函数，得到 k 个索引，查看对应位置是否全为1， 如果有0则一定不存在。</p>\n<h2 id=\"怎么选择-参数？\"><a href=\"#怎么选择-参数？\" class=\"headerlink\" title=\"怎么选择 参数？\"></a>怎么选择 参数？</h2><p>假设输入元素的个数为 n，二进制向量的长度为m（也就是布隆过滤器大小），所容忍的误判率p和随机映射函数的个数k。计算公式如下：（小数向上取整）</p>\n<p><img src=\"/2020/05/16/Bloom-Filter-布隆过滤器/F6AD6F9EB403400A8E5208E3422A2EBF\" alt=\"image\"></p>\n<h1 id=\"实现代码\"><a href=\"#实现代码\" class=\"headerlink\" title=\"实现代码\"></a>实现代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.BitSet;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MyBloomFilter &#123;</span><br><span class=\"line\">    //2&lt;&lt;25表示32亿个比特位</span><br><span class=\"line\">    private static final int DEFAULT_SIZE= 2&lt;&lt; 25;</span><br><span class=\"line\">    private  static  final int[] seeds=new int[]&#123;3,5,7,11,13,19,23,37&#125;;</span><br><span class=\"line\">   </span><br><span class=\"line\">    //这么大存储在BitSet</span><br><span class=\"line\">    private BitSet bits=new BitSet(DEFAULT_SIZE);</span><br><span class=\"line\">    private SimpleHash[] func=new SimpleHash[seeds.length];</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">        //可疑网站</span><br><span class=\"line\">        String value=&quot;www.baidu.com&quot;;</span><br><span class=\"line\">        MyBloomFilter filter=new MyBloomFilter();</span><br><span class=\"line\">      </span><br><span class=\"line\">        //加入之前判断一下</span><br><span class=\"line\">        System.out.println(filter.contains(value));</span><br><span class=\"line\">        filter.add(value);</span><br><span class=\"line\">      </span><br><span class=\"line\">        //加入之后判断一下</span><br><span class=\"line\">        System.out.println(filter.contains(value));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //构造函数</span><br><span class=\"line\">    public MyBloomFilter()&#123;</span><br><span class=\"line\">        for(int i=0;i&lt;seeds.length;i++)&#123;</span><br><span class=\"line\">            func[i]=new SimpleHash(DEFAULT_SIZE,seeds[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //添加网站</span><br><span class=\"line\">    public void add(String value)&#123;</span><br><span class=\"line\">        for (SimpleHash f : func) &#123;</span><br><span class=\"line\">            bits.set(f.hash(value),true);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //判断可疑网站是否存在</span><br><span class=\"line\">    public boolean contains(String value)&#123;</span><br><span class=\"line\">        if(value==null)&#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        boolean ret=true;</span><br><span class=\"line\">        for (SimpleHash f : func) &#123;</span><br><span class=\"line\">            ret=ret&amp;&amp;bits.get(f.hash(value));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static class SimpleHash &#123;</span><br><span class=\"line\">        private int cap;</span><br><span class=\"line\">        private int seed;</span><br><span class=\"line\">        public SimpleHash(int cap,int seed)&#123;</span><br><span class=\"line\">            this.cap=cap;</span><br><span class=\"line\">            this.seed=seed;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public int hash(String value)&#123;</span><br><span class=\"line\">            int result=0;</span><br><span class=\"line\">            int len=value.length();</span><br><span class=\"line\">            for(int i=0;i&lt;len;i++)&#123;</span><br><span class=\"line\">                result=seed*result+value.charAt(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return (cap-1)&amp;result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>[toc] </p>\n<p>[toc]</p>\n<p><a href=\"https://github.com/google/guava\" target=\"_blank\" rel=\"noopener\">谷歌开源的Guava的布隆过滤器</a></p>\n<h1 id=\"布隆过滤器是什么？\"><a href=\"#布隆过滤器是什么？\" class=\"headerlink\" title=\"布隆过滤器是什么？\"></a>布隆过滤器是什么？</h1><p>布隆过滤器由很长的<strong>二进制向量</strong>和一系列<strong>随机映射函数</strong>组成。</p>\n<p>布隆过滤器可以用于检索一个元素是否在一个集合中。</p>\n<p>它能给出的答案是： ==<strong>一定不存在 /可能存在</strong>==</p>\n<h1 id=\"布隆过滤器的应用场景？\"><a href=\"#布隆过滤器的应用场景？\" class=\"headerlink\" title=\"布隆过滤器的应用场景？\"></a>布隆过滤器的应用场景？</h1><ul>\n<li><strong>提升磁盘查询未命中的效率</strong><ul>\n<li>通过bloom filter 过滤掉一定不存在的数据查询，减少访问磁盘和网络的次数。</li>\n</ul>\n</li>\n<li><strong>redis限流-缓存击穿问题</strong><ul>\n<li>redis 缓存前加一层布隆过滤器，应对缓存击穿问题 </li>\n</ul>\n</li>\n<li><strong>海量网页黑名单</strong></li>\n<li><strong>爬虫网址判重系统</strong></li>\n</ul>\n<h1 id=\"布隆过滤器的优缺点\"><a href=\"#布隆过滤器的优缺点\" class=\"headerlink\" title=\"布隆过滤器的优缺点?\"></a>布隆过滤器的优缺点?</h1><ul>\n<li><strong>优点</strong>：<ul>\n<li>布隆过滤器存储空间和插入/查询时间都是常数 O（k）</li>\n<li>随机映射函数间独立，可以并行计算</li>\n</ul>\n</li>\n<li><strong>缺点</strong>：<ul>\n<li>随着存入的元素数量增加，误算率随之增加。</li>\n<li>无法删除，因为不能确定元素是否真的在bitmap中。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h1><p>布隆过滤器是一个很长的二进制向量，配合K 个随机映射函数，主要的操作是两个：<br><strong>插入</strong>和<strong>查找</strong></p>\n<p><strong>插入时</strong>： 元素通过k 个随机映射函数，得到 k 个索引， 将二进制向量中的对应位置 置1</p>\n<p><strong>查找时</strong>： 元素通过k 个随机映射函数，得到 k 个索引，查看对应位置是否全为1， 如果有0则一定不存在。</p>\n<h2 id=\"怎么选择-参数？\"><a href=\"#怎么选择-参数？\" class=\"headerlink\" title=\"怎么选择 参数？\"></a>怎么选择 参数？</h2><p>假设输入元素的个数为 n，二进制向量的长度为m（也就是布隆过滤器大小），所容忍的误判率p和随机映射函数的个数k。计算公式如下：（小数向上取整）</p>\n<p><img src=\"/2020/05/16/Bloom-Filter-布隆过滤器/F6AD6F9EB403400A8E5208E3422A2EBF\" alt=\"image\"></p>\n<h1 id=\"实现代码\"><a href=\"#实现代码\" class=\"headerlink\" title=\"实现代码\"></a>实现代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.BitSet;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MyBloomFilter &#123;</span><br><span class=\"line\">    //2&lt;&lt;25表示32亿个比特位</span><br><span class=\"line\">    private static final int DEFAULT_SIZE= 2&lt;&lt; 25;</span><br><span class=\"line\">    private  static  final int[] seeds=new int[]&#123;3,5,7,11,13,19,23,37&#125;;</span><br><span class=\"line\">   </span><br><span class=\"line\">    //这么大存储在BitSet</span><br><span class=\"line\">    private BitSet bits=new BitSet(DEFAULT_SIZE);</span><br><span class=\"line\">    private SimpleHash[] func=new SimpleHash[seeds.length];</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">        //可疑网站</span><br><span class=\"line\">        String value=&quot;www.baidu.com&quot;;</span><br><span class=\"line\">        MyBloomFilter filter=new MyBloomFilter();</span><br><span class=\"line\">      </span><br><span class=\"line\">        //加入之前判断一下</span><br><span class=\"line\">        System.out.println(filter.contains(value));</span><br><span class=\"line\">        filter.add(value);</span><br><span class=\"line\">      </span><br><span class=\"line\">        //加入之后判断一下</span><br><span class=\"line\">        System.out.println(filter.contains(value));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //构造函数</span><br><span class=\"line\">    public MyBloomFilter()&#123;</span><br><span class=\"line\">        for(int i=0;i&lt;seeds.length;i++)&#123;</span><br><span class=\"line\">            func[i]=new SimpleHash(DEFAULT_SIZE,seeds[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //添加网站</span><br><span class=\"line\">    public void add(String value)&#123;</span><br><span class=\"line\">        for (SimpleHash f : func) &#123;</span><br><span class=\"line\">            bits.set(f.hash(value),true);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //判断可疑网站是否存在</span><br><span class=\"line\">    public boolean contains(String value)&#123;</span><br><span class=\"line\">        if(value==null)&#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        boolean ret=true;</span><br><span class=\"line\">        for (SimpleHash f : func) &#123;</span><br><span class=\"line\">            ret=ret&amp;&amp;bits.get(f.hash(value));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static class SimpleHash &#123;</span><br><span class=\"line\">        private int cap;</span><br><span class=\"line\">        private int seed;</span><br><span class=\"line\">        public SimpleHash(int cap,int seed)&#123;</span><br><span class=\"line\">            this.cap=cap;</span><br><span class=\"line\">            this.seed=seed;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public int hash(String value)&#123;</span><br><span class=\"line\">            int result=0;</span><br><span class=\"line\">            int len=value.length();</span><br><span class=\"line\">            for(int i=0;i&lt;len;i++)&#123;</span><br><span class=\"line\">                result=seed*result+value.charAt(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return (cap-1)&amp;result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"XGBoost","mathjax":true,"date":"2019-07-30T14:02:00.000Z","_content":"\n# xgboost 学习笔记\n\n> 主要内容均来自官方文档，官方文档是英文版，所以简单的翻译了一下，方便日后查看。\n[详细内容见官方手册](https://xgboost.readthedocs.io/en/latest/python/python_intro.html)\n## 安装 XGBoost\n\n```\nubuntu -python3:\n    pip3 install xgboost\n \n导入:\n    import xgboost as xgb\n    \n```\n\n## 数据接口\n\n`XGBoost` 可以从以下结构中加载数据：\n- LibSVM text format file\n- CSV\n- Numpy 2D array\n- Scipy 2D sparse array\n- Pandas\n- XGBoost binary buffer file.\n\n加载的数据都放在 `DMatrix`对象中，下面是具体加载的过程演示：\n\n- LibSVM text format file\n```python\n    dtrain = xgb.DMatrix('train.svm.txt')\n    dtest = xgb.DMatrix('test.svm.buffer')\n```\n\n- CSV\n```python\n    // 需要指定标签所在的列\n    dtrain = xgb.DMatrix('train.csv?format=csv&label_column=0')\n    dtest = xgb.DMatrix('test.csv?format=csv&label_column=0')\n```\n<font color=\"#FF0000\"> \n\n XGBoost 不支持种类特征，需要先加载为Numpy数组，然后进行 `one-hot` 编码;推荐使用pandas 加载数据.\n</font> \n\n- Numpy\n```python\n    data = np.random.rand(5, 10)  # 5个样本，每个样本10个特征\n    label = np.random.randint(2, size=5)  # 二值标签\n    \n    dtrain = xgb.DMatrix(data, label=label)\n```\n\n- Scipy\n```python\n    csr = scipy.sparse.csr_matrix((dat, (row, col)))\n    dtrain = xgb.DMatrix(csr)\n```\n\n- Pandas\n```python\n    data = pandas.DataFrame(np.arange(12).reshape((4,3)), columns=['a', 'b', 'c'])\n    label = pandas.DataFrame(np.random.randint(2, size=4))\n    dtrain = xgb.DMatrix(data, label=label)\n```\n\n- 保存为 XGBoost 二进制文件\n```python\n    dtrain = xgb.DMatrix('train.svm.txt')\n    dtrain.save_binary('train.buffer')\n\n```\n- 缺失值处理\n```python\n    dtrain = xgb.DMatrix(data, label=label, missing=-999.0)\n```\n\n- 样本权重\n```\n    w = np.random.rand(5, 1)\n    dtrain = xgb.DMatrix(data, label=label, missing=-999.0, weight=w)\n```\n\n## 参数设置\n\n> XGBoost 可以通过列表或者字典来设置参数，例如：\n\n- Booster 参数\n```python\n    param = {'max_depth': 2, 'eta': 1, 'objective': 'binary:logistic'}\n    param['nthread'] = 4\n    param['eval_metric'] = 'auc'\n```\n\n- 指定多个评估指标\n```python\n    param['eval_metric'] = ['auc', 'ams@0']\n\n```\n\n- 指定验证集来监视性能\n```python\n    evallist = [(dtest, 'eval'), (dtrain, 'train')]\n```\n\n## 训练\n\n- 模型训练\n```\n    num_round = 10\n    bst = xgb.train(param, dtrain, num_round, evallist)\n```\n\n- 模型保存\n```python\n    bst.save_model('0001.model')\n```\n\n- 保存模型和特征\n```python\n    # dump model\n    bst.dump_model('dump.raw.txt')\n    # dump model with feature map\n    bst.dump_model('dump.raw.txt', 'featmap.txt')\n```\n\n- 模型加载\n```\n    bst = xgb.Booster({'nthread': 4})  # init model\n    bst.load_model('model.bin')  # load data\n```\n\n\n## 早停\n\n> 如果你有验证集，则可以使用早停机制来寻找最佳的 `num_round`, 需要将 验证集传入 `evals`,如果传入多个，则使用最后一个。\n```\n    train(..., evals=evals, early_stopping_rounds=10)\n```\n如果模型在 `early_stopping_rounds`次，监控的参数 `param['eval_metric']` 都没有提升，则会停止训练，`train` 返回的是最后一次训练的模型，而不是最佳模型，最佳模型可以通过一下方式找到：\n\n- `bst.best_score`\n- `bst.best_iteration`\n- `bst.best_ntree_limit`  # 使用最佳模型\n\n同样的，监控多个参数时，最后一个参数起早停的作用。\n\n## 预测\n\n已经训练好的模型，或者已经加载的模型可以拿来预测新数据：\n```\n    data = np.random.rand(7, 10)\n    dtest = xgb.DMatrix(data)\n    ypred = bst.predict(dtest)\n```\n\n使用最佳的迭代次数的模型：\n```\n    ypred = bst.predict(dtest, ntree_limit=bst.best_ntree_limit)\n```\n\n\n## 绘制\n\n你可以使用绘图模块来画出树结构：\n\n- 绘制参数重要性\n\n```\n    xgb.plot_importance(bst)\n```\n\n- 绘制目标树\n\n```\n    xgb.plot_tree(bst, num_trees=2)\n```\n\n- Ipython 中绘制树\n\n```\n    xgb.to_graphviz(bst, num_trees=2)\n```","source":"_posts/XGBoost.md","raw":"---\ntitle: XGBoost\nmathjax: true\ndate: 2019-07-30 22:02:00\ncategories: XGBoost\ntags: XGBoost\n---\n\n# xgboost 学习笔记\n\n> 主要内容均来自官方文档，官方文档是英文版，所以简单的翻译了一下，方便日后查看。\n[详细内容见官方手册](https://xgboost.readthedocs.io/en/latest/python/python_intro.html)\n## 安装 XGBoost\n\n```\nubuntu -python3:\n    pip3 install xgboost\n \n导入:\n    import xgboost as xgb\n    \n```\n\n## 数据接口\n\n`XGBoost` 可以从以下结构中加载数据：\n- LibSVM text format file\n- CSV\n- Numpy 2D array\n- Scipy 2D sparse array\n- Pandas\n- XGBoost binary buffer file.\n\n加载的数据都放在 `DMatrix`对象中，下面是具体加载的过程演示：\n\n- LibSVM text format file\n```python\n    dtrain = xgb.DMatrix('train.svm.txt')\n    dtest = xgb.DMatrix('test.svm.buffer')\n```\n\n- CSV\n```python\n    // 需要指定标签所在的列\n    dtrain = xgb.DMatrix('train.csv?format=csv&label_column=0')\n    dtest = xgb.DMatrix('test.csv?format=csv&label_column=0')\n```\n<font color=\"#FF0000\"> \n\n XGBoost 不支持种类特征，需要先加载为Numpy数组，然后进行 `one-hot` 编码;推荐使用pandas 加载数据.\n</font> \n\n- Numpy\n```python\n    data = np.random.rand(5, 10)  # 5个样本，每个样本10个特征\n    label = np.random.randint(2, size=5)  # 二值标签\n    \n    dtrain = xgb.DMatrix(data, label=label)\n```\n\n- Scipy\n```python\n    csr = scipy.sparse.csr_matrix((dat, (row, col)))\n    dtrain = xgb.DMatrix(csr)\n```\n\n- Pandas\n```python\n    data = pandas.DataFrame(np.arange(12).reshape((4,3)), columns=['a', 'b', 'c'])\n    label = pandas.DataFrame(np.random.randint(2, size=4))\n    dtrain = xgb.DMatrix(data, label=label)\n```\n\n- 保存为 XGBoost 二进制文件\n```python\n    dtrain = xgb.DMatrix('train.svm.txt')\n    dtrain.save_binary('train.buffer')\n\n```\n- 缺失值处理\n```python\n    dtrain = xgb.DMatrix(data, label=label, missing=-999.0)\n```\n\n- 样本权重\n```\n    w = np.random.rand(5, 1)\n    dtrain = xgb.DMatrix(data, label=label, missing=-999.0, weight=w)\n```\n\n## 参数设置\n\n> XGBoost 可以通过列表或者字典来设置参数，例如：\n\n- Booster 参数\n```python\n    param = {'max_depth': 2, 'eta': 1, 'objective': 'binary:logistic'}\n    param['nthread'] = 4\n    param['eval_metric'] = 'auc'\n```\n\n- 指定多个评估指标\n```python\n    param['eval_metric'] = ['auc', 'ams@0']\n\n```\n\n- 指定验证集来监视性能\n```python\n    evallist = [(dtest, 'eval'), (dtrain, 'train')]\n```\n\n## 训练\n\n- 模型训练\n```\n    num_round = 10\n    bst = xgb.train(param, dtrain, num_round, evallist)\n```\n\n- 模型保存\n```python\n    bst.save_model('0001.model')\n```\n\n- 保存模型和特征\n```python\n    # dump model\n    bst.dump_model('dump.raw.txt')\n    # dump model with feature map\n    bst.dump_model('dump.raw.txt', 'featmap.txt')\n```\n\n- 模型加载\n```\n    bst = xgb.Booster({'nthread': 4})  # init model\n    bst.load_model('model.bin')  # load data\n```\n\n\n## 早停\n\n> 如果你有验证集，则可以使用早停机制来寻找最佳的 `num_round`, 需要将 验证集传入 `evals`,如果传入多个，则使用最后一个。\n```\n    train(..., evals=evals, early_stopping_rounds=10)\n```\n如果模型在 `early_stopping_rounds`次，监控的参数 `param['eval_metric']` 都没有提升，则会停止训练，`train` 返回的是最后一次训练的模型，而不是最佳模型，最佳模型可以通过一下方式找到：\n\n- `bst.best_score`\n- `bst.best_iteration`\n- `bst.best_ntree_limit`  # 使用最佳模型\n\n同样的，监控多个参数时，最后一个参数起早停的作用。\n\n## 预测\n\n已经训练好的模型，或者已经加载的模型可以拿来预测新数据：\n```\n    data = np.random.rand(7, 10)\n    dtest = xgb.DMatrix(data)\n    ypred = bst.predict(dtest)\n```\n\n使用最佳的迭代次数的模型：\n```\n    ypred = bst.predict(dtest, ntree_limit=bst.best_ntree_limit)\n```\n\n\n## 绘制\n\n你可以使用绘图模块来画出树结构：\n\n- 绘制参数重要性\n\n```\n    xgb.plot_importance(bst)\n```\n\n- 绘制目标树\n\n```\n    xgb.plot_tree(bst, num_trees=2)\n```\n\n- Ipython 中绘制树\n\n```\n    xgb.to_graphviz(bst, num_trees=2)\n```","slug":"XGBoost","published":1,"updated":"2020-02-20T04:41:37.810Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephck000bt8pl2iuoezo3","content":"<h1 id=\"xgboost-学习笔记\"><a href=\"#xgboost-学习笔记\" class=\"headerlink\" title=\"xgboost 学习笔记\"></a>xgboost 学习笔记</h1><blockquote>\n<p>主要内容均来自官方文档，官方文档是英文版，所以简单的翻译了一下，方便日后查看。<br><a href=\"https://xgboost.readthedocs.io/en/latest/python/python_intro.html\" target=\"_blank\" rel=\"noopener\">详细内容见官方手册</a></p>\n<h2 id=\"安装-XGBoost\"><a href=\"#安装-XGBoost\" class=\"headerlink\" title=\"安装 XGBoost\"></a>安装 XGBoost</h2></blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu -python3:</span><br><span class=\"line\">    pip3 install xgboost</span><br><span class=\"line\"> </span><br><span class=\"line\">导入:</span><br><span class=\"line\">    import xgboost as xgb</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据接口\"><a href=\"#数据接口\" class=\"headerlink\" title=\"数据接口\"></a>数据接口</h2><p><code>XGBoost</code> 可以从以下结构中加载数据：</p>\n<ul>\n<li>LibSVM text format file</li>\n<li>CSV</li>\n<li>Numpy 2D array</li>\n<li>Scipy 2D sparse array</li>\n<li>Pandas</li>\n<li>XGBoost binary buffer file.</li>\n</ul>\n<p>加载的数据都放在 <code>DMatrix</code>对象中，下面是具体加载的过程演示：</p>\n<ul>\n<li><p>LibSVM text format file</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dtrain = xgb.DMatrix(<span class=\"string\">'train.svm.txt'</span>)</span><br><span class=\"line\">dtest = xgb.DMatrix(<span class=\"string\">'test.svm.buffer'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSV</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 需要指定标签所在的列</span><br><span class=\"line\">dtrain = xgb.DMatrix(<span class=\"string\">'train.csv?format=csv&amp;label_column=0'</span>)</span><br><span class=\"line\">dtest = xgb.DMatrix(<span class=\"string\">'test.csv?format=csv&amp;label_column=0'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<font color=\"#FF0000\"> \n\n XGBoost 不支持种类特征，需要先加载为Numpy数组，然后进行 `one-hot` 编码;推荐使用pandas 加载数据.\n</font> \n\n<ul>\n<li><p>Numpy</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = np.random.rand(<span class=\"number\">5</span>, <span class=\"number\">10</span>)  <span class=\"comment\"># 5个样本，每个样本10个特征</span></span><br><span class=\"line\">label = np.random.randint(<span class=\"number\">2</span>, size=<span class=\"number\">5</span>)  <span class=\"comment\"># 二值标签</span></span><br><span class=\"line\"></span><br><span class=\"line\">dtrain = xgb.DMatrix(data, label=label)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Scipy</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">csr = scipy.sparse.csr_matrix((dat, (row, col)))</span><br><span class=\"line\">dtrain = xgb.DMatrix(csr)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Pandas</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = pandas.DataFrame(np.arange(<span class=\"number\">12</span>).reshape((<span class=\"number\">4</span>,<span class=\"number\">3</span>)), columns=[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>])</span><br><span class=\"line\">label = pandas.DataFrame(np.random.randint(<span class=\"number\">2</span>, size=<span class=\"number\">4</span>))</span><br><span class=\"line\">dtrain = xgb.DMatrix(data, label=label)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>保存为 XGBoost 二进制文件</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dtrain = xgb.DMatrix(<span class=\"string\">'train.svm.txt'</span>)</span><br><span class=\"line\">dtrain.save_binary(<span class=\"string\">'train.buffer'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>缺失值处理</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dtrain = xgb.DMatrix(data, label=label, missing=<span class=\"number\">-999.0</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>样本权重</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">w = np.random.rand(5, 1)</span><br><span class=\"line\">dtrain = xgb.DMatrix(data, label=label, missing=-999.0, weight=w)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"参数设置\"><a href=\"#参数设置\" class=\"headerlink\" title=\"参数设置\"></a>参数设置</h2><blockquote>\n<p>XGBoost 可以通过列表或者字典来设置参数，例如：</p>\n</blockquote>\n<ul>\n<li><p>Booster 参数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">param = &#123;<span class=\"string\">'max_depth'</span>: <span class=\"number\">2</span>, <span class=\"string\">'eta'</span>: <span class=\"number\">1</span>, <span class=\"string\">'objective'</span>: <span class=\"string\">'binary:logistic'</span>&#125;</span><br><span class=\"line\">param[<span class=\"string\">'nthread'</span>] = <span class=\"number\">4</span></span><br><span class=\"line\">param[<span class=\"string\">'eval_metric'</span>] = <span class=\"string\">'auc'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指定多个评估指标</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">param[<span class=\"string\">'eval_metric'</span>] = [<span class=\"string\">'auc'</span>, <span class=\"string\">'ams@0'</span>]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指定验证集来监视性能</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evallist = [(dtest, <span class=\"string\">'eval'</span>), (dtrain, <span class=\"string\">'train'</span>)]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"训练\"><a href=\"#训练\" class=\"headerlink\" title=\"训练\"></a>训练</h2><ul>\n<li><p>模型训练</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num_round = 10</span><br><span class=\"line\">bst = xgb.train(param, dtrain, num_round, evallist)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>模型保存</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bst.save_model(<span class=\"string\">'0001.model'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>保存模型和特征</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># dump model</span></span><br><span class=\"line\">bst.dump_model(<span class=\"string\">'dump.raw.txt'</span>)</span><br><span class=\"line\"><span class=\"comment\"># dump model with feature map</span></span><br><span class=\"line\">bst.dump_model(<span class=\"string\">'dump.raw.txt'</span>, <span class=\"string\">'featmap.txt'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>模型加载</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bst = xgb.Booster(&#123;&apos;nthread&apos;: 4&#125;)  # init model</span><br><span class=\"line\">bst.load_model(&apos;model.bin&apos;)  # load data</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"早停\"><a href=\"#早停\" class=\"headerlink\" title=\"早停\"></a>早停</h2><blockquote>\n<p>如果你有验证集，则可以使用早停机制来寻找最佳的 <code>num_round</code>, 需要将 验证集传入 <code>evals</code>,如果传入多个，则使用最后一个。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">train(..., evals=evals, early_stopping_rounds=10)</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>如果模型在 <code>early_stopping_rounds</code>次，监控的参数 <code>param[&#39;eval_metric&#39;]</code> 都没有提升，则会停止训练，<code>train</code> 返回的是最后一次训练的模型，而不是最佳模型，最佳模型可以通过一下方式找到：</p>\n<ul>\n<li><code>bst.best_score</code></li>\n<li><code>bst.best_iteration</code></li>\n<li><code>bst.best_ntree_limit</code>  # 使用最佳模型</li>\n</ul>\n<p>同样的，监控多个参数时，最后一个参数起早停的作用。</p>\n<h2 id=\"预测\"><a href=\"#预测\" class=\"headerlink\" title=\"预测\"></a>预测</h2><p>已经训练好的模型，或者已经加载的模型可以拿来预测新数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = np.random.rand(7, 10)</span><br><span class=\"line\">dtest = xgb.DMatrix(data)</span><br><span class=\"line\">ypred = bst.predict(dtest)</span><br></pre></td></tr></table></figure></p>\n<p>使用最佳的迭代次数的模型：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ypred = bst.predict(dtest, ntree_limit=bst.best_ntree_limit)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"绘制\"><a href=\"#绘制\" class=\"headerlink\" title=\"绘制\"></a>绘制</h2><p>你可以使用绘图模块来画出树结构：</p>\n<ul>\n<li>绘制参数重要性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xgb.plot_importance(bst)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>绘制目标树</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xgb.plot_tree(bst, num_trees=2)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Ipython 中绘制树</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xgb.to_graphviz(bst, num_trees=2)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"xgboost-学习笔记\"><a href=\"#xgboost-学习笔记\" class=\"headerlink\" title=\"xgboost 学习笔记\"></a>xgboost 学习笔记</h1><blockquote>\n<p>主要内容均来自官方文档，官方文档是英文版，所以简单的翻译了一下，方便日后查看。<br><a href=\"https://xgboost.readthedocs.io/en/latest/python/python_intro.html\" target=\"_blank\" rel=\"noopener\">详细内容见官方手册</a></p>\n<h2 id=\"安装-XGBoost\"><a href=\"#安装-XGBoost\" class=\"headerlink\" title=\"安装 XGBoost\"></a>安装 XGBoost</h2></blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ubuntu -python3:</span><br><span class=\"line\">    pip3 install xgboost</span><br><span class=\"line\"> </span><br><span class=\"line\">导入:</span><br><span class=\"line\">    import xgboost as xgb</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据接口\"><a href=\"#数据接口\" class=\"headerlink\" title=\"数据接口\"></a>数据接口</h2><p><code>XGBoost</code> 可以从以下结构中加载数据：</p>\n<ul>\n<li>LibSVM text format file</li>\n<li>CSV</li>\n<li>Numpy 2D array</li>\n<li>Scipy 2D sparse array</li>\n<li>Pandas</li>\n<li>XGBoost binary buffer file.</li>\n</ul>\n<p>加载的数据都放在 <code>DMatrix</code>对象中，下面是具体加载的过程演示：</p>\n<ul>\n<li><p>LibSVM text format file</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dtrain = xgb.DMatrix(<span class=\"string\">'train.svm.txt'</span>)</span><br><span class=\"line\">dtest = xgb.DMatrix(<span class=\"string\">'test.svm.buffer'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSV</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 需要指定标签所在的列</span><br><span class=\"line\">dtrain = xgb.DMatrix(<span class=\"string\">'train.csv?format=csv&amp;label_column=0'</span>)</span><br><span class=\"line\">dtest = xgb.DMatrix(<span class=\"string\">'test.csv?format=csv&amp;label_column=0'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<font color=\"#FF0000\"> \n\n XGBoost 不支持种类特征，需要先加载为Numpy数组，然后进行 `one-hot` 编码;推荐使用pandas 加载数据.\n</font> \n\n<ul>\n<li><p>Numpy</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = np.random.rand(<span class=\"number\">5</span>, <span class=\"number\">10</span>)  <span class=\"comment\"># 5个样本，每个样本10个特征</span></span><br><span class=\"line\">label = np.random.randint(<span class=\"number\">2</span>, size=<span class=\"number\">5</span>)  <span class=\"comment\"># 二值标签</span></span><br><span class=\"line\"></span><br><span class=\"line\">dtrain = xgb.DMatrix(data, label=label)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Scipy</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">csr = scipy.sparse.csr_matrix((dat, (row, col)))</span><br><span class=\"line\">dtrain = xgb.DMatrix(csr)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Pandas</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = pandas.DataFrame(np.arange(<span class=\"number\">12</span>).reshape((<span class=\"number\">4</span>,<span class=\"number\">3</span>)), columns=[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>])</span><br><span class=\"line\">label = pandas.DataFrame(np.random.randint(<span class=\"number\">2</span>, size=<span class=\"number\">4</span>))</span><br><span class=\"line\">dtrain = xgb.DMatrix(data, label=label)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>保存为 XGBoost 二进制文件</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dtrain = xgb.DMatrix(<span class=\"string\">'train.svm.txt'</span>)</span><br><span class=\"line\">dtrain.save_binary(<span class=\"string\">'train.buffer'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>缺失值处理</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dtrain = xgb.DMatrix(data, label=label, missing=<span class=\"number\">-999.0</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>样本权重</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">w = np.random.rand(5, 1)</span><br><span class=\"line\">dtrain = xgb.DMatrix(data, label=label, missing=-999.0, weight=w)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"参数设置\"><a href=\"#参数设置\" class=\"headerlink\" title=\"参数设置\"></a>参数设置</h2><blockquote>\n<p>XGBoost 可以通过列表或者字典来设置参数，例如：</p>\n</blockquote>\n<ul>\n<li><p>Booster 参数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">param = &#123;<span class=\"string\">'max_depth'</span>: <span class=\"number\">2</span>, <span class=\"string\">'eta'</span>: <span class=\"number\">1</span>, <span class=\"string\">'objective'</span>: <span class=\"string\">'binary:logistic'</span>&#125;</span><br><span class=\"line\">param[<span class=\"string\">'nthread'</span>] = <span class=\"number\">4</span></span><br><span class=\"line\">param[<span class=\"string\">'eval_metric'</span>] = <span class=\"string\">'auc'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指定多个评估指标</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">param[<span class=\"string\">'eval_metric'</span>] = [<span class=\"string\">'auc'</span>, <span class=\"string\">'ams@0'</span>]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指定验证集来监视性能</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evallist = [(dtest, <span class=\"string\">'eval'</span>), (dtrain, <span class=\"string\">'train'</span>)]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"训练\"><a href=\"#训练\" class=\"headerlink\" title=\"训练\"></a>训练</h2><ul>\n<li><p>模型训练</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num_round = 10</span><br><span class=\"line\">bst = xgb.train(param, dtrain, num_round, evallist)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>模型保存</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bst.save_model(<span class=\"string\">'0001.model'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>保存模型和特征</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># dump model</span></span><br><span class=\"line\">bst.dump_model(<span class=\"string\">'dump.raw.txt'</span>)</span><br><span class=\"line\"><span class=\"comment\"># dump model with feature map</span></span><br><span class=\"line\">bst.dump_model(<span class=\"string\">'dump.raw.txt'</span>, <span class=\"string\">'featmap.txt'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>模型加载</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bst = xgb.Booster(&#123;&apos;nthread&apos;: 4&#125;)  # init model</span><br><span class=\"line\">bst.load_model(&apos;model.bin&apos;)  # load data</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"早停\"><a href=\"#早停\" class=\"headerlink\" title=\"早停\"></a>早停</h2><blockquote>\n<p>如果你有验证集，则可以使用早停机制来寻找最佳的 <code>num_round</code>, 需要将 验证集传入 <code>evals</code>,如果传入多个，则使用最后一个。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">train(..., evals=evals, early_stopping_rounds=10)</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>如果模型在 <code>early_stopping_rounds</code>次，监控的参数 <code>param[&#39;eval_metric&#39;]</code> 都没有提升，则会停止训练，<code>train</code> 返回的是最后一次训练的模型，而不是最佳模型，最佳模型可以通过一下方式找到：</p>\n<ul>\n<li><code>bst.best_score</code></li>\n<li><code>bst.best_iteration</code></li>\n<li><code>bst.best_ntree_limit</code>  # 使用最佳模型</li>\n</ul>\n<p>同样的，监控多个参数时，最后一个参数起早停的作用。</p>\n<h2 id=\"预测\"><a href=\"#预测\" class=\"headerlink\" title=\"预测\"></a>预测</h2><p>已经训练好的模型，或者已经加载的模型可以拿来预测新数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = np.random.rand(7, 10)</span><br><span class=\"line\">dtest = xgb.DMatrix(data)</span><br><span class=\"line\">ypred = bst.predict(dtest)</span><br></pre></td></tr></table></figure></p>\n<p>使用最佳的迭代次数的模型：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ypred = bst.predict(dtest, ntree_limit=bst.best_ntree_limit)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"绘制\"><a href=\"#绘制\" class=\"headerlink\" title=\"绘制\"></a>绘制</h2><p>你可以使用绘图模块来画出树结构：</p>\n<ul>\n<li>绘制参数重要性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xgb.plot_importance(bst)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>绘制目标树</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xgb.plot_tree(bst, num_trees=2)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Ipython 中绘制树</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xgb.to_graphviz(bst, num_trees=2)</span><br></pre></td></tr></table></figure>"},{"title":"eclipse-and-github","date":"2019-01-19T14:28:19.000Z","_content":"# 内容概要\n\n\n- `本地`  首次上传到  `github`\n- `本地`  更新到   `github`\n- `github` 首次下载到  `本地`\n- `github`  更新到  `本地`\n\n## 本地首次上传到 **github**\n1. 进入 `github官网`，选择 `New repository`\n\n\n2. 复制地址  `http:XXXXXXXXXX.git`\n\n\n3. `本地` 右键自己的项目文件夹，选择 `git bash here`\n\n\n4. 克隆 `github` 仓库到本地(执行如下命令), 会在本地产生一个 github 上仓库同名的文件夹 `XXX`，<code>将工程所有内容移入文件夹内</code>\n\n\t`git clone http:XXXXXXXXXX.git`\n\n5.  `cd XXX`, 进入该目录，执行以下操作：\n\n\t\n\tgit add .  \n\n\t// git status   \n\n\tgit commit -m \"此次提交的备注信息\"\n\n\tgit push -u origin  master\n\n\n## 本地更新到 github\n\n方法与上节中的5一致。\n\n\n## 首次下载到本地\n\n`git clone http:XXXXXXXXXX.git`\n\n## 更新到本地\n\n`git pull`\n\t\n\n\n","source":"_posts/git使用.md","raw":"---\ntitle: eclipse-and-github\ndate: 2019-01-19 22:28:19\ncategories: git\ntags: git\n---\n# 内容概要\n\n\n- `本地`  首次上传到  `github`\n- `本地`  更新到   `github`\n- `github` 首次下载到  `本地`\n- `github`  更新到  `本地`\n\n## 本地首次上传到 **github**\n1. 进入 `github官网`，选择 `New repository`\n\n\n2. 复制地址  `http:XXXXXXXXXX.git`\n\n\n3. `本地` 右键自己的项目文件夹，选择 `git bash here`\n\n\n4. 克隆 `github` 仓库到本地(执行如下命令), 会在本地产生一个 github 上仓库同名的文件夹 `XXX`，<code>将工程所有内容移入文件夹内</code>\n\n\t`git clone http:XXXXXXXXXX.git`\n\n5.  `cd XXX`, 进入该目录，执行以下操作：\n\n\t\n\tgit add .  \n\n\t// git status   \n\n\tgit commit -m \"此次提交的备注信息\"\n\n\tgit push -u origin  master\n\n\n## 本地更新到 github\n\n方法与上节中的5一致。\n\n\n## 首次下载到本地\n\n`git clone http:XXXXXXXXXX.git`\n\n## 更新到本地\n\n`git pull`\n\t\n\n\n","slug":"git使用","published":1,"updated":"2020-02-20T04:41:37.811Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephcz000ft8pl24xzf93f","content":"<h1 id=\"内容概要\"><a href=\"#内容概要\" class=\"headerlink\" title=\"内容概要\"></a>内容概要</h1><ul>\n<li><code>本地</code>  首次上传到  <code>github</code></li>\n<li><code>本地</code>  更新到   <code>github</code></li>\n<li><code>github</code> 首次下载到  <code>本地</code></li>\n<li><code>github</code>  更新到  <code>本地</code></li>\n</ul>\n<h2 id=\"本地首次上传到-github\"><a href=\"#本地首次上传到-github\" class=\"headerlink\" title=\"本地首次上传到 github\"></a>本地首次上传到 <strong>github</strong></h2><ol>\n<li>进入 <code>github官网</code>，选择 <code>New repository</code></li>\n</ol>\n<ol>\n<li>复制地址  <code>http:XXXXXXXXXX.git</code></li>\n</ol>\n<ol>\n<li><code>本地</code> 右键自己的项目文件夹，选择 <code>git bash here</code></li>\n</ol>\n<ol>\n<li><p>克隆 <code>github</code> 仓库到本地(执行如下命令), 会在本地产生一个 github 上仓库同名的文件夹 <code>XXX</code>，<code>将工程所有内容移入文件夹内</code></p>\n<p> <code>git clone http:XXXXXXXXXX.git</code></p>\n</li>\n<li><p><code>cd XXX</code>, 进入该目录，执行以下操作：</p>\n</li>\n</ol>\n<pre><code>git add .  \n\n// git status   \n\ngit commit -m &quot;此次提交的备注信息&quot;\n\ngit push -u origin  master\n</code></pre><h2 id=\"本地更新到-github\"><a href=\"#本地更新到-github\" class=\"headerlink\" title=\"本地更新到 github\"></a>本地更新到 github</h2><p>方法与上节中的5一致。</p>\n<h2 id=\"首次下载到本地\"><a href=\"#首次下载到本地\" class=\"headerlink\" title=\"首次下载到本地\"></a>首次下载到本地</h2><p><code>git clone http:XXXXXXXXXX.git</code></p>\n<h2 id=\"更新到本地\"><a href=\"#更新到本地\" class=\"headerlink\" title=\"更新到本地\"></a>更新到本地</h2><p><code>git pull</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"内容概要\"><a href=\"#内容概要\" class=\"headerlink\" title=\"内容概要\"></a>内容概要</h1><ul>\n<li><code>本地</code>  首次上传到  <code>github</code></li>\n<li><code>本地</code>  更新到   <code>github</code></li>\n<li><code>github</code> 首次下载到  <code>本地</code></li>\n<li><code>github</code>  更新到  <code>本地</code></li>\n</ul>\n<h2 id=\"本地首次上传到-github\"><a href=\"#本地首次上传到-github\" class=\"headerlink\" title=\"本地首次上传到 github\"></a>本地首次上传到 <strong>github</strong></h2><ol>\n<li>进入 <code>github官网</code>，选择 <code>New repository</code></li>\n</ol>\n<ol>\n<li>复制地址  <code>http:XXXXXXXXXX.git</code></li>\n</ol>\n<ol>\n<li><code>本地</code> 右键自己的项目文件夹，选择 <code>git bash here</code></li>\n</ol>\n<ol>\n<li><p>克隆 <code>github</code> 仓库到本地(执行如下命令), 会在本地产生一个 github 上仓库同名的文件夹 <code>XXX</code>，<code>将工程所有内容移入文件夹内</code></p>\n<p> <code>git clone http:XXXXXXXXXX.git</code></p>\n</li>\n<li><p><code>cd XXX</code>, 进入该目录，执行以下操作：</p>\n</li>\n</ol>\n<pre><code>git add .  \n\n// git status   \n\ngit commit -m &quot;此次提交的备注信息&quot;\n\ngit push -u origin  master\n</code></pre><h2 id=\"本地更新到-github\"><a href=\"#本地更新到-github\" class=\"headerlink\" title=\"本地更新到 github\"></a>本地更新到 github</h2><p>方法与上节中的5一致。</p>\n<h2 id=\"首次下载到本地\"><a href=\"#首次下载到本地\" class=\"headerlink\" title=\"首次下载到本地\"></a>首次下载到本地</h2><p><code>git clone http:XXXXXXXXXX.git</code></p>\n<h2 id=\"更新到本地\"><a href=\"#更新到本地\" class=\"headerlink\" title=\"更新到本地\"></a>更新到本地</h2><p><code>git pull</code></p>\n"},{"title":"Network in Network","date":"2019-01-24T07:08:27.000Z","copyright":true,"_content":"`2014年` 论文地址：  [https://arxiv.org/abs/1312.4400](https://arxiv.org/abs/1312.4400 \"论文地址\")\n\n## 论文核心\n\nNIN特点: \n\n- 微型网络: \n\t- 增强模型在感受野（receptive field）内对局部区域的辨别能力;  \n\n\n- GAP全局平均池化: \n\t- 强化了特征图与分类的对应关系;\n\t- GAP本身是结构化的正则化器，能避免整体结构的过拟合；\n\n\t\n\n\n> 　　卷积层使用线性滤波器（卷积核）来扫描输入，后面接一个非线性激活函数。而卷积核是广义线性模型（generalized linear model ）GLM，抽象程度低（该特征对同一概念的变体是不变的）,用更有效的 `非线性函数逼近器` 代替 `GLM` 可以增强局部模型的抽象能力。当样本的隐含概念（latent concept）线性可分时，GLM可以达到很好的抽象程度，例如：这些概念的变体都在GLM分割平面的同一边，而<font color=red>传统的CNN就默认了这个假设——认为隐含概念（latent concept）是线性可分的</font>。然而，同一概念的数据通常是非线性流形的（nonlinear manifold），捕捉这些概念的表达通常都是输入的高维非线性函数。在NIN中，GLM用“微型网络”结构替代，该结构是一个`非线性函数逼近器`。  \n> \n> 　　本文作者选择多层感知器实例化微型网络，该感知器是一个通用函数逼近器，也是一个通过反向传播训练的神经网络。\n\n![logo](Network-in-Network/nerworkInNetwork1.png)\n该图是 单独的 `mlpconv 层`。\n这里有没有尝试过其他微型网络结构？？？？（可创新吗）\n- \n## NIN 网络结构\n![logo](Network-in-Network/nerworkInNetwork2.png)\n\n　　NIN 的整体结构是一系列 `mlpconve层` 的堆叠，最上层接一个 `GAP层` 和 `分类层`。 `mlpconv层` 间的子层可以被相加，像CNN和maxout网络一样。上图展示了一个包含三个mlpconv层的NIN。每个mlpconv层，包含一个三层的感知器，NIN和微型网络的层数都是灵活的，可以根据具体任务微调。\n\n　　这里没有采用传统CNN的 `全连接层` 进行分类，而是直接通过 `全局平均池化层（GAP）`输出最后一个 `mlpconv层特征图`的空间平均值作为类别的置信度值，然后将得到的向量输入 `softmax层`。","source":"_posts/Network-in-Network.md","raw":"---\ntitle: Network in Network\ndate: 2019-01-24 15:08:27\ncategories: \n- 计算机视觉论文阅读\ntags: 深度学习论文\ncopyright: true\n---\n`2014年` 论文地址：  [https://arxiv.org/abs/1312.4400](https://arxiv.org/abs/1312.4400 \"论文地址\")\n\n## 论文核心\n\nNIN特点: \n\n- 微型网络: \n\t- 增强模型在感受野（receptive field）内对局部区域的辨别能力;  \n\n\n- GAP全局平均池化: \n\t- 强化了特征图与分类的对应关系;\n\t- GAP本身是结构化的正则化器，能避免整体结构的过拟合；\n\n\t\n\n\n> 　　卷积层使用线性滤波器（卷积核）来扫描输入，后面接一个非线性激活函数。而卷积核是广义线性模型（generalized linear model ）GLM，抽象程度低（该特征对同一概念的变体是不变的）,用更有效的 `非线性函数逼近器` 代替 `GLM` 可以增强局部模型的抽象能力。当样本的隐含概念（latent concept）线性可分时，GLM可以达到很好的抽象程度，例如：这些概念的变体都在GLM分割平面的同一边，而<font color=red>传统的CNN就默认了这个假设——认为隐含概念（latent concept）是线性可分的</font>。然而，同一概念的数据通常是非线性流形的（nonlinear manifold），捕捉这些概念的表达通常都是输入的高维非线性函数。在NIN中，GLM用“微型网络”结构替代，该结构是一个`非线性函数逼近器`。  \n> \n> 　　本文作者选择多层感知器实例化微型网络，该感知器是一个通用函数逼近器，也是一个通过反向传播训练的神经网络。\n\n![logo](Network-in-Network/nerworkInNetwork1.png)\n该图是 单独的 `mlpconv 层`。\n这里有没有尝试过其他微型网络结构？？？？（可创新吗）\n- \n## NIN 网络结构\n![logo](Network-in-Network/nerworkInNetwork2.png)\n\n　　NIN 的整体结构是一系列 `mlpconve层` 的堆叠，最上层接一个 `GAP层` 和 `分类层`。 `mlpconv层` 间的子层可以被相加，像CNN和maxout网络一样。上图展示了一个包含三个mlpconv层的NIN。每个mlpconv层，包含一个三层的感知器，NIN和微型网络的层数都是灵活的，可以根据具体任务微调。\n\n　　这里没有采用传统CNN的 `全连接层` 进行分类，而是直接通过 `全局平均池化层（GAP）`输出最后一个 `mlpconv层特征图`的空间平均值作为类别的置信度值，然后将得到的向量输入 `softmax层`。","slug":"Network-in-Network","published":1,"updated":"2020-02-20T06:39:50.127Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephd4000gt8plxd4wqilb","content":"<p><code>2014年</code> 论文地址：  <a href=\"https://arxiv.org/abs/1312.4400\" title=\"论文地址\" target=\"_blank\" rel=\"noopener\">https://arxiv.org/abs/1312.4400</a></p>\n<h2 id=\"论文核心\"><a href=\"#论文核心\" class=\"headerlink\" title=\"论文核心\"></a>论文核心</h2><p>NIN特点: </p>\n<ul>\n<li>微型网络: <ul>\n<li>增强模型在感受野（receptive field）内对局部区域的辨别能力;  </li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>GAP全局平均池化: <ul>\n<li>强化了特征图与分类的对应关系;</li>\n<li>GAP本身是结构化的正则化器，能避免整体结构的过拟合；</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>　　卷积层使用线性滤波器（卷积核）来扫描输入，后面接一个非线性激活函数。而卷积核是广义线性模型（generalized linear model ）GLM，抽象程度低（该特征对同一概念的变体是不变的）,用更有效的 <code>非线性函数逼近器</code> 代替 <code>GLM</code> 可以增强局部模型的抽象能力。当样本的隐含概念（latent concept）线性可分时，GLM可以达到很好的抽象程度，例如：这些概念的变体都在GLM分割平面的同一边，而<font color=\"red\">传统的CNN就默认了这个假设——认为隐含概念（latent concept）是线性可分的</font>。然而，同一概念的数据通常是非线性流形的（nonlinear manifold），捕捉这些概念的表达通常都是输入的高维非线性函数。在NIN中，GLM用“微型网络”结构替代，该结构是一个<code>非线性函数逼近器</code>。  </p>\n<p>　　本文作者选择多层感知器实例化微型网络，该感知器是一个通用函数逼近器，也是一个通过反向传播训练的神经网络。</p>\n</blockquote>\n<p><img src=\"/2019/01/24/Network-in-Network/nerworkInNetwork1.png\" alt=\"logo\"><br>该图是 单独的 <code>mlpconv 层</code>。<br>这里有没有尝试过其他微型网络结构？？？？（可创新吗）</p>\n<ul>\n<li><h2 id=\"NIN-网络结构\"><a href=\"#NIN-网络结构\" class=\"headerlink\" title=\"NIN 网络结构\"></a>NIN 网络结构</h2><img src=\"/2019/01/24/Network-in-Network/nerworkInNetwork2.png\" alt=\"logo\"></li>\n</ul>\n<p>　　NIN 的整体结构是一系列 <code>mlpconve层</code> 的堆叠，最上层接一个 <code>GAP层</code> 和 <code>分类层</code>。 <code>mlpconv层</code> 间的子层可以被相加，像CNN和maxout网络一样。上图展示了一个包含三个mlpconv层的NIN。每个mlpconv层，包含一个三层的感知器，NIN和微型网络的层数都是灵活的，可以根据具体任务微调。</p>\n<p>　　这里没有采用传统CNN的 <code>全连接层</code> 进行分类，而是直接通过 <code>全局平均池化层（GAP）</code>输出最后一个 <code>mlpconv层特征图</code>的空间平均值作为类别的置信度值，然后将得到的向量输入 <code>softmax层</code>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>2014年</code> 论文地址：  <a href=\"https://arxiv.org/abs/1312.4400\" title=\"论文地址\" target=\"_blank\" rel=\"noopener\">https://arxiv.org/abs/1312.4400</a></p>\n<h2 id=\"论文核心\"><a href=\"#论文核心\" class=\"headerlink\" title=\"论文核心\"></a>论文核心</h2><p>NIN特点: </p>\n<ul>\n<li>微型网络: <ul>\n<li>增强模型在感受野（receptive field）内对局部区域的辨别能力;  </li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>GAP全局平均池化: <ul>\n<li>强化了特征图与分类的对应关系;</li>\n<li>GAP本身是结构化的正则化器，能避免整体结构的过拟合；</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>　　卷积层使用线性滤波器（卷积核）来扫描输入，后面接一个非线性激活函数。而卷积核是广义线性模型（generalized linear model ）GLM，抽象程度低（该特征对同一概念的变体是不变的）,用更有效的 <code>非线性函数逼近器</code> 代替 <code>GLM</code> 可以增强局部模型的抽象能力。当样本的隐含概念（latent concept）线性可分时，GLM可以达到很好的抽象程度，例如：这些概念的变体都在GLM分割平面的同一边，而<font color=\"red\">传统的CNN就默认了这个假设——认为隐含概念（latent concept）是线性可分的</font>。然而，同一概念的数据通常是非线性流形的（nonlinear manifold），捕捉这些概念的表达通常都是输入的高维非线性函数。在NIN中，GLM用“微型网络”结构替代，该结构是一个<code>非线性函数逼近器</code>。  </p>\n<p>　　本文作者选择多层感知器实例化微型网络，该感知器是一个通用函数逼近器，也是一个通过反向传播训练的神经网络。</p>\n</blockquote>\n<p><img src=\"/2019/01/24/Network-in-Network/nerworkInNetwork1.png\" alt=\"logo\"><br>该图是 单独的 <code>mlpconv 层</code>。<br>这里有没有尝试过其他微型网络结构？？？？（可创新吗）</p>\n<ul>\n<li><h2 id=\"NIN-网络结构\"><a href=\"#NIN-网络结构\" class=\"headerlink\" title=\"NIN 网络结构\"></a>NIN 网络结构</h2><img src=\"/2019/01/24/Network-in-Network/nerworkInNetwork2.png\" alt=\"logo\"></li>\n</ul>\n<p>　　NIN 的整体结构是一系列 <code>mlpconve层</code> 的堆叠，最上层接一个 <code>GAP层</code> 和 <code>分类层</code>。 <code>mlpconv层</code> 间的子层可以被相加，像CNN和maxout网络一样。上图展示了一个包含三个mlpconv层的NIN。每个mlpconv层，包含一个三层的感知器，NIN和微型网络的层数都是灵活的，可以根据具体任务微调。</p>\n<p>　　这里没有采用传统CNN的 <code>全连接层</code> 进行分类，而是直接通过 <code>全局平均池化层（GAP）</code>输出最后一个 <code>mlpconv层特征图</code>的空间平均值作为类别的置信度值，然后将得到的向量输入 <code>softmax层</code>。</p>\n"},{"title":"Java集合-目录","date":"2020-01-01T08:10:40.000Z","_content":"\n![logo](Java-集合结构/集合.png)\n\nJava 集合类都在java.util包中，提供了如可变长数组，集合，队列，堆栈，链表等数据结构。\n宏观上看整个结构可以分为两大部分： 属于单列集合Collection 接口和带映射的多列集合的Map接口。\n\n\n-\t[**Collection**](www.elgong.top) 接口：集合的基本操作和属性\n\n\t- **List** 接口：有序列表\n\t\t- [**ArrayList**](www.elgong.top)：  可变长的数组。 \n\t\t- [**LinkedList**](www.elgong.top)： 双端队列的链表结构。 \n\n\t- **Set** 接口： 不重复元素的集合\n\t\t- [**HashSet**](www.elgong.top)： HashMap 实现的，无序。\n\t\t- [**TreeSet**](www.elgong.top)：  HashMTree 实现的，有序。\n\t- **Queue** 接口： \n\t\t- **Deque** 接口：  [**LinkedList**](www.elgong.top)\n\n-\t[**Map**](http://zhuzhuyule.xyz) 接口：key-value键值对的映射接口\n\t- [**HashMap**](http://zhuzhuyule.xyz)：*数组+链表* 组成的哈希表，无序。\n\t- [**TreeMap**](http://zhuzhuyule.xyz)：基于 *红黑树的排序顺序* 存储键/值对，有序。\n\t- [**Hashtable**](http://zhuzhuyule.xyz)： HashMap类很相似，支持同步。\n\n**两个工具类**：\n\n- **Arrays**\n- **Collections**\n\n\n","source":"_posts/Java-集合结构.md","raw":"---\ntitle: Java集合-目录\ndate: 2020-01-01 16:10:40\ncategories: Java基础\ntags: Java集合\n---\n\n![logo](Java-集合结构/集合.png)\n\nJava 集合类都在java.util包中，提供了如可变长数组，集合，队列，堆栈，链表等数据结构。\n宏观上看整个结构可以分为两大部分： 属于单列集合Collection 接口和带映射的多列集合的Map接口。\n\n\n-\t[**Collection**](www.elgong.top) 接口：集合的基本操作和属性\n\n\t- **List** 接口：有序列表\n\t\t- [**ArrayList**](www.elgong.top)：  可变长的数组。 \n\t\t- [**LinkedList**](www.elgong.top)： 双端队列的链表结构。 \n\n\t- **Set** 接口： 不重复元素的集合\n\t\t- [**HashSet**](www.elgong.top)： HashMap 实现的，无序。\n\t\t- [**TreeSet**](www.elgong.top)：  HashMTree 实现的，有序。\n\t- **Queue** 接口： \n\t\t- **Deque** 接口：  [**LinkedList**](www.elgong.top)\n\n-\t[**Map**](http://zhuzhuyule.xyz) 接口：key-value键值对的映射接口\n\t- [**HashMap**](http://zhuzhuyule.xyz)：*数组+链表* 组成的哈希表，无序。\n\t- [**TreeMap**](http://zhuzhuyule.xyz)：基于 *红黑树的排序顺序* 存储键/值对，有序。\n\t- [**Hashtable**](http://zhuzhuyule.xyz)： HashMap类很相似，支持同步。\n\n**两个工具类**：\n\n- **Arrays**\n- **Collections**\n\n\n","slug":"Java-集合结构","published":1,"updated":"2020-02-20T04:41:37.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephdb000kt8plvisqu77f","content":"<p><img src=\"/2020/01/01/Java-集合结构/集合.png\" alt=\"logo\"></p>\n<p>Java 集合类都在java.util包中，提供了如可变长数组，集合，队列，堆栈，链表等数据结构。<br>宏观上看整个结构可以分为两大部分： 属于单列集合Collection 接口和带映射的多列集合的Map接口。</p>\n<ul>\n<li><p><a href=\"www.elgong.top\"><strong>Collection</strong></a> 接口：集合的基本操作和属性</p>\n<ul>\n<li><p><strong>List</strong> 接口：有序列表</p>\n<ul>\n<li><a href=\"www.elgong.top\"><strong>ArrayList</strong></a>：  可变长的数组。 </li>\n<li><a href=\"www.elgong.top\"><strong>LinkedList</strong></a>： 双端队列的链表结构。 </li>\n</ul>\n</li>\n<li><p><strong>Set</strong> 接口： 不重复元素的集合</p>\n<ul>\n<li><a href=\"www.elgong.top\"><strong>HashSet</strong></a>： HashMap 实现的，无序。</li>\n<li><a href=\"www.elgong.top\"><strong>TreeSet</strong></a>：  HashMTree 实现的，有序。</li>\n</ul>\n</li>\n<li><strong>Queue</strong> 接口： <ul>\n<li><strong>Deque</strong> 接口：  <a href=\"www.elgong.top\"><strong>LinkedList</strong></a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"http://zhuzhuyule.xyz\" target=\"_blank\" rel=\"noopener\"><strong>Map</strong></a> 接口：key-value键值对的映射接口</p>\n<ul>\n<li><a href=\"http://zhuzhuyule.xyz\" target=\"_blank\" rel=\"noopener\"><strong>HashMap</strong></a>：<em>数组+链表</em> 组成的哈希表，无序。</li>\n<li><a href=\"http://zhuzhuyule.xyz\" target=\"_blank\" rel=\"noopener\"><strong>TreeMap</strong></a>：基于 <em>红黑树的排序顺序</em> 存储键/值对，有序。</li>\n<li><a href=\"http://zhuzhuyule.xyz\" target=\"_blank\" rel=\"noopener\"><strong>Hashtable</strong></a>： HashMap类很相似，支持同步。</li>\n</ul>\n</li>\n</ul>\n<p><strong>两个工具类</strong>：</p>\n<ul>\n<li><strong>Arrays</strong></li>\n<li><strong>Collections</strong></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/2020/01/01/Java-集合结构/集合.png\" alt=\"logo\"></p>\n<p>Java 集合类都在java.util包中，提供了如可变长数组，集合，队列，堆栈，链表等数据结构。<br>宏观上看整个结构可以分为两大部分： 属于单列集合Collection 接口和带映射的多列集合的Map接口。</p>\n<ul>\n<li><p><a href=\"www.elgong.top\"><strong>Collection</strong></a> 接口：集合的基本操作和属性</p>\n<ul>\n<li><p><strong>List</strong> 接口：有序列表</p>\n<ul>\n<li><a href=\"www.elgong.top\"><strong>ArrayList</strong></a>：  可变长的数组。 </li>\n<li><a href=\"www.elgong.top\"><strong>LinkedList</strong></a>： 双端队列的链表结构。 </li>\n</ul>\n</li>\n<li><p><strong>Set</strong> 接口： 不重复元素的集合</p>\n<ul>\n<li><a href=\"www.elgong.top\"><strong>HashSet</strong></a>： HashMap 实现的，无序。</li>\n<li><a href=\"www.elgong.top\"><strong>TreeSet</strong></a>：  HashMTree 实现的，有序。</li>\n</ul>\n</li>\n<li><strong>Queue</strong> 接口： <ul>\n<li><strong>Deque</strong> 接口：  <a href=\"www.elgong.top\"><strong>LinkedList</strong></a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"http://zhuzhuyule.xyz\" target=\"_blank\" rel=\"noopener\"><strong>Map</strong></a> 接口：key-value键值对的映射接口</p>\n<ul>\n<li><a href=\"http://zhuzhuyule.xyz\" target=\"_blank\" rel=\"noopener\"><strong>HashMap</strong></a>：<em>数组+链表</em> 组成的哈希表，无序。</li>\n<li><a href=\"http://zhuzhuyule.xyz\" target=\"_blank\" rel=\"noopener\"><strong>TreeMap</strong></a>：基于 <em>红黑树的排序顺序</em> 存储键/值对，有序。</li>\n<li><a href=\"http://zhuzhuyule.xyz\" target=\"_blank\" rel=\"noopener\"><strong>Hashtable</strong></a>： HashMap类很相似，支持同步。</li>\n</ul>\n</li>\n</ul>\n<p><strong>两个工具类</strong>：</p>\n<ul>\n<li><strong>Arrays</strong></li>\n<li><strong>Collections</strong></li>\n</ul>\n"},{"title":"mysql-必知必会1-数据定义语言DDL","date":"2020-04-11T03:15:23.000Z","_content":"\n# **数据库和表的创建，修改，删除**\n\n- 创建  create\n- 修改  alter\n- 删除  drop\n\n```mysql\n# ########  数据库相关\n# 创建库\nCREATE DATABASE 库名 IF NOT EXISTS;\n\n# 修改库名\nRENAME DATABASE  books  TO   新库名;\n\n# 删除库\nDROP DATABASE  IF EXISTS books;\n\n# ######### 表相关\n#  创建表\nCREATE TABLE   IF NOT EXISTS customers\n(\n    cust_id    int    NOT NULL AUTO_INCREMENT,  #  自动增加\n    cust_name  char(50) NOT NULL  DEFAULT GEL,  #  设默认值\n    cust_address char(50) NULL,\n   cust_city  char(50) NULL,\n   cust_state  char(5) NULL,\n   cust_email  char(255) NULL,\n   PRIMARY KEY (cust_id)   #  指定主键\n) ENGINE=InnoDB;\n\n\nCREATE TABLE   IF NOT EXISTS student\n(\n    id    int    NOT NULL AUTO_INCREMENT,  \n    name  char(50) NOT NULL,  \n    address char(50) NULL,\n    city  char(50) NULL,\n    email  char(255) NULL,\n   PRIMARY KEY (id) \n) ENGINE=InnoDB;\n\n\n#  更新表\n#  添加一列 ADD\nALTER TABLE customers ADD cust_phone CHAR(20);\n\n#  删除表 \nDROP TABLE customers\n#  修改表名\nRENAME TABLE customers TO customers222;  \n#  修改列名\nALTER  TABLE book CHANGE COLUMN 旧名  新名  类型;\n\n#  修改列名，约束\nALTER  TABLE book MODIFY COLUMN 列名  类型;\n\n#  删除一列 DROP\nALTER TABLE customers DROP COLUMN cust_phone;\n\n```\n\n","source":"_posts/mysql-必知必会1-数据定义语言DDL.md","raw":"---\ntitle: mysql-必知必会1-数据定义语言DDL\ndate: 2020-04-11 11:15:23\ncategories: mysql\ntags: mysql-必知必会系列\n\n---\n\n# **数据库和表的创建，修改，删除**\n\n- 创建  create\n- 修改  alter\n- 删除  drop\n\n```mysql\n# ########  数据库相关\n# 创建库\nCREATE DATABASE 库名 IF NOT EXISTS;\n\n# 修改库名\nRENAME DATABASE  books  TO   新库名;\n\n# 删除库\nDROP DATABASE  IF EXISTS books;\n\n# ######### 表相关\n#  创建表\nCREATE TABLE   IF NOT EXISTS customers\n(\n    cust_id    int    NOT NULL AUTO_INCREMENT,  #  自动增加\n    cust_name  char(50) NOT NULL  DEFAULT GEL,  #  设默认值\n    cust_address char(50) NULL,\n   cust_city  char(50) NULL,\n   cust_state  char(5) NULL,\n   cust_email  char(255) NULL,\n   PRIMARY KEY (cust_id)   #  指定主键\n) ENGINE=InnoDB;\n\n\nCREATE TABLE   IF NOT EXISTS student\n(\n    id    int    NOT NULL AUTO_INCREMENT,  \n    name  char(50) NOT NULL,  \n    address char(50) NULL,\n    city  char(50) NULL,\n    email  char(255) NULL,\n   PRIMARY KEY (id) \n) ENGINE=InnoDB;\n\n\n#  更新表\n#  添加一列 ADD\nALTER TABLE customers ADD cust_phone CHAR(20);\n\n#  删除表 \nDROP TABLE customers\n#  修改表名\nRENAME TABLE customers TO customers222;  \n#  修改列名\nALTER  TABLE book CHANGE COLUMN 旧名  新名  类型;\n\n#  修改列名，约束\nALTER  TABLE book MODIFY COLUMN 列名  类型;\n\n#  删除一列 DROP\nALTER TABLE customers DROP COLUMN cust_phone;\n\n```\n\n","slug":"mysql-必知必会1-数据定义语言DDL","published":1,"updated":"2020-04-11T03:21:09.948Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephdf000mt8plzdw2a1pc","content":"<h1 id=\"数据库和表的创建，修改，删除\"><a href=\"#数据库和表的创建，修改，删除\" class=\"headerlink\" title=\"数据库和表的创建，修改，删除\"></a><strong>数据库和表的创建，修改，删除</strong></h1><ul>\n<li>创建  create</li>\n<li>修改  alter</li>\n<li>删除  drop</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ########  数据库相关</span><br><span class=\"line\"># 创建库</span><br><span class=\"line\">CREATE DATABASE 库名 IF NOT EXISTS;</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改库名</span><br><span class=\"line\">RENAME DATABASE  books  TO   新库名;</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除库</span><br><span class=\"line\">DROP DATABASE  IF EXISTS books;</span><br><span class=\"line\"></span><br><span class=\"line\"># ######### 表相关</span><br><span class=\"line\">#  创建表</span><br><span class=\"line\">CREATE TABLE   IF NOT EXISTS customers</span><br><span class=\"line\">(</span><br><span class=\"line\">    cust_id    int    NOT NULL AUTO_INCREMENT,  #  自动增加</span><br><span class=\"line\">    cust_name  char(50) NOT NULL  DEFAULT GEL,  #  设默认值</span><br><span class=\"line\">    cust_address char(50) NULL,</span><br><span class=\"line\">   cust_city  char(50) NULL,</span><br><span class=\"line\">   cust_state  char(5) NULL,</span><br><span class=\"line\">   cust_email  char(255) NULL,</span><br><span class=\"line\">   PRIMARY KEY (cust_id)   #  指定主键</span><br><span class=\"line\">) ENGINE=InnoDB;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE   IF NOT EXISTS student</span><br><span class=\"line\">(</span><br><span class=\"line\">    id    int    NOT NULL AUTO_INCREMENT,  </span><br><span class=\"line\">    name  char(50) NOT NULL,  </span><br><span class=\"line\">    address char(50) NULL,</span><br><span class=\"line\">    city  char(50) NULL,</span><br><span class=\"line\">    email  char(255) NULL,</span><br><span class=\"line\">   PRIMARY KEY (id) </span><br><span class=\"line\">) ENGINE=InnoDB;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#  更新表</span><br><span class=\"line\">#  添加一列 ADD</span><br><span class=\"line\">ALTER TABLE customers ADD cust_phone CHAR(20);</span><br><span class=\"line\"></span><br><span class=\"line\">#  删除表 </span><br><span class=\"line\">DROP TABLE customers</span><br><span class=\"line\">#  修改表名</span><br><span class=\"line\">RENAME TABLE customers TO customers222;  </span><br><span class=\"line\">#  修改列名</span><br><span class=\"line\">ALTER  TABLE book CHANGE COLUMN 旧名  新名  类型;</span><br><span class=\"line\"></span><br><span class=\"line\">#  修改列名，约束</span><br><span class=\"line\">ALTER  TABLE book MODIFY COLUMN 列名  类型;</span><br><span class=\"line\"></span><br><span class=\"line\">#  删除一列 DROP</span><br><span class=\"line\">ALTER TABLE customers DROP COLUMN cust_phone;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数据库和表的创建，修改，删除\"><a href=\"#数据库和表的创建，修改，删除\" class=\"headerlink\" title=\"数据库和表的创建，修改，删除\"></a><strong>数据库和表的创建，修改，删除</strong></h1><ul>\n<li>创建  create</li>\n<li>修改  alter</li>\n<li>删除  drop</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ########  数据库相关</span><br><span class=\"line\"># 创建库</span><br><span class=\"line\">CREATE DATABASE 库名 IF NOT EXISTS;</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改库名</span><br><span class=\"line\">RENAME DATABASE  books  TO   新库名;</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除库</span><br><span class=\"line\">DROP DATABASE  IF EXISTS books;</span><br><span class=\"line\"></span><br><span class=\"line\"># ######### 表相关</span><br><span class=\"line\">#  创建表</span><br><span class=\"line\">CREATE TABLE   IF NOT EXISTS customers</span><br><span class=\"line\">(</span><br><span class=\"line\">    cust_id    int    NOT NULL AUTO_INCREMENT,  #  自动增加</span><br><span class=\"line\">    cust_name  char(50) NOT NULL  DEFAULT GEL,  #  设默认值</span><br><span class=\"line\">    cust_address char(50) NULL,</span><br><span class=\"line\">   cust_city  char(50) NULL,</span><br><span class=\"line\">   cust_state  char(5) NULL,</span><br><span class=\"line\">   cust_email  char(255) NULL,</span><br><span class=\"line\">   PRIMARY KEY (cust_id)   #  指定主键</span><br><span class=\"line\">) ENGINE=InnoDB;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE   IF NOT EXISTS student</span><br><span class=\"line\">(</span><br><span class=\"line\">    id    int    NOT NULL AUTO_INCREMENT,  </span><br><span class=\"line\">    name  char(50) NOT NULL,  </span><br><span class=\"line\">    address char(50) NULL,</span><br><span class=\"line\">    city  char(50) NULL,</span><br><span class=\"line\">    email  char(255) NULL,</span><br><span class=\"line\">   PRIMARY KEY (id) </span><br><span class=\"line\">) ENGINE=InnoDB;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#  更新表</span><br><span class=\"line\">#  添加一列 ADD</span><br><span class=\"line\">ALTER TABLE customers ADD cust_phone CHAR(20);</span><br><span class=\"line\"></span><br><span class=\"line\">#  删除表 </span><br><span class=\"line\">DROP TABLE customers</span><br><span class=\"line\">#  修改表名</span><br><span class=\"line\">RENAME TABLE customers TO customers222;  </span><br><span class=\"line\">#  修改列名</span><br><span class=\"line\">ALTER  TABLE book CHANGE COLUMN 旧名  新名  类型;</span><br><span class=\"line\"></span><br><span class=\"line\">#  修改列名，约束</span><br><span class=\"line\">ALTER  TABLE book MODIFY COLUMN 列名  类型;</span><br><span class=\"line\"></span><br><span class=\"line\">#  删除一列 DROP</span><br><span class=\"line\">ALTER TABLE customers DROP COLUMN cust_phone;</span><br></pre></td></tr></table></figure>\n"},{"title":"mysql-必知必会2-数据操作语言DML","date":"2020-04-11T03:24:42.000Z","_content":"\n\n\n# **DML  数据操作语言**\n\n- **插入  INSERT** \n- **更新  UPDATE**\n- **删除  DELETE**\n\n## **1.  插入**\n\n**规则： 插入值的类型要一致**\n\n- 语法1：\n\n​\t\t`INSERT   INTO   表名（列名） VALUES ( 值1...)`\n\n- 语法2：\n\n​\t\t`INSERT   INTO   表名 SET  列名1=值1，列名2=值2`\n\n\n\n```mysql\n#  插入 INSERT\n#  插入完整行,或者部分\nINSERT INTO customers(\n    cust_name,\n    cust_address,\n    cust_city,\n    cust_state)\nVALUES(\n    'elgong',\n    '1552460315',\n    'hangzhou',\n    '1'\n);\n\n#  插入多行\nINSERT INTO customers(\n    cust_name,\n    cust_address,\n    cust_city,\n    cust_state)\nVALUES(\n    'elgong',\n    '1552460315',\n    'hangzhou',\n    '1'\n),\n(\n    'gel',\n    '178905324',\n    'hangzhou',\n    '0'\n);\n\n```\n\n\n\n## **2.  更新（**<font color=\"red\"><big>缺了where 就全部更新啦，一定要注意</big></font>）\n\n- 单表更新语法：\n\n  ```mysql\n  UPDATE   表名   SET  列名1=值 ...  WHERE  筛选条件;\n  ```\n\n  \n\n- 多表更新语法：\n\n  ```mysql\n  UPDATE   表名  SET  列名1=值...   \n  \n  WHERE  连接条件 AND  筛选条件;\n  ```\n\n  \n\n```mysql\n#  更新 UPDATE  SET\n#  更新某行的某些列值\nUPDATE customers \nSET cust_email = \"1552460315@qq.com\",   #  列1\n    cust_name = \"ELGONG\"\nWHERE cust_id = 1;\n```\n\n\n\n**3.  删除**\n\n**删除整行**\n\n```mysql\n#   删除\n#  删除特定行\nDELETE FROM customers WHERE cust_id=1;\n\n#  删除所有行\nDELETE FROM customers ;  \nTRUNCATE TABLE;  \n```","source":"_posts/mysql-必知必会2-数据操作语言DML.md","raw":"---\ntitle: mysql-必知必会2-数据操作语言DML\ndate: 2020-04-11 11:24:42\ncategories: mysql\ntags: mysql-必知必会系列\n---\n\n\n\n# **DML  数据操作语言**\n\n- **插入  INSERT** \n- **更新  UPDATE**\n- **删除  DELETE**\n\n## **1.  插入**\n\n**规则： 插入值的类型要一致**\n\n- 语法1：\n\n​\t\t`INSERT   INTO   表名（列名） VALUES ( 值1...)`\n\n- 语法2：\n\n​\t\t`INSERT   INTO   表名 SET  列名1=值1，列名2=值2`\n\n\n\n```mysql\n#  插入 INSERT\n#  插入完整行,或者部分\nINSERT INTO customers(\n    cust_name,\n    cust_address,\n    cust_city,\n    cust_state)\nVALUES(\n    'elgong',\n    '1552460315',\n    'hangzhou',\n    '1'\n);\n\n#  插入多行\nINSERT INTO customers(\n    cust_name,\n    cust_address,\n    cust_city,\n    cust_state)\nVALUES(\n    'elgong',\n    '1552460315',\n    'hangzhou',\n    '1'\n),\n(\n    'gel',\n    '178905324',\n    'hangzhou',\n    '0'\n);\n\n```\n\n\n\n## **2.  更新（**<font color=\"red\"><big>缺了where 就全部更新啦，一定要注意</big></font>）\n\n- 单表更新语法：\n\n  ```mysql\n  UPDATE   表名   SET  列名1=值 ...  WHERE  筛选条件;\n  ```\n\n  \n\n- 多表更新语法：\n\n  ```mysql\n  UPDATE   表名  SET  列名1=值...   \n  \n  WHERE  连接条件 AND  筛选条件;\n  ```\n\n  \n\n```mysql\n#  更新 UPDATE  SET\n#  更新某行的某些列值\nUPDATE customers \nSET cust_email = \"1552460315@qq.com\",   #  列1\n    cust_name = \"ELGONG\"\nWHERE cust_id = 1;\n```\n\n\n\n**3.  删除**\n\n**删除整行**\n\n```mysql\n#   删除\n#  删除特定行\nDELETE FROM customers WHERE cust_id=1;\n\n#  删除所有行\nDELETE FROM customers ;  \nTRUNCATE TABLE;  \n```","slug":"mysql-必知必会2-数据操作语言DML","published":1,"updated":"2020-04-11T03:33:47.274Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephdm000rt8plr1zt4kn8","content":"<h1 id=\"DML-数据操作语言\"><a href=\"#DML-数据操作语言\" class=\"headerlink\" title=\"DML  数据操作语言\"></a><strong>DML  数据操作语言</strong></h1><ul>\n<li><strong>插入  INSERT</strong> </li>\n<li><strong>更新  UPDATE</strong></li>\n<li><strong>删除  DELETE</strong></li>\n</ul>\n<h2 id=\"1-插入\"><a href=\"#1-插入\" class=\"headerlink\" title=\"1.  插入\"></a><strong>1.  插入</strong></h2><p><strong>规则： 插入值的类型要一致</strong></p>\n<ul>\n<li>语法1：</li>\n</ul>\n<p>​        <code>INSERT   INTO   表名（列名） VALUES ( 值1...)</code></p>\n<ul>\n<li>语法2：</li>\n</ul>\n<p>​        <code>INSERT   INTO   表名 SET  列名1=值1，列名2=值2</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#  插入 INSERT</span><br><span class=\"line\">#  插入完整行,或者部分</span><br><span class=\"line\">INSERT INTO customers(</span><br><span class=\"line\">    cust_name,</span><br><span class=\"line\">    cust_address,</span><br><span class=\"line\">    cust_city,</span><br><span class=\"line\">    cust_state)</span><br><span class=\"line\">VALUES(</span><br><span class=\"line\">    &apos;elgong&apos;,</span><br><span class=\"line\">    &apos;1552460315&apos;,</span><br><span class=\"line\">    &apos;hangzhou&apos;,</span><br><span class=\"line\">    &apos;1&apos;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">#  插入多行</span><br><span class=\"line\">INSERT INTO customers(</span><br><span class=\"line\">    cust_name,</span><br><span class=\"line\">    cust_address,</span><br><span class=\"line\">    cust_city,</span><br><span class=\"line\">    cust_state)</span><br><span class=\"line\">VALUES(</span><br><span class=\"line\">    &apos;elgong&apos;,</span><br><span class=\"line\">    &apos;1552460315&apos;,</span><br><span class=\"line\">    &apos;hangzhou&apos;,</span><br><span class=\"line\">    &apos;1&apos;</span><br><span class=\"line\">),</span><br><span class=\"line\">(</span><br><span class=\"line\">    &apos;gel&apos;,</span><br><span class=\"line\">    &apos;178905324&apos;,</span><br><span class=\"line\">    &apos;hangzhou&apos;,</span><br><span class=\"line\">    &apos;0&apos;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-更新（缺了where-就全部更新啦，一定要注意）\"><a href=\"#2-更新（缺了where-就全部更新啦，一定要注意）\" class=\"headerlink\" title=\"2.  更新（缺了where 就全部更新啦，一定要注意）\"></a><strong>2.  更新（</strong><font color=\"red\"><big>缺了where 就全部更新啦，一定要注意</big></font>）</h2><ul>\n<li><p>单表更新语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UPDATE   表名   SET  列名1=值 ...  WHERE  筛选条件;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>多表更新语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UPDATE   表名  SET  列名1=值...   </span><br><span class=\"line\"></span><br><span class=\"line\">WHERE  连接条件 AND  筛选条件;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#  更新 UPDATE  SET</span><br><span class=\"line\">#  更新某行的某些列值</span><br><span class=\"line\">UPDATE customers </span><br><span class=\"line\">SET cust_email = &quot;1552460315@qq.com&quot;,   #  列1</span><br><span class=\"line\">    cust_name = &quot;ELGONG&quot;</span><br><span class=\"line\">WHERE cust_id = 1;</span><br></pre></td></tr></table></figure>\n<p><strong>3.  删除</strong></p>\n<p><strong>删除整行</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#   删除</span><br><span class=\"line\">#  删除特定行</span><br><span class=\"line\">DELETE FROM customers WHERE cust_id=1;</span><br><span class=\"line\"></span><br><span class=\"line\">#  删除所有行</span><br><span class=\"line\">DELETE FROM customers ;  </span><br><span class=\"line\">TRUNCATE TABLE;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"DML-数据操作语言\"><a href=\"#DML-数据操作语言\" class=\"headerlink\" title=\"DML  数据操作语言\"></a><strong>DML  数据操作语言</strong></h1><ul>\n<li><strong>插入  INSERT</strong> </li>\n<li><strong>更新  UPDATE</strong></li>\n<li><strong>删除  DELETE</strong></li>\n</ul>\n<h2 id=\"1-插入\"><a href=\"#1-插入\" class=\"headerlink\" title=\"1.  插入\"></a><strong>1.  插入</strong></h2><p><strong>规则： 插入值的类型要一致</strong></p>\n<ul>\n<li>语法1：</li>\n</ul>\n<p>​        <code>INSERT   INTO   表名（列名） VALUES ( 值1...)</code></p>\n<ul>\n<li>语法2：</li>\n</ul>\n<p>​        <code>INSERT   INTO   表名 SET  列名1=值1，列名2=值2</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#  插入 INSERT</span><br><span class=\"line\">#  插入完整行,或者部分</span><br><span class=\"line\">INSERT INTO customers(</span><br><span class=\"line\">    cust_name,</span><br><span class=\"line\">    cust_address,</span><br><span class=\"line\">    cust_city,</span><br><span class=\"line\">    cust_state)</span><br><span class=\"line\">VALUES(</span><br><span class=\"line\">    &apos;elgong&apos;,</span><br><span class=\"line\">    &apos;1552460315&apos;,</span><br><span class=\"line\">    &apos;hangzhou&apos;,</span><br><span class=\"line\">    &apos;1&apos;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">#  插入多行</span><br><span class=\"line\">INSERT INTO customers(</span><br><span class=\"line\">    cust_name,</span><br><span class=\"line\">    cust_address,</span><br><span class=\"line\">    cust_city,</span><br><span class=\"line\">    cust_state)</span><br><span class=\"line\">VALUES(</span><br><span class=\"line\">    &apos;elgong&apos;,</span><br><span class=\"line\">    &apos;1552460315&apos;,</span><br><span class=\"line\">    &apos;hangzhou&apos;,</span><br><span class=\"line\">    &apos;1&apos;</span><br><span class=\"line\">),</span><br><span class=\"line\">(</span><br><span class=\"line\">    &apos;gel&apos;,</span><br><span class=\"line\">    &apos;178905324&apos;,</span><br><span class=\"line\">    &apos;hangzhou&apos;,</span><br><span class=\"line\">    &apos;0&apos;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-更新（缺了where-就全部更新啦，一定要注意）\"><a href=\"#2-更新（缺了where-就全部更新啦，一定要注意）\" class=\"headerlink\" title=\"2.  更新（缺了where 就全部更新啦，一定要注意）\"></a><strong>2.  更新（</strong><font color=\"red\"><big>缺了where 就全部更新啦，一定要注意</big></font>）</h2><ul>\n<li><p>单表更新语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UPDATE   表名   SET  列名1=值 ...  WHERE  筛选条件;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>多表更新语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UPDATE   表名  SET  列名1=值...   </span><br><span class=\"line\"></span><br><span class=\"line\">WHERE  连接条件 AND  筛选条件;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#  更新 UPDATE  SET</span><br><span class=\"line\">#  更新某行的某些列值</span><br><span class=\"line\">UPDATE customers </span><br><span class=\"line\">SET cust_email = &quot;1552460315@qq.com&quot;,   #  列1</span><br><span class=\"line\">    cust_name = &quot;ELGONG&quot;</span><br><span class=\"line\">WHERE cust_id = 1;</span><br></pre></td></tr></table></figure>\n<p><strong>3.  删除</strong></p>\n<p><strong>删除整行</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#   删除</span><br><span class=\"line\">#  删除特定行</span><br><span class=\"line\">DELETE FROM customers WHERE cust_id=1;</span><br><span class=\"line\"></span><br><span class=\"line\">#  删除所有行</span><br><span class=\"line\">DELETE FROM customers ;  </span><br><span class=\"line\">TRUNCATE TABLE;</span><br></pre></td></tr></table></figure>"},{"title":"mysql-必知必会7-综合内容","date":"2020-04-11T03:35:36.000Z","_content":"\n# **一、关系型数据库Mysql**\n\n数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。\n\n- **数据库:** 数据库是一些关联表的集合。.\n- **数据表:** 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。\n- **列:** 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。\n- **行：**一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。\n- **冗余**：存储两倍数据，冗余可以使系统速度更快。\n- **主键**：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。\n- **外键：**外键用于关联两个表。\n- **复合键**：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。\n- **索引：**使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。\n- **参照完整性:** 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性\n\n- **主键: 表示特定行.**\n  - 主键不能重复\n  - 每行必有主键,且不能为 NULL\n\n- **外键:**  product 只存产品信息, 和供应商ID,  vendors 存供应商的信息(主键是ID),则vendors的主键就是product的外键.\n\n\n\nMySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。\n\n\n\n# **二、 安装与删**\n\n- 删除mysql\n\n  `sudo apt purge mysql-* sudo apt autoremove `\n\n- 安装mysql\n\n  ```shell\n  sudo apt-get install mysql-server \n  sudo apt install mysql-client \n  sudo apt install libmysqlclient-dev `\n  ```\n\n\n\n**数据库规范：**\n\n- 关键字大写，表名，列名小写\n- 索引从1开始\n- 每条命令用分号隔开\n- 注释\n\n- 单行注释   #\n- 单行注释  -- 注释文\n- 多行注释  /* */\n\n<font color=\"red\"><big>索引从1开始！</big></font>\n\n\n\n# **三、常用命令** \n\n##   **指令执行顺序：**\n\n**SELECT  FROM  WHERE   GROUP BY  HAVING  ORDER BY LIMIT.**\n\n   <font color=\"red\"><big>开始 **->** FROM子句 **->** WHERE子句 **->** GROUP BY子句 **->** HAVING子句 **->** ORDER BY子句 **->** SELECT子句 **->** LIMIT子句 **->** 最终结果 </big></font>    \n\n<font color=\"red\"><big>每个步骤都会为下一个步骤生成一个虚拟表</big></font>\n\n\n\n## **1. 登陆系统, 选择数据库**\n\n```mysql\nmysql -u 用户名 -p 密码\nmysql -h localhost -P 3306 -p\n\n# 查看所有数据库列表\nSHOW DATABSASES;\n# 查看选择的数据库中的表的列表\nSHOW TABLES;\n# 查看表中的列有哪些\nSHOW COLUMNS FROM 表名;  ||  DESCRIBE 表名;\n\n# 选择库\nUSE 数据库的名字;\n\n# 查看表结构\nDESC 表名;\n```\n\n\n\n## **2 基础查询——检索 SELECT + DISTINCT**\n\nSELECT 子句 固定的顺序:\n\n**SELECT  FROM  WHERE （原始表有的字段）  GROUP BY  HAVING  （分组后有的字段）ORDER BY LIMIT.**\n\n```mysql\n# 选择多个字段 `着重号`当字段名与关键字冲突，用它可以避免冲突\nSELECT id, `name`, price FROM 表名; \n\n# 起别名 AS, 可以省略SELECT salary \"Month Salary\" from employees;\nSELECT salary AS \"Month Salary\" from employees;\n\n# 字符串拼接 concat\n# 特别注意+：  \n# 1+9=10  两个数值型做加法\n# '12'+ 3 = 15 字符转整数，再加 \n# 'job'+2 = 2  转换失败，则字符串变0\n# null+任何值 = null\nSELECT concat('a', 'b', 'c') , price FROM 表名; \n\n# 检索所有字段\nSELECT * FROM 表名;\n\n# 字段去重  DISTINCT\nSELECT DISTINCT id FROM 表名;   # 不能应用于多列\n\n# 限制检索结果\n SELECT  id FROM 表名  LIMIT 5;  # 前5 \n SELECT  id FROM 表名  LIMIT 2,5;  #从 2+1 开始的  5个行\n SELECT id FROM 表名 LIMIT 5 OFFSET 3;  # 从行3取5\n```\n\n\n\n## **3. 排序检索 ORDER   BY (默认升序) + LIMIT,  OFFSET, DESC**\n\n可以根据非 select 字段排序。\n\nSELECT  查询列表\n\nFROM  表\n\n【where 筛选条件】\n\nORDER BY  排序列表  [asc |  desc]\n\n```mysql\n# 按照某列排序,  多条件排序\nSELECT id FROM 表名 ORDER BY id ASC, age DESC;   # 可以根据其他列来排序\n\n# 按照多个条件排序\nSELECT id FROM 表名 ORDER BY age, size;   # 优先age, 重复时才根据size排序.\n\n#  指定降序  DESC\nSELECT id FROM 表名 ORDER BY age  DESC  size;  # DESC 只作用于在DESC 前面的, 所以 size仍然为升序\n\n# 找到最********的id\nSELECT id FROM 表名 ORDER BY age LIMIT 1;\n# 第二最的*******id\nSELECT id FROM 表名 ORDER BY age LIMIT 1 OFFSET 2;\n```\n\n\n\n## **4. 条件查询**\n\n### **4.1  ——逻辑运算 WHERE + AND, OR,NOT** **IN 和EXISTS(看优化部分)**\n\n**作用：**\n\n连接条件表达式\n\n<font color=\"red\"><big>**如果计算次序不加括号时,  优先 AND**</big></font>\n\n```mysql\n#  =  !=  <  > >=    \"BETWEEN 1 AND 2\"在指定值之间,包含端点\n# 不等于 ！=   或者  <>\nSELECT id FROM 表名 WHERE age=12 ORDER BY size;\n\n# 组合筛选  AND  OR\nSELECT id FROM 表名 WHERE age=12 AND size < 10;\n\n# 计算次序,  不加括号时,  优先 AND\n# 解释: id>3且age>10,  或者 id=1\nSELECT id FROM 表名 WHERE id=1 OR id=3 AND age > 10;   \n\n# NOT  否定后跟的所有条件.\nSELECT id FROM 表名 NOT WHERE id IN (1002, 1003)\n```\n\n\n\n![img](C:\\Users\\Misaya\\AppData\\Local\\YNote\\data\\elgong@126.com\\e87e0bbb47ff40228ca7b6dbebad7954\\clipboard.png)\n\n### **4.2  ——模糊查询  WHERE + LIKE, between and, in, is null**\n\n- **like + 通配符：** 参考7.\n- **between and ：** 包含临界值， 不可颠倒顺序\n- **in：**\n\n```mysql\n# between and\nSELECT  * FROM 表名  WHERE id BETWEEN 100 and 120;\n\n# IN 取值必须在括号内\nSELECT id FROM 表名 WHERE id IN (1002, 1003)\n\n# IS NULL 筛选出空值  IS NOT NULL\nSELECT id FROM 表名 WHERE age IS NULL;\n```\n\n\n\n**补. 空值处理 IFNULL(字段，空值时返回值)**\n\n`SELECT IFNULL(price, 0) FROM 表名;  `\n\n\n\n## **5. 通配符   LIKE + % , _   + 正则表达式** **REGEXP   都****不区分大小写**\n\n1. 通配符速度慢, 不要放在搜索开始处\n\n2. **LIKE 匹配整个串,  正则表达式可以匹配子串**\n\n```mysql\n#  通配符\n#  % 匹配0,1,多个字符\nSELECT id FROM 表名 WHERE string LIKE 's%';   # s开头   \n\n# 下划线 _ , 匹配单个字符\n# 需要匹配 _ 时， 用转义   \\_\nSELECT id FROM 表名 WHERE string LIKE 's_';  \n\n------------------------------------------------------------------\n#  正则表达式 REGEXP\n# 标准表达\nSELECT name FROM customers WHERE name REGEXP '1000';\n\n'.'   # 任意一个字符\n'A1'| 'B2'  # 匹配两个串之一\n'[1-9]'     # 匹配 1~9 范围内的值\n'[123]'     # 匹配1，2，3之一， 等价于【1 | 2 | 3】\n'[^123]'    # 匹配非123的值\n'\\\\.'       # 特殊字符转译   \n\n# 匹配多个实例, 不能单独出现,必须是指定上边的某种字符的匹配\n# 例如 '.*' 而不是'*'\n'*'  # 0或多个匹配\n'+'  # 1或多个匹配\n'?'  # 0或者1个匹配\n{n}  # 指定数目匹配\n{n,}  # 不少于指定数目的匹配\n{n,m}  # 数目范围,不超过255\n\n#定位元字符\n'^'   # 开始位置\n'$'   # 结尾\n'[[:<:]]'  # 词开始\n'[[:<:]]'  # 词结尾\n\n# 举例:\n'^[1-9]'   \nBINARY 'J 1000'     # 指定区分大小写\n\n'[a-zA-Z0-9]'   # 匹配所有字符\n```\n\n\n\n## **6. 数据处理常用函数 (不区分大小写)**\n\n- 字符函数\n- 数学函数\n- 日期函数\n- 其他函数\n- 流程函数\n\n字符函数\n\n```mysql\n# 文本处理函数\n# 1. 字符串字节个数,  汉字算三个字符\nLength() \n\n# 2. 拼接\nCONCAT(id, \"_\", name)\n\n# 3. 大写 小写\nLower()  # 小写\nUpper()  # 大写\n\n# 4. 返回子串的字符, 数据库索引从1开始\nSubStr(last_name, start) \nSubStr(last_name, start, length)   # 长度\n\n# 5. 查找子串, 返回第一次出现的索引， 查不到返回0\nINSTR(\"待查子串abcd\", \"a\")\n\n# 6. 去空格\nTrim(), LTrim(), RTrim()  \n\n# 7. 指定长度填充\nLPAD(name, length, '*')\nRPAD(name, length, '*')\n\n# 8. 替换\nREPLACE(原串, '被替换串', '新串')\n\n# 9. 字符串字符长度, 汉字也算 1个字符\nCHAR_LENGTH(s)  \nSoundex()   # 返回串的SOUNDEX值\n\n  \n```\n\n\n\n数学函数\n\n```mysql\n# 1. 四舍五入\nROUND(1.6);   # 2\nROUND(1.567, 2)  # 小数点保留两位\n\n# 2. 上取整， >=该参数的最小整数\nCEIL(1.00) \n# 下取整,   <=该参数的最大整数\nFLOOR(-9.99)   # -10\n\n# 3. 小数点直接截断\nTRUNCATE(1.69999, 1)  # 1.6\n\n# 4. 取余数\nMOD(10, 3)  # 10%3\n\nABS(x)   # 绝对值\nAVG(age)  # 某列的平均值 \nEXP(x)\nRAND()  # 0到1的随机数\n```\n\n\n\n日期函数\n\n```mysql\nNOW()   # 当前日期和时间\nCURDATE() # 当前日期，不含时间\nDate()  # 返回时间中的日期部分....\nDay()   # 返回时间中的天数部分\nYear(NOW())\nTime()\nMonth()  \nHour()\nDateDiff()  # 计算日期差\n\n# 字符串转日期\nSTR_TO_DATE('02-19-2020', \"%m-%d-%Y\")\n\n# 日期的格式化输出\nDATE_FORMAT(NOW(), '%y年%m月%d日')\n```\n\n\n\n其他函数\n\n`VERSION() `\n\n## **7. 流程控制函数**\n\nIF(逻辑判断， 成立执行， 不成立执行)\n\nCASE:\n\n```mysql\n# IF\nIF(10>5, '大', '小')\nSELECT name IF(salary IS NULL, \"没薪水\", \"有薪水\")\n\n# CASE 第一种使用\nCASE '要判断的表达式'\nWHEN '常量1' then 值(没有分号) / 表达式(有分号);\nWHEN '常量2' then 值(没有分号) / 表达式(有分号);\nWHEN '常量3' then 值(没有分号) / 表达式(有分号);\n...\nELSE 值(没有分号) / 表达式(有分号);\nEND;\n\n# CASE 第二种语句\nCASE \nWHEN 表达式 then 值(没有分号) / 表达式(有分号);\nWHEN 表达式 then 值(没有分号) / 表达式(有分号);\nWHEN 表达式 then 值(没有分号) / 表达式(有分号);\n...\nELSE 值(没有分号) / 表达式(有分号);\nEND;\n```\n\n\n\n## **8. 数据汇总-聚集函数  AVG, COUNT, MAX, MIN, SUM**\n\n运行在行组, 计算和返回单个值的函数.\n\n统计使用\n\n```mysql\n# AVG() 针对单列,  对多列需要使用多个\nSELECT AVG(age) AS avg_age FROM 表名;   # 忽略 NULL\n\n# COUNT() 函数\nCOUNT(1);   # 行数\nCOUNT(*);   # 表的行数, 含有 NULL的有数据行也可，但是不能全NULL\nCOUNT(column)  # 某列非NULL 的个数\nCOUNT(distinct 字段)  # 统计不重复的\n# 效率对比：\nMYISAM 储存引擎下， COUNT(*) 效率高\nINNODB 存储引擎下，COUNT(*) 和COUNT(1) 差不多，比COUNT(字段高)\n\n# 聚集不同的值 + DISTINCT\n# 聚集函数默认ALL\nSELECT AVG(DISTINCT age) FROM 表名;  # 对唯一值求均值\nSELECT COUNt(DISTINCT age) FROM 表名;  # 对age列的唯一值统计个数\n```\n\n\n\n## **9. 数据分组查询 —— GROUP BY,   HAVING**\n\n### **1. GROUP BY   分组字段**\n\n​          <font color=\"red\"><big>**如果分组列中具有 NULL,  则NULL 将作为一个分组返回.**</big></font>\n\n### **2. HAVING 过滤条件  =====WHERE 条件**\n\n\n\n### **3. 必加 ORDER BY,  因为G出来的结果不保证排序了.**\n\n\n\n### **4. 能where 就不用having**\n\n- **按字段分组**\n\n- - GROUP BY id \n\n- **按表达式或者函数**\n\n- - GROUP BY length(id)  AS  len   HAVING  len>3;\n\n- **按多个字段分组**\n\n```mysql\n# 分组统计值\nSELECT id, COUNT(*) AS num_ FROM 表名 GROUP BY id ORDER BY age;\n\n# 分组过滤  大于2的值\nSELECT age FROM 表名 GROUP BY  id  HAVING COUNT(*)>=2 ORDER BY age;\n```\n\n\n\n## **10. 子查询  IN + 括号**\n\n- 查询的结果作为另一个查询的条件,然后多层嵌套.\n- 内层查询**建立一个临时表**。费时间.\n- 优化需要用join 联结表替代....\n\n**where 和 having 后可放的子查询：**\n\n- 子查询放在小括号内\n\n- **标量子查询（单值）**，一般配合单行操作符使用：  >  <   >=  =  <>\n\n- **列子查询（单列多行）**， 一般配合多行操作符使用：  \n\n- - IN   列表中的一个\n  - ANY/SOME   \n  - ALL\n\n**select 后可以放的子查询：**\n\n**from 后可以放的子查询：**\n\n- 必须起别名\n\n- - FROM (子查询表)  newtable \n\n```mysql\n# 标量子查询\n# 1. 谁工资比  elgong 高\nSELECT  * FROM employee \nWHERE salary>(select salary from emplot WHERE name = 'elgong');\n\n# 查询超过平均工资的员工信息\nselect avg(sal) from emp;   /* avg(sal)=2000 */\nselect * from emp where sal >= 2000;\n/* 子查询方法 */\nselect * from emp where sal >= (select avg(sal) from emp);\n```\n\n\n\n## **11. 连接查询——JOIN 联结表 ( INNER JOIN, LEFT JOIN, RIGHT JOIN)**\n\n**注意判断驱动表是哪个？  查询计划  explain**\n\n正常情况下，from 后的表是驱动表，但是当出现下面情况，驱动表变成了 class。\n\n分析： 当 where 后的条件使得表之间数据多少不一样时，数据少的为主表\n\n**小表驱动大表的原则**\n\n`select * from student left join class on  class.classid = student.classid where class.classid = 2; `\n\n\n\n**概念:    联结指两张表,或者多张表之间组合在一起进行查询, 是在运行时做的操作;**\n\n- **left JOIN ** (左联结)保证读取主表的全部数据\n\n- **right JOIN**  (右联结) 保证读取主表的全部数据\n\n- **inner JOIN**  (内部联结,等值联结)  只读取共有的数据\n\n- **自联结:  **常用来代替从同一个表检索数据的子查询.  FROM table1 AS t1, table2 AS t2, WHERE t1.col = t2.col;\n\n- **自然联结: ** 联结有主副表之分,  在INNER JOIN 之前的是主表, 待查询的输出中,排前边的内容所在的表为主表.\n\n左外联结可通过颠倒FROM 或者WHERE 子句中表的顺序转换成右外部联结\n\n**连接的分类**\n\n- SQL92语法\n\n- - **等值连接**\n\n  - - `FROM table1 AS t1, table2 AS t2, table3 AS t3  WHERE t1.col = t2.col  AND t2.c = t3.c ;`\t\n\n  - **自连接（单表）**\n\n  - - 同表不同名\n    - `FROM   employees   e1,  employees  e2  WHERE  e1.id = e2.iidd`\n\n- SQL99语法\n\n- - SELECT   查询列表\n  - `FROM   表1  别名  [连接类型]   join        表2  别名   on          连接条件`\n\n- - **内连接**  inner join\n\n  - **外连接**  left， right\n\n  - - 主表全部显示\n    - 从表中没有与主表匹配的结果，显示NULL\n    - 等价于==== 内连接结果 + 主表有而从表没有的记录\n    - 左外和右外，交换表顺序可以等价效果\n\n  - **全外连接**  full join\n\n  - **交叉连接**   cross join\n\n  - - 笛卡尔乘机\n\n  - **非等值连接**\n\n  - - FROM e  join g on e.salary  BETWEEN g.low AND g.upper\n\n  - **自连接**\n\n  - - 一样的join on   不同名的同一张表\n\n```mysql\n# 创建联结表的两种方式\n# 1. 等值连接  WHERE 表1.id = 表2.id AND 表2.size = 表3.size\nSELECT vendors.vendor_name, product.prod_name, product.prod_price \nFROM product,vendors \nWHERE vendors.vendor_id = product.vendor_id \nORDER BY vendor_name;\n\n# 2.内部联结(等值联结) 表的键数量相同  FROM 表1 INNER JOIN 表2 ON 表1.id = 表2.id\nSELECT v.vendor_name, p.prod_name, p.prod_price \nFROM product AS p \nINNER JOIN vendors AS v \nON v.vendor_id = p.vendor_id  \nORDER BY v.vendor_name;\n\n# \n# 对联结的表使用聚合方法\n待补充.....\n```\n\n\n\n![img](C:\\Users\\Misaya\\AppData\\Local\\YNote\\data\\elgong@126.com\\e6a36fe8659843b897ed6b6e6ee6977d\\clipboard.png)\n\n\n\n## **12. 分页查询**\n\n  **LIMIT  行X(从0开始),  size;**\n\n  **LIMIT  size OFFSET  size;**\n\n**当要显示的数据，需要分页显示** \n\n- 从行0开始\n- 从第四行开始，检索5行\n- **LIMIT   3,  5**\n- **LIMIT   5  OFFSET  3**\n\n```mysql\n#  查询前5条数据\nSELECT  *  FROM employees LIMIT 0, 5;\n\t\n# 查询11到25条数据\nSELECT  *  FROM employees LIMIT 10, 25-11+1;\n\n# 计算公式\nLIMIT (page-1)*size,  size;\n```\n\n\n\n## **13. 联合查询  union  （自动去重，union all  不去重）**\n\n将多条查询语句合并成一个结果\n\n**特点：**\n\n- 查询 **列数** 和 **列顺序** 必须一致\n- 自动去重\n- 不去重  union all\n\n```mysql\nSELECT   *   FROM    e1   WHERE   \nUNION\nSELECT   *   FROM    e1   WHERE \n```\n\n\n\n## **14. 视图**\n\n视图是虚拟的表, 是对其基表的封装.\n\n使用的好处:\n\n1. 重用 SQL 语句\n\n2. 使用表的部分,即过滤掉部分数据\n\n限制:\n\n1. 图名唯一\n\n2. 视图可以嵌套\n\n3. 视图的ORDER BY  次于 从该视图检索数据的ORDER\n\n4. 视图可以和表一起使用\n\n```mysql\n# 创建视图\nCREATE VIEW  viewname AS\nSELECT * FROM table WHERE id!=1;\n```\n\n","source":"_posts/mysql-必知必会7-综合内容.md","raw":"---\ntitle: mysql-必知必会7-综合内容\ndate: 2020-04-11 11:35:36\ncategories: mysql\ntags: mysql-必知必会系列\n---\n\n# **一、关系型数据库Mysql**\n\n数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。\n\n- **数据库:** 数据库是一些关联表的集合。.\n- **数据表:** 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。\n- **列:** 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。\n- **行：**一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。\n- **冗余**：存储两倍数据，冗余可以使系统速度更快。\n- **主键**：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。\n- **外键：**外键用于关联两个表。\n- **复合键**：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。\n- **索引：**使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。\n- **参照完整性:** 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性\n\n- **主键: 表示特定行.**\n  - 主键不能重复\n  - 每行必有主键,且不能为 NULL\n\n- **外键:**  product 只存产品信息, 和供应商ID,  vendors 存供应商的信息(主键是ID),则vendors的主键就是product的外键.\n\n\n\nMySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。\n\n\n\n# **二、 安装与删**\n\n- 删除mysql\n\n  `sudo apt purge mysql-* sudo apt autoremove `\n\n- 安装mysql\n\n  ```shell\n  sudo apt-get install mysql-server \n  sudo apt install mysql-client \n  sudo apt install libmysqlclient-dev `\n  ```\n\n\n\n**数据库规范：**\n\n- 关键字大写，表名，列名小写\n- 索引从1开始\n- 每条命令用分号隔开\n- 注释\n\n- 单行注释   #\n- 单行注释  -- 注释文\n- 多行注释  /* */\n\n<font color=\"red\"><big>索引从1开始！</big></font>\n\n\n\n# **三、常用命令** \n\n##   **指令执行顺序：**\n\n**SELECT  FROM  WHERE   GROUP BY  HAVING  ORDER BY LIMIT.**\n\n   <font color=\"red\"><big>开始 **->** FROM子句 **->** WHERE子句 **->** GROUP BY子句 **->** HAVING子句 **->** ORDER BY子句 **->** SELECT子句 **->** LIMIT子句 **->** 最终结果 </big></font>    \n\n<font color=\"red\"><big>每个步骤都会为下一个步骤生成一个虚拟表</big></font>\n\n\n\n## **1. 登陆系统, 选择数据库**\n\n```mysql\nmysql -u 用户名 -p 密码\nmysql -h localhost -P 3306 -p\n\n# 查看所有数据库列表\nSHOW DATABSASES;\n# 查看选择的数据库中的表的列表\nSHOW TABLES;\n# 查看表中的列有哪些\nSHOW COLUMNS FROM 表名;  ||  DESCRIBE 表名;\n\n# 选择库\nUSE 数据库的名字;\n\n# 查看表结构\nDESC 表名;\n```\n\n\n\n## **2 基础查询——检索 SELECT + DISTINCT**\n\nSELECT 子句 固定的顺序:\n\n**SELECT  FROM  WHERE （原始表有的字段）  GROUP BY  HAVING  （分组后有的字段）ORDER BY LIMIT.**\n\n```mysql\n# 选择多个字段 `着重号`当字段名与关键字冲突，用它可以避免冲突\nSELECT id, `name`, price FROM 表名; \n\n# 起别名 AS, 可以省略SELECT salary \"Month Salary\" from employees;\nSELECT salary AS \"Month Salary\" from employees;\n\n# 字符串拼接 concat\n# 特别注意+：  \n# 1+9=10  两个数值型做加法\n# '12'+ 3 = 15 字符转整数，再加 \n# 'job'+2 = 2  转换失败，则字符串变0\n# null+任何值 = null\nSELECT concat('a', 'b', 'c') , price FROM 表名; \n\n# 检索所有字段\nSELECT * FROM 表名;\n\n# 字段去重  DISTINCT\nSELECT DISTINCT id FROM 表名;   # 不能应用于多列\n\n# 限制检索结果\n SELECT  id FROM 表名  LIMIT 5;  # 前5 \n SELECT  id FROM 表名  LIMIT 2,5;  #从 2+1 开始的  5个行\n SELECT id FROM 表名 LIMIT 5 OFFSET 3;  # 从行3取5\n```\n\n\n\n## **3. 排序检索 ORDER   BY (默认升序) + LIMIT,  OFFSET, DESC**\n\n可以根据非 select 字段排序。\n\nSELECT  查询列表\n\nFROM  表\n\n【where 筛选条件】\n\nORDER BY  排序列表  [asc |  desc]\n\n```mysql\n# 按照某列排序,  多条件排序\nSELECT id FROM 表名 ORDER BY id ASC, age DESC;   # 可以根据其他列来排序\n\n# 按照多个条件排序\nSELECT id FROM 表名 ORDER BY age, size;   # 优先age, 重复时才根据size排序.\n\n#  指定降序  DESC\nSELECT id FROM 表名 ORDER BY age  DESC  size;  # DESC 只作用于在DESC 前面的, 所以 size仍然为升序\n\n# 找到最********的id\nSELECT id FROM 表名 ORDER BY age LIMIT 1;\n# 第二最的*******id\nSELECT id FROM 表名 ORDER BY age LIMIT 1 OFFSET 2;\n```\n\n\n\n## **4. 条件查询**\n\n### **4.1  ——逻辑运算 WHERE + AND, OR,NOT** **IN 和EXISTS(看优化部分)**\n\n**作用：**\n\n连接条件表达式\n\n<font color=\"red\"><big>**如果计算次序不加括号时,  优先 AND**</big></font>\n\n```mysql\n#  =  !=  <  > >=    \"BETWEEN 1 AND 2\"在指定值之间,包含端点\n# 不等于 ！=   或者  <>\nSELECT id FROM 表名 WHERE age=12 ORDER BY size;\n\n# 组合筛选  AND  OR\nSELECT id FROM 表名 WHERE age=12 AND size < 10;\n\n# 计算次序,  不加括号时,  优先 AND\n# 解释: id>3且age>10,  或者 id=1\nSELECT id FROM 表名 WHERE id=1 OR id=3 AND age > 10;   \n\n# NOT  否定后跟的所有条件.\nSELECT id FROM 表名 NOT WHERE id IN (1002, 1003)\n```\n\n\n\n![img](C:\\Users\\Misaya\\AppData\\Local\\YNote\\data\\elgong@126.com\\e87e0bbb47ff40228ca7b6dbebad7954\\clipboard.png)\n\n### **4.2  ——模糊查询  WHERE + LIKE, between and, in, is null**\n\n- **like + 通配符：** 参考7.\n- **between and ：** 包含临界值， 不可颠倒顺序\n- **in：**\n\n```mysql\n# between and\nSELECT  * FROM 表名  WHERE id BETWEEN 100 and 120;\n\n# IN 取值必须在括号内\nSELECT id FROM 表名 WHERE id IN (1002, 1003)\n\n# IS NULL 筛选出空值  IS NOT NULL\nSELECT id FROM 表名 WHERE age IS NULL;\n```\n\n\n\n**补. 空值处理 IFNULL(字段，空值时返回值)**\n\n`SELECT IFNULL(price, 0) FROM 表名;  `\n\n\n\n## **5. 通配符   LIKE + % , _   + 正则表达式** **REGEXP   都****不区分大小写**\n\n1. 通配符速度慢, 不要放在搜索开始处\n\n2. **LIKE 匹配整个串,  正则表达式可以匹配子串**\n\n```mysql\n#  通配符\n#  % 匹配0,1,多个字符\nSELECT id FROM 表名 WHERE string LIKE 's%';   # s开头   \n\n# 下划线 _ , 匹配单个字符\n# 需要匹配 _ 时， 用转义   \\_\nSELECT id FROM 表名 WHERE string LIKE 's_';  \n\n------------------------------------------------------------------\n#  正则表达式 REGEXP\n# 标准表达\nSELECT name FROM customers WHERE name REGEXP '1000';\n\n'.'   # 任意一个字符\n'A1'| 'B2'  # 匹配两个串之一\n'[1-9]'     # 匹配 1~9 范围内的值\n'[123]'     # 匹配1，2，3之一， 等价于【1 | 2 | 3】\n'[^123]'    # 匹配非123的值\n'\\\\.'       # 特殊字符转译   \n\n# 匹配多个实例, 不能单独出现,必须是指定上边的某种字符的匹配\n# 例如 '.*' 而不是'*'\n'*'  # 0或多个匹配\n'+'  # 1或多个匹配\n'?'  # 0或者1个匹配\n{n}  # 指定数目匹配\n{n,}  # 不少于指定数目的匹配\n{n,m}  # 数目范围,不超过255\n\n#定位元字符\n'^'   # 开始位置\n'$'   # 结尾\n'[[:<:]]'  # 词开始\n'[[:<:]]'  # 词结尾\n\n# 举例:\n'^[1-9]'   \nBINARY 'J 1000'     # 指定区分大小写\n\n'[a-zA-Z0-9]'   # 匹配所有字符\n```\n\n\n\n## **6. 数据处理常用函数 (不区分大小写)**\n\n- 字符函数\n- 数学函数\n- 日期函数\n- 其他函数\n- 流程函数\n\n字符函数\n\n```mysql\n# 文本处理函数\n# 1. 字符串字节个数,  汉字算三个字符\nLength() \n\n# 2. 拼接\nCONCAT(id, \"_\", name)\n\n# 3. 大写 小写\nLower()  # 小写\nUpper()  # 大写\n\n# 4. 返回子串的字符, 数据库索引从1开始\nSubStr(last_name, start) \nSubStr(last_name, start, length)   # 长度\n\n# 5. 查找子串, 返回第一次出现的索引， 查不到返回0\nINSTR(\"待查子串abcd\", \"a\")\n\n# 6. 去空格\nTrim(), LTrim(), RTrim()  \n\n# 7. 指定长度填充\nLPAD(name, length, '*')\nRPAD(name, length, '*')\n\n# 8. 替换\nREPLACE(原串, '被替换串', '新串')\n\n# 9. 字符串字符长度, 汉字也算 1个字符\nCHAR_LENGTH(s)  \nSoundex()   # 返回串的SOUNDEX值\n\n  \n```\n\n\n\n数学函数\n\n```mysql\n# 1. 四舍五入\nROUND(1.6);   # 2\nROUND(1.567, 2)  # 小数点保留两位\n\n# 2. 上取整， >=该参数的最小整数\nCEIL(1.00) \n# 下取整,   <=该参数的最大整数\nFLOOR(-9.99)   # -10\n\n# 3. 小数点直接截断\nTRUNCATE(1.69999, 1)  # 1.6\n\n# 4. 取余数\nMOD(10, 3)  # 10%3\n\nABS(x)   # 绝对值\nAVG(age)  # 某列的平均值 \nEXP(x)\nRAND()  # 0到1的随机数\n```\n\n\n\n日期函数\n\n```mysql\nNOW()   # 当前日期和时间\nCURDATE() # 当前日期，不含时间\nDate()  # 返回时间中的日期部分....\nDay()   # 返回时间中的天数部分\nYear(NOW())\nTime()\nMonth()  \nHour()\nDateDiff()  # 计算日期差\n\n# 字符串转日期\nSTR_TO_DATE('02-19-2020', \"%m-%d-%Y\")\n\n# 日期的格式化输出\nDATE_FORMAT(NOW(), '%y年%m月%d日')\n```\n\n\n\n其他函数\n\n`VERSION() `\n\n## **7. 流程控制函数**\n\nIF(逻辑判断， 成立执行， 不成立执行)\n\nCASE:\n\n```mysql\n# IF\nIF(10>5, '大', '小')\nSELECT name IF(salary IS NULL, \"没薪水\", \"有薪水\")\n\n# CASE 第一种使用\nCASE '要判断的表达式'\nWHEN '常量1' then 值(没有分号) / 表达式(有分号);\nWHEN '常量2' then 值(没有分号) / 表达式(有分号);\nWHEN '常量3' then 值(没有分号) / 表达式(有分号);\n...\nELSE 值(没有分号) / 表达式(有分号);\nEND;\n\n# CASE 第二种语句\nCASE \nWHEN 表达式 then 值(没有分号) / 表达式(有分号);\nWHEN 表达式 then 值(没有分号) / 表达式(有分号);\nWHEN 表达式 then 值(没有分号) / 表达式(有分号);\n...\nELSE 值(没有分号) / 表达式(有分号);\nEND;\n```\n\n\n\n## **8. 数据汇总-聚集函数  AVG, COUNT, MAX, MIN, SUM**\n\n运行在行组, 计算和返回单个值的函数.\n\n统计使用\n\n```mysql\n# AVG() 针对单列,  对多列需要使用多个\nSELECT AVG(age) AS avg_age FROM 表名;   # 忽略 NULL\n\n# COUNT() 函数\nCOUNT(1);   # 行数\nCOUNT(*);   # 表的行数, 含有 NULL的有数据行也可，但是不能全NULL\nCOUNT(column)  # 某列非NULL 的个数\nCOUNT(distinct 字段)  # 统计不重复的\n# 效率对比：\nMYISAM 储存引擎下， COUNT(*) 效率高\nINNODB 存储引擎下，COUNT(*) 和COUNT(1) 差不多，比COUNT(字段高)\n\n# 聚集不同的值 + DISTINCT\n# 聚集函数默认ALL\nSELECT AVG(DISTINCT age) FROM 表名;  # 对唯一值求均值\nSELECT COUNt(DISTINCT age) FROM 表名;  # 对age列的唯一值统计个数\n```\n\n\n\n## **9. 数据分组查询 —— GROUP BY,   HAVING**\n\n### **1. GROUP BY   分组字段**\n\n​          <font color=\"red\"><big>**如果分组列中具有 NULL,  则NULL 将作为一个分组返回.**</big></font>\n\n### **2. HAVING 过滤条件  =====WHERE 条件**\n\n\n\n### **3. 必加 ORDER BY,  因为G出来的结果不保证排序了.**\n\n\n\n### **4. 能where 就不用having**\n\n- **按字段分组**\n\n- - GROUP BY id \n\n- **按表达式或者函数**\n\n- - GROUP BY length(id)  AS  len   HAVING  len>3;\n\n- **按多个字段分组**\n\n```mysql\n# 分组统计值\nSELECT id, COUNT(*) AS num_ FROM 表名 GROUP BY id ORDER BY age;\n\n# 分组过滤  大于2的值\nSELECT age FROM 表名 GROUP BY  id  HAVING COUNT(*)>=2 ORDER BY age;\n```\n\n\n\n## **10. 子查询  IN + 括号**\n\n- 查询的结果作为另一个查询的条件,然后多层嵌套.\n- 内层查询**建立一个临时表**。费时间.\n- 优化需要用join 联结表替代....\n\n**where 和 having 后可放的子查询：**\n\n- 子查询放在小括号内\n\n- **标量子查询（单值）**，一般配合单行操作符使用：  >  <   >=  =  <>\n\n- **列子查询（单列多行）**， 一般配合多行操作符使用：  \n\n- - IN   列表中的一个\n  - ANY/SOME   \n  - ALL\n\n**select 后可以放的子查询：**\n\n**from 后可以放的子查询：**\n\n- 必须起别名\n\n- - FROM (子查询表)  newtable \n\n```mysql\n# 标量子查询\n# 1. 谁工资比  elgong 高\nSELECT  * FROM employee \nWHERE salary>(select salary from emplot WHERE name = 'elgong');\n\n# 查询超过平均工资的员工信息\nselect avg(sal) from emp;   /* avg(sal)=2000 */\nselect * from emp where sal >= 2000;\n/* 子查询方法 */\nselect * from emp where sal >= (select avg(sal) from emp);\n```\n\n\n\n## **11. 连接查询——JOIN 联结表 ( INNER JOIN, LEFT JOIN, RIGHT JOIN)**\n\n**注意判断驱动表是哪个？  查询计划  explain**\n\n正常情况下，from 后的表是驱动表，但是当出现下面情况，驱动表变成了 class。\n\n分析： 当 where 后的条件使得表之间数据多少不一样时，数据少的为主表\n\n**小表驱动大表的原则**\n\n`select * from student left join class on  class.classid = student.classid where class.classid = 2; `\n\n\n\n**概念:    联结指两张表,或者多张表之间组合在一起进行查询, 是在运行时做的操作;**\n\n- **left JOIN ** (左联结)保证读取主表的全部数据\n\n- **right JOIN**  (右联结) 保证读取主表的全部数据\n\n- **inner JOIN**  (内部联结,等值联结)  只读取共有的数据\n\n- **自联结:  **常用来代替从同一个表检索数据的子查询.  FROM table1 AS t1, table2 AS t2, WHERE t1.col = t2.col;\n\n- **自然联结: ** 联结有主副表之分,  在INNER JOIN 之前的是主表, 待查询的输出中,排前边的内容所在的表为主表.\n\n左外联结可通过颠倒FROM 或者WHERE 子句中表的顺序转换成右外部联结\n\n**连接的分类**\n\n- SQL92语法\n\n- - **等值连接**\n\n  - - `FROM table1 AS t1, table2 AS t2, table3 AS t3  WHERE t1.col = t2.col  AND t2.c = t3.c ;`\t\n\n  - **自连接（单表）**\n\n  - - 同表不同名\n    - `FROM   employees   e1,  employees  e2  WHERE  e1.id = e2.iidd`\n\n- SQL99语法\n\n- - SELECT   查询列表\n  - `FROM   表1  别名  [连接类型]   join        表2  别名   on          连接条件`\n\n- - **内连接**  inner join\n\n  - **外连接**  left， right\n\n  - - 主表全部显示\n    - 从表中没有与主表匹配的结果，显示NULL\n    - 等价于==== 内连接结果 + 主表有而从表没有的记录\n    - 左外和右外，交换表顺序可以等价效果\n\n  - **全外连接**  full join\n\n  - **交叉连接**   cross join\n\n  - - 笛卡尔乘机\n\n  - **非等值连接**\n\n  - - FROM e  join g on e.salary  BETWEEN g.low AND g.upper\n\n  - **自连接**\n\n  - - 一样的join on   不同名的同一张表\n\n```mysql\n# 创建联结表的两种方式\n# 1. 等值连接  WHERE 表1.id = 表2.id AND 表2.size = 表3.size\nSELECT vendors.vendor_name, product.prod_name, product.prod_price \nFROM product,vendors \nWHERE vendors.vendor_id = product.vendor_id \nORDER BY vendor_name;\n\n# 2.内部联结(等值联结) 表的键数量相同  FROM 表1 INNER JOIN 表2 ON 表1.id = 表2.id\nSELECT v.vendor_name, p.prod_name, p.prod_price \nFROM product AS p \nINNER JOIN vendors AS v \nON v.vendor_id = p.vendor_id  \nORDER BY v.vendor_name;\n\n# \n# 对联结的表使用聚合方法\n待补充.....\n```\n\n\n\n![img](C:\\Users\\Misaya\\AppData\\Local\\YNote\\data\\elgong@126.com\\e6a36fe8659843b897ed6b6e6ee6977d\\clipboard.png)\n\n\n\n## **12. 分页查询**\n\n  **LIMIT  行X(从0开始),  size;**\n\n  **LIMIT  size OFFSET  size;**\n\n**当要显示的数据，需要分页显示** \n\n- 从行0开始\n- 从第四行开始，检索5行\n- **LIMIT   3,  5**\n- **LIMIT   5  OFFSET  3**\n\n```mysql\n#  查询前5条数据\nSELECT  *  FROM employees LIMIT 0, 5;\n\t\n# 查询11到25条数据\nSELECT  *  FROM employees LIMIT 10, 25-11+1;\n\n# 计算公式\nLIMIT (page-1)*size,  size;\n```\n\n\n\n## **13. 联合查询  union  （自动去重，union all  不去重）**\n\n将多条查询语句合并成一个结果\n\n**特点：**\n\n- 查询 **列数** 和 **列顺序** 必须一致\n- 自动去重\n- 不去重  union all\n\n```mysql\nSELECT   *   FROM    e1   WHERE   \nUNION\nSELECT   *   FROM    e1   WHERE \n```\n\n\n\n## **14. 视图**\n\n视图是虚拟的表, 是对其基表的封装.\n\n使用的好处:\n\n1. 重用 SQL 语句\n\n2. 使用表的部分,即过滤掉部分数据\n\n限制:\n\n1. 图名唯一\n\n2. 视图可以嵌套\n\n3. 视图的ORDER BY  次于 从该视图检索数据的ORDER\n\n4. 视图可以和表一起使用\n\n```mysql\n# 创建视图\nCREATE VIEW  viewname AS\nSELECT * FROM table WHERE id!=1;\n```\n\n","slug":"mysql-必知必会7-综合内容","published":1,"updated":"2020-04-11T04:08:35.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephdq000ut8plqcwxcigh","content":"<h1 id=\"一、关系型数据库Mysql\"><a href=\"#一、关系型数据库Mysql\" class=\"headerlink\" title=\"一、关系型数据库Mysql\"></a><strong>一、关系型数据库Mysql</strong></h1><p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。</p>\n<ul>\n<li><strong>数据库:</strong> 数据库是一些关联表的集合。.</li>\n<li><strong>数据表:</strong> 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li>\n<li><strong>列:</strong> 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。</li>\n<li><strong>行：</strong>一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</li>\n<li><strong>冗余</strong>：存储两倍数据，冗余可以使系统速度更快。</li>\n<li><strong>主键</strong>：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li>\n<li><strong>外键：</strong>外键用于关联两个表。</li>\n<li><strong>复合键</strong>：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li>\n<li><strong>索引：</strong>使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li>\n<li><p><strong>参照完整性:</strong> 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性</p>\n</li>\n<li><p><strong>主键: 表示特定行.</strong></p>\n<ul>\n<li>主键不能重复</li>\n<li>每行必有主键,且不能为 NULL</li>\n</ul>\n</li>\n<li><p><strong>外键:</strong>  product 只存产品信息, 和供应商ID,  vendors 存供应商的信息(主键是ID),则vendors的主键就是product的外键.</p>\n</li>\n</ul>\n<p>MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。</p>\n<h1 id=\"二、-安装与删\"><a href=\"#二、-安装与删\" class=\"headerlink\" title=\"二、 安装与删\"></a><strong>二、 安装与删</strong></h1><ul>\n<li><p>删除mysql</p>\n<p><code>sudo apt purge mysql-* sudo apt autoremove</code></p>\n</li>\n<li><p>安装mysql</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install mysql-server </span><br><span class=\"line\">sudo apt install mysql-client </span><br><span class=\"line\">sudo apt install libmysqlclient-dev `</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>数据库规范：</strong></p>\n<ul>\n<li>关键字大写，表名，列名小写</li>\n<li>索引从1开始</li>\n<li>每条命令用分号隔开</li>\n<li><p>注释</p>\n</li>\n<li><p>单行注释   #</p>\n</li>\n<li>单行注释  — 注释文</li>\n<li>多行注释  /<em> </em>/</li>\n</ul>\n<font color=\"red\"><big>索引从1开始！</big></font>\n\n\n\n<h1 id=\"三、常用命令\"><a href=\"#三、常用命令\" class=\"headerlink\" title=\"三、常用命令\"></a><strong>三、常用命令</strong></h1><h2 id=\"指令执行顺序：\"><a href=\"#指令执行顺序：\" class=\"headerlink\" title=\"指令执行顺序：\"></a><strong>指令执行顺序：</strong></h2><p><strong>SELECT  FROM  WHERE   GROUP BY  HAVING  ORDER BY LIMIT.</strong></p>\n   <font color=\"red\"><big>开始 **->** FROM子句 **->** WHERE子句 **->** GROUP BY子句 **->** HAVING子句 **->** ORDER BY子句 **->** SELECT子句 **->** LIMIT子句 **->** 最终结果 </big></font>    \n\n<font color=\"red\"><big>每个步骤都会为下一个步骤生成一个虚拟表</big></font>\n\n\n\n<h2 id=\"1-登陆系统-选择数据库\"><a href=\"#1-登陆系统-选择数据库\" class=\"headerlink\" title=\"1. 登陆系统, 选择数据库\"></a><strong>1. 登陆系统, 选择数据库</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u 用户名 -p 密码</span><br><span class=\"line\">mysql -h localhost -P 3306 -p</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看所有数据库列表</span><br><span class=\"line\">SHOW DATABSASES;</span><br><span class=\"line\"># 查看选择的数据库中的表的列表</span><br><span class=\"line\">SHOW TABLES;</span><br><span class=\"line\"># 查看表中的列有哪些</span><br><span class=\"line\">SHOW COLUMNS FROM 表名;  ||  DESCRIBE 表名;</span><br><span class=\"line\"></span><br><span class=\"line\"># 选择库</span><br><span class=\"line\">USE 数据库的名字;</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看表结构</span><br><span class=\"line\">DESC 表名;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-基础查询——检索-SELECT-DISTINCT\"><a href=\"#2-基础查询——检索-SELECT-DISTINCT\" class=\"headerlink\" title=\"2 基础查询——检索 SELECT + DISTINCT\"></a><strong>2 基础查询——检索 SELECT + DISTINCT</strong></h2><p>SELECT 子句 固定的顺序:</p>\n<p><strong>SELECT  FROM  WHERE （原始表有的字段）  GROUP BY  HAVING  （分组后有的字段）ORDER BY LIMIT.</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 选择多个字段 `着重号`当字段名与关键字冲突，用它可以避免冲突</span><br><span class=\"line\">SELECT id, `name`, price FROM 表名; </span><br><span class=\"line\"></span><br><span class=\"line\"># 起别名 AS, 可以省略SELECT salary &quot;Month Salary&quot; from employees;</span><br><span class=\"line\">SELECT salary AS &quot;Month Salary&quot; from employees;</span><br><span class=\"line\"></span><br><span class=\"line\"># 字符串拼接 concat</span><br><span class=\"line\"># 特别注意+：  </span><br><span class=\"line\"># 1+9=10  两个数值型做加法</span><br><span class=\"line\"># &apos;12&apos;+ 3 = 15 字符转整数，再加 </span><br><span class=\"line\"># &apos;job&apos;+2 = 2  转换失败，则字符串变0</span><br><span class=\"line\"># null+任何值 = null</span><br><span class=\"line\">SELECT concat(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) , price FROM 表名; </span><br><span class=\"line\"></span><br><span class=\"line\"># 检索所有字段</span><br><span class=\"line\">SELECT * FROM 表名;</span><br><span class=\"line\"></span><br><span class=\"line\"># 字段去重  DISTINCT</span><br><span class=\"line\">SELECT DISTINCT id FROM 表名;   # 不能应用于多列</span><br><span class=\"line\"></span><br><span class=\"line\"># 限制检索结果</span><br><span class=\"line\"> SELECT  id FROM 表名  LIMIT 5;  # 前5 </span><br><span class=\"line\"> SELECT  id FROM 表名  LIMIT 2,5;  #从 2+1 开始的  5个行</span><br><span class=\"line\"> SELECT id FROM 表名 LIMIT 5 OFFSET 3;  # 从行3取5</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-排序检索-ORDER-BY-默认升序-LIMIT-OFFSET-DESC\"><a href=\"#3-排序检索-ORDER-BY-默认升序-LIMIT-OFFSET-DESC\" class=\"headerlink\" title=\"3. 排序检索 ORDER   BY (默认升序) + LIMIT,  OFFSET, DESC\"></a><strong>3. 排序检索 ORDER   BY (默认升序) + LIMIT,  OFFSET, DESC</strong></h2><p>可以根据非 select 字段排序。</p>\n<p>SELECT  查询列表</p>\n<p>FROM  表</p>\n<p>【where 筛选条件】</p>\n<p>ORDER BY  排序列表  [asc |  desc]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 按照某列排序,  多条件排序</span><br><span class=\"line\">SELECT id FROM 表名 ORDER BY id ASC, age DESC;   # 可以根据其他列来排序</span><br><span class=\"line\"></span><br><span class=\"line\"># 按照多个条件排序</span><br><span class=\"line\">SELECT id FROM 表名 ORDER BY age, size;   # 优先age, 重复时才根据size排序.</span><br><span class=\"line\"></span><br><span class=\"line\">#  指定降序  DESC</span><br><span class=\"line\">SELECT id FROM 表名 ORDER BY age  DESC  size;  # DESC 只作用于在DESC 前面的, 所以 size仍然为升序</span><br><span class=\"line\"></span><br><span class=\"line\"># 找到最********的id</span><br><span class=\"line\">SELECT id FROM 表名 ORDER BY age LIMIT 1;</span><br><span class=\"line\"># 第二最的*******id</span><br><span class=\"line\">SELECT id FROM 表名 ORDER BY age LIMIT 1 OFFSET 2;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-条件查询\"><a href=\"#4-条件查询\" class=\"headerlink\" title=\"4. 条件查询\"></a><strong>4. 条件查询</strong></h2><h3 id=\"4-1-——逻辑运算-WHERE-AND-OR-NOT-IN-和EXISTS-看优化部分\"><a href=\"#4-1-——逻辑运算-WHERE-AND-OR-NOT-IN-和EXISTS-看优化部分\" class=\"headerlink\" title=\"4.1  ——逻辑运算 WHERE + AND, OR,NOT IN 和EXISTS(看优化部分)\"></a><strong>4.1  ——逻辑运算 WHERE + AND, OR,NOT</strong> <strong>IN 和EXISTS(看优化部分)</strong></h3><p><strong>作用：</strong></p>\n<p>连接条件表达式</p>\n<font color=\"red\"><big>**如果计算次序不加括号时,  优先 AND**</big></font>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#  =  !=  &lt;  &gt; &gt;=    &quot;BETWEEN 1 AND 2&quot;在指定值之间,包含端点</span><br><span class=\"line\"># 不等于 ！=   或者  &lt;&gt;</span><br><span class=\"line\">SELECT id FROM 表名 WHERE age=12 ORDER BY size;</span><br><span class=\"line\"></span><br><span class=\"line\"># 组合筛选  AND  OR</span><br><span class=\"line\">SELECT id FROM 表名 WHERE age=12 AND size &lt; 10;</span><br><span class=\"line\"></span><br><span class=\"line\"># 计算次序,  不加括号时,  优先 AND</span><br><span class=\"line\"># 解释: id&gt;3且age&gt;10,  或者 id=1</span><br><span class=\"line\">SELECT id FROM 表名 WHERE id=1 OR id=3 AND age &gt; 10;   </span><br><span class=\"line\"></span><br><span class=\"line\"># NOT  否定后跟的所有条件.</span><br><span class=\"line\">SELECT id FROM 表名 NOT WHERE id IN (1002, 1003)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2020/04/11/mysql-必知必会7-综合内容/Users\\Misaya\\AppData\\Local\\YNote\\data\\elgong@126.com\\e87e0bbb47ff40228ca7b6dbebad7954\\clipboard.png\" alt=\"img\"></p>\n<h3 id=\"4-2-——模糊查询-WHERE-LIKE-between-and-in-is-null\"><a href=\"#4-2-——模糊查询-WHERE-LIKE-between-and-in-is-null\" class=\"headerlink\" title=\"4.2  ——模糊查询  WHERE + LIKE, between and, in, is null\"></a><strong>4.2  ——模糊查询  WHERE + LIKE, between and, in, is null</strong></h3><ul>\n<li><strong>like + 通配符：</strong> 参考7.</li>\n<li><strong>between and ：</strong> 包含临界值， 不可颠倒顺序</li>\n<li><strong>in：</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># between and</span><br><span class=\"line\">SELECT  * FROM 表名  WHERE id BETWEEN 100 and 120;</span><br><span class=\"line\"></span><br><span class=\"line\"># IN 取值必须在括号内</span><br><span class=\"line\">SELECT id FROM 表名 WHERE id IN (1002, 1003)</span><br><span class=\"line\"></span><br><span class=\"line\"># IS NULL 筛选出空值  IS NOT NULL</span><br><span class=\"line\">SELECT id FROM 表名 WHERE age IS NULL;</span><br></pre></td></tr></table></figure>\n<p><strong>补. 空值处理 IFNULL(字段，空值时返回值)</strong></p>\n<p><code>SELECT IFNULL(price, 0) FROM 表名;</code></p>\n<h2 id=\"5-通配符-LIKE-正则表达式-REGEXP-都-不区分大小写\"><a href=\"#5-通配符-LIKE-正则表达式-REGEXP-都-不区分大小写\" class=\"headerlink\" title=\"5. 通配符   LIKE + % , _   + 正则表达式 REGEXP   都**不区分大小写**\"></a><strong>5. 通配符   LIKE + % , _   + 正则表达式</strong> <strong>REGEXP   都**</strong>不区分大小写**</h2><ol>\n<li><p>通配符速度慢, 不要放在搜索开始处</p>\n</li>\n<li><p><strong>LIKE 匹配整个串,  正则表达式可以匹配子串</strong></p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#  通配符</span><br><span class=\"line\">#  % 匹配0,1,多个字符</span><br><span class=\"line\">SELECT id FROM 表名 WHERE string LIKE &apos;s%&apos;;   # s开头   </span><br><span class=\"line\"></span><br><span class=\"line\"># 下划线 _ , 匹配单个字符</span><br><span class=\"line\"># 需要匹配 _ 时， 用转义   \\_</span><br><span class=\"line\">SELECT id FROM 表名 WHERE string LIKE &apos;s_&apos;;  </span><br><span class=\"line\"></span><br><span class=\"line\">------------------------------------------------------------------</span><br><span class=\"line\">#  正则表达式 REGEXP</span><br><span class=\"line\"># 标准表达</span><br><span class=\"line\">SELECT name FROM customers WHERE name REGEXP &apos;1000&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;.&apos;   # 任意一个字符</span><br><span class=\"line\">&apos;A1&apos;| &apos;B2&apos;  # 匹配两个串之一</span><br><span class=\"line\">&apos;[1-9]&apos;     # 匹配 1~9 范围内的值</span><br><span class=\"line\">&apos;[123]&apos;     # 匹配1，2，3之一， 等价于【1 | 2 | 3】</span><br><span class=\"line\">&apos;[^123]&apos;    # 匹配非123的值</span><br><span class=\"line\">&apos;\\\\.&apos;       # 特殊字符转译   </span><br><span class=\"line\"></span><br><span class=\"line\"># 匹配多个实例, 不能单独出现,必须是指定上边的某种字符的匹配</span><br><span class=\"line\"># 例如 &apos;.*&apos; 而不是&apos;*&apos;</span><br><span class=\"line\">&apos;*&apos;  # 0或多个匹配</span><br><span class=\"line\">&apos;+&apos;  # 1或多个匹配</span><br><span class=\"line\">&apos;?&apos;  # 0或者1个匹配</span><br><span class=\"line\">&#123;n&#125;  # 指定数目匹配</span><br><span class=\"line\">&#123;n,&#125;  # 不少于指定数目的匹配</span><br><span class=\"line\">&#123;n,m&#125;  # 数目范围,不超过255</span><br><span class=\"line\"></span><br><span class=\"line\">#定位元字符</span><br><span class=\"line\">&apos;^&apos;   # 开始位置</span><br><span class=\"line\">&apos;$&apos;   # 结尾</span><br><span class=\"line\">&apos;[[:&lt;:]]&apos;  # 词开始</span><br><span class=\"line\">&apos;[[:&lt;:]]&apos;  # 词结尾</span><br><span class=\"line\"></span><br><span class=\"line\"># 举例:</span><br><span class=\"line\">&apos;^[1-9]&apos;   </span><br><span class=\"line\">BINARY &apos;J 1000&apos;     # 指定区分大小写</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;[a-zA-Z0-9]&apos;   # 匹配所有字符</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-数据处理常用函数-不区分大小写\"><a href=\"#6-数据处理常用函数-不区分大小写\" class=\"headerlink\" title=\"6. 数据处理常用函数 (不区分大小写)\"></a><strong>6. 数据处理常用函数 (不区分大小写)</strong></h2><ul>\n<li>字符函数</li>\n<li>数学函数</li>\n<li>日期函数</li>\n<li>其他函数</li>\n<li>流程函数</li>\n</ul>\n<p>字符函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 文本处理函数</span><br><span class=\"line\"># 1. 字符串字节个数,  汉字算三个字符</span><br><span class=\"line\">Length() </span><br><span class=\"line\"></span><br><span class=\"line\"># 2. 拼接</span><br><span class=\"line\">CONCAT(id, &quot;_&quot;, name)</span><br><span class=\"line\"></span><br><span class=\"line\"># 3. 大写 小写</span><br><span class=\"line\">Lower()  # 小写</span><br><span class=\"line\">Upper()  # 大写</span><br><span class=\"line\"></span><br><span class=\"line\"># 4. 返回子串的字符, 数据库索引从1开始</span><br><span class=\"line\">SubStr(last_name, start) </span><br><span class=\"line\">SubStr(last_name, start, length)   # 长度</span><br><span class=\"line\"></span><br><span class=\"line\"># 5. 查找子串, 返回第一次出现的索引， 查不到返回0</span><br><span class=\"line\">INSTR(&quot;待查子串abcd&quot;, &quot;a&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"># 6. 去空格</span><br><span class=\"line\">Trim(), LTrim(), RTrim()  </span><br><span class=\"line\"></span><br><span class=\"line\"># 7. 指定长度填充</span><br><span class=\"line\">LPAD(name, length, &apos;*&apos;)</span><br><span class=\"line\">RPAD(name, length, &apos;*&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\"># 8. 替换</span><br><span class=\"line\">REPLACE(原串, &apos;被替换串&apos;, &apos;新串&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\"># 9. 字符串字符长度, 汉字也算 1个字符</span><br><span class=\"line\">CHAR_LENGTH(s)  </span><br><span class=\"line\">Soundex()   # 返回串的SOUNDEX值</span><br></pre></td></tr></table></figure>\n<p>数学函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1. 四舍五入</span><br><span class=\"line\">ROUND(1.6);   # 2</span><br><span class=\"line\">ROUND(1.567, 2)  # 小数点保留两位</span><br><span class=\"line\"></span><br><span class=\"line\"># 2. 上取整， &gt;=该参数的最小整数</span><br><span class=\"line\">CEIL(1.00) </span><br><span class=\"line\"># 下取整,   &lt;=该参数的最大整数</span><br><span class=\"line\">FLOOR(-9.99)   # -10</span><br><span class=\"line\"></span><br><span class=\"line\"># 3. 小数点直接截断</span><br><span class=\"line\">TRUNCATE(1.69999, 1)  # 1.6</span><br><span class=\"line\"></span><br><span class=\"line\"># 4. 取余数</span><br><span class=\"line\">MOD(10, 3)  # 10%3</span><br><span class=\"line\"></span><br><span class=\"line\">ABS(x)   # 绝对值</span><br><span class=\"line\">AVG(age)  # 某列的平均值 </span><br><span class=\"line\">EXP(x)</span><br><span class=\"line\">RAND()  # 0到1的随机数</span><br></pre></td></tr></table></figure>\n<p>日期函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NOW()   # 当前日期和时间</span><br><span class=\"line\">CURDATE() # 当前日期，不含时间</span><br><span class=\"line\">Date()  # 返回时间中的日期部分....</span><br><span class=\"line\">Day()   # 返回时间中的天数部分</span><br><span class=\"line\">Year(NOW())</span><br><span class=\"line\">Time()</span><br><span class=\"line\">Month()  </span><br><span class=\"line\">Hour()</span><br><span class=\"line\">DateDiff()  # 计算日期差</span><br><span class=\"line\"></span><br><span class=\"line\"># 字符串转日期</span><br><span class=\"line\">STR_TO_DATE(&apos;02-19-2020&apos;, &quot;%m-%d-%Y&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"># 日期的格式化输出</span><br><span class=\"line\">DATE_FORMAT(NOW(), &apos;%y年%m月%d日&apos;)</span><br></pre></td></tr></table></figure>\n<p>其他函数</p>\n<p><code>VERSION()</code></p>\n<h2 id=\"7-流程控制函数\"><a href=\"#7-流程控制函数\" class=\"headerlink\" title=\"7. 流程控制函数\"></a><strong>7. 流程控制函数</strong></h2><p>IF(逻辑判断， 成立执行， 不成立执行)</p>\n<p>CASE:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># IF</span><br><span class=\"line\">IF(10&gt;5, &apos;大&apos;, &apos;小&apos;)</span><br><span class=\"line\">SELECT name IF(salary IS NULL, &quot;没薪水&quot;, &quot;有薪水&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"># CASE 第一种使用</span><br><span class=\"line\">CASE &apos;要判断的表达式&apos;</span><br><span class=\"line\">WHEN &apos;常量1&apos; then 值(没有分号) / 表达式(有分号);</span><br><span class=\"line\">WHEN &apos;常量2&apos; then 值(没有分号) / 表达式(有分号);</span><br><span class=\"line\">WHEN &apos;常量3&apos; then 值(没有分号) / 表达式(有分号);</span><br><span class=\"line\">...</span><br><span class=\"line\">ELSE 值(没有分号) / 表达式(有分号);</span><br><span class=\"line\">END;</span><br><span class=\"line\"></span><br><span class=\"line\"># CASE 第二种语句</span><br><span class=\"line\">CASE </span><br><span class=\"line\">WHEN 表达式 then 值(没有分号) / 表达式(有分号);</span><br><span class=\"line\">WHEN 表达式 then 值(没有分号) / 表达式(有分号);</span><br><span class=\"line\">WHEN 表达式 then 值(没有分号) / 表达式(有分号);</span><br><span class=\"line\">...</span><br><span class=\"line\">ELSE 值(没有分号) / 表达式(有分号);</span><br><span class=\"line\">END;</span><br></pre></td></tr></table></figure>\n<h2 id=\"8-数据汇总-聚集函数-AVG-COUNT-MAX-MIN-SUM\"><a href=\"#8-数据汇总-聚集函数-AVG-COUNT-MAX-MIN-SUM\" class=\"headerlink\" title=\"8. 数据汇总-聚集函数  AVG, COUNT, MAX, MIN, SUM\"></a><strong>8. 数据汇总-聚集函数  AVG, COUNT, MAX, MIN, SUM</strong></h2><p>运行在行组, 计算和返回单个值的函数.</p>\n<p>统计使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># AVG() 针对单列,  对多列需要使用多个</span><br><span class=\"line\">SELECT AVG(age) AS avg_age FROM 表名;   # 忽略 NULL</span><br><span class=\"line\"></span><br><span class=\"line\"># COUNT() 函数</span><br><span class=\"line\">COUNT(1);   # 行数</span><br><span class=\"line\">COUNT(*);   # 表的行数, 含有 NULL的有数据行也可，但是不能全NULL</span><br><span class=\"line\">COUNT(column)  # 某列非NULL 的个数</span><br><span class=\"line\">COUNT(distinct 字段)  # 统计不重复的</span><br><span class=\"line\"># 效率对比：</span><br><span class=\"line\">MYISAM 储存引擎下， COUNT(*) 效率高</span><br><span class=\"line\">INNODB 存储引擎下，COUNT(*) 和COUNT(1) 差不多，比COUNT(字段高)</span><br><span class=\"line\"></span><br><span class=\"line\"># 聚集不同的值 + DISTINCT</span><br><span class=\"line\"># 聚集函数默认ALL</span><br><span class=\"line\">SELECT AVG(DISTINCT age) FROM 表名;  # 对唯一值求均值</span><br><span class=\"line\">SELECT COUNt(DISTINCT age) FROM 表名;  # 对age列的唯一值统计个数</span><br></pre></td></tr></table></figure>\n<h2 id=\"9-数据分组查询-——-GROUP-BY-HAVING\"><a href=\"#9-数据分组查询-——-GROUP-BY-HAVING\" class=\"headerlink\" title=\"9. 数据分组查询 —— GROUP BY,   HAVING\"></a><strong>9. 数据分组查询 —— GROUP BY,   HAVING</strong></h2><h3 id=\"1-GROUP-BY-分组字段\"><a href=\"#1-GROUP-BY-分组字段\" class=\"headerlink\" title=\"1. GROUP BY   分组字段\"></a><strong>1. GROUP BY   分组字段</strong></h3><p>​          <font color=\"red\"><big><strong>如果分组列中具有 NULL,  则NULL 将作为一个分组返回.</strong></big></font></p>\n<h3 id=\"2-HAVING-过滤条件-WHERE-条件\"><a href=\"#2-HAVING-过滤条件-WHERE-条件\" class=\"headerlink\" title=\"2. HAVING 过滤条件  =====WHERE 条件\"></a><strong>2. HAVING 过滤条件  =====WHERE 条件</strong></h3><h3 id=\"3-必加-ORDER-BY-因为G出来的结果不保证排序了\"><a href=\"#3-必加-ORDER-BY-因为G出来的结果不保证排序了\" class=\"headerlink\" title=\"3. 必加 ORDER BY,  因为G出来的结果不保证排序了.\"></a><strong>3. 必加 ORDER BY,  因为G出来的结果不保证排序了.</strong></h3><h3 id=\"4-能where-就不用having\"><a href=\"#4-能where-就不用having\" class=\"headerlink\" title=\"4. 能where 就不用having\"></a><strong>4. 能where 就不用having</strong></h3><ul>\n<li><p><strong>按字段分组</strong></p>\n</li>\n<li><ul>\n<li>GROUP BY id </li>\n</ul>\n</li>\n<li><p><strong>按表达式或者函数</strong></p>\n</li>\n<li><ul>\n<li>GROUP BY length(id)  AS  len   HAVING  len&gt;3;</li>\n</ul>\n</li>\n<li><p><strong>按多个字段分组</strong></p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 分组统计值</span><br><span class=\"line\">SELECT id, COUNT(*) AS num_ FROM 表名 GROUP BY id ORDER BY age;</span><br><span class=\"line\"></span><br><span class=\"line\"># 分组过滤  大于2的值</span><br><span class=\"line\">SELECT age FROM 表名 GROUP BY  id  HAVING COUNT(*)&gt;=2 ORDER BY age;</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-子查询-IN-括号\"><a href=\"#10-子查询-IN-括号\" class=\"headerlink\" title=\"10. 子查询  IN + 括号\"></a><strong>10. 子查询  IN + 括号</strong></h2><ul>\n<li>查询的结果作为另一个查询的条件,然后多层嵌套.</li>\n<li>内层查询<strong>建立一个临时表</strong>。费时间.</li>\n<li>优化需要用join 联结表替代….</li>\n</ul>\n<p><strong>where 和 having 后可放的子查询：</strong></p>\n<ul>\n<li><p>子查询放在小括号内</p>\n</li>\n<li><p><strong>标量子查询（单值）</strong>，一般配合单行操作符使用：  &gt;  &lt;   &gt;=  =  &lt;&gt;</p>\n</li>\n<li><p><strong>列子查询（单列多行）</strong>， 一般配合多行操作符使用：  </p>\n</li>\n<li><ul>\n<li>IN   列表中的一个</li>\n<li>ANY/SOME   </li>\n<li>ALL</li>\n</ul>\n</li>\n</ul>\n<p><strong>select 后可以放的子查询：</strong></p>\n<p><strong>from 后可以放的子查询：</strong></p>\n<ul>\n<li><p>必须起别名</p>\n</li>\n<li><ul>\n<li>FROM (子查询表)  newtable </li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 标量子查询</span><br><span class=\"line\"># 1. 谁工资比  elgong 高</span><br><span class=\"line\">SELECT  * FROM employee </span><br><span class=\"line\">WHERE salary&gt;(select salary from emplot WHERE name = &apos;elgong&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\"># 查询超过平均工资的员工信息</span><br><span class=\"line\">select avg(sal) from emp;   /* avg(sal)=2000 */</span><br><span class=\"line\">select * from emp where sal &gt;= 2000;</span><br><span class=\"line\">/* 子查询方法 */</span><br><span class=\"line\">select * from emp where sal &gt;= (select avg(sal) from emp);</span><br></pre></td></tr></table></figure>\n<h2 id=\"11-连接查询——JOIN-联结表-INNER-JOIN-LEFT-JOIN-RIGHT-JOIN\"><a href=\"#11-连接查询——JOIN-联结表-INNER-JOIN-LEFT-JOIN-RIGHT-JOIN\" class=\"headerlink\" title=\"11. 连接查询——JOIN 联结表 ( INNER JOIN, LEFT JOIN, RIGHT JOIN)\"></a><strong>11. 连接查询——JOIN 联结表 ( INNER JOIN, LEFT JOIN, RIGHT JOIN)</strong></h2><p><strong>注意判断驱动表是哪个？  查询计划  explain</strong></p>\n<p>正常情况下，from 后的表是驱动表，但是当出现下面情况，驱动表变成了 class。</p>\n<p>分析： 当 where 后的条件使得表之间数据多少不一样时，数据少的为主表</p>\n<p><strong>小表驱动大表的原则</strong></p>\n<p><code>select * from student left join class on  class.classid = student.classid where class.classid = 2;</code></p>\n<p><strong>概念:    联结指两张表,或者多张表之间组合在一起进行查询, 是在运行时做的操作;</strong></p>\n<ul>\n<li><p><strong>left JOIN </strong> (左联结)保证读取主表的全部数据</p>\n</li>\n<li><p><strong>right JOIN</strong>  (右联结) 保证读取主表的全部数据</p>\n</li>\n<li><p><strong>inner JOIN</strong>  (内部联结,等值联结)  只读取共有的数据</p>\n</li>\n<li><p><strong>自联结:  </strong>常用来代替从同一个表检索数据的子查询.  FROM table1 AS t1, table2 AS t2, WHERE t1.col = t2.col;</p>\n</li>\n<li><p><strong>自然联结: </strong> 联结有主副表之分,  在INNER JOIN 之前的是主表, 待查询的输出中,排前边的内容所在的表为主表.</p>\n</li>\n</ul>\n<p>左外联结可通过颠倒FROM 或者WHERE 子句中表的顺序转换成右外部联结</p>\n<p><strong>连接的分类</strong></p>\n<ul>\n<li><p>SQL92语法</p>\n</li>\n<li><ul>\n<li><p><strong>等值连接</strong></p>\n</li>\n<li><ul>\n<li><code>FROM table1 AS t1, table2 AS t2, table3 AS t3  WHERE t1.col = t2.col  AND t2.c = t3.c ;</code>    </li>\n</ul>\n</li>\n<li><p><strong>自连接（单表）</strong></p>\n</li>\n<li><ul>\n<li>同表不同名</li>\n<li><code>FROM   employees   e1,  employees  e2  WHERE  e1.id = e2.iidd</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>SQL99语法</p>\n</li>\n<li><ul>\n<li>SELECT   查询列表</li>\n<li><code>FROM   表1  别名  [连接类型]   join        表2  别名   on          连接条件</code></li>\n</ul>\n</li>\n<li><ul>\n<li><p><strong>内连接</strong>  inner join</p>\n</li>\n<li><p><strong>外连接</strong>  left， right</p>\n</li>\n<li><ul>\n<li>主表全部显示</li>\n<li>从表中没有与主表匹配的结果，显示NULL</li>\n<li>等价于==== 内连接结果 + 主表有而从表没有的记录</li>\n<li>左外和右外，交换表顺序可以等价效果</li>\n</ul>\n</li>\n<li><p><strong>全外连接</strong>  full join</p>\n</li>\n<li><p><strong>交叉连接</strong>   cross join</p>\n</li>\n<li><ul>\n<li>笛卡尔乘机</li>\n</ul>\n</li>\n<li><p><strong>非等值连接</strong></p>\n</li>\n<li><ul>\n<li>FROM e  join g on e.salary  BETWEEN g.low AND g.upper</li>\n</ul>\n</li>\n<li><p><strong>自连接</strong></p>\n</li>\n<li><ul>\n<li>一样的join on   不同名的同一张表</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 创建联结表的两种方式</span><br><span class=\"line\"># 1. 等值连接  WHERE 表1.id = 表2.id AND 表2.size = 表3.size</span><br><span class=\"line\">SELECT vendors.vendor_name, product.prod_name, product.prod_price </span><br><span class=\"line\">FROM product,vendors </span><br><span class=\"line\">WHERE vendors.vendor_id = product.vendor_id </span><br><span class=\"line\">ORDER BY vendor_name;</span><br><span class=\"line\"></span><br><span class=\"line\"># 2.内部联结(等值联结) 表的键数量相同  FROM 表1 INNER JOIN 表2 ON 表1.id = 表2.id</span><br><span class=\"line\">SELECT v.vendor_name, p.prod_name, p.prod_price </span><br><span class=\"line\">FROM product AS p </span><br><span class=\"line\">INNER JOIN vendors AS v </span><br><span class=\"line\">ON v.vendor_id = p.vendor_id  </span><br><span class=\"line\">ORDER BY v.vendor_name;</span><br><span class=\"line\"></span><br><span class=\"line\"># </span><br><span class=\"line\"># 对联结的表使用聚合方法</span><br><span class=\"line\">待补充.....</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2020/04/11/mysql-必知必会7-综合内容/Users\\Misaya\\AppData\\Local\\YNote\\data\\elgong@126.com\\e6a36fe8659843b897ed6b6e6ee6977d\\clipboard.png\" alt=\"img\"></p>\n<h2 id=\"12-分页查询\"><a href=\"#12-分页查询\" class=\"headerlink\" title=\"12. 分页查询\"></a><strong>12. 分页查询</strong></h2><p>  <strong>LIMIT  行X(从0开始),  size;</strong></p>\n<p>  <strong>LIMIT  size OFFSET  size;</strong></p>\n<p><strong>当要显示的数据，需要分页显示</strong> </p>\n<ul>\n<li>从行0开始</li>\n<li>从第四行开始，检索5行</li>\n<li><strong>LIMIT   3,  5</strong></li>\n<li><strong>LIMIT   5  OFFSET  3</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#  查询前5条数据</span><br><span class=\"line\">SELECT  *  FROM employees LIMIT 0, 5;</span><br><span class=\"line\">\t</span><br><span class=\"line\"># 查询11到25条数据</span><br><span class=\"line\">SELECT  *  FROM employees LIMIT 10, 25-11+1;</span><br><span class=\"line\"></span><br><span class=\"line\"># 计算公式</span><br><span class=\"line\">LIMIT (page-1)*size,  size;</span><br></pre></td></tr></table></figure>\n<h2 id=\"13-联合查询-union-（自动去重，union-all-不去重）\"><a href=\"#13-联合查询-union-（自动去重，union-all-不去重）\" class=\"headerlink\" title=\"13. 联合查询  union  （自动去重，union all  不去重）\"></a><strong>13. 联合查询  union  （自动去重，union all  不去重）</strong></h2><p>将多条查询语句合并成一个结果</p>\n<p><strong>特点：</strong></p>\n<ul>\n<li>查询 <strong>列数</strong> 和 <strong>列顺序</strong> 必须一致</li>\n<li>自动去重</li>\n<li>不去重  union all</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT   *   FROM    e1   WHERE   </span><br><span class=\"line\">UNION</span><br><span class=\"line\">SELECT   *   FROM    e1   WHERE</span><br></pre></td></tr></table></figure>\n<h2 id=\"14-视图\"><a href=\"#14-视图\" class=\"headerlink\" title=\"14. 视图\"></a><strong>14. 视图</strong></h2><p>视图是虚拟的表, 是对其基表的封装.</p>\n<p>使用的好处:</p>\n<ol>\n<li><p>重用 SQL 语句</p>\n</li>\n<li><p>使用表的部分,即过滤掉部分数据</p>\n</li>\n</ol>\n<p>限制:</p>\n<ol>\n<li><p>图名唯一</p>\n</li>\n<li><p>视图可以嵌套</p>\n</li>\n<li><p>视图的ORDER BY  次于 从该视图检索数据的ORDER</p>\n</li>\n<li><p>视图可以和表一起使用</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 创建视图</span><br><span class=\"line\">CREATE VIEW  viewname AS</span><br><span class=\"line\">SELECT * FROM table WHERE id!=1;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、关系型数据库Mysql\"><a href=\"#一、关系型数据库Mysql\" class=\"headerlink\" title=\"一、关系型数据库Mysql\"></a><strong>一、关系型数据库Mysql</strong></h1><p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。</p>\n<ul>\n<li><strong>数据库:</strong> 数据库是一些关联表的集合。.</li>\n<li><strong>数据表:</strong> 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li>\n<li><strong>列:</strong> 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。</li>\n<li><strong>行：</strong>一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</li>\n<li><strong>冗余</strong>：存储两倍数据，冗余可以使系统速度更快。</li>\n<li><strong>主键</strong>：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li>\n<li><strong>外键：</strong>外键用于关联两个表。</li>\n<li><strong>复合键</strong>：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li>\n<li><strong>索引：</strong>使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li>\n<li><p><strong>参照完整性:</strong> 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性</p>\n</li>\n<li><p><strong>主键: 表示特定行.</strong></p>\n<ul>\n<li>主键不能重复</li>\n<li>每行必有主键,且不能为 NULL</li>\n</ul>\n</li>\n<li><p><strong>外键:</strong>  product 只存产品信息, 和供应商ID,  vendors 存供应商的信息(主键是ID),则vendors的主键就是product的外键.</p>\n</li>\n</ul>\n<p>MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。</p>\n<h1 id=\"二、-安装与删\"><a href=\"#二、-安装与删\" class=\"headerlink\" title=\"二、 安装与删\"></a><strong>二、 安装与删</strong></h1><ul>\n<li><p>删除mysql</p>\n<p><code>sudo apt purge mysql-* sudo apt autoremove</code></p>\n</li>\n<li><p>安装mysql</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install mysql-server </span><br><span class=\"line\">sudo apt install mysql-client </span><br><span class=\"line\">sudo apt install libmysqlclient-dev `</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>数据库规范：</strong></p>\n<ul>\n<li>关键字大写，表名，列名小写</li>\n<li>索引从1开始</li>\n<li>每条命令用分号隔开</li>\n<li><p>注释</p>\n</li>\n<li><p>单行注释   #</p>\n</li>\n<li>单行注释  — 注释文</li>\n<li>多行注释  /<em> </em>/</li>\n</ul>\n<font color=\"red\"><big>索引从1开始！</big></font>\n\n\n\n<h1 id=\"三、常用命令\"><a href=\"#三、常用命令\" class=\"headerlink\" title=\"三、常用命令\"></a><strong>三、常用命令</strong></h1><h2 id=\"指令执行顺序：\"><a href=\"#指令执行顺序：\" class=\"headerlink\" title=\"指令执行顺序：\"></a><strong>指令执行顺序：</strong></h2><p><strong>SELECT  FROM  WHERE   GROUP BY  HAVING  ORDER BY LIMIT.</strong></p>\n   <font color=\"red\"><big>开始 **->** FROM子句 **->** WHERE子句 **->** GROUP BY子句 **->** HAVING子句 **->** ORDER BY子句 **->** SELECT子句 **->** LIMIT子句 **->** 最终结果 </big></font>    \n\n<font color=\"red\"><big>每个步骤都会为下一个步骤生成一个虚拟表</big></font>\n\n\n\n<h2 id=\"1-登陆系统-选择数据库\"><a href=\"#1-登陆系统-选择数据库\" class=\"headerlink\" title=\"1. 登陆系统, 选择数据库\"></a><strong>1. 登陆系统, 选择数据库</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u 用户名 -p 密码</span><br><span class=\"line\">mysql -h localhost -P 3306 -p</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看所有数据库列表</span><br><span class=\"line\">SHOW DATABSASES;</span><br><span class=\"line\"># 查看选择的数据库中的表的列表</span><br><span class=\"line\">SHOW TABLES;</span><br><span class=\"line\"># 查看表中的列有哪些</span><br><span class=\"line\">SHOW COLUMNS FROM 表名;  ||  DESCRIBE 表名;</span><br><span class=\"line\"></span><br><span class=\"line\"># 选择库</span><br><span class=\"line\">USE 数据库的名字;</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看表结构</span><br><span class=\"line\">DESC 表名;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-基础查询——检索-SELECT-DISTINCT\"><a href=\"#2-基础查询——检索-SELECT-DISTINCT\" class=\"headerlink\" title=\"2 基础查询——检索 SELECT + DISTINCT\"></a><strong>2 基础查询——检索 SELECT + DISTINCT</strong></h2><p>SELECT 子句 固定的顺序:</p>\n<p><strong>SELECT  FROM  WHERE （原始表有的字段）  GROUP BY  HAVING  （分组后有的字段）ORDER BY LIMIT.</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 选择多个字段 `着重号`当字段名与关键字冲突，用它可以避免冲突</span><br><span class=\"line\">SELECT id, `name`, price FROM 表名; </span><br><span class=\"line\"></span><br><span class=\"line\"># 起别名 AS, 可以省略SELECT salary &quot;Month Salary&quot; from employees;</span><br><span class=\"line\">SELECT salary AS &quot;Month Salary&quot; from employees;</span><br><span class=\"line\"></span><br><span class=\"line\"># 字符串拼接 concat</span><br><span class=\"line\"># 特别注意+：  </span><br><span class=\"line\"># 1+9=10  两个数值型做加法</span><br><span class=\"line\"># &apos;12&apos;+ 3 = 15 字符转整数，再加 </span><br><span class=\"line\"># &apos;job&apos;+2 = 2  转换失败，则字符串变0</span><br><span class=\"line\"># null+任何值 = null</span><br><span class=\"line\">SELECT concat(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) , price FROM 表名; </span><br><span class=\"line\"></span><br><span class=\"line\"># 检索所有字段</span><br><span class=\"line\">SELECT * FROM 表名;</span><br><span class=\"line\"></span><br><span class=\"line\"># 字段去重  DISTINCT</span><br><span class=\"line\">SELECT DISTINCT id FROM 表名;   # 不能应用于多列</span><br><span class=\"line\"></span><br><span class=\"line\"># 限制检索结果</span><br><span class=\"line\"> SELECT  id FROM 表名  LIMIT 5;  # 前5 </span><br><span class=\"line\"> SELECT  id FROM 表名  LIMIT 2,5;  #从 2+1 开始的  5个行</span><br><span class=\"line\"> SELECT id FROM 表名 LIMIT 5 OFFSET 3;  # 从行3取5</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-排序检索-ORDER-BY-默认升序-LIMIT-OFFSET-DESC\"><a href=\"#3-排序检索-ORDER-BY-默认升序-LIMIT-OFFSET-DESC\" class=\"headerlink\" title=\"3. 排序检索 ORDER   BY (默认升序) + LIMIT,  OFFSET, DESC\"></a><strong>3. 排序检索 ORDER   BY (默认升序) + LIMIT,  OFFSET, DESC</strong></h2><p>可以根据非 select 字段排序。</p>\n<p>SELECT  查询列表</p>\n<p>FROM  表</p>\n<p>【where 筛选条件】</p>\n<p>ORDER BY  排序列表  [asc |  desc]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 按照某列排序,  多条件排序</span><br><span class=\"line\">SELECT id FROM 表名 ORDER BY id ASC, age DESC;   # 可以根据其他列来排序</span><br><span class=\"line\"></span><br><span class=\"line\"># 按照多个条件排序</span><br><span class=\"line\">SELECT id FROM 表名 ORDER BY age, size;   # 优先age, 重复时才根据size排序.</span><br><span class=\"line\"></span><br><span class=\"line\">#  指定降序  DESC</span><br><span class=\"line\">SELECT id FROM 表名 ORDER BY age  DESC  size;  # DESC 只作用于在DESC 前面的, 所以 size仍然为升序</span><br><span class=\"line\"></span><br><span class=\"line\"># 找到最********的id</span><br><span class=\"line\">SELECT id FROM 表名 ORDER BY age LIMIT 1;</span><br><span class=\"line\"># 第二最的*******id</span><br><span class=\"line\">SELECT id FROM 表名 ORDER BY age LIMIT 1 OFFSET 2;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-条件查询\"><a href=\"#4-条件查询\" class=\"headerlink\" title=\"4. 条件查询\"></a><strong>4. 条件查询</strong></h2><h3 id=\"4-1-——逻辑运算-WHERE-AND-OR-NOT-IN-和EXISTS-看优化部分\"><a href=\"#4-1-——逻辑运算-WHERE-AND-OR-NOT-IN-和EXISTS-看优化部分\" class=\"headerlink\" title=\"4.1  ——逻辑运算 WHERE + AND, OR,NOT IN 和EXISTS(看优化部分)\"></a><strong>4.1  ——逻辑运算 WHERE + AND, OR,NOT</strong> <strong>IN 和EXISTS(看优化部分)</strong></h3><p><strong>作用：</strong></p>\n<p>连接条件表达式</p>\n<font color=\"red\"><big>**如果计算次序不加括号时,  优先 AND**</big></font>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#  =  !=  &lt;  &gt; &gt;=    &quot;BETWEEN 1 AND 2&quot;在指定值之间,包含端点</span><br><span class=\"line\"># 不等于 ！=   或者  &lt;&gt;</span><br><span class=\"line\">SELECT id FROM 表名 WHERE age=12 ORDER BY size;</span><br><span class=\"line\"></span><br><span class=\"line\"># 组合筛选  AND  OR</span><br><span class=\"line\">SELECT id FROM 表名 WHERE age=12 AND size &lt; 10;</span><br><span class=\"line\"></span><br><span class=\"line\"># 计算次序,  不加括号时,  优先 AND</span><br><span class=\"line\"># 解释: id&gt;3且age&gt;10,  或者 id=1</span><br><span class=\"line\">SELECT id FROM 表名 WHERE id=1 OR id=3 AND age &gt; 10;   </span><br><span class=\"line\"></span><br><span class=\"line\"># NOT  否定后跟的所有条件.</span><br><span class=\"line\">SELECT id FROM 表名 NOT WHERE id IN (1002, 1003)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2020/04/11/mysql-必知必会7-综合内容/Users\\Misaya\\AppData\\Local\\YNote\\data\\elgong@126.com\\e87e0bbb47ff40228ca7b6dbebad7954\\clipboard.png\" alt=\"img\"></p>\n<h3 id=\"4-2-——模糊查询-WHERE-LIKE-between-and-in-is-null\"><a href=\"#4-2-——模糊查询-WHERE-LIKE-between-and-in-is-null\" class=\"headerlink\" title=\"4.2  ——模糊查询  WHERE + LIKE, between and, in, is null\"></a><strong>4.2  ——模糊查询  WHERE + LIKE, between and, in, is null</strong></h3><ul>\n<li><strong>like + 通配符：</strong> 参考7.</li>\n<li><strong>between and ：</strong> 包含临界值， 不可颠倒顺序</li>\n<li><strong>in：</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># between and</span><br><span class=\"line\">SELECT  * FROM 表名  WHERE id BETWEEN 100 and 120;</span><br><span class=\"line\"></span><br><span class=\"line\"># IN 取值必须在括号内</span><br><span class=\"line\">SELECT id FROM 表名 WHERE id IN (1002, 1003)</span><br><span class=\"line\"></span><br><span class=\"line\"># IS NULL 筛选出空值  IS NOT NULL</span><br><span class=\"line\">SELECT id FROM 表名 WHERE age IS NULL;</span><br></pre></td></tr></table></figure>\n<p><strong>补. 空值处理 IFNULL(字段，空值时返回值)</strong></p>\n<p><code>SELECT IFNULL(price, 0) FROM 表名;</code></p>\n<h2 id=\"5-通配符-LIKE-正则表达式-REGEXP-都-不区分大小写\"><a href=\"#5-通配符-LIKE-正则表达式-REGEXP-都-不区分大小写\" class=\"headerlink\" title=\"5. 通配符   LIKE + % , _   + 正则表达式 REGEXP   都**不区分大小写**\"></a><strong>5. 通配符   LIKE + % , _   + 正则表达式</strong> <strong>REGEXP   都**</strong>不区分大小写**</h2><ol>\n<li><p>通配符速度慢, 不要放在搜索开始处</p>\n</li>\n<li><p><strong>LIKE 匹配整个串,  正则表达式可以匹配子串</strong></p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#  通配符</span><br><span class=\"line\">#  % 匹配0,1,多个字符</span><br><span class=\"line\">SELECT id FROM 表名 WHERE string LIKE &apos;s%&apos;;   # s开头   </span><br><span class=\"line\"></span><br><span class=\"line\"># 下划线 _ , 匹配单个字符</span><br><span class=\"line\"># 需要匹配 _ 时， 用转义   \\_</span><br><span class=\"line\">SELECT id FROM 表名 WHERE string LIKE &apos;s_&apos;;  </span><br><span class=\"line\"></span><br><span class=\"line\">------------------------------------------------------------------</span><br><span class=\"line\">#  正则表达式 REGEXP</span><br><span class=\"line\"># 标准表达</span><br><span class=\"line\">SELECT name FROM customers WHERE name REGEXP &apos;1000&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;.&apos;   # 任意一个字符</span><br><span class=\"line\">&apos;A1&apos;| &apos;B2&apos;  # 匹配两个串之一</span><br><span class=\"line\">&apos;[1-9]&apos;     # 匹配 1~9 范围内的值</span><br><span class=\"line\">&apos;[123]&apos;     # 匹配1，2，3之一， 等价于【1 | 2 | 3】</span><br><span class=\"line\">&apos;[^123]&apos;    # 匹配非123的值</span><br><span class=\"line\">&apos;\\\\.&apos;       # 特殊字符转译   </span><br><span class=\"line\"></span><br><span class=\"line\"># 匹配多个实例, 不能单独出现,必须是指定上边的某种字符的匹配</span><br><span class=\"line\"># 例如 &apos;.*&apos; 而不是&apos;*&apos;</span><br><span class=\"line\">&apos;*&apos;  # 0或多个匹配</span><br><span class=\"line\">&apos;+&apos;  # 1或多个匹配</span><br><span class=\"line\">&apos;?&apos;  # 0或者1个匹配</span><br><span class=\"line\">&#123;n&#125;  # 指定数目匹配</span><br><span class=\"line\">&#123;n,&#125;  # 不少于指定数目的匹配</span><br><span class=\"line\">&#123;n,m&#125;  # 数目范围,不超过255</span><br><span class=\"line\"></span><br><span class=\"line\">#定位元字符</span><br><span class=\"line\">&apos;^&apos;   # 开始位置</span><br><span class=\"line\">&apos;$&apos;   # 结尾</span><br><span class=\"line\">&apos;[[:&lt;:]]&apos;  # 词开始</span><br><span class=\"line\">&apos;[[:&lt;:]]&apos;  # 词结尾</span><br><span class=\"line\"></span><br><span class=\"line\"># 举例:</span><br><span class=\"line\">&apos;^[1-9]&apos;   </span><br><span class=\"line\">BINARY &apos;J 1000&apos;     # 指定区分大小写</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;[a-zA-Z0-9]&apos;   # 匹配所有字符</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-数据处理常用函数-不区分大小写\"><a href=\"#6-数据处理常用函数-不区分大小写\" class=\"headerlink\" title=\"6. 数据处理常用函数 (不区分大小写)\"></a><strong>6. 数据处理常用函数 (不区分大小写)</strong></h2><ul>\n<li>字符函数</li>\n<li>数学函数</li>\n<li>日期函数</li>\n<li>其他函数</li>\n<li>流程函数</li>\n</ul>\n<p>字符函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 文本处理函数</span><br><span class=\"line\"># 1. 字符串字节个数,  汉字算三个字符</span><br><span class=\"line\">Length() </span><br><span class=\"line\"></span><br><span class=\"line\"># 2. 拼接</span><br><span class=\"line\">CONCAT(id, &quot;_&quot;, name)</span><br><span class=\"line\"></span><br><span class=\"line\"># 3. 大写 小写</span><br><span class=\"line\">Lower()  # 小写</span><br><span class=\"line\">Upper()  # 大写</span><br><span class=\"line\"></span><br><span class=\"line\"># 4. 返回子串的字符, 数据库索引从1开始</span><br><span class=\"line\">SubStr(last_name, start) </span><br><span class=\"line\">SubStr(last_name, start, length)   # 长度</span><br><span class=\"line\"></span><br><span class=\"line\"># 5. 查找子串, 返回第一次出现的索引， 查不到返回0</span><br><span class=\"line\">INSTR(&quot;待查子串abcd&quot;, &quot;a&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"># 6. 去空格</span><br><span class=\"line\">Trim(), LTrim(), RTrim()  </span><br><span class=\"line\"></span><br><span class=\"line\"># 7. 指定长度填充</span><br><span class=\"line\">LPAD(name, length, &apos;*&apos;)</span><br><span class=\"line\">RPAD(name, length, &apos;*&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\"># 8. 替换</span><br><span class=\"line\">REPLACE(原串, &apos;被替换串&apos;, &apos;新串&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\"># 9. 字符串字符长度, 汉字也算 1个字符</span><br><span class=\"line\">CHAR_LENGTH(s)  </span><br><span class=\"line\">Soundex()   # 返回串的SOUNDEX值</span><br></pre></td></tr></table></figure>\n<p>数学函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1. 四舍五入</span><br><span class=\"line\">ROUND(1.6);   # 2</span><br><span class=\"line\">ROUND(1.567, 2)  # 小数点保留两位</span><br><span class=\"line\"></span><br><span class=\"line\"># 2. 上取整， &gt;=该参数的最小整数</span><br><span class=\"line\">CEIL(1.00) </span><br><span class=\"line\"># 下取整,   &lt;=该参数的最大整数</span><br><span class=\"line\">FLOOR(-9.99)   # -10</span><br><span class=\"line\"></span><br><span class=\"line\"># 3. 小数点直接截断</span><br><span class=\"line\">TRUNCATE(1.69999, 1)  # 1.6</span><br><span class=\"line\"></span><br><span class=\"line\"># 4. 取余数</span><br><span class=\"line\">MOD(10, 3)  # 10%3</span><br><span class=\"line\"></span><br><span class=\"line\">ABS(x)   # 绝对值</span><br><span class=\"line\">AVG(age)  # 某列的平均值 </span><br><span class=\"line\">EXP(x)</span><br><span class=\"line\">RAND()  # 0到1的随机数</span><br></pre></td></tr></table></figure>\n<p>日期函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NOW()   # 当前日期和时间</span><br><span class=\"line\">CURDATE() # 当前日期，不含时间</span><br><span class=\"line\">Date()  # 返回时间中的日期部分....</span><br><span class=\"line\">Day()   # 返回时间中的天数部分</span><br><span class=\"line\">Year(NOW())</span><br><span class=\"line\">Time()</span><br><span class=\"line\">Month()  </span><br><span class=\"line\">Hour()</span><br><span class=\"line\">DateDiff()  # 计算日期差</span><br><span class=\"line\"></span><br><span class=\"line\"># 字符串转日期</span><br><span class=\"line\">STR_TO_DATE(&apos;02-19-2020&apos;, &quot;%m-%d-%Y&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"># 日期的格式化输出</span><br><span class=\"line\">DATE_FORMAT(NOW(), &apos;%y年%m月%d日&apos;)</span><br></pre></td></tr></table></figure>\n<p>其他函数</p>\n<p><code>VERSION()</code></p>\n<h2 id=\"7-流程控制函数\"><a href=\"#7-流程控制函数\" class=\"headerlink\" title=\"7. 流程控制函数\"></a><strong>7. 流程控制函数</strong></h2><p>IF(逻辑判断， 成立执行， 不成立执行)</p>\n<p>CASE:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># IF</span><br><span class=\"line\">IF(10&gt;5, &apos;大&apos;, &apos;小&apos;)</span><br><span class=\"line\">SELECT name IF(salary IS NULL, &quot;没薪水&quot;, &quot;有薪水&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"># CASE 第一种使用</span><br><span class=\"line\">CASE &apos;要判断的表达式&apos;</span><br><span class=\"line\">WHEN &apos;常量1&apos; then 值(没有分号) / 表达式(有分号);</span><br><span class=\"line\">WHEN &apos;常量2&apos; then 值(没有分号) / 表达式(有分号);</span><br><span class=\"line\">WHEN &apos;常量3&apos; then 值(没有分号) / 表达式(有分号);</span><br><span class=\"line\">...</span><br><span class=\"line\">ELSE 值(没有分号) / 表达式(有分号);</span><br><span class=\"line\">END;</span><br><span class=\"line\"></span><br><span class=\"line\"># CASE 第二种语句</span><br><span class=\"line\">CASE </span><br><span class=\"line\">WHEN 表达式 then 值(没有分号) / 表达式(有分号);</span><br><span class=\"line\">WHEN 表达式 then 值(没有分号) / 表达式(有分号);</span><br><span class=\"line\">WHEN 表达式 then 值(没有分号) / 表达式(有分号);</span><br><span class=\"line\">...</span><br><span class=\"line\">ELSE 值(没有分号) / 表达式(有分号);</span><br><span class=\"line\">END;</span><br></pre></td></tr></table></figure>\n<h2 id=\"8-数据汇总-聚集函数-AVG-COUNT-MAX-MIN-SUM\"><a href=\"#8-数据汇总-聚集函数-AVG-COUNT-MAX-MIN-SUM\" class=\"headerlink\" title=\"8. 数据汇总-聚集函数  AVG, COUNT, MAX, MIN, SUM\"></a><strong>8. 数据汇总-聚集函数  AVG, COUNT, MAX, MIN, SUM</strong></h2><p>运行在行组, 计算和返回单个值的函数.</p>\n<p>统计使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># AVG() 针对单列,  对多列需要使用多个</span><br><span class=\"line\">SELECT AVG(age) AS avg_age FROM 表名;   # 忽略 NULL</span><br><span class=\"line\"></span><br><span class=\"line\"># COUNT() 函数</span><br><span class=\"line\">COUNT(1);   # 行数</span><br><span class=\"line\">COUNT(*);   # 表的行数, 含有 NULL的有数据行也可，但是不能全NULL</span><br><span class=\"line\">COUNT(column)  # 某列非NULL 的个数</span><br><span class=\"line\">COUNT(distinct 字段)  # 统计不重复的</span><br><span class=\"line\"># 效率对比：</span><br><span class=\"line\">MYISAM 储存引擎下， COUNT(*) 效率高</span><br><span class=\"line\">INNODB 存储引擎下，COUNT(*) 和COUNT(1) 差不多，比COUNT(字段高)</span><br><span class=\"line\"></span><br><span class=\"line\"># 聚集不同的值 + DISTINCT</span><br><span class=\"line\"># 聚集函数默认ALL</span><br><span class=\"line\">SELECT AVG(DISTINCT age) FROM 表名;  # 对唯一值求均值</span><br><span class=\"line\">SELECT COUNt(DISTINCT age) FROM 表名;  # 对age列的唯一值统计个数</span><br></pre></td></tr></table></figure>\n<h2 id=\"9-数据分组查询-——-GROUP-BY-HAVING\"><a href=\"#9-数据分组查询-——-GROUP-BY-HAVING\" class=\"headerlink\" title=\"9. 数据分组查询 —— GROUP BY,   HAVING\"></a><strong>9. 数据分组查询 —— GROUP BY,   HAVING</strong></h2><h3 id=\"1-GROUP-BY-分组字段\"><a href=\"#1-GROUP-BY-分组字段\" class=\"headerlink\" title=\"1. GROUP BY   分组字段\"></a><strong>1. GROUP BY   分组字段</strong></h3><p>​          <font color=\"red\"><big><strong>如果分组列中具有 NULL,  则NULL 将作为一个分组返回.</strong></big></font></p>\n<h3 id=\"2-HAVING-过滤条件-WHERE-条件\"><a href=\"#2-HAVING-过滤条件-WHERE-条件\" class=\"headerlink\" title=\"2. HAVING 过滤条件  =====WHERE 条件\"></a><strong>2. HAVING 过滤条件  =====WHERE 条件</strong></h3><h3 id=\"3-必加-ORDER-BY-因为G出来的结果不保证排序了\"><a href=\"#3-必加-ORDER-BY-因为G出来的结果不保证排序了\" class=\"headerlink\" title=\"3. 必加 ORDER BY,  因为G出来的结果不保证排序了.\"></a><strong>3. 必加 ORDER BY,  因为G出来的结果不保证排序了.</strong></h3><h3 id=\"4-能where-就不用having\"><a href=\"#4-能where-就不用having\" class=\"headerlink\" title=\"4. 能where 就不用having\"></a><strong>4. 能where 就不用having</strong></h3><ul>\n<li><p><strong>按字段分组</strong></p>\n</li>\n<li><ul>\n<li>GROUP BY id </li>\n</ul>\n</li>\n<li><p><strong>按表达式或者函数</strong></p>\n</li>\n<li><ul>\n<li>GROUP BY length(id)  AS  len   HAVING  len&gt;3;</li>\n</ul>\n</li>\n<li><p><strong>按多个字段分组</strong></p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 分组统计值</span><br><span class=\"line\">SELECT id, COUNT(*) AS num_ FROM 表名 GROUP BY id ORDER BY age;</span><br><span class=\"line\"></span><br><span class=\"line\"># 分组过滤  大于2的值</span><br><span class=\"line\">SELECT age FROM 表名 GROUP BY  id  HAVING COUNT(*)&gt;=2 ORDER BY age;</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-子查询-IN-括号\"><a href=\"#10-子查询-IN-括号\" class=\"headerlink\" title=\"10. 子查询  IN + 括号\"></a><strong>10. 子查询  IN + 括号</strong></h2><ul>\n<li>查询的结果作为另一个查询的条件,然后多层嵌套.</li>\n<li>内层查询<strong>建立一个临时表</strong>。费时间.</li>\n<li>优化需要用join 联结表替代….</li>\n</ul>\n<p><strong>where 和 having 后可放的子查询：</strong></p>\n<ul>\n<li><p>子查询放在小括号内</p>\n</li>\n<li><p><strong>标量子查询（单值）</strong>，一般配合单行操作符使用：  &gt;  &lt;   &gt;=  =  &lt;&gt;</p>\n</li>\n<li><p><strong>列子查询（单列多行）</strong>， 一般配合多行操作符使用：  </p>\n</li>\n<li><ul>\n<li>IN   列表中的一个</li>\n<li>ANY/SOME   </li>\n<li>ALL</li>\n</ul>\n</li>\n</ul>\n<p><strong>select 后可以放的子查询：</strong></p>\n<p><strong>from 后可以放的子查询：</strong></p>\n<ul>\n<li><p>必须起别名</p>\n</li>\n<li><ul>\n<li>FROM (子查询表)  newtable </li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 标量子查询</span><br><span class=\"line\"># 1. 谁工资比  elgong 高</span><br><span class=\"line\">SELECT  * FROM employee </span><br><span class=\"line\">WHERE salary&gt;(select salary from emplot WHERE name = &apos;elgong&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\"># 查询超过平均工资的员工信息</span><br><span class=\"line\">select avg(sal) from emp;   /* avg(sal)=2000 */</span><br><span class=\"line\">select * from emp where sal &gt;= 2000;</span><br><span class=\"line\">/* 子查询方法 */</span><br><span class=\"line\">select * from emp where sal &gt;= (select avg(sal) from emp);</span><br></pre></td></tr></table></figure>\n<h2 id=\"11-连接查询——JOIN-联结表-INNER-JOIN-LEFT-JOIN-RIGHT-JOIN\"><a href=\"#11-连接查询——JOIN-联结表-INNER-JOIN-LEFT-JOIN-RIGHT-JOIN\" class=\"headerlink\" title=\"11. 连接查询——JOIN 联结表 ( INNER JOIN, LEFT JOIN, RIGHT JOIN)\"></a><strong>11. 连接查询——JOIN 联结表 ( INNER JOIN, LEFT JOIN, RIGHT JOIN)</strong></h2><p><strong>注意判断驱动表是哪个？  查询计划  explain</strong></p>\n<p>正常情况下，from 后的表是驱动表，但是当出现下面情况，驱动表变成了 class。</p>\n<p>分析： 当 where 后的条件使得表之间数据多少不一样时，数据少的为主表</p>\n<p><strong>小表驱动大表的原则</strong></p>\n<p><code>select * from student left join class on  class.classid = student.classid where class.classid = 2;</code></p>\n<p><strong>概念:    联结指两张表,或者多张表之间组合在一起进行查询, 是在运行时做的操作;</strong></p>\n<ul>\n<li><p><strong>left JOIN </strong> (左联结)保证读取主表的全部数据</p>\n</li>\n<li><p><strong>right JOIN</strong>  (右联结) 保证读取主表的全部数据</p>\n</li>\n<li><p><strong>inner JOIN</strong>  (内部联结,等值联结)  只读取共有的数据</p>\n</li>\n<li><p><strong>自联结:  </strong>常用来代替从同一个表检索数据的子查询.  FROM table1 AS t1, table2 AS t2, WHERE t1.col = t2.col;</p>\n</li>\n<li><p><strong>自然联结: </strong> 联结有主副表之分,  在INNER JOIN 之前的是主表, 待查询的输出中,排前边的内容所在的表为主表.</p>\n</li>\n</ul>\n<p>左外联结可通过颠倒FROM 或者WHERE 子句中表的顺序转换成右外部联结</p>\n<p><strong>连接的分类</strong></p>\n<ul>\n<li><p>SQL92语法</p>\n</li>\n<li><ul>\n<li><p><strong>等值连接</strong></p>\n</li>\n<li><ul>\n<li><code>FROM table1 AS t1, table2 AS t2, table3 AS t3  WHERE t1.col = t2.col  AND t2.c = t3.c ;</code>    </li>\n</ul>\n</li>\n<li><p><strong>自连接（单表）</strong></p>\n</li>\n<li><ul>\n<li>同表不同名</li>\n<li><code>FROM   employees   e1,  employees  e2  WHERE  e1.id = e2.iidd</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>SQL99语法</p>\n</li>\n<li><ul>\n<li>SELECT   查询列表</li>\n<li><code>FROM   表1  别名  [连接类型]   join        表2  别名   on          连接条件</code></li>\n</ul>\n</li>\n<li><ul>\n<li><p><strong>内连接</strong>  inner join</p>\n</li>\n<li><p><strong>外连接</strong>  left， right</p>\n</li>\n<li><ul>\n<li>主表全部显示</li>\n<li>从表中没有与主表匹配的结果，显示NULL</li>\n<li>等价于==== 内连接结果 + 主表有而从表没有的记录</li>\n<li>左外和右外，交换表顺序可以等价效果</li>\n</ul>\n</li>\n<li><p><strong>全外连接</strong>  full join</p>\n</li>\n<li><p><strong>交叉连接</strong>   cross join</p>\n</li>\n<li><ul>\n<li>笛卡尔乘机</li>\n</ul>\n</li>\n<li><p><strong>非等值连接</strong></p>\n</li>\n<li><ul>\n<li>FROM e  join g on e.salary  BETWEEN g.low AND g.upper</li>\n</ul>\n</li>\n<li><p><strong>自连接</strong></p>\n</li>\n<li><ul>\n<li>一样的join on   不同名的同一张表</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 创建联结表的两种方式</span><br><span class=\"line\"># 1. 等值连接  WHERE 表1.id = 表2.id AND 表2.size = 表3.size</span><br><span class=\"line\">SELECT vendors.vendor_name, product.prod_name, product.prod_price </span><br><span class=\"line\">FROM product,vendors </span><br><span class=\"line\">WHERE vendors.vendor_id = product.vendor_id </span><br><span class=\"line\">ORDER BY vendor_name;</span><br><span class=\"line\"></span><br><span class=\"line\"># 2.内部联结(等值联结) 表的键数量相同  FROM 表1 INNER JOIN 表2 ON 表1.id = 表2.id</span><br><span class=\"line\">SELECT v.vendor_name, p.prod_name, p.prod_price </span><br><span class=\"line\">FROM product AS p </span><br><span class=\"line\">INNER JOIN vendors AS v </span><br><span class=\"line\">ON v.vendor_id = p.vendor_id  </span><br><span class=\"line\">ORDER BY v.vendor_name;</span><br><span class=\"line\"></span><br><span class=\"line\"># </span><br><span class=\"line\"># 对联结的表使用聚合方法</span><br><span class=\"line\">待补充.....</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2020/04/11/mysql-必知必会7-综合内容/Users\\Misaya\\AppData\\Local\\YNote\\data\\elgong@126.com\\e6a36fe8659843b897ed6b6e6ee6977d\\clipboard.png\" alt=\"img\"></p>\n<h2 id=\"12-分页查询\"><a href=\"#12-分页查询\" class=\"headerlink\" title=\"12. 分页查询\"></a><strong>12. 分页查询</strong></h2><p>  <strong>LIMIT  行X(从0开始),  size;</strong></p>\n<p>  <strong>LIMIT  size OFFSET  size;</strong></p>\n<p><strong>当要显示的数据，需要分页显示</strong> </p>\n<ul>\n<li>从行0开始</li>\n<li>从第四行开始，检索5行</li>\n<li><strong>LIMIT   3,  5</strong></li>\n<li><strong>LIMIT   5  OFFSET  3</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#  查询前5条数据</span><br><span class=\"line\">SELECT  *  FROM employees LIMIT 0, 5;</span><br><span class=\"line\">\t</span><br><span class=\"line\"># 查询11到25条数据</span><br><span class=\"line\">SELECT  *  FROM employees LIMIT 10, 25-11+1;</span><br><span class=\"line\"></span><br><span class=\"line\"># 计算公式</span><br><span class=\"line\">LIMIT (page-1)*size,  size;</span><br></pre></td></tr></table></figure>\n<h2 id=\"13-联合查询-union-（自动去重，union-all-不去重）\"><a href=\"#13-联合查询-union-（自动去重，union-all-不去重）\" class=\"headerlink\" title=\"13. 联合查询  union  （自动去重，union all  不去重）\"></a><strong>13. 联合查询  union  （自动去重，union all  不去重）</strong></h2><p>将多条查询语句合并成一个结果</p>\n<p><strong>特点：</strong></p>\n<ul>\n<li>查询 <strong>列数</strong> 和 <strong>列顺序</strong> 必须一致</li>\n<li>自动去重</li>\n<li>不去重  union all</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT   *   FROM    e1   WHERE   </span><br><span class=\"line\">UNION</span><br><span class=\"line\">SELECT   *   FROM    e1   WHERE</span><br></pre></td></tr></table></figure>\n<h2 id=\"14-视图\"><a href=\"#14-视图\" class=\"headerlink\" title=\"14. 视图\"></a><strong>14. 视图</strong></h2><p>视图是虚拟的表, 是对其基表的封装.</p>\n<p>使用的好处:</p>\n<ol>\n<li><p>重用 SQL 语句</p>\n</li>\n<li><p>使用表的部分,即过滤掉部分数据</p>\n</li>\n</ol>\n<p>限制:</p>\n<ol>\n<li><p>图名唯一</p>\n</li>\n<li><p>视图可以嵌套</p>\n</li>\n<li><p>视图的ORDER BY  次于 从该视图检索数据的ORDER</p>\n</li>\n<li><p>视图可以和表一起使用</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 创建视图</span><br><span class=\"line\">CREATE VIEW  viewname AS</span><br><span class=\"line\">SELECT * FROM table WHERE id!=1;</span><br></pre></td></tr></table></figure>\n"},{"title":"mysql-索引篇1-索引的概念","date":"2019-08-11T02:46:16.000Z","_content":"\n# **一、索引的概念**\n\n## 1.1 索引的作用\n\n\n\n## 1.2 索引的分类（还不清楚到底怎么归类）**\n\n**查看有哪些索引：**   `SHOW   index;`\n\n\n\n**聚簇索引（主键索引)**    **每张表只能有一个**，**数据和索引在同一个文件**\n\n​        按照每张表的主键构造一颗B+树，同时叶子节点中存放的即为整张表的记录数据。\n\n**辅助索引（二级索引）**: **叶子节点并不包含行记录的全部数据**\n\n​       非主键索引，叶子节点=键值+书签（行的索引值）\n\n**覆盖索引：** **（extra 提示using index）**\n\n​       InnoDB存储引擎支持覆盖索引，即从**辅助索引中就可以得到查询的记录**，而不需要查询聚集索引中的记录了（不需要回表操作）。\n\n​       覆盖索引并不适用于任意的索引类型，**索引必须存储列的值**，所以<font color=\"red\"><big>**不需要回表操作。**</big></font>\n\nMySQL只能使用B-树.\n\n**联合索引：**\n\n​        联合索引也是一棵**B+树，其键值数量大于等于2。键值都是排序的**，通过叶子节点可以逻辑上顺序的读出所有数据。\n\n**单值索引：** 一个索引只包含单个列\n\n**多值索引、复合索引**（**组合索引**）: 即一个索包含多个列\n\n**复合索引**只会对与创建索引时的排序顺序完全相同或相反的 order by语句进行优化\n\n**唯一索引**: 索引唯一，但可以null， 声明unique关键字时,会为其字段自动添加唯一索引\n\n\n```\n// 单值索引 \n#外部创建 \nCREATE INDEX [indexname]ON t1(colname); \n\n#创建表的时候创建 \nCREATE TABLE mytable(   ID INT NOT NULL,    username VARCHAR(16) NOT NULL,   INDEX [indexName] (username(length))   );  \n\n#alter语句添加 \nALTER table tableName ADD INDEX indexName(columnName)  \n\n// 复合索引 \nCREATE INDEX idx_c1_c2_c3ON tablename(c1,c2,c3)\n```\n\n![img](https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/35ED850E7CCF446C903DD2A0AED7AABE/18916)\n\n\n\n## **1.3 创建**\n\n![img](https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/5FAAFB8FB8BD43CC8F2CD5853ED88350/18908)\n\n\n\n## **1.4 什么时候该创建索引？**\n\n![img](https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/7C97A4A5F692496686ED1CB7890E0543/18901)\n\n**不该创建？**\n\n![img](https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/ADE489407E394B16856C9B839E2416DE/18902)\n\n对于最长使用的查询，可以针对性的建立索引来优化速度。\n\njoin查询在有索引条件下\n\n　　驱动表有索引不会使用到索引\n\n　　被驱动表建立索引会使用到索引\n\n\n\n# **二、性能分析和优化策略**\n\n![img](https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/20D9F3FA33FF41E2AB5EAB6EA9D24A25/18895)\n\n![img](https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/7AC131346BED4F13AA046DA87FEFC40C/18894)\n\n![img](https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/61AED2EF4E4D4DEB8D33DEBCBFD93175/18857)\n\n\n","source":"_posts/mysql-索引篇1-索引的概念.md","raw":"---\ntitle: mysql-索引篇1-索引的概念\ndate: 2019-08-11 10:46:16\ncategories: mysql\ntags: 数据库索引\n---\n\n# **一、索引的概念**\n\n## 1.1 索引的作用\n\n\n\n## 1.2 索引的分类（还不清楚到底怎么归类）**\n\n**查看有哪些索引：**   `SHOW   index;`\n\n\n\n**聚簇索引（主键索引)**    **每张表只能有一个**，**数据和索引在同一个文件**\n\n​        按照每张表的主键构造一颗B+树，同时叶子节点中存放的即为整张表的记录数据。\n\n**辅助索引（二级索引）**: **叶子节点并不包含行记录的全部数据**\n\n​       非主键索引，叶子节点=键值+书签（行的索引值）\n\n**覆盖索引：** **（extra 提示using index）**\n\n​       InnoDB存储引擎支持覆盖索引，即从**辅助索引中就可以得到查询的记录**，而不需要查询聚集索引中的记录了（不需要回表操作）。\n\n​       覆盖索引并不适用于任意的索引类型，**索引必须存储列的值**，所以<font color=\"red\"><big>**不需要回表操作。**</big></font>\n\nMySQL只能使用B-树.\n\n**联合索引：**\n\n​        联合索引也是一棵**B+树，其键值数量大于等于2。键值都是排序的**，通过叶子节点可以逻辑上顺序的读出所有数据。\n\n**单值索引：** 一个索引只包含单个列\n\n**多值索引、复合索引**（**组合索引**）: 即一个索包含多个列\n\n**复合索引**只会对与创建索引时的排序顺序完全相同或相反的 order by语句进行优化\n\n**唯一索引**: 索引唯一，但可以null， 声明unique关键字时,会为其字段自动添加唯一索引\n\n\n```\n// 单值索引 \n#外部创建 \nCREATE INDEX [indexname]ON t1(colname); \n\n#创建表的时候创建 \nCREATE TABLE mytable(   ID INT NOT NULL,    username VARCHAR(16) NOT NULL,   INDEX [indexName] (username(length))   );  \n\n#alter语句添加 \nALTER table tableName ADD INDEX indexName(columnName)  \n\n// 复合索引 \nCREATE INDEX idx_c1_c2_c3ON tablename(c1,c2,c3)\n```\n\n![img](https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/35ED850E7CCF446C903DD2A0AED7AABE/18916)\n\n\n\n## **1.3 创建**\n\n![img](https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/5FAAFB8FB8BD43CC8F2CD5853ED88350/18908)\n\n\n\n## **1.4 什么时候该创建索引？**\n\n![img](https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/7C97A4A5F692496686ED1CB7890E0543/18901)\n\n**不该创建？**\n\n![img](https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/ADE489407E394B16856C9B839E2416DE/18902)\n\n对于最长使用的查询，可以针对性的建立索引来优化速度。\n\njoin查询在有索引条件下\n\n　　驱动表有索引不会使用到索引\n\n　　被驱动表建立索引会使用到索引\n\n\n\n# **二、性能分析和优化策略**\n\n![img](https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/20D9F3FA33FF41E2AB5EAB6EA9D24A25/18895)\n\n![img](https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/7AC131346BED4F13AA046DA87FEFC40C/18894)\n\n![img](https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/61AED2EF4E4D4DEB8D33DEBCBFD93175/18857)\n\n\n","slug":"mysql-索引篇1-索引的概念","published":1,"updated":"2020-04-11T03:02:11.179Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephdu000yt8pl7mr6b2lj","content":"<h1 id=\"一、索引的概念\"><a href=\"#一、索引的概念\" class=\"headerlink\" title=\"一、索引的概念\"></a><strong>一、索引的概念</strong></h1><h2 id=\"1-1-索引的作用\"><a href=\"#1-1-索引的作用\" class=\"headerlink\" title=\"1.1 索引的作用\"></a>1.1 索引的作用</h2><h2 id=\"1-2-索引的分类（还不清楚到底怎么归类）\"><a href=\"#1-2-索引的分类（还不清楚到底怎么归类）\" class=\"headerlink\" title=\"1.2 索引的分类（还不清楚到底怎么归类）**\"></a>1.2 索引的分类（还不清楚到底怎么归类）**</h2><p><strong>查看有哪些索引：</strong>   <code>SHOW   index;</code></p>\n<p><strong>聚簇索引（主键索引)</strong>    <strong>每张表只能有一个</strong>，<strong>数据和索引在同一个文件</strong></p>\n<p>​        按照每张表的主键构造一颗B+树，同时叶子节点中存放的即为整张表的记录数据。</p>\n<p><strong>辅助索引（二级索引）</strong>: <strong>叶子节点并不包含行记录的全部数据</strong></p>\n<p>​       非主键索引，叶子节点=键值+书签（行的索引值）</p>\n<p><strong>覆盖索引：</strong> <strong>（extra 提示using index）</strong></p>\n<p>​       InnoDB存储引擎支持覆盖索引，即从<strong>辅助索引中就可以得到查询的记录</strong>，而不需要查询聚集索引中的记录了（不需要回表操作）。</p>\n<p>​       覆盖索引并不适用于任意的索引类型，<strong>索引必须存储列的值</strong>，所以<font color=\"red\"><big><strong>不需要回表操作。</strong></big></font></p>\n<p>MySQL只能使用B-树.</p>\n<p><strong>联合索引：</strong></p>\n<p>​        联合索引也是一棵<strong>B+树，其键值数量大于等于2。键值都是排序的</strong>，通过叶子节点可以逻辑上顺序的读出所有数据。</p>\n<p><strong>单值索引：</strong> 一个索引只包含单个列</p>\n<p><strong>多值索引、复合索引</strong>（<strong>组合索引</strong>）: 即一个索包含多个列</p>\n<p><strong>复合索引</strong>只会对与创建索引时的排序顺序完全相同或相反的 order by语句进行优化</p>\n<p><strong>唯一索引</strong>: 索引唯一，但可以null， 声明unique关键字时,会为其字段自动添加唯一索引</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 单值索引 </span><br><span class=\"line\">#外部创建 </span><br><span class=\"line\">CREATE INDEX [indexname]ON t1(colname); </span><br><span class=\"line\"></span><br><span class=\"line\">#创建表的时候创建 </span><br><span class=\"line\">CREATE TABLE mytable(   ID INT NOT NULL,    username VARCHAR(16) NOT NULL,   INDEX [indexName] (username(length))   );  </span><br><span class=\"line\"></span><br><span class=\"line\">#alter语句添加 </span><br><span class=\"line\">ALTER table tableName ADD INDEX indexName(columnName)  </span><br><span class=\"line\"></span><br><span class=\"line\">// 复合索引 </span><br><span class=\"line\">CREATE INDEX idx_c1_c2_c3ON tablename(c1,c2,c3)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/35ED850E7CCF446C903DD2A0AED7AABE/18916\" alt=\"img\"></p>\n<h2 id=\"1-3-创建\"><a href=\"#1-3-创建\" class=\"headerlink\" title=\"1.3 创建\"></a><strong>1.3 创建</strong></h2><p><img src=\"https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/5FAAFB8FB8BD43CC8F2CD5853ED88350/18908\" alt=\"img\"></p>\n<h2 id=\"1-4-什么时候该创建索引？\"><a href=\"#1-4-什么时候该创建索引？\" class=\"headerlink\" title=\"1.4 什么时候该创建索引？\"></a><strong>1.4 什么时候该创建索引？</strong></h2><p><img src=\"https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/7C97A4A5F692496686ED1CB7890E0543/18901\" alt=\"img\"></p>\n<p><strong>不该创建？</strong></p>\n<p><img src=\"https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/ADE489407E394B16856C9B839E2416DE/18902\" alt=\"img\"></p>\n<p>对于最长使用的查询，可以针对性的建立索引来优化速度。</p>\n<p>join查询在有索引条件下</p>\n<p>　　驱动表有索引不会使用到索引</p>\n<p>　　被驱动表建立索引会使用到索引</p>\n<h1 id=\"二、性能分析和优化策略\"><a href=\"#二、性能分析和优化策略\" class=\"headerlink\" title=\"二、性能分析和优化策略\"></a><strong>二、性能分析和优化策略</strong></h1><p><img src=\"https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/20D9F3FA33FF41E2AB5EAB6EA9D24A25/18895\" alt=\"img\"></p>\n<p><img src=\"https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/7AC131346BED4F13AA046DA87FEFC40C/18894\" alt=\"img\"></p>\n<p><img src=\"https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/61AED2EF4E4D4DEB8D33DEBCBFD93175/18857\" alt=\"img\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、索引的概念\"><a href=\"#一、索引的概念\" class=\"headerlink\" title=\"一、索引的概念\"></a><strong>一、索引的概念</strong></h1><h2 id=\"1-1-索引的作用\"><a href=\"#1-1-索引的作用\" class=\"headerlink\" title=\"1.1 索引的作用\"></a>1.1 索引的作用</h2><h2 id=\"1-2-索引的分类（还不清楚到底怎么归类）\"><a href=\"#1-2-索引的分类（还不清楚到底怎么归类）\" class=\"headerlink\" title=\"1.2 索引的分类（还不清楚到底怎么归类）**\"></a>1.2 索引的分类（还不清楚到底怎么归类）**</h2><p><strong>查看有哪些索引：</strong>   <code>SHOW   index;</code></p>\n<p><strong>聚簇索引（主键索引)</strong>    <strong>每张表只能有一个</strong>，<strong>数据和索引在同一个文件</strong></p>\n<p>​        按照每张表的主键构造一颗B+树，同时叶子节点中存放的即为整张表的记录数据。</p>\n<p><strong>辅助索引（二级索引）</strong>: <strong>叶子节点并不包含行记录的全部数据</strong></p>\n<p>​       非主键索引，叶子节点=键值+书签（行的索引值）</p>\n<p><strong>覆盖索引：</strong> <strong>（extra 提示using index）</strong></p>\n<p>​       InnoDB存储引擎支持覆盖索引，即从<strong>辅助索引中就可以得到查询的记录</strong>，而不需要查询聚集索引中的记录了（不需要回表操作）。</p>\n<p>​       覆盖索引并不适用于任意的索引类型，<strong>索引必须存储列的值</strong>，所以<font color=\"red\"><big><strong>不需要回表操作。</strong></big></font></p>\n<p>MySQL只能使用B-树.</p>\n<p><strong>联合索引：</strong></p>\n<p>​        联合索引也是一棵<strong>B+树，其键值数量大于等于2。键值都是排序的</strong>，通过叶子节点可以逻辑上顺序的读出所有数据。</p>\n<p><strong>单值索引：</strong> 一个索引只包含单个列</p>\n<p><strong>多值索引、复合索引</strong>（<strong>组合索引</strong>）: 即一个索包含多个列</p>\n<p><strong>复合索引</strong>只会对与创建索引时的排序顺序完全相同或相反的 order by语句进行优化</p>\n<p><strong>唯一索引</strong>: 索引唯一，但可以null， 声明unique关键字时,会为其字段自动添加唯一索引</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 单值索引 </span><br><span class=\"line\">#外部创建 </span><br><span class=\"line\">CREATE INDEX [indexname]ON t1(colname); </span><br><span class=\"line\"></span><br><span class=\"line\">#创建表的时候创建 </span><br><span class=\"line\">CREATE TABLE mytable(   ID INT NOT NULL,    username VARCHAR(16) NOT NULL,   INDEX [indexName] (username(length))   );  </span><br><span class=\"line\"></span><br><span class=\"line\">#alter语句添加 </span><br><span class=\"line\">ALTER table tableName ADD INDEX indexName(columnName)  </span><br><span class=\"line\"></span><br><span class=\"line\">// 复合索引 </span><br><span class=\"line\">CREATE INDEX idx_c1_c2_c3ON tablename(c1,c2,c3)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/35ED850E7CCF446C903DD2A0AED7AABE/18916\" alt=\"img\"></p>\n<h2 id=\"1-3-创建\"><a href=\"#1-3-创建\" class=\"headerlink\" title=\"1.3 创建\"></a><strong>1.3 创建</strong></h2><p><img src=\"https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/5FAAFB8FB8BD43CC8F2CD5853ED88350/18908\" alt=\"img\"></p>\n<h2 id=\"1-4-什么时候该创建索引？\"><a href=\"#1-4-什么时候该创建索引？\" class=\"headerlink\" title=\"1.4 什么时候该创建索引？\"></a><strong>1.4 什么时候该创建索引？</strong></h2><p><img src=\"https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/7C97A4A5F692496686ED1CB7890E0543/18901\" alt=\"img\"></p>\n<p><strong>不该创建？</strong></p>\n<p><img src=\"https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/ADE489407E394B16856C9B839E2416DE/18902\" alt=\"img\"></p>\n<p>对于最长使用的查询，可以针对性的建立索引来优化速度。</p>\n<p>join查询在有索引条件下</p>\n<p>　　驱动表有索引不会使用到索引</p>\n<p>　　被驱动表建立索引会使用到索引</p>\n<h1 id=\"二、性能分析和优化策略\"><a href=\"#二、性能分析和优化策略\" class=\"headerlink\" title=\"二、性能分析和优化策略\"></a><strong>二、性能分析和优化策略</strong></h1><p><img src=\"https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/20D9F3FA33FF41E2AB5EAB6EA9D24A25/18895\" alt=\"img\"></p>\n<p><img src=\"https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/7AC131346BED4F13AA046DA87FEFC40C/18894\" alt=\"img\"></p>\n<p><img src=\"https://note.youdao.com/yws/public/resource/003c0cce526f2a71945614993d250377/xmlnote/61AED2EF4E4D4DEB8D33DEBCBFD93175/18857\" alt=\"img\"></p>\n"},{"title":"mysql-索引篇2-索引的底层实现","date":"2019-08-12T03:02:57.000Z","_content":"\n\n\n# 一、常用的索引底层结构有哪些？\n\n==**索引是一种排序的，便于查找的数据结构。**==\n\n下面是一些常见数据结构的概念，具体每种类型的详细特点，再去看别的文档吧。\n\n## **1. 二叉查找树：**\n\n​        左子树的键值小于根的键值，右子树的键值大于根的键值。\n\n## **2. AVL 树：**\n\n​       平衡二叉树（AVL 树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为 1。\n\n## **3. 红黑树：**\n\n​      每个节点都带有颜色属性的二叉查找树。\n\n## **4. 平衡多路查找树（M阶的 B树）：**\n\n## **为磁盘等外存储设备设计的一种平衡查找树。**\n\n- 每个节点最多有**m-1个关键字**（可以存有的键值对）。\n- 根节点最少可以只有1个**关键字**。\n- 非根节点至少有m/2个**关键字**。\n- 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。\n- 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。\n- ==**每个节点都存有索引和数据，也就是对应的key和value。**==\n- ==**数据库中的节点 value 其实是指针。。**==\n\n\n\n## **5. B+树：**\n\nB+树其实和B树是非常相似的，我们首先看看**相同点**。\n\n- 根节点至少一个元素\n- 非根节点元素范围：m/2 <= k <= m-1\n\n**不同点**：\n\n- B+树有两种类型的节点：==**内部节点不存储数据，只存储索引，数据都存储在叶子节点。**==\n- 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。**叶子结点中的记录也按照key的大小排列**。\n- 每个叶子结点都存有相邻叶子结点的指针，**叶子结点本身依关键字的大小自小而大顺序链接。**\n- **父节点存有右孩子的第一个元素的索引**。\n\n![img](https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/35C585A0A1CA45A48325427D3856F495/25313)\n\n\n\n# 二、Mysql 的两种存储引擎的索引\n\n文档主要介绍 MyISAM 和 InnoDB 两个存储引擎的索引实现方式。 两者均使用的B+ 树实现的索引。\n\n## **2.1 InnoDB索引实现**\n\n### **1）主键索引（聚簇索引，B+树）：**\n\n   **主键默认采用聚簇索引**（聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致），且一张表只允许存在一个聚簇索引。\n\n​\t\t==**聚簇索引的叶子节点就是数据节点（存放完整的行数据）**==\n\n​\t\t==**非聚簇索引**的叶子节点保存**非完整行的数据**（只有对应的键值数据） + **书签**（主键的聚集索引的索引值）==\n\n​\t\t叶子节点是**数据页(默认16K)**。==每个数据页上存放的是完整的行记录。B+ 树将 叶子页加载到内存后，再去查找对应数据行。==\n\n​\t\t非叶子节点、存放的仅仅是键值及指向数据页的偏移量\n\n**聚集索引的好处：**\n\n- 对于**主键的排序查找非常的快**（因为其叶子节点是用双向链表链接的）\n- 对于**主键的范围查找非常的快**（因为通过叶子节点的上层中间节点，就可以得到叶结点的范围值）\n\n   **在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构**，**这棵树的叶节点data域保存了完整的数据记录。索引的key是数据表的主键（primary key），因此InnoDB表数据文件本身就是主索引。\n\n![img](https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/0C52AD61056947BFB3ADB363A745E21E/25366)\n\n**InnoDB存储引擎的最小存储单元是页(16K)**，页可以用于存放数据也可以用于存放键值+指针, **在InnoDB中B+树高度一般为1-3层**，**它就能满足千万级的数据存储**。在查找数据时一次页的查找代表一次IO，所以通过**主键索引查询通常只需要1-3次IO操作即可查找到数据**。\n\n**因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有）**，如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。\n\n \n\n### **2）InnoDB的辅助索引（非聚簇索引，B+树/ B树）**\n\n**B+树：**\n\n**非聚簇索引**的叶子节点保存**非完整行的数据**（只有对应的键值数据） + **书签**（主键的聚集索引的索引值）\n\n**二级索引使用非聚簇索引。**\n\n**通过二级索引查询首先，查到是主键值和对应的数据字段，如果查询的字段更多，InnoDB再根据查到的主键值通过主键索引找到相应的数据块。**（ 这个流程叫 **回表**）\n\n**B树：覆盖索引用到的。**\n\nInnoDB 表是基于**聚簇索引**建立的。因此InnoDB 的索引能提供一种非常快速的主键查找性能。它的辅助索引（Secondary Index， 也就是非主键索引）也会包含主键列，所以，如果主键定义的比较大，其他索引也将很大。如果想在表上定义 、很多索引，则**争取尽量把主键定义得小一些**。InnoDB 不会压缩索引。\n\n   文字符的ASCII码作为比较准则。**聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录**。\n\n![img](https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/FD856A9A723440D296A95C46A86E1431/25390)\n\n**1、为什么不建议使用过长的字段作为主键？**\n\n**因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。**\n\n**2、用非单调的字段作为主键在InnoDB中不是个好主意？**\n\n**因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效。**\n\n## **2.2  MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。**\n\nMyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。\n\n### **1）主键索引（非聚簇索引，B+树）：**\n\nMyISAM引擎使用B+Tree作为索引结构，**叶节点的data域存放的是数据记录的地址**。下图是MyISAM主键索引的原理图：\n\n![img](https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/B431C4572E464F8B9E410C3F74685439/25416)\n\n### **2）辅助索引（Secondary key）**\n\n**在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求** **key是唯一**，而辅助索引的key可以重复。\n\n同样也是一颗B+Tree，data域保存数据记录的地址。因此，**MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。**\n\nMyISAM的索引方式也叫做“**非聚簇**”的，之所以这么称呼是为了与InnoDB的聚簇索引区分。\n\n\n\n# 三、为什么说B+树比B树更适合数据库索引？\n\n**1、 B+树的磁盘读写代价更低**：B+树的内部节点并没有指向关键字具体信息的指针，因此**其内部节点相对B树更小**，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，**一次性读入内存的需要查找的关键字也就越多**，相对IO读写次数就降低了。**（B 树 非叶子节点中还包含了数据指针，所以占空间大）**\n\n**2、B+树的查询效率更加稳定（数据都存在叶子节点，路径都是从根到叶子的路径，一般3次以下的IO读取，等于树的高度）**\n\nB树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少），指针少的情况下要保存大量数据，**只能增加树的高度，导致IO操作变多**，查询性能变低；\n\n**3、由于B+树的数据都存储在叶子结点中，非叶子点均为索引，****方便全盘扫描和范围查找。**\n\n但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，**需要进行一次中序遍历按序来扫**，所以**B+树更加适合在区间查询的情况**，所以通常B+树用于数据库索引。\n\n\n\n\n","source":"_posts/mysql-索引篇2-索引的底层实现.md","raw":"---\ntitle: mysql-索引篇2-索引的底层实现\ndate: 2019-08-12 11:02:57\ncategories: mysql\ntags: 数据库索引\n---\n\n\n\n# 一、常用的索引底层结构有哪些？\n\n==**索引是一种排序的，便于查找的数据结构。**==\n\n下面是一些常见数据结构的概念，具体每种类型的详细特点，再去看别的文档吧。\n\n## **1. 二叉查找树：**\n\n​        左子树的键值小于根的键值，右子树的键值大于根的键值。\n\n## **2. AVL 树：**\n\n​       平衡二叉树（AVL 树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为 1。\n\n## **3. 红黑树：**\n\n​      每个节点都带有颜色属性的二叉查找树。\n\n## **4. 平衡多路查找树（M阶的 B树）：**\n\n## **为磁盘等外存储设备设计的一种平衡查找树。**\n\n- 每个节点最多有**m-1个关键字**（可以存有的键值对）。\n- 根节点最少可以只有1个**关键字**。\n- 非根节点至少有m/2个**关键字**。\n- 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。\n- 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。\n- ==**每个节点都存有索引和数据，也就是对应的key和value。**==\n- ==**数据库中的节点 value 其实是指针。。**==\n\n\n\n## **5. B+树：**\n\nB+树其实和B树是非常相似的，我们首先看看**相同点**。\n\n- 根节点至少一个元素\n- 非根节点元素范围：m/2 <= k <= m-1\n\n**不同点**：\n\n- B+树有两种类型的节点：==**内部节点不存储数据，只存储索引，数据都存储在叶子节点。**==\n- 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。**叶子结点中的记录也按照key的大小排列**。\n- 每个叶子结点都存有相邻叶子结点的指针，**叶子结点本身依关键字的大小自小而大顺序链接。**\n- **父节点存有右孩子的第一个元素的索引**。\n\n![img](https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/35C585A0A1CA45A48325427D3856F495/25313)\n\n\n\n# 二、Mysql 的两种存储引擎的索引\n\n文档主要介绍 MyISAM 和 InnoDB 两个存储引擎的索引实现方式。 两者均使用的B+ 树实现的索引。\n\n## **2.1 InnoDB索引实现**\n\n### **1）主键索引（聚簇索引，B+树）：**\n\n   **主键默认采用聚簇索引**（聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致），且一张表只允许存在一个聚簇索引。\n\n​\t\t==**聚簇索引的叶子节点就是数据节点（存放完整的行数据）**==\n\n​\t\t==**非聚簇索引**的叶子节点保存**非完整行的数据**（只有对应的键值数据） + **书签**（主键的聚集索引的索引值）==\n\n​\t\t叶子节点是**数据页(默认16K)**。==每个数据页上存放的是完整的行记录。B+ 树将 叶子页加载到内存后，再去查找对应数据行。==\n\n​\t\t非叶子节点、存放的仅仅是键值及指向数据页的偏移量\n\n**聚集索引的好处：**\n\n- 对于**主键的排序查找非常的快**（因为其叶子节点是用双向链表链接的）\n- 对于**主键的范围查找非常的快**（因为通过叶子节点的上层中间节点，就可以得到叶结点的范围值）\n\n   **在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构**，**这棵树的叶节点data域保存了完整的数据记录。索引的key是数据表的主键（primary key），因此InnoDB表数据文件本身就是主索引。\n\n![img](https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/0C52AD61056947BFB3ADB363A745E21E/25366)\n\n**InnoDB存储引擎的最小存储单元是页(16K)**，页可以用于存放数据也可以用于存放键值+指针, **在InnoDB中B+树高度一般为1-3层**，**它就能满足千万级的数据存储**。在查找数据时一次页的查找代表一次IO，所以通过**主键索引查询通常只需要1-3次IO操作即可查找到数据**。\n\n**因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有）**，如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。\n\n \n\n### **2）InnoDB的辅助索引（非聚簇索引，B+树/ B树）**\n\n**B+树：**\n\n**非聚簇索引**的叶子节点保存**非完整行的数据**（只有对应的键值数据） + **书签**（主键的聚集索引的索引值）\n\n**二级索引使用非聚簇索引。**\n\n**通过二级索引查询首先，查到是主键值和对应的数据字段，如果查询的字段更多，InnoDB再根据查到的主键值通过主键索引找到相应的数据块。**（ 这个流程叫 **回表**）\n\n**B树：覆盖索引用到的。**\n\nInnoDB 表是基于**聚簇索引**建立的。因此InnoDB 的索引能提供一种非常快速的主键查找性能。它的辅助索引（Secondary Index， 也就是非主键索引）也会包含主键列，所以，如果主键定义的比较大，其他索引也将很大。如果想在表上定义 、很多索引，则**争取尽量把主键定义得小一些**。InnoDB 不会压缩索引。\n\n   文字符的ASCII码作为比较准则。**聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录**。\n\n![img](https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/FD856A9A723440D296A95C46A86E1431/25390)\n\n**1、为什么不建议使用过长的字段作为主键？**\n\n**因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。**\n\n**2、用非单调的字段作为主键在InnoDB中不是个好主意？**\n\n**因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效。**\n\n## **2.2  MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。**\n\nMyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。\n\n### **1）主键索引（非聚簇索引，B+树）：**\n\nMyISAM引擎使用B+Tree作为索引结构，**叶节点的data域存放的是数据记录的地址**。下图是MyISAM主键索引的原理图：\n\n![img](https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/B431C4572E464F8B9E410C3F74685439/25416)\n\n### **2）辅助索引（Secondary key）**\n\n**在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求** **key是唯一**，而辅助索引的key可以重复。\n\n同样也是一颗B+Tree，data域保存数据记录的地址。因此，**MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。**\n\nMyISAM的索引方式也叫做“**非聚簇**”的，之所以这么称呼是为了与InnoDB的聚簇索引区分。\n\n\n\n# 三、为什么说B+树比B树更适合数据库索引？\n\n**1、 B+树的磁盘读写代价更低**：B+树的内部节点并没有指向关键字具体信息的指针，因此**其内部节点相对B树更小**，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，**一次性读入内存的需要查找的关键字也就越多**，相对IO读写次数就降低了。**（B 树 非叶子节点中还包含了数据指针，所以占空间大）**\n\n**2、B+树的查询效率更加稳定（数据都存在叶子节点，路径都是从根到叶子的路径，一般3次以下的IO读取，等于树的高度）**\n\nB树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少），指针少的情况下要保存大量数据，**只能增加树的高度，导致IO操作变多**，查询性能变低；\n\n**3、由于B+树的数据都存储在叶子结点中，非叶子点均为索引，****方便全盘扫描和范围查找。**\n\n但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，**需要进行一次中序遍历按序来扫**，所以**B+树更加适合在区间查询的情况**，所以通常B+树用于数据库索引。\n\n\n\n\n","slug":"mysql-索引篇2-索引的底层实现","published":1,"updated":"2020-04-11T03:09:33.206Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephdx0010t8plxhl82k1d","content":"<h1 id=\"一、常用的索引底层结构有哪些？\"><a href=\"#一、常用的索引底层结构有哪些？\" class=\"headerlink\" title=\"一、常用的索引底层结构有哪些？\"></a>一、常用的索引底层结构有哪些？</h1><p>==<strong>索引是一种排序的，便于查找的数据结构。</strong>==</p>\n<p>下面是一些常见数据结构的概念，具体每种类型的详细特点，再去看别的文档吧。</p>\n<h2 id=\"1-二叉查找树：\"><a href=\"#1-二叉查找树：\" class=\"headerlink\" title=\"1. 二叉查找树：\"></a><strong>1. 二叉查找树：</strong></h2><p>​        左子树的键值小于根的键值，右子树的键值大于根的键值。</p>\n<h2 id=\"2-AVL-树：\"><a href=\"#2-AVL-树：\" class=\"headerlink\" title=\"2. AVL 树：\"></a><strong>2. AVL 树：</strong></h2><p>​       平衡二叉树（AVL 树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为 1。</p>\n<h2 id=\"3-红黑树：\"><a href=\"#3-红黑树：\" class=\"headerlink\" title=\"3. 红黑树：\"></a><strong>3. 红黑树：</strong></h2><p>​      每个节点都带有颜色属性的二叉查找树。</p>\n<h2 id=\"4-平衡多路查找树（M阶的-B树）：\"><a href=\"#4-平衡多路查找树（M阶的-B树）：\" class=\"headerlink\" title=\"4. 平衡多路查找树（M阶的 B树）：\"></a><strong>4. 平衡多路查找树（M阶的 B树）：</strong></h2><h2 id=\"为磁盘等外存储设备设计的一种平衡查找树。\"><a href=\"#为磁盘等外存储设备设计的一种平衡查找树。\" class=\"headerlink\" title=\"为磁盘等外存储设备设计的一种平衡查找树。\"></a><strong>为磁盘等外存储设备设计的一种平衡查找树。</strong></h2><ul>\n<li>每个节点最多有<strong>m-1个关键字</strong>（可以存有的键值对）。</li>\n<li>根节点最少可以只有1个<strong>关键字</strong>。</li>\n<li>非根节点至少有m/2个<strong>关键字</strong>。</li>\n<li>每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li>\n<li>所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。</li>\n<li>==<strong>每个节点都存有索引和数据，也就是对应的key和value。</strong>==</li>\n<li>==<strong>数据库中的节点 value 其实是指针。。</strong>==</li>\n</ul>\n<h2 id=\"5-B-树：\"><a href=\"#5-B-树：\" class=\"headerlink\" title=\"5. B+树：\"></a><strong>5. B+树：</strong></h2><p>B+树其实和B树是非常相似的，我们首先看看<strong>相同点</strong>。</p>\n<ul>\n<li>根节点至少一个元素</li>\n<li>非根节点元素范围：m/2 &lt;= k &lt;= m-1</li>\n</ul>\n<p><strong>不同点</strong>：</p>\n<ul>\n<li>B+树有两种类型的节点：==<strong>内部节点不存储数据，只存储索引，数据都存储在叶子节点。</strong>==</li>\n<li>内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。<strong>叶子结点中的记录也按照key的大小排列</strong>。</li>\n<li>每个叶子结点都存有相邻叶子结点的指针，<strong>叶子结点本身依关键字的大小自小而大顺序链接。</strong></li>\n<li><strong>父节点存有右孩子的第一个元素的索引</strong>。</li>\n</ul>\n<p><img src=\"https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/35C585A0A1CA45A48325427D3856F495/25313\" alt=\"img\"></p>\n<h1 id=\"二、Mysql-的两种存储引擎的索引\"><a href=\"#二、Mysql-的两种存储引擎的索引\" class=\"headerlink\" title=\"二、Mysql 的两种存储引擎的索引\"></a>二、Mysql 的两种存储引擎的索引</h1><p>文档主要介绍 MyISAM 和 InnoDB 两个存储引擎的索引实现方式。 两者均使用的B+ 树实现的索引。</p>\n<h2 id=\"2-1-InnoDB索引实现\"><a href=\"#2-1-InnoDB索引实现\" class=\"headerlink\" title=\"2.1 InnoDB索引实现\"></a><strong>2.1 InnoDB索引实现</strong></h2><h3 id=\"1）主键索引（聚簇索引，B-树）：\"><a href=\"#1）主键索引（聚簇索引，B-树）：\" class=\"headerlink\" title=\"1）主键索引（聚簇索引，B+树）：\"></a><strong>1）主键索引（聚簇索引，B+树）：</strong></h3><p>   <strong>主键默认采用聚簇索引</strong>（聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致），且一张表只允许存在一个聚簇索引。</p>\n<p>​        ==<strong>聚簇索引的叶子节点就是数据节点（存放完整的行数据）</strong>==</p>\n<p>​        ==<strong>非聚簇索引</strong>的叶子节点保存<strong>非完整行的数据</strong>（只有对应的键值数据） + <strong>书签</strong>（主键的聚集索引的索引值）==</p>\n<p>​        叶子节点是<strong>数据页(默认16K)</strong>。==每个数据页上存放的是完整的行记录。B+ 树将 叶子页加载到内存后，再去查找对应数据行。==</p>\n<p>​        非叶子节点、存放的仅仅是键值及指向数据页的偏移量</p>\n<p><strong>聚集索引的好处：</strong></p>\n<ul>\n<li>对于<strong>主键的排序查找非常的快</strong>（因为其叶子节点是用双向链表链接的）</li>\n<li><p>对于<strong>主键的范围查找非常的快</strong>（因为通过叶子节点的上层中间节点，就可以得到叶结点的范围值）</p>\n<p> <strong>在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构</strong>，**这棵树的叶节点data域保存了完整的数据记录。索引的key是数据表的主键（primary key），因此InnoDB表数据文件本身就是主索引。</p>\n</li>\n</ul>\n<p><img src=\"https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/0C52AD61056947BFB3ADB363A745E21E/25366\" alt=\"img\"></p>\n<p><strong>InnoDB存储引擎的最小存储单元是页(16K)</strong>，页可以用于存放数据也可以用于存放键值+指针, <strong>在InnoDB中B+树高度一般为1-3层</strong>，<strong>它就能满足千万级的数据存储</strong>。在查找数据时一次页的查找代表一次IO，所以通过<strong>主键索引查询通常只需要1-3次IO操作即可查找到数据</strong>。</p>\n<p><strong>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有）</strong>，如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>\n<h3 id=\"2）InnoDB的辅助索引（非聚簇索引，B-树-B树）\"><a href=\"#2）InnoDB的辅助索引（非聚簇索引，B-树-B树）\" class=\"headerlink\" title=\"2）InnoDB的辅助索引（非聚簇索引，B+树/ B树）\"></a><strong>2）InnoDB的辅助索引（非聚簇索引，B+树/ B树）</strong></h3><p><strong>B+树：</strong></p>\n<p><strong>非聚簇索引</strong>的叶子节点保存<strong>非完整行的数据</strong>（只有对应的键值数据） + <strong>书签</strong>（主键的聚集索引的索引值）</p>\n<p><strong>二级索引使用非聚簇索引。</strong></p>\n<p><strong>通过二级索引查询首先，查到是主键值和对应的数据字段，如果查询的字段更多，InnoDB再根据查到的主键值通过主键索引找到相应的数据块。</strong>（ 这个流程叫 <strong>回表</strong>）</p>\n<p><strong>B树：覆盖索引用到的。</strong></p>\n<p>InnoDB 表是基于<strong>聚簇索引</strong>建立的。因此InnoDB 的索引能提供一种非常快速的主键查找性能。它的辅助索引（Secondary Index， 也就是非主键索引）也会包含主键列，所以，如果主键定义的比较大，其他索引也将很大。如果想在表上定义 、很多索引，则<strong>争取尽量把主键定义得小一些</strong>。InnoDB 不会压缩索引。</p>\n<p>   文字符的ASCII码作为比较准则。<strong>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录</strong>。</p>\n<p><img src=\"https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/FD856A9A723440D296A95C46A86E1431/25390\" alt=\"img\"></p>\n<p><strong>1、为什么不建议使用过长的字段作为主键？</strong></p>\n<p><strong>因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。</strong></p>\n<p><strong>2、用非单调的字段作为主键在InnoDB中不是个好主意？</strong></p>\n<p><strong>因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效。</strong></p>\n<h2 id=\"2-2-MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。\"><a href=\"#2-2-MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。\" class=\"headerlink\" title=\"2.2  MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。\"></a><strong>2.2  MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</strong></h2><p>MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</p>\n<h3 id=\"1）主键索引（非聚簇索引，B-树）：\"><a href=\"#1）主键索引（非聚簇索引，B-树）：\" class=\"headerlink\" title=\"1）主键索引（非聚簇索引，B+树）：\"></a><strong>1）主键索引（非聚簇索引，B+树）：</strong></h3><p>MyISAM引擎使用B+Tree作为索引结构，<strong>叶节点的data域存放的是数据记录的地址</strong>。下图是MyISAM主键索引的原理图：</p>\n<p><img src=\"https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/B431C4572E464F8B9E410C3F74685439/25416\" alt=\"img\"></p>\n<h3 id=\"2）辅助索引（Secondary-key）\"><a href=\"#2）辅助索引（Secondary-key）\" class=\"headerlink\" title=\"2）辅助索引（Secondary key）\"></a><strong>2）辅助索引（Secondary key）</strong></h3><p><strong>在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求</strong> <strong>key是唯一</strong>，而辅助索引的key可以重复。</p>\n<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，<strong>MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</strong></p>\n<p>MyISAM的索引方式也叫做“<strong>非聚簇</strong>”的，之所以这么称呼是为了与InnoDB的聚簇索引区分。</p>\n<h1 id=\"三、为什么说B-树比B树更适合数据库索引？\"><a href=\"#三、为什么说B-树比B树更适合数据库索引？\" class=\"headerlink\" title=\"三、为什么说B+树比B树更适合数据库索引？\"></a>三、为什么说B+树比B树更适合数据库索引？</h1><p><strong>1、 B+树的磁盘读写代价更低</strong>：B+树的内部节点并没有指向关键字具体信息的指针，因此<strong>其内部节点相对B树更小</strong>，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，<strong>一次性读入内存的需要查找的关键字也就越多</strong>，相对IO读写次数就降低了。<strong>（B 树 非叶子节点中还包含了数据指针，所以占空间大）</strong></p>\n<p><strong>2、B+树的查询效率更加稳定（数据都存在叶子节点，路径都是从根到叶子的路径，一般3次以下的IO读取，等于树的高度）</strong></p>\n<p>B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少），指针少的情况下要保存大量数据，<strong>只能增加树的高度，导致IO操作变多</strong>，查询性能变低；</p>\n<p><strong>3、由于B+树的数据都存储在叶子结点中，非叶子点均为索引，**</strong>方便全盘扫描和范围查找。**</p>\n<p>但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，<strong>需要进行一次中序遍历按序来扫</strong>，所以<strong>B+树更加适合在区间查询的情况</strong>，所以通常B+树用于数据库索引。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、常用的索引底层结构有哪些？\"><a href=\"#一、常用的索引底层结构有哪些？\" class=\"headerlink\" title=\"一、常用的索引底层结构有哪些？\"></a>一、常用的索引底层结构有哪些？</h1><p>==<strong>索引是一种排序的，便于查找的数据结构。</strong>==</p>\n<p>下面是一些常见数据结构的概念，具体每种类型的详细特点，再去看别的文档吧。</p>\n<h2 id=\"1-二叉查找树：\"><a href=\"#1-二叉查找树：\" class=\"headerlink\" title=\"1. 二叉查找树：\"></a><strong>1. 二叉查找树：</strong></h2><p>​        左子树的键值小于根的键值，右子树的键值大于根的键值。</p>\n<h2 id=\"2-AVL-树：\"><a href=\"#2-AVL-树：\" class=\"headerlink\" title=\"2. AVL 树：\"></a><strong>2. AVL 树：</strong></h2><p>​       平衡二叉树（AVL 树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为 1。</p>\n<h2 id=\"3-红黑树：\"><a href=\"#3-红黑树：\" class=\"headerlink\" title=\"3. 红黑树：\"></a><strong>3. 红黑树：</strong></h2><p>​      每个节点都带有颜色属性的二叉查找树。</p>\n<h2 id=\"4-平衡多路查找树（M阶的-B树）：\"><a href=\"#4-平衡多路查找树（M阶的-B树）：\" class=\"headerlink\" title=\"4. 平衡多路查找树（M阶的 B树）：\"></a><strong>4. 平衡多路查找树（M阶的 B树）：</strong></h2><h2 id=\"为磁盘等外存储设备设计的一种平衡查找树。\"><a href=\"#为磁盘等外存储设备设计的一种平衡查找树。\" class=\"headerlink\" title=\"为磁盘等外存储设备设计的一种平衡查找树。\"></a><strong>为磁盘等外存储设备设计的一种平衡查找树。</strong></h2><ul>\n<li>每个节点最多有<strong>m-1个关键字</strong>（可以存有的键值对）。</li>\n<li>根节点最少可以只有1个<strong>关键字</strong>。</li>\n<li>非根节点至少有m/2个<strong>关键字</strong>。</li>\n<li>每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li>\n<li>所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。</li>\n<li>==<strong>每个节点都存有索引和数据，也就是对应的key和value。</strong>==</li>\n<li>==<strong>数据库中的节点 value 其实是指针。。</strong>==</li>\n</ul>\n<h2 id=\"5-B-树：\"><a href=\"#5-B-树：\" class=\"headerlink\" title=\"5. B+树：\"></a><strong>5. B+树：</strong></h2><p>B+树其实和B树是非常相似的，我们首先看看<strong>相同点</strong>。</p>\n<ul>\n<li>根节点至少一个元素</li>\n<li>非根节点元素范围：m/2 &lt;= k &lt;= m-1</li>\n</ul>\n<p><strong>不同点</strong>：</p>\n<ul>\n<li>B+树有两种类型的节点：==<strong>内部节点不存储数据，只存储索引，数据都存储在叶子节点。</strong>==</li>\n<li>内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。<strong>叶子结点中的记录也按照key的大小排列</strong>。</li>\n<li>每个叶子结点都存有相邻叶子结点的指针，<strong>叶子结点本身依关键字的大小自小而大顺序链接。</strong></li>\n<li><strong>父节点存有右孩子的第一个元素的索引</strong>。</li>\n</ul>\n<p><img src=\"https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/35C585A0A1CA45A48325427D3856F495/25313\" alt=\"img\"></p>\n<h1 id=\"二、Mysql-的两种存储引擎的索引\"><a href=\"#二、Mysql-的两种存储引擎的索引\" class=\"headerlink\" title=\"二、Mysql 的两种存储引擎的索引\"></a>二、Mysql 的两种存储引擎的索引</h1><p>文档主要介绍 MyISAM 和 InnoDB 两个存储引擎的索引实现方式。 两者均使用的B+ 树实现的索引。</p>\n<h2 id=\"2-1-InnoDB索引实现\"><a href=\"#2-1-InnoDB索引实现\" class=\"headerlink\" title=\"2.1 InnoDB索引实现\"></a><strong>2.1 InnoDB索引实现</strong></h2><h3 id=\"1）主键索引（聚簇索引，B-树）：\"><a href=\"#1）主键索引（聚簇索引，B-树）：\" class=\"headerlink\" title=\"1）主键索引（聚簇索引，B+树）：\"></a><strong>1）主键索引（聚簇索引，B+树）：</strong></h3><p>   <strong>主键默认采用聚簇索引</strong>（聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致），且一张表只允许存在一个聚簇索引。</p>\n<p>​        ==<strong>聚簇索引的叶子节点就是数据节点（存放完整的行数据）</strong>==</p>\n<p>​        ==<strong>非聚簇索引</strong>的叶子节点保存<strong>非完整行的数据</strong>（只有对应的键值数据） + <strong>书签</strong>（主键的聚集索引的索引值）==</p>\n<p>​        叶子节点是<strong>数据页(默认16K)</strong>。==每个数据页上存放的是完整的行记录。B+ 树将 叶子页加载到内存后，再去查找对应数据行。==</p>\n<p>​        非叶子节点、存放的仅仅是键值及指向数据页的偏移量</p>\n<p><strong>聚集索引的好处：</strong></p>\n<ul>\n<li>对于<strong>主键的排序查找非常的快</strong>（因为其叶子节点是用双向链表链接的）</li>\n<li><p>对于<strong>主键的范围查找非常的快</strong>（因为通过叶子节点的上层中间节点，就可以得到叶结点的范围值）</p>\n<p> <strong>在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构</strong>，**这棵树的叶节点data域保存了完整的数据记录。索引的key是数据表的主键（primary key），因此InnoDB表数据文件本身就是主索引。</p>\n</li>\n</ul>\n<p><img src=\"https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/0C52AD61056947BFB3ADB363A745E21E/25366\" alt=\"img\"></p>\n<p><strong>InnoDB存储引擎的最小存储单元是页(16K)</strong>，页可以用于存放数据也可以用于存放键值+指针, <strong>在InnoDB中B+树高度一般为1-3层</strong>，<strong>它就能满足千万级的数据存储</strong>。在查找数据时一次页的查找代表一次IO，所以通过<strong>主键索引查询通常只需要1-3次IO操作即可查找到数据</strong>。</p>\n<p><strong>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有）</strong>，如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>\n<h3 id=\"2）InnoDB的辅助索引（非聚簇索引，B-树-B树）\"><a href=\"#2）InnoDB的辅助索引（非聚簇索引，B-树-B树）\" class=\"headerlink\" title=\"2）InnoDB的辅助索引（非聚簇索引，B+树/ B树）\"></a><strong>2）InnoDB的辅助索引（非聚簇索引，B+树/ B树）</strong></h3><p><strong>B+树：</strong></p>\n<p><strong>非聚簇索引</strong>的叶子节点保存<strong>非完整行的数据</strong>（只有对应的键值数据） + <strong>书签</strong>（主键的聚集索引的索引值）</p>\n<p><strong>二级索引使用非聚簇索引。</strong></p>\n<p><strong>通过二级索引查询首先，查到是主键值和对应的数据字段，如果查询的字段更多，InnoDB再根据查到的主键值通过主键索引找到相应的数据块。</strong>（ 这个流程叫 <strong>回表</strong>）</p>\n<p><strong>B树：覆盖索引用到的。</strong></p>\n<p>InnoDB 表是基于<strong>聚簇索引</strong>建立的。因此InnoDB 的索引能提供一种非常快速的主键查找性能。它的辅助索引（Secondary Index， 也就是非主键索引）也会包含主键列，所以，如果主键定义的比较大，其他索引也将很大。如果想在表上定义 、很多索引，则<strong>争取尽量把主键定义得小一些</strong>。InnoDB 不会压缩索引。</p>\n<p>   文字符的ASCII码作为比较准则。<strong>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录</strong>。</p>\n<p><img src=\"https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/FD856A9A723440D296A95C46A86E1431/25390\" alt=\"img\"></p>\n<p><strong>1、为什么不建议使用过长的字段作为主键？</strong></p>\n<p><strong>因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。</strong></p>\n<p><strong>2、用非单调的字段作为主键在InnoDB中不是个好主意？</strong></p>\n<p><strong>因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效。</strong></p>\n<h2 id=\"2-2-MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。\"><a href=\"#2-2-MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。\" class=\"headerlink\" title=\"2.2  MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。\"></a><strong>2.2  MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</strong></h2><p>MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</p>\n<h3 id=\"1）主键索引（非聚簇索引，B-树）：\"><a href=\"#1）主键索引（非聚簇索引，B-树）：\" class=\"headerlink\" title=\"1）主键索引（非聚簇索引，B+树）：\"></a><strong>1）主键索引（非聚簇索引，B+树）：</strong></h3><p>MyISAM引擎使用B+Tree作为索引结构，<strong>叶节点的data域存放的是数据记录的地址</strong>。下图是MyISAM主键索引的原理图：</p>\n<p><img src=\"https://note.youdao.com/yws/public/resource/a527e1fa83cc6b429814c2f8710b891c/xmlnote/B431C4572E464F8B9E410C3F74685439/25416\" alt=\"img\"></p>\n<h3 id=\"2）辅助索引（Secondary-key）\"><a href=\"#2）辅助索引（Secondary-key）\" class=\"headerlink\" title=\"2）辅助索引（Secondary key）\"></a><strong>2）辅助索引（Secondary key）</strong></h3><p><strong>在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求</strong> <strong>key是唯一</strong>，而辅助索引的key可以重复。</p>\n<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，<strong>MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</strong></p>\n<p>MyISAM的索引方式也叫做“<strong>非聚簇</strong>”的，之所以这么称呼是为了与InnoDB的聚簇索引区分。</p>\n<h1 id=\"三、为什么说B-树比B树更适合数据库索引？\"><a href=\"#三、为什么说B-树比B树更适合数据库索引？\" class=\"headerlink\" title=\"三、为什么说B+树比B树更适合数据库索引？\"></a>三、为什么说B+树比B树更适合数据库索引？</h1><p><strong>1、 B+树的磁盘读写代价更低</strong>：B+树的内部节点并没有指向关键字具体信息的指针，因此<strong>其内部节点相对B树更小</strong>，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，<strong>一次性读入内存的需要查找的关键字也就越多</strong>，相对IO读写次数就降低了。<strong>（B 树 非叶子节点中还包含了数据指针，所以占空间大）</strong></p>\n<p><strong>2、B+树的查询效率更加稳定（数据都存在叶子节点，路径都是从根到叶子的路径，一般3次以下的IO读取，等于树的高度）</strong></p>\n<p>B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少），指针少的情况下要保存大量数据，<strong>只能增加树的高度，导致IO操作变多</strong>，查询性能变低；</p>\n<p><strong>3、由于B+树的数据都存储在叶子结点中，非叶子点均为索引，**</strong>方便全盘扫描和范围查找。**</p>\n<p>但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，<strong>需要进行一次中序遍历按序来扫</strong>，所以<strong>B+树更加适合在区间查询的情况</strong>，所以通常B+树用于数据库索引。</p>\n"},{"title":"pandas -1数据结构","mathjax":true,"date":"2019-07-22T01:01:01.000Z","_content":"\n# pandas -1 数据结构\n> pandas 基本操作都很简单，只是在刚开始学习的过程中，容易忘掉一些API，导致完成一些操作时，总会想着翻翻手册，这一系列博客，是对这些方法进行了梳理，可作为入门学习的参考材料。平时经常翻阅。\n\n“index” (axis=0, default), “columns” (axis=1)\n## 1. Series\n\n> Series 是一个带有 名称 和索引的一维数组。\n\n### 创建seriex\n\n```\n\n// Series 数组生成，指定数据类型\nIn:   \n    user_age = pd.Series(data=[18, 30, 25, 40], dtype=float)\n    \nOut:\n        0    18\n        1    30\n        2    25\n        3    40\n        dtype: int64\n\n\n// 增加索引 index\nIn:   \n    user_age.index = [\"Tom\", \"Bob\", \"Mary\", \"James\"]\n    \nOut:\n    Tom      18\n    Bob      30\n    Mary     25\n    James    40\n    dtype: int64\n    \n// 表头\nIn:\n    user_age.index.name(\"name\")\n    \nOut:\n    name\n    Tom      18\n    Bob      30\n    Mary     25\n    James    40\n    dtype: int64\n    \n\n```\n\n### 像字典一样使用series\n\n```\n// index 当键值\nIn: \n    user_age[\"Tom\"]\n    user_age.get(\"Tom\")\n\n// 切片-列\nIn:\n    user_age[2:3]\n    \n// 按条件查找\nIn:\n    user_age[user_age > 30]\n    \nOut:\n    name\n    James    40.0\n    Name: user_age_info, dtype: float64\n    \n```\n\n### 像向量一样使用series\n\n> 可以传递给np方法\n\n```\n// 整列加减\nIn:\n    user_age + 1\n    \nOut:\n    name\n    Tom      19.0\n    Bob      31.0\n    Mary     26.0\n    James    41.0\n    Name: user_age_info, dtype: float64\n\n\n```\n\n## 2. DataFrame\n\n> DataFrame 是一个带有 名称 和索引的二维数组，像一张Excel表格。\n\n### 创建DataFrame\n\n```\n\n// DataFrame 根据字典生成\n\nIn:\n    index = pd.Index(data=[\"Tom\", \"Bob\", \"Mary\", \"James\"], name=\"name\")\n    \n    data = {\n        \"age\": [18, 30, 40],\n        \"city\": [\"BeiJing\", \"ShangHai\", \"HangZhou\"]\n    }\n    \n    user_info = pd.DataFrame(data=data, index=index)\n    user_info\n\nOut:\n    \n// DataFrame 根据二维列表生成\nIn:\n    data = [[18, \"BeiJing\"], \n            [30, \"ShangHai\"], \n            [25, \"GuangZhou\"], \n            [40, \"ShenZhen\"]]\n    columns = [\"age\", \"city\"]\n    \n    user_info = pd.DataFrame(data=data, index=index, columns=columns)\n    user_info\n\n```","source":"_posts/pandas-1数据结构.md","raw":"---\ntitle: pandas -1数据结构\nmathjax: true\ndate: 2019-07-22 09:01:01\ncategories: pandas系列教程\ntags: pandas\n---\n\n# pandas -1 数据结构\n> pandas 基本操作都很简单，只是在刚开始学习的过程中，容易忘掉一些API，导致完成一些操作时，总会想着翻翻手册，这一系列博客，是对这些方法进行了梳理，可作为入门学习的参考材料。平时经常翻阅。\n\n“index” (axis=0, default), “columns” (axis=1)\n## 1. Series\n\n> Series 是一个带有 名称 和索引的一维数组。\n\n### 创建seriex\n\n```\n\n// Series 数组生成，指定数据类型\nIn:   \n    user_age = pd.Series(data=[18, 30, 25, 40], dtype=float)\n    \nOut:\n        0    18\n        1    30\n        2    25\n        3    40\n        dtype: int64\n\n\n// 增加索引 index\nIn:   \n    user_age.index = [\"Tom\", \"Bob\", \"Mary\", \"James\"]\n    \nOut:\n    Tom      18\n    Bob      30\n    Mary     25\n    James    40\n    dtype: int64\n    \n// 表头\nIn:\n    user_age.index.name(\"name\")\n    \nOut:\n    name\n    Tom      18\n    Bob      30\n    Mary     25\n    James    40\n    dtype: int64\n    \n\n```\n\n### 像字典一样使用series\n\n```\n// index 当键值\nIn: \n    user_age[\"Tom\"]\n    user_age.get(\"Tom\")\n\n// 切片-列\nIn:\n    user_age[2:3]\n    \n// 按条件查找\nIn:\n    user_age[user_age > 30]\n    \nOut:\n    name\n    James    40.0\n    Name: user_age_info, dtype: float64\n    \n```\n\n### 像向量一样使用series\n\n> 可以传递给np方法\n\n```\n// 整列加减\nIn:\n    user_age + 1\n    \nOut:\n    name\n    Tom      19.0\n    Bob      31.0\n    Mary     26.0\n    James    41.0\n    Name: user_age_info, dtype: float64\n\n\n```\n\n## 2. DataFrame\n\n> DataFrame 是一个带有 名称 和索引的二维数组，像一张Excel表格。\n\n### 创建DataFrame\n\n```\n\n// DataFrame 根据字典生成\n\nIn:\n    index = pd.Index(data=[\"Tom\", \"Bob\", \"Mary\", \"James\"], name=\"name\")\n    \n    data = {\n        \"age\": [18, 30, 40],\n        \"city\": [\"BeiJing\", \"ShangHai\", \"HangZhou\"]\n    }\n    \n    user_info = pd.DataFrame(data=data, index=index)\n    user_info\n\nOut:\n    \n// DataFrame 根据二维列表生成\nIn:\n    data = [[18, \"BeiJing\"], \n            [30, \"ShangHai\"], \n            [25, \"GuangZhou\"], \n            [40, \"ShenZhen\"]]\n    columns = [\"age\", \"city\"]\n    \n    user_info = pd.DataFrame(data=data, index=index, columns=columns)\n    user_info\n\n```","slug":"pandas-1数据结构","published":1,"updated":"2020-02-20T04:41:37.812Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephdz0012t8plgf4czlz3","content":"<h1 id=\"pandas-1-数据结构\"><a href=\"#pandas-1-数据结构\" class=\"headerlink\" title=\"pandas -1 数据结构\"></a>pandas -1 数据结构</h1><blockquote>\n<p>pandas 基本操作都很简单，只是在刚开始学习的过程中，容易忘掉一些API，导致完成一些操作时，总会想着翻翻手册，这一系列博客，是对这些方法进行了梳理，可作为入门学习的参考材料。平时经常翻阅。</p>\n</blockquote>\n<p>“index” (axis=0, default), “columns” (axis=1)</p>\n<h2 id=\"1-Series\"><a href=\"#1-Series\" class=\"headerlink\" title=\"1. Series\"></a>1. Series</h2><blockquote>\n<p>Series 是一个带有 名称 和索引的一维数组。</p>\n</blockquote>\n<h3 id=\"创建seriex\"><a href=\"#创建seriex\" class=\"headerlink\" title=\"创建seriex\"></a>创建seriex</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// Series 数组生成，指定数据类型</span><br><span class=\"line\">In:   </span><br><span class=\"line\">    user_age = pd.Series(data=[18, 30, 25, 40], dtype=float)</span><br><span class=\"line\">    </span><br><span class=\"line\">Out:</span><br><span class=\"line\">        0    18</span><br><span class=\"line\">        1    30</span><br><span class=\"line\">        2    25</span><br><span class=\"line\">        3    40</span><br><span class=\"line\">        dtype: int64</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 增加索引 index</span><br><span class=\"line\">In:   </span><br><span class=\"line\">    user_age.index = [&quot;Tom&quot;, &quot;Bob&quot;, &quot;Mary&quot;, &quot;James&quot;]</span><br><span class=\"line\">    </span><br><span class=\"line\">Out:</span><br><span class=\"line\">    Tom      18</span><br><span class=\"line\">    Bob      30</span><br><span class=\"line\">    Mary     25</span><br><span class=\"line\">    James    40</span><br><span class=\"line\">    dtype: int64</span><br><span class=\"line\">    </span><br><span class=\"line\">// 表头</span><br><span class=\"line\">In:</span><br><span class=\"line\">    user_age.index.name(&quot;name&quot;)</span><br><span class=\"line\">    </span><br><span class=\"line\">Out:</span><br><span class=\"line\">    name</span><br><span class=\"line\">    Tom      18</span><br><span class=\"line\">    Bob      30</span><br><span class=\"line\">    Mary     25</span><br><span class=\"line\">    James    40</span><br><span class=\"line\">    dtype: int64</span><br></pre></td></tr></table></figure>\n<h3 id=\"像字典一样使用series\"><a href=\"#像字典一样使用series\" class=\"headerlink\" title=\"像字典一样使用series\"></a>像字典一样使用series</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index 当键值</span><br><span class=\"line\">In: </span><br><span class=\"line\">    user_age[&quot;Tom&quot;]</span><br><span class=\"line\">    user_age.get(&quot;Tom&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 切片-列</span><br><span class=\"line\">In:</span><br><span class=\"line\">    user_age[2:3]</span><br><span class=\"line\">    </span><br><span class=\"line\">// 按条件查找</span><br><span class=\"line\">In:</span><br><span class=\"line\">    user_age[user_age &gt; 30]</span><br><span class=\"line\">    </span><br><span class=\"line\">Out:</span><br><span class=\"line\">    name</span><br><span class=\"line\">    James    40.0</span><br><span class=\"line\">    Name: user_age_info, dtype: float64</span><br></pre></td></tr></table></figure>\n<h3 id=\"像向量一样使用series\"><a href=\"#像向量一样使用series\" class=\"headerlink\" title=\"像向量一样使用series\"></a>像向量一样使用series</h3><blockquote>\n<p>可以传递给np方法</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 整列加减</span><br><span class=\"line\">In:</span><br><span class=\"line\">    user_age + 1</span><br><span class=\"line\">    </span><br><span class=\"line\">Out:</span><br><span class=\"line\">    name</span><br><span class=\"line\">    Tom      19.0</span><br><span class=\"line\">    Bob      31.0</span><br><span class=\"line\">    Mary     26.0</span><br><span class=\"line\">    James    41.0</span><br><span class=\"line\">    Name: user_age_info, dtype: float64</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-DataFrame\"><a href=\"#2-DataFrame\" class=\"headerlink\" title=\"2. DataFrame\"></a>2. DataFrame</h2><blockquote>\n<p>DataFrame 是一个带有 名称 和索引的二维数组，像一张Excel表格。</p>\n</blockquote>\n<h3 id=\"创建DataFrame\"><a href=\"#创建DataFrame\" class=\"headerlink\" title=\"创建DataFrame\"></a>创建DataFrame</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// DataFrame 根据字典生成</span><br><span class=\"line\"></span><br><span class=\"line\">In:</span><br><span class=\"line\">    index = pd.Index(data=[&quot;Tom&quot;, &quot;Bob&quot;, &quot;Mary&quot;, &quot;James&quot;], name=&quot;name&quot;)</span><br><span class=\"line\">    </span><br><span class=\"line\">    data = &#123;</span><br><span class=\"line\">        &quot;age&quot;: [18, 30, 40],</span><br><span class=\"line\">        &quot;city&quot;: [&quot;BeiJing&quot;, &quot;ShangHai&quot;, &quot;HangZhou&quot;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    user_info = pd.DataFrame(data=data, index=index)</span><br><span class=\"line\">    user_info</span><br><span class=\"line\"></span><br><span class=\"line\">Out:</span><br><span class=\"line\">    </span><br><span class=\"line\">// DataFrame 根据二维列表生成</span><br><span class=\"line\">In:</span><br><span class=\"line\">    data = [[18, &quot;BeiJing&quot;], </span><br><span class=\"line\">            [30, &quot;ShangHai&quot;], </span><br><span class=\"line\">            [25, &quot;GuangZhou&quot;], </span><br><span class=\"line\">            [40, &quot;ShenZhen&quot;]]</span><br><span class=\"line\">    columns = [&quot;age&quot;, &quot;city&quot;]</span><br><span class=\"line\">    </span><br><span class=\"line\">    user_info = pd.DataFrame(data=data, index=index, columns=columns)</span><br><span class=\"line\">    user_info</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"pandas-1-数据结构\"><a href=\"#pandas-1-数据结构\" class=\"headerlink\" title=\"pandas -1 数据结构\"></a>pandas -1 数据结构</h1><blockquote>\n<p>pandas 基本操作都很简单，只是在刚开始学习的过程中，容易忘掉一些API，导致完成一些操作时，总会想着翻翻手册，这一系列博客，是对这些方法进行了梳理，可作为入门学习的参考材料。平时经常翻阅。</p>\n</blockquote>\n<p>“index” (axis=0, default), “columns” (axis=1)</p>\n<h2 id=\"1-Series\"><a href=\"#1-Series\" class=\"headerlink\" title=\"1. Series\"></a>1. Series</h2><blockquote>\n<p>Series 是一个带有 名称 和索引的一维数组。</p>\n</blockquote>\n<h3 id=\"创建seriex\"><a href=\"#创建seriex\" class=\"headerlink\" title=\"创建seriex\"></a>创建seriex</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// Series 数组生成，指定数据类型</span><br><span class=\"line\">In:   </span><br><span class=\"line\">    user_age = pd.Series(data=[18, 30, 25, 40], dtype=float)</span><br><span class=\"line\">    </span><br><span class=\"line\">Out:</span><br><span class=\"line\">        0    18</span><br><span class=\"line\">        1    30</span><br><span class=\"line\">        2    25</span><br><span class=\"line\">        3    40</span><br><span class=\"line\">        dtype: int64</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 增加索引 index</span><br><span class=\"line\">In:   </span><br><span class=\"line\">    user_age.index = [&quot;Tom&quot;, &quot;Bob&quot;, &quot;Mary&quot;, &quot;James&quot;]</span><br><span class=\"line\">    </span><br><span class=\"line\">Out:</span><br><span class=\"line\">    Tom      18</span><br><span class=\"line\">    Bob      30</span><br><span class=\"line\">    Mary     25</span><br><span class=\"line\">    James    40</span><br><span class=\"line\">    dtype: int64</span><br><span class=\"line\">    </span><br><span class=\"line\">// 表头</span><br><span class=\"line\">In:</span><br><span class=\"line\">    user_age.index.name(&quot;name&quot;)</span><br><span class=\"line\">    </span><br><span class=\"line\">Out:</span><br><span class=\"line\">    name</span><br><span class=\"line\">    Tom      18</span><br><span class=\"line\">    Bob      30</span><br><span class=\"line\">    Mary     25</span><br><span class=\"line\">    James    40</span><br><span class=\"line\">    dtype: int64</span><br></pre></td></tr></table></figure>\n<h3 id=\"像字典一样使用series\"><a href=\"#像字典一样使用series\" class=\"headerlink\" title=\"像字典一样使用series\"></a>像字典一样使用series</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index 当键值</span><br><span class=\"line\">In: </span><br><span class=\"line\">    user_age[&quot;Tom&quot;]</span><br><span class=\"line\">    user_age.get(&quot;Tom&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 切片-列</span><br><span class=\"line\">In:</span><br><span class=\"line\">    user_age[2:3]</span><br><span class=\"line\">    </span><br><span class=\"line\">// 按条件查找</span><br><span class=\"line\">In:</span><br><span class=\"line\">    user_age[user_age &gt; 30]</span><br><span class=\"line\">    </span><br><span class=\"line\">Out:</span><br><span class=\"line\">    name</span><br><span class=\"line\">    James    40.0</span><br><span class=\"line\">    Name: user_age_info, dtype: float64</span><br></pre></td></tr></table></figure>\n<h3 id=\"像向量一样使用series\"><a href=\"#像向量一样使用series\" class=\"headerlink\" title=\"像向量一样使用series\"></a>像向量一样使用series</h3><blockquote>\n<p>可以传递给np方法</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 整列加减</span><br><span class=\"line\">In:</span><br><span class=\"line\">    user_age + 1</span><br><span class=\"line\">    </span><br><span class=\"line\">Out:</span><br><span class=\"line\">    name</span><br><span class=\"line\">    Tom      19.0</span><br><span class=\"line\">    Bob      31.0</span><br><span class=\"line\">    Mary     26.0</span><br><span class=\"line\">    James    41.0</span><br><span class=\"line\">    Name: user_age_info, dtype: float64</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-DataFrame\"><a href=\"#2-DataFrame\" class=\"headerlink\" title=\"2. DataFrame\"></a>2. DataFrame</h2><blockquote>\n<p>DataFrame 是一个带有 名称 和索引的二维数组，像一张Excel表格。</p>\n</blockquote>\n<h3 id=\"创建DataFrame\"><a href=\"#创建DataFrame\" class=\"headerlink\" title=\"创建DataFrame\"></a>创建DataFrame</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// DataFrame 根据字典生成</span><br><span class=\"line\"></span><br><span class=\"line\">In:</span><br><span class=\"line\">    index = pd.Index(data=[&quot;Tom&quot;, &quot;Bob&quot;, &quot;Mary&quot;, &quot;James&quot;], name=&quot;name&quot;)</span><br><span class=\"line\">    </span><br><span class=\"line\">    data = &#123;</span><br><span class=\"line\">        &quot;age&quot;: [18, 30, 40],</span><br><span class=\"line\">        &quot;city&quot;: [&quot;BeiJing&quot;, &quot;ShangHai&quot;, &quot;HangZhou&quot;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    user_info = pd.DataFrame(data=data, index=index)</span><br><span class=\"line\">    user_info</span><br><span class=\"line\"></span><br><span class=\"line\">Out:</span><br><span class=\"line\">    </span><br><span class=\"line\">// DataFrame 根据二维列表生成</span><br><span class=\"line\">In:</span><br><span class=\"line\">    data = [[18, &quot;BeiJing&quot;], </span><br><span class=\"line\">            [30, &quot;ShangHai&quot;], </span><br><span class=\"line\">            [25, &quot;GuangZhou&quot;], </span><br><span class=\"line\">            [40, &quot;ShenZhen&quot;]]</span><br><span class=\"line\">    columns = [&quot;age&quot;, &quot;city&quot;]</span><br><span class=\"line\">    </span><br><span class=\"line\">    user_info = pd.DataFrame(data=data, index=index, columns=columns)</span><br><span class=\"line\">    user_info</span><br></pre></td></tr></table></figure>"},{"title":"pandas-8分层和多级索引","mathjax":true,"date":"2019-08-13T02:54:12.000Z","_content":"\n# pandas -8 分层和多级索引\n\n> Multi-level indexing. 在 “[pandas -2 索引和选择数据](http://www.elgong.top/2019/07/25/pandas-%E7%B4%A2%E5%BC%95%E5%92%8C%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE/)” 一节中, 已经提到了如何选择行列元素, 而Series 和 Dataframe 是低维度的数据结构，对于更高维度的数据，可以通过分层和多级索引来实现。\n\n## 分层索引的创建\n\n> 创建分层索引的方式有很多, 这里直接摘抄自官方的文档，可以通过元组，列表，Dataframe, arrays 等方式生成分层索引。\n\n> 同时要知道，通过 groupby 分组操作之后得到的也是这种分层结构。\n\n```\n    //  1. 元组\nIn: \n\n    arrays = [['bar', 'bar', 'baz', 'baz', 'foo', 'foo','qux', 'qux'], ['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two']]\n    tuples = list(zip(*arrays))\nOut: \n    [('bar', 'one'),\n     ('bar', 'two'),\n     ('baz', 'one'),\n     ('baz', 'two'),\n     ('foo', 'one'),\n     ('foo', 'two'),\n     ('qux', 'one'),\n     ('qux', 'two')]\n\nIn:\n    index = pd.MultiIndex.from_tuples(tuples, names=['first', 'second'])\n    df = pd.Series(np.random.randn(8), index=index)\n    \nOut:\n    first  second\n    bar    one       0.469112\n           two      -0.282863\n    baz    one      -1.509059\n           two      -1.135632\n    foo    one       1.212112\n           two      -0.173215\n    qux    one       0.119209\n           two      -1.044236\n    dtype: float64\n    \n    \n    // 2. dataftame\n    \n    index = pd.MultiIndex.from_frame(df)\n    \n    \n    // 3. arrays\n    \nIn: \n    arrays = [np.array(['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux']),\n              np.array(['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two'])]\n\n\n     s = pd.Series(np.random.randn(8), index=arrays)\n\n\n```\n## 从DataFrame 产生 MultiIndex\n\n```\n    df = df.set_index(['col1','col2'])\n```\n\n## MultiIndex 转化成 列\n\n```\n    df = df.reset_index()\n```\n## 选择不同层\n\n> 查看不同层的索引值。\n\n```\nIn:\n    index.get_level_values(0)\n    \n    index.get_level_values(\"name\")\n    \nOut:\n    Index(['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux'], dtype='object', name='first')\n\n```\n\n> 根据不同层索引\n\n```\n    df[\"bar\"]\n    df[\"one\"]\n    df[\"bar\"][\"one\"]\n    \n    // 元组\n    df.loc[('bar', 'two')]\n\n```\n\n<font color=0xff111>  注意, 切片时不会改变 多层索引。 </font>\n","source":"_posts/pandas-分层和多级索引.md","raw":"---\ntitle: pandas-8分层和多级索引\nmathjax: true\ndate: 2019-08-13 10:54:12\ncategories: pandas系列教程\ntags: pandas-MultiIndex\n---\n\n# pandas -8 分层和多级索引\n\n> Multi-level indexing. 在 “[pandas -2 索引和选择数据](http://www.elgong.top/2019/07/25/pandas-%E7%B4%A2%E5%BC%95%E5%92%8C%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE/)” 一节中, 已经提到了如何选择行列元素, 而Series 和 Dataframe 是低维度的数据结构，对于更高维度的数据，可以通过分层和多级索引来实现。\n\n## 分层索引的创建\n\n> 创建分层索引的方式有很多, 这里直接摘抄自官方的文档，可以通过元组，列表，Dataframe, arrays 等方式生成分层索引。\n\n> 同时要知道，通过 groupby 分组操作之后得到的也是这种分层结构。\n\n```\n    //  1. 元组\nIn: \n\n    arrays = [['bar', 'bar', 'baz', 'baz', 'foo', 'foo','qux', 'qux'], ['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two']]\n    tuples = list(zip(*arrays))\nOut: \n    [('bar', 'one'),\n     ('bar', 'two'),\n     ('baz', 'one'),\n     ('baz', 'two'),\n     ('foo', 'one'),\n     ('foo', 'two'),\n     ('qux', 'one'),\n     ('qux', 'two')]\n\nIn:\n    index = pd.MultiIndex.from_tuples(tuples, names=['first', 'second'])\n    df = pd.Series(np.random.randn(8), index=index)\n    \nOut:\n    first  second\n    bar    one       0.469112\n           two      -0.282863\n    baz    one      -1.509059\n           two      -1.135632\n    foo    one       1.212112\n           two      -0.173215\n    qux    one       0.119209\n           two      -1.044236\n    dtype: float64\n    \n    \n    // 2. dataftame\n    \n    index = pd.MultiIndex.from_frame(df)\n    \n    \n    // 3. arrays\n    \nIn: \n    arrays = [np.array(['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux']),\n              np.array(['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two'])]\n\n\n     s = pd.Series(np.random.randn(8), index=arrays)\n\n\n```\n## 从DataFrame 产生 MultiIndex\n\n```\n    df = df.set_index(['col1','col2'])\n```\n\n## MultiIndex 转化成 列\n\n```\n    df = df.reset_index()\n```\n## 选择不同层\n\n> 查看不同层的索引值。\n\n```\nIn:\n    index.get_level_values(0)\n    \n    index.get_level_values(\"name\")\n    \nOut:\n    Index(['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux'], dtype='object', name='first')\n\n```\n\n> 根据不同层索引\n\n```\n    df[\"bar\"]\n    df[\"one\"]\n    df[\"bar\"][\"one\"]\n    \n    // 元组\n    df.loc[('bar', 'two')]\n\n```\n\n<font color=0xff111>  注意, 切片时不会改变 多层索引。 </font>\n","slug":"pandas-分层和多级索引","published":1,"updated":"2020-02-20T04:41:37.813Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephe70016t8pldz4y6skc","content":"<h1 id=\"pandas-8-分层和多级索引\"><a href=\"#pandas-8-分层和多级索引\" class=\"headerlink\" title=\"pandas -8 分层和多级索引\"></a>pandas -8 分层和多级索引</h1><blockquote>\n<p>Multi-level indexing. 在 “<a href=\"http://www.elgong.top/2019/07/25/pandas-%E7%B4%A2%E5%BC%95%E5%92%8C%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE/\">pandas -2 索引和选择数据</a>” 一节中, 已经提到了如何选择行列元素, 而Series 和 Dataframe 是低维度的数据结构，对于更高维度的数据，可以通过分层和多级索引来实现。</p>\n</blockquote>\n<h2 id=\"分层索引的创建\"><a href=\"#分层索引的创建\" class=\"headerlink\" title=\"分层索引的创建\"></a>分层索引的创建</h2><blockquote>\n<p>创建分层索引的方式有很多, 这里直接摘抄自官方的文档，可以通过元组，列表，Dataframe, arrays 等方式生成分层索引。</p>\n<p>同时要知道，通过 groupby 分组操作之后得到的也是这种分层结构。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    //  1. 元组</span><br><span class=\"line\">In: </span><br><span class=\"line\"></span><br><span class=\"line\">    arrays = [[&apos;bar&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;baz&apos;, &apos;foo&apos;, &apos;foo&apos;,&apos;qux&apos;, &apos;qux&apos;], [&apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;]]</span><br><span class=\"line\">    tuples = list(zip(*arrays))</span><br><span class=\"line\">Out: </span><br><span class=\"line\">    [(&apos;bar&apos;, &apos;one&apos;),</span><br><span class=\"line\">     (&apos;bar&apos;, &apos;two&apos;),</span><br><span class=\"line\">     (&apos;baz&apos;, &apos;one&apos;),</span><br><span class=\"line\">     (&apos;baz&apos;, &apos;two&apos;),</span><br><span class=\"line\">     (&apos;foo&apos;, &apos;one&apos;),</span><br><span class=\"line\">     (&apos;foo&apos;, &apos;two&apos;),</span><br><span class=\"line\">     (&apos;qux&apos;, &apos;one&apos;),</span><br><span class=\"line\">     (&apos;qux&apos;, &apos;two&apos;)]</span><br><span class=\"line\"></span><br><span class=\"line\">In:</span><br><span class=\"line\">    index = pd.MultiIndex.from_tuples(tuples, names=[&apos;first&apos;, &apos;second&apos;])</span><br><span class=\"line\">    df = pd.Series(np.random.randn(8), index=index)</span><br><span class=\"line\">    </span><br><span class=\"line\">Out:</span><br><span class=\"line\">    first  second</span><br><span class=\"line\">    bar    one       0.469112</span><br><span class=\"line\">           two      -0.282863</span><br><span class=\"line\">    baz    one      -1.509059</span><br><span class=\"line\">           two      -1.135632</span><br><span class=\"line\">    foo    one       1.212112</span><br><span class=\"line\">           two      -0.173215</span><br><span class=\"line\">    qux    one       0.119209</span><br><span class=\"line\">           two      -1.044236</span><br><span class=\"line\">    dtype: float64</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    // 2. dataftame</span><br><span class=\"line\">    </span><br><span class=\"line\">    index = pd.MultiIndex.from_frame(df)</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    // 3. arrays</span><br><span class=\"line\">    </span><br><span class=\"line\">In: </span><br><span class=\"line\">    arrays = [np.array([&apos;bar&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;baz&apos;, &apos;foo&apos;, &apos;foo&apos;, &apos;qux&apos;, &apos;qux&apos;]),</span><br><span class=\"line\">              np.array([&apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;])]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">     s = pd.Series(np.random.randn(8), index=arrays)</span><br></pre></td></tr></table></figure>\n<h2 id=\"从DataFrame-产生-MultiIndex\"><a href=\"#从DataFrame-产生-MultiIndex\" class=\"headerlink\" title=\"从DataFrame 产生 MultiIndex\"></a>从DataFrame 产生 MultiIndex</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df = df.set_index([&apos;col1&apos;,&apos;col2&apos;])</span><br></pre></td></tr></table></figure>\n<h2 id=\"MultiIndex-转化成-列\"><a href=\"#MultiIndex-转化成-列\" class=\"headerlink\" title=\"MultiIndex 转化成 列\"></a>MultiIndex 转化成 列</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df = df.reset_index()</span><br></pre></td></tr></table></figure>\n<h2 id=\"选择不同层\"><a href=\"#选择不同层\" class=\"headerlink\" title=\"选择不同层\"></a>选择不同层</h2><blockquote>\n<p>查看不同层的索引值。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In:</span><br><span class=\"line\">    index.get_level_values(0)</span><br><span class=\"line\">    </span><br><span class=\"line\">    index.get_level_values(&quot;name&quot;)</span><br><span class=\"line\">    </span><br><span class=\"line\">Out:</span><br><span class=\"line\">    Index([&apos;bar&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;baz&apos;, &apos;foo&apos;, &apos;foo&apos;, &apos;qux&apos;, &apos;qux&apos;], dtype=&apos;object&apos;, name=&apos;first&apos;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>根据不同层索引</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df[&quot;bar&quot;]</span><br><span class=\"line\">df[&quot;one&quot;]</span><br><span class=\"line\">df[&quot;bar&quot;][&quot;one&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">// 元组</span><br><span class=\"line\">df.loc[(&apos;bar&apos;, &apos;two&apos;)]</span><br></pre></td></tr></table></figure>\n<font color=\"0xff111\">  注意, 切片时不会改变 多层索引。 </font>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"pandas-8-分层和多级索引\"><a href=\"#pandas-8-分层和多级索引\" class=\"headerlink\" title=\"pandas -8 分层和多级索引\"></a>pandas -8 分层和多级索引</h1><blockquote>\n<p>Multi-level indexing. 在 “<a href=\"http://www.elgong.top/2019/07/25/pandas-%E7%B4%A2%E5%BC%95%E5%92%8C%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE/\">pandas -2 索引和选择数据</a>” 一节中, 已经提到了如何选择行列元素, 而Series 和 Dataframe 是低维度的数据结构，对于更高维度的数据，可以通过分层和多级索引来实现。</p>\n</blockquote>\n<h2 id=\"分层索引的创建\"><a href=\"#分层索引的创建\" class=\"headerlink\" title=\"分层索引的创建\"></a>分层索引的创建</h2><blockquote>\n<p>创建分层索引的方式有很多, 这里直接摘抄自官方的文档，可以通过元组，列表，Dataframe, arrays 等方式生成分层索引。</p>\n<p>同时要知道，通过 groupby 分组操作之后得到的也是这种分层结构。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    //  1. 元组</span><br><span class=\"line\">In: </span><br><span class=\"line\"></span><br><span class=\"line\">    arrays = [[&apos;bar&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;baz&apos;, &apos;foo&apos;, &apos;foo&apos;,&apos;qux&apos;, &apos;qux&apos;], [&apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;]]</span><br><span class=\"line\">    tuples = list(zip(*arrays))</span><br><span class=\"line\">Out: </span><br><span class=\"line\">    [(&apos;bar&apos;, &apos;one&apos;),</span><br><span class=\"line\">     (&apos;bar&apos;, &apos;two&apos;),</span><br><span class=\"line\">     (&apos;baz&apos;, &apos;one&apos;),</span><br><span class=\"line\">     (&apos;baz&apos;, &apos;two&apos;),</span><br><span class=\"line\">     (&apos;foo&apos;, &apos;one&apos;),</span><br><span class=\"line\">     (&apos;foo&apos;, &apos;two&apos;),</span><br><span class=\"line\">     (&apos;qux&apos;, &apos;one&apos;),</span><br><span class=\"line\">     (&apos;qux&apos;, &apos;two&apos;)]</span><br><span class=\"line\"></span><br><span class=\"line\">In:</span><br><span class=\"line\">    index = pd.MultiIndex.from_tuples(tuples, names=[&apos;first&apos;, &apos;second&apos;])</span><br><span class=\"line\">    df = pd.Series(np.random.randn(8), index=index)</span><br><span class=\"line\">    </span><br><span class=\"line\">Out:</span><br><span class=\"line\">    first  second</span><br><span class=\"line\">    bar    one       0.469112</span><br><span class=\"line\">           two      -0.282863</span><br><span class=\"line\">    baz    one      -1.509059</span><br><span class=\"line\">           two      -1.135632</span><br><span class=\"line\">    foo    one       1.212112</span><br><span class=\"line\">           two      -0.173215</span><br><span class=\"line\">    qux    one       0.119209</span><br><span class=\"line\">           two      -1.044236</span><br><span class=\"line\">    dtype: float64</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    // 2. dataftame</span><br><span class=\"line\">    </span><br><span class=\"line\">    index = pd.MultiIndex.from_frame(df)</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    // 3. arrays</span><br><span class=\"line\">    </span><br><span class=\"line\">In: </span><br><span class=\"line\">    arrays = [np.array([&apos;bar&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;baz&apos;, &apos;foo&apos;, &apos;foo&apos;, &apos;qux&apos;, &apos;qux&apos;]),</span><br><span class=\"line\">              np.array([&apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;])]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">     s = pd.Series(np.random.randn(8), index=arrays)</span><br></pre></td></tr></table></figure>\n<h2 id=\"从DataFrame-产生-MultiIndex\"><a href=\"#从DataFrame-产生-MultiIndex\" class=\"headerlink\" title=\"从DataFrame 产生 MultiIndex\"></a>从DataFrame 产生 MultiIndex</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df = df.set_index([&apos;col1&apos;,&apos;col2&apos;])</span><br></pre></td></tr></table></figure>\n<h2 id=\"MultiIndex-转化成-列\"><a href=\"#MultiIndex-转化成-列\" class=\"headerlink\" title=\"MultiIndex 转化成 列\"></a>MultiIndex 转化成 列</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df = df.reset_index()</span><br></pre></td></tr></table></figure>\n<h2 id=\"选择不同层\"><a href=\"#选择不同层\" class=\"headerlink\" title=\"选择不同层\"></a>选择不同层</h2><blockquote>\n<p>查看不同层的索引值。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In:</span><br><span class=\"line\">    index.get_level_values(0)</span><br><span class=\"line\">    </span><br><span class=\"line\">    index.get_level_values(&quot;name&quot;)</span><br><span class=\"line\">    </span><br><span class=\"line\">Out:</span><br><span class=\"line\">    Index([&apos;bar&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;baz&apos;, &apos;foo&apos;, &apos;foo&apos;, &apos;qux&apos;, &apos;qux&apos;], dtype=&apos;object&apos;, name=&apos;first&apos;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>根据不同层索引</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df[&quot;bar&quot;]</span><br><span class=\"line\">df[&quot;one&quot;]</span><br><span class=\"line\">df[&quot;bar&quot;][&quot;one&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">// 元组</span><br><span class=\"line\">df.loc[(&apos;bar&apos;, &apos;two&apos;)]</span><br></pre></td></tr></table></figure>\n<font color=\"0xff111\">  注意, 切片时不会改变 多层索引。 </font>\n"},{"layout":"w","title":"pandas-2索引和选择数据","mathjax":true,"date":"2019-07-24T23:01:01.000Z","_content":"# pandas -2 索引和选择数据\n\n\n> 对于一种数据结构,最基本的操作就应该是增删改查了。\n\n## 1. 行列选择\n行选择和列选择有许多方法，很容易记混，常用的要记住。\n主要方法有三种： `iloc`, `loc`, `[]`\n\n### 行选择\n\n- 切片 \n```\n    // 切片\n    df[a:b]\n    \n    // 隔1行选择\n    df[::2]\n```\n\n- 指定位置\n\n  ` df.iloc[1, 1]`\n  \n  ` df.iloc[1:10, 2:3]`\n\n  ` df.iloc[1:10]['Price']`\n  \n- 指定索引\n\n  `df.loc[\"index1\", \"index2\"]`\n- 按照条件查找\n\n  ` df[( df[\"row2\"] == 1) & (df[\"row2\"] == \"null\")]`\n  \n  ` df.loc[( df[\"row2\"] == 1) & (df[\"row2\"] == \"null\")]`\n  \n- 根据列的多个值,选择行\n  \n  `List = [1,2,3,4,5]`\n  ` train[train[\"customer_id\"].isin(List)]`\n\n\n  \n### 列选择\n\n- 通过列标签选择单列\n\n    `df[\"price\"]`\n  \n- 通过列标签选择多列\n\n   `df[[\"price\", \"time\"]]`\n   \n- 通过列索引,选择前3列\n\n  `df.iloc[:, :3]` \n\n### 行列选择\n\n  `df.loc[\"index1\" : \"index2\",  [\"price\"]]`\n  \n  `df.iloc[a:b]['Price']`\n  \n### 随机采样行或者列\n\n```\n    s.sample(frac=0.5)\n    // 参数\n    // 默认选择行，n = 行数，  frac = 比例\n    // replace: 默认False 无放回采样\n    // weights: 样本采样权重\n    // axis:  默认=0 行,  =1 列\n    // random_state=2\n\n```\n\n### 分类别等数量抽样\n\n```\n# 降采样 -- 分类抽样\ndef subSample(df_x, splitAttribute = \"Attribute4\"):\n    \n    subsampleNum = min(df_x.groupby(splitAttribute).size())\n    print(subsampleNum)\n    df_x_sub = df_x.iloc[1:2,:]\n    #df_y_sub = df_y.iloc[1:2,:]\n    for label in df_x[splitAttribute].unique():\n        tmp_x = df_x[df_x[splitAttribute] == label]\n\n        random_list = random.sample(range(0,len(tmp_x)),subsampleNum )\n        df_x_sub = df_x_sub.append(tmp_x.iloc[random_list,:])\n        df_y_sub.append(tmp_y.iloc[random_list,:])\n    return df_x_sub #, df_y_sub\n\n```\n  \n  \n## 2. 行的增删改查\n\n### 增加\n\n> 单列\n\n```\n// 末尾增加\n   df[\"new col\"] = None\n   \n// 指定位置增加，在2列后\n   df.insert(2,'city') \n```\n   \n> 多列\n\n   ` pd.concat([df, pd.DataFrame(columns=[\"C\",\"D\"])])`\n   \n> 单行（待验证）\n\n```\n// loc 添加\n  df.loc[‘5‘] = [3, 3, 3, 3]\n    \n// set_value 添加\n  df.set_value(‘5‘, df.columns, [3,3,3,3], takeable=False) \n```\n> 多行\n\n多行相当于合并两张表了,可以参考(merge,concat)[方法](https://note.youdao.com/)。\n\n`test_ = pd.merge(tmp, data.loc[:,[\"customer_id\", \"label\"]],on=['customer_id'],how='left',copy=False\")`\n\n\n### 删除\n\n> 列\n\n```\n// del 方法\n   def df[\"col_name\"]\n\n//根据列名 drop 方法\n   df.drop([\"b\", \"c\"], axis=1,inplace = True)\naxis = 1 列\naxis = 0 行\n\n// 根据列号 drop 方法\n   df.drop(df.columns[[1,2]], axis=1, inplace=True)\n```\n\n> 行\n\n```\n// 根据索引 删除行\n   df = df.drop([1, 2])\n\n// 根据value 删除行\n   df = df[~df[\"col\"].isin(5,9)\n    \n```\n\n> 按照条件删除行\n\n```\ndf.drop(df[df[\"order_pay_time\"] < pd.to_datetime(\"2013-11-12 23:59:44\") ].index)\n```\n\n### 修改与查找\n\n> 单值修改和查找时, 参考选择行列方法。\n\n> 多值查找时，\n\n#### 按条件查找\n\n ` df_train[( df_train[\"row\"] == 1) &( == \"null\")]`\n \n#### query 查找\n\n `df.query('(a < b) & (b < c)')`\n \n#### 替换\n\n> 单个替换，inplace = True 覆盖源文件\n\n  `df.replace(to_replace, value, inplace = True)`\n  \n> 多值替换---字典\n\n  `df.replace({\"A\":\"B\",  29:100})`\n  \n> 按条件替换\n\n  `df.where(df > 0, -df, inplace=True)`\n  \n#### 交换两列的位置\n\n```\n    df[['B', 'A']] = df[['A', 'B']]\n\n```\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/pandas-2索引和选择数据.md","raw":"---\nlayout: w\ntitle: pandas-2索引和选择数据\nmathjax: true\ndate: 2019-07-25 07:01:01\ncategories: pandas系列教程\ntags: pandas\n---\n# pandas -2 索引和选择数据\n\n\n> 对于一种数据结构,最基本的操作就应该是增删改查了。\n\n## 1. 行列选择\n行选择和列选择有许多方法，很容易记混，常用的要记住。\n主要方法有三种： `iloc`, `loc`, `[]`\n\n### 行选择\n\n- 切片 \n```\n    // 切片\n    df[a:b]\n    \n    // 隔1行选择\n    df[::2]\n```\n\n- 指定位置\n\n  ` df.iloc[1, 1]`\n  \n  ` df.iloc[1:10, 2:3]`\n\n  ` df.iloc[1:10]['Price']`\n  \n- 指定索引\n\n  `df.loc[\"index1\", \"index2\"]`\n- 按照条件查找\n\n  ` df[( df[\"row2\"] == 1) & (df[\"row2\"] == \"null\")]`\n  \n  ` df.loc[( df[\"row2\"] == 1) & (df[\"row2\"] == \"null\")]`\n  \n- 根据列的多个值,选择行\n  \n  `List = [1,2,3,4,5]`\n  ` train[train[\"customer_id\"].isin(List)]`\n\n\n  \n### 列选择\n\n- 通过列标签选择单列\n\n    `df[\"price\"]`\n  \n- 通过列标签选择多列\n\n   `df[[\"price\", \"time\"]]`\n   \n- 通过列索引,选择前3列\n\n  `df.iloc[:, :3]` \n\n### 行列选择\n\n  `df.loc[\"index1\" : \"index2\",  [\"price\"]]`\n  \n  `df.iloc[a:b]['Price']`\n  \n### 随机采样行或者列\n\n```\n    s.sample(frac=0.5)\n    // 参数\n    // 默认选择行，n = 行数，  frac = 比例\n    // replace: 默认False 无放回采样\n    // weights: 样本采样权重\n    // axis:  默认=0 行,  =1 列\n    // random_state=2\n\n```\n\n### 分类别等数量抽样\n\n```\n# 降采样 -- 分类抽样\ndef subSample(df_x, splitAttribute = \"Attribute4\"):\n    \n    subsampleNum = min(df_x.groupby(splitAttribute).size())\n    print(subsampleNum)\n    df_x_sub = df_x.iloc[1:2,:]\n    #df_y_sub = df_y.iloc[1:2,:]\n    for label in df_x[splitAttribute].unique():\n        tmp_x = df_x[df_x[splitAttribute] == label]\n\n        random_list = random.sample(range(0,len(tmp_x)),subsampleNum )\n        df_x_sub = df_x_sub.append(tmp_x.iloc[random_list,:])\n        df_y_sub.append(tmp_y.iloc[random_list,:])\n    return df_x_sub #, df_y_sub\n\n```\n  \n  \n## 2. 行的增删改查\n\n### 增加\n\n> 单列\n\n```\n// 末尾增加\n   df[\"new col\"] = None\n   \n// 指定位置增加，在2列后\n   df.insert(2,'city') \n```\n   \n> 多列\n\n   ` pd.concat([df, pd.DataFrame(columns=[\"C\",\"D\"])])`\n   \n> 单行（待验证）\n\n```\n// loc 添加\n  df.loc[‘5‘] = [3, 3, 3, 3]\n    \n// set_value 添加\n  df.set_value(‘5‘, df.columns, [3,3,3,3], takeable=False) \n```\n> 多行\n\n多行相当于合并两张表了,可以参考(merge,concat)[方法](https://note.youdao.com/)。\n\n`test_ = pd.merge(tmp, data.loc[:,[\"customer_id\", \"label\"]],on=['customer_id'],how='left',copy=False\")`\n\n\n### 删除\n\n> 列\n\n```\n// del 方法\n   def df[\"col_name\"]\n\n//根据列名 drop 方法\n   df.drop([\"b\", \"c\"], axis=1,inplace = True)\naxis = 1 列\naxis = 0 行\n\n// 根据列号 drop 方法\n   df.drop(df.columns[[1,2]], axis=1, inplace=True)\n```\n\n> 行\n\n```\n// 根据索引 删除行\n   df = df.drop([1, 2])\n\n// 根据value 删除行\n   df = df[~df[\"col\"].isin(5,9)\n    \n```\n\n> 按照条件删除行\n\n```\ndf.drop(df[df[\"order_pay_time\"] < pd.to_datetime(\"2013-11-12 23:59:44\") ].index)\n```\n\n### 修改与查找\n\n> 单值修改和查找时, 参考选择行列方法。\n\n> 多值查找时，\n\n#### 按条件查找\n\n ` df_train[( df_train[\"row\"] == 1) &( == \"null\")]`\n \n#### query 查找\n\n `df.query('(a < b) & (b < c)')`\n \n#### 替换\n\n> 单个替换，inplace = True 覆盖源文件\n\n  `df.replace(to_replace, value, inplace = True)`\n  \n> 多值替换---字典\n\n  `df.replace({\"A\":\"B\",  29:100})`\n  \n> 按条件替换\n\n  `df.where(df > 0, -df, inplace=True)`\n  \n#### 交换两列的位置\n\n```\n    df[['B', 'A']] = df[['A', 'B']]\n\n```\n\n\n\n\n\n\n\n\n\n\n","slug":"pandas-2索引和选择数据","published":1,"updated":"2020-02-20T04:41:37.812Z","comments":1,"photos":[],"link":"","_id":"cka8ephed0017t8plfffldjgh","content":"<h1 id=\"pandas-2-索引和选择数据\"><a href=\"#pandas-2-索引和选择数据\" class=\"headerlink\" title=\"pandas -2 索引和选择数据\"></a>pandas -2 索引和选择数据</h1><blockquote>\n<p>对于一种数据结构,最基本的操作就应该是增删改查了。</p>\n</blockquote>\n<h2 id=\"1-行列选择\"><a href=\"#1-行列选择\" class=\"headerlink\" title=\"1. 行列选择\"></a>1. 行列选择</h2><p>行选择和列选择有许多方法，很容易记混，常用的要记住。<br>主要方法有三种： <code>iloc</code>, <code>loc</code>, <code>[]</code></p>\n<h3 id=\"行选择\"><a href=\"#行选择\" class=\"headerlink\" title=\"行选择\"></a>行选择</h3><ul>\n<li><p>切片 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 切片</span><br><span class=\"line\">df[a:b]</span><br><span class=\"line\"></span><br><span class=\"line\">// 隔1行选择</span><br><span class=\"line\">df[::2]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指定位置</p>\n<p><code>df.iloc[1, 1]</code></p>\n<p><code>df.iloc[1:10, 2:3]</code></p>\n<p><code>df.iloc[1:10][&#39;Price&#39;]</code></p>\n</li>\n<li><p>指定索引</p>\n<p><code>df.loc[&quot;index1&quot;, &quot;index2&quot;]</code></p>\n</li>\n<li><p>按照条件查找</p>\n<p><code>df[( df[&quot;row2&quot;] == 1) &amp; (df[&quot;row2&quot;] == &quot;null&quot;)]</code></p>\n<p><code>df.loc[( df[&quot;row2&quot;] == 1) &amp; (df[&quot;row2&quot;] == &quot;null&quot;)]</code></p>\n</li>\n<li><p>根据列的多个值,选择行</p>\n<p><code>List = [1,2,3,4,5]</code><br><code>train[train[&quot;customer_id&quot;].isin(List)]</code></p>\n</li>\n</ul>\n<h3 id=\"列选择\"><a href=\"#列选择\" class=\"headerlink\" title=\"列选择\"></a>列选择</h3><ul>\n<li><p>通过列标签选择单列</p>\n<p>  <code>df[&quot;price&quot;]</code></p>\n</li>\n<li><p>通过列标签选择多列</p>\n<p> <code>df[[&quot;price&quot;, &quot;time&quot;]]</code></p>\n</li>\n<li><p>通过列索引,选择前3列</p>\n<p><code>df.iloc[:, :3]</code> </p>\n</li>\n</ul>\n<h3 id=\"行列选择\"><a href=\"#行列选择\" class=\"headerlink\" title=\"行列选择\"></a>行列选择</h3><p>  <code>df.loc[&quot;index1&quot; : &quot;index2&quot;,  [&quot;price&quot;]]</code></p>\n<p>  <code>df.iloc[a:b][&#39;Price&#39;]</code></p>\n<h3 id=\"随机采样行或者列\"><a href=\"#随机采样行或者列\" class=\"headerlink\" title=\"随机采样行或者列\"></a>随机采样行或者列</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.sample(frac=0.5)</span><br><span class=\"line\">// 参数</span><br><span class=\"line\">// 默认选择行，n = 行数，  frac = 比例</span><br><span class=\"line\">// replace: 默认False 无放回采样</span><br><span class=\"line\">// weights: 样本采样权重</span><br><span class=\"line\">// axis:  默认=0 行,  =1 列</span><br><span class=\"line\">// random_state=2</span><br></pre></td></tr></table></figure>\n<h3 id=\"分类别等数量抽样\"><a href=\"#分类别等数量抽样\" class=\"headerlink\" title=\"分类别等数量抽样\"></a>分类别等数量抽样</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 降采样 -- 分类抽样</span><br><span class=\"line\">def subSample(df_x, splitAttribute = &quot;Attribute4&quot;):</span><br><span class=\"line\">    </span><br><span class=\"line\">    subsampleNum = min(df_x.groupby(splitAttribute).size())</span><br><span class=\"line\">    print(subsampleNum)</span><br><span class=\"line\">    df_x_sub = df_x.iloc[1:2,:]</span><br><span class=\"line\">    #df_y_sub = df_y.iloc[1:2,:]</span><br><span class=\"line\">    for label in df_x[splitAttribute].unique():</span><br><span class=\"line\">        tmp_x = df_x[df_x[splitAttribute] == label]</span><br><span class=\"line\"></span><br><span class=\"line\">        random_list = random.sample(range(0,len(tmp_x)),subsampleNum )</span><br><span class=\"line\">        df_x_sub = df_x_sub.append(tmp_x.iloc[random_list,:])</span><br><span class=\"line\">        df_y_sub.append(tmp_y.iloc[random_list,:])</span><br><span class=\"line\">    return df_x_sub #, df_y_sub</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-行的增删改查\"><a href=\"#2-行的增删改查\" class=\"headerlink\" title=\"2. 行的增删改查\"></a>2. 行的增删改查</h2><h3 id=\"增加\"><a href=\"#增加\" class=\"headerlink\" title=\"增加\"></a>增加</h3><blockquote>\n<p>单列</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 末尾增加</span><br><span class=\"line\">   df[&quot;new col&quot;] = None</span><br><span class=\"line\">   </span><br><span class=\"line\">// 指定位置增加，在2列后</span><br><span class=\"line\">   df.insert(2,&apos;city&apos;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>多列</p>\n</blockquote>\n<p>   <code>pd.concat([df, pd.DataFrame(columns=[&quot;C&quot;,&quot;D&quot;])])</code></p>\n<blockquote>\n<p>单行（待验证）</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// loc 添加</span><br><span class=\"line\">  df.loc[‘5‘] = [3, 3, 3, 3]</span><br><span class=\"line\">    </span><br><span class=\"line\">// set_value 添加</span><br><span class=\"line\">  df.set_value(‘5‘, df.columns, [3,3,3,3], takeable=False)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>多行</p>\n</blockquote>\n<p>多行相当于合并两张表了,可以参考(merge,concat)<a href=\"https://note.youdao.com/\" target=\"_blank\" rel=\"noopener\">方法</a>。</p>\n<p><code>test_ = pd.merge(tmp, data.loc[:,[&quot;customer_id&quot;, &quot;label&quot;]],on=[&#39;customer_id&#39;],how=&#39;left&#39;,copy=False&quot;)</code></p>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><blockquote>\n<p>列</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// del 方法</span><br><span class=\"line\">   def df[&quot;col_name&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">//根据列名 drop 方法</span><br><span class=\"line\">   df.drop([&quot;b&quot;, &quot;c&quot;], axis=1,inplace = True)</span><br><span class=\"line\">axis = 1 列</span><br><span class=\"line\">axis = 0 行</span><br><span class=\"line\"></span><br><span class=\"line\">// 根据列号 drop 方法</span><br><span class=\"line\">   df.drop(df.columns[[1,2]], axis=1, inplace=True)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>行</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 根据索引 删除行</span><br><span class=\"line\">   df = df.drop([1, 2])</span><br><span class=\"line\"></span><br><span class=\"line\">// 根据value 删除行</span><br><span class=\"line\">   df = df[~df[&quot;col&quot;].isin(5,9)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>按照条件删除行</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df.drop(df[df[&quot;order_pay_time&quot;] &lt; pd.to_datetime(&quot;2013-11-12 23:59:44&quot;) ].index)</span><br></pre></td></tr></table></figure>\n<h3 id=\"修改与查找\"><a href=\"#修改与查找\" class=\"headerlink\" title=\"修改与查找\"></a>修改与查找</h3><blockquote>\n<p>单值修改和查找时, 参考选择行列方法。</p>\n<p>多值查找时，</p>\n</blockquote>\n<h4 id=\"按条件查找\"><a href=\"#按条件查找\" class=\"headerlink\" title=\"按条件查找\"></a>按条件查找</h4><p> <code>df_train[( df_train[&quot;row&quot;] == 1) &amp;( == &quot;null&quot;)]</code></p>\n<h4 id=\"query-查找\"><a href=\"#query-查找\" class=\"headerlink\" title=\"query 查找\"></a>query 查找</h4><p> <code>df.query(&#39;(a &lt; b) &amp; (b &lt; c)&#39;)</code></p>\n<h4 id=\"替换\"><a href=\"#替换\" class=\"headerlink\" title=\"替换\"></a>替换</h4><blockquote>\n<p>单个替换，inplace = True 覆盖源文件</p>\n</blockquote>\n<p>  <code>df.replace(to_replace, value, inplace = True)</code></p>\n<blockquote>\n<p>多值替换—-字典</p>\n</blockquote>\n<p>  <code>df.replace({&quot;A&quot;:&quot;B&quot;,  29:100})</code></p>\n<blockquote>\n<p>按条件替换</p>\n</blockquote>\n<p>  <code>df.where(df &gt; 0, -df, inplace=True)</code></p>\n<h4 id=\"交换两列的位置\"><a href=\"#交换两列的位置\" class=\"headerlink\" title=\"交换两列的位置\"></a>交换两列的位置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df[[&apos;B&apos;, &apos;A&apos;]] = df[[&apos;A&apos;, &apos;B&apos;]]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"pandas-2-索引和选择数据\"><a href=\"#pandas-2-索引和选择数据\" class=\"headerlink\" title=\"pandas -2 索引和选择数据\"></a>pandas -2 索引和选择数据</h1><blockquote>\n<p>对于一种数据结构,最基本的操作就应该是增删改查了。</p>\n</blockquote>\n<h2 id=\"1-行列选择\"><a href=\"#1-行列选择\" class=\"headerlink\" title=\"1. 行列选择\"></a>1. 行列选择</h2><p>行选择和列选择有许多方法，很容易记混，常用的要记住。<br>主要方法有三种： <code>iloc</code>, <code>loc</code>, <code>[]</code></p>\n<h3 id=\"行选择\"><a href=\"#行选择\" class=\"headerlink\" title=\"行选择\"></a>行选择</h3><ul>\n<li><p>切片 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 切片</span><br><span class=\"line\">df[a:b]</span><br><span class=\"line\"></span><br><span class=\"line\">// 隔1行选择</span><br><span class=\"line\">df[::2]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指定位置</p>\n<p><code>df.iloc[1, 1]</code></p>\n<p><code>df.iloc[1:10, 2:3]</code></p>\n<p><code>df.iloc[1:10][&#39;Price&#39;]</code></p>\n</li>\n<li><p>指定索引</p>\n<p><code>df.loc[&quot;index1&quot;, &quot;index2&quot;]</code></p>\n</li>\n<li><p>按照条件查找</p>\n<p><code>df[( df[&quot;row2&quot;] == 1) &amp; (df[&quot;row2&quot;] == &quot;null&quot;)]</code></p>\n<p><code>df.loc[( df[&quot;row2&quot;] == 1) &amp; (df[&quot;row2&quot;] == &quot;null&quot;)]</code></p>\n</li>\n<li><p>根据列的多个值,选择行</p>\n<p><code>List = [1,2,3,4,5]</code><br><code>train[train[&quot;customer_id&quot;].isin(List)]</code></p>\n</li>\n</ul>\n<h3 id=\"列选择\"><a href=\"#列选择\" class=\"headerlink\" title=\"列选择\"></a>列选择</h3><ul>\n<li><p>通过列标签选择单列</p>\n<p>  <code>df[&quot;price&quot;]</code></p>\n</li>\n<li><p>通过列标签选择多列</p>\n<p> <code>df[[&quot;price&quot;, &quot;time&quot;]]</code></p>\n</li>\n<li><p>通过列索引,选择前3列</p>\n<p><code>df.iloc[:, :3]</code> </p>\n</li>\n</ul>\n<h3 id=\"行列选择\"><a href=\"#行列选择\" class=\"headerlink\" title=\"行列选择\"></a>行列选择</h3><p>  <code>df.loc[&quot;index1&quot; : &quot;index2&quot;,  [&quot;price&quot;]]</code></p>\n<p>  <code>df.iloc[a:b][&#39;Price&#39;]</code></p>\n<h3 id=\"随机采样行或者列\"><a href=\"#随机采样行或者列\" class=\"headerlink\" title=\"随机采样行或者列\"></a>随机采样行或者列</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.sample(frac=0.5)</span><br><span class=\"line\">// 参数</span><br><span class=\"line\">// 默认选择行，n = 行数，  frac = 比例</span><br><span class=\"line\">// replace: 默认False 无放回采样</span><br><span class=\"line\">// weights: 样本采样权重</span><br><span class=\"line\">// axis:  默认=0 行,  =1 列</span><br><span class=\"line\">// random_state=2</span><br></pre></td></tr></table></figure>\n<h3 id=\"分类别等数量抽样\"><a href=\"#分类别等数量抽样\" class=\"headerlink\" title=\"分类别等数量抽样\"></a>分类别等数量抽样</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 降采样 -- 分类抽样</span><br><span class=\"line\">def subSample(df_x, splitAttribute = &quot;Attribute4&quot;):</span><br><span class=\"line\">    </span><br><span class=\"line\">    subsampleNum = min(df_x.groupby(splitAttribute).size())</span><br><span class=\"line\">    print(subsampleNum)</span><br><span class=\"line\">    df_x_sub = df_x.iloc[1:2,:]</span><br><span class=\"line\">    #df_y_sub = df_y.iloc[1:2,:]</span><br><span class=\"line\">    for label in df_x[splitAttribute].unique():</span><br><span class=\"line\">        tmp_x = df_x[df_x[splitAttribute] == label]</span><br><span class=\"line\"></span><br><span class=\"line\">        random_list = random.sample(range(0,len(tmp_x)),subsampleNum )</span><br><span class=\"line\">        df_x_sub = df_x_sub.append(tmp_x.iloc[random_list,:])</span><br><span class=\"line\">        df_y_sub.append(tmp_y.iloc[random_list,:])</span><br><span class=\"line\">    return df_x_sub #, df_y_sub</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-行的增删改查\"><a href=\"#2-行的增删改查\" class=\"headerlink\" title=\"2. 行的增删改查\"></a>2. 行的增删改查</h2><h3 id=\"增加\"><a href=\"#增加\" class=\"headerlink\" title=\"增加\"></a>增加</h3><blockquote>\n<p>单列</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 末尾增加</span><br><span class=\"line\">   df[&quot;new col&quot;] = None</span><br><span class=\"line\">   </span><br><span class=\"line\">// 指定位置增加，在2列后</span><br><span class=\"line\">   df.insert(2,&apos;city&apos;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>多列</p>\n</blockquote>\n<p>   <code>pd.concat([df, pd.DataFrame(columns=[&quot;C&quot;,&quot;D&quot;])])</code></p>\n<blockquote>\n<p>单行（待验证）</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// loc 添加</span><br><span class=\"line\">  df.loc[‘5‘] = [3, 3, 3, 3]</span><br><span class=\"line\">    </span><br><span class=\"line\">// set_value 添加</span><br><span class=\"line\">  df.set_value(‘5‘, df.columns, [3,3,3,3], takeable=False)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>多行</p>\n</blockquote>\n<p>多行相当于合并两张表了,可以参考(merge,concat)<a href=\"https://note.youdao.com/\" target=\"_blank\" rel=\"noopener\">方法</a>。</p>\n<p><code>test_ = pd.merge(tmp, data.loc[:,[&quot;customer_id&quot;, &quot;label&quot;]],on=[&#39;customer_id&#39;],how=&#39;left&#39;,copy=False&quot;)</code></p>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><blockquote>\n<p>列</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// del 方法</span><br><span class=\"line\">   def df[&quot;col_name&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">//根据列名 drop 方法</span><br><span class=\"line\">   df.drop([&quot;b&quot;, &quot;c&quot;], axis=1,inplace = True)</span><br><span class=\"line\">axis = 1 列</span><br><span class=\"line\">axis = 0 行</span><br><span class=\"line\"></span><br><span class=\"line\">// 根据列号 drop 方法</span><br><span class=\"line\">   df.drop(df.columns[[1,2]], axis=1, inplace=True)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>行</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 根据索引 删除行</span><br><span class=\"line\">   df = df.drop([1, 2])</span><br><span class=\"line\"></span><br><span class=\"line\">// 根据value 删除行</span><br><span class=\"line\">   df = df[~df[&quot;col&quot;].isin(5,9)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>按照条件删除行</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df.drop(df[df[&quot;order_pay_time&quot;] &lt; pd.to_datetime(&quot;2013-11-12 23:59:44&quot;) ].index)</span><br></pre></td></tr></table></figure>\n<h3 id=\"修改与查找\"><a href=\"#修改与查找\" class=\"headerlink\" title=\"修改与查找\"></a>修改与查找</h3><blockquote>\n<p>单值修改和查找时, 参考选择行列方法。</p>\n<p>多值查找时，</p>\n</blockquote>\n<h4 id=\"按条件查找\"><a href=\"#按条件查找\" class=\"headerlink\" title=\"按条件查找\"></a>按条件查找</h4><p> <code>df_train[( df_train[&quot;row&quot;] == 1) &amp;( == &quot;null&quot;)]</code></p>\n<h4 id=\"query-查找\"><a href=\"#query-查找\" class=\"headerlink\" title=\"query 查找\"></a>query 查找</h4><p> <code>df.query(&#39;(a &lt; b) &amp; (b &lt; c)&#39;)</code></p>\n<h4 id=\"替换\"><a href=\"#替换\" class=\"headerlink\" title=\"替换\"></a>替换</h4><blockquote>\n<p>单个替换，inplace = True 覆盖源文件</p>\n</blockquote>\n<p>  <code>df.replace(to_replace, value, inplace = True)</code></p>\n<blockquote>\n<p>多值替换—-字典</p>\n</blockquote>\n<p>  <code>df.replace({&quot;A&quot;:&quot;B&quot;,  29:100})</code></p>\n<blockquote>\n<p>按条件替换</p>\n</blockquote>\n<p>  <code>df.where(df &gt; 0, -df, inplace=True)</code></p>\n<h4 id=\"交换两列的位置\"><a href=\"#交换两列的位置\" class=\"headerlink\" title=\"交换两列的位置\"></a>交换两列的位置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df[[&apos;B&apos;, &apos;A&apos;]] = df[[&apos;A&apos;, &apos;B&apos;]]</span><br></pre></td></tr></table></figure>\n"},{"title":"pandas-7时间&日期处理","mathjax":true,"date":"2019-08-06T00:42:00.000Z","_content":"\n# pandas -7 时间&日期处理\n\n\n## pandas 常出现的时间格式\n\n- 字符串类型 `object`\n\n> 一般是字符串类型，pandas 储存string时 使用 narray， 每一个object 是一个指针\n\n- datetime 类型 `datetime64`\n\n\n- timedelta 类型\n\n> 表示时间差的数据类型\n\n## 类型转换\n\n1. ` object` 2 `datetime`\n\n```\n    // 方法1\n    df[1] = pd.to_datetime(df[1], format='%d.%m.%Y')\n    \n    # 指定format，速度会加快很多。\n    \n    // 方法2\n    dateStr = \"2019-02-03\"\n    \n    myDate = datetime.strptime(dateStr, \"\"%Y-%m-%d\"\")\n\n```\n2. `datetime` 2 `object`\n\n```\n    df[\"time_list\"] = df[\"time_list\"].strftime(\"%Y-%m-%d\")\n    \n    // Y 2019\n    // y  19\n    \n```\n\n## datetime 相关操作\n\n```\n    // 查看列元素的年，月，日，星期（整数型）\n    df[\"time\"].dt.year\n    df[\"time\"].dt.month\n    df[\"time\"].dt.day\n    df[\"time\"].dt.weekday  # 星期一是0\n    \n    // 一年中的第几天,第几周\n    df[\"time\"].dt.dayofyear\n    df[\"time\"].dt.weekofyear\n    // 查看列元素 某年的数据数量\n    df[df[\"time\"].dt.year == 2019].shape\n    \n    \n```\n## 时间运算\n\n1. 计算时间差\n\n```\n    // 计算时间差， 结果为timedelta\n    df[\"时间差\"] = df[\"时间1\"] - df[\"时间2\"]\n    \n    // 转换成 天数差\n    df[\"时间差\"].days\n```\n\n2. 计算未来日期\n\n```\n    // N天后的日期\n    // 天  days,   时 hours， 周 weeks\n    df[\"时间\"] = df[\"时间1\"] - timedelta(days=10)\n```\n\n\n\n\n","source":"_posts/pandas-时间-日期处理.md","raw":"---\ntitle: pandas-7时间&日期处理\nmathjax: true\ndate: 2019-08-06 08:42:00\ncategories: pandas系列教程\ntags: pandas\n---\n\n# pandas -7 时间&日期处理\n\n\n## pandas 常出现的时间格式\n\n- 字符串类型 `object`\n\n> 一般是字符串类型，pandas 储存string时 使用 narray， 每一个object 是一个指针\n\n- datetime 类型 `datetime64`\n\n\n- timedelta 类型\n\n> 表示时间差的数据类型\n\n## 类型转换\n\n1. ` object` 2 `datetime`\n\n```\n    // 方法1\n    df[1] = pd.to_datetime(df[1], format='%d.%m.%Y')\n    \n    # 指定format，速度会加快很多。\n    \n    // 方法2\n    dateStr = \"2019-02-03\"\n    \n    myDate = datetime.strptime(dateStr, \"\"%Y-%m-%d\"\")\n\n```\n2. `datetime` 2 `object`\n\n```\n    df[\"time_list\"] = df[\"time_list\"].strftime(\"%Y-%m-%d\")\n    \n    // Y 2019\n    // y  19\n    \n```\n\n## datetime 相关操作\n\n```\n    // 查看列元素的年，月，日，星期（整数型）\n    df[\"time\"].dt.year\n    df[\"time\"].dt.month\n    df[\"time\"].dt.day\n    df[\"time\"].dt.weekday  # 星期一是0\n    \n    // 一年中的第几天,第几周\n    df[\"time\"].dt.dayofyear\n    df[\"time\"].dt.weekofyear\n    // 查看列元素 某年的数据数量\n    df[df[\"time\"].dt.year == 2019].shape\n    \n    \n```\n## 时间运算\n\n1. 计算时间差\n\n```\n    // 计算时间差， 结果为timedelta\n    df[\"时间差\"] = df[\"时间1\"] - df[\"时间2\"]\n    \n    // 转换成 天数差\n    df[\"时间差\"].days\n```\n\n2. 计算未来日期\n\n```\n    // N天后的日期\n    // 天  days,   时 hours， 周 weeks\n    df[\"时间\"] = df[\"时间1\"] - timedelta(days=10)\n```\n\n\n\n\n","slug":"pandas-时间-日期处理","published":1,"updated":"2020-02-20T04:41:37.814Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephek001bt8pltwi7ob2q","content":"<h1 id=\"pandas-7-时间-amp-日期处理\"><a href=\"#pandas-7-时间-amp-日期处理\" class=\"headerlink\" title=\"pandas -7 时间&amp;日期处理\"></a>pandas -7 时间&amp;日期处理</h1><h2 id=\"pandas-常出现的时间格式\"><a href=\"#pandas-常出现的时间格式\" class=\"headerlink\" title=\"pandas 常出现的时间格式\"></a>pandas 常出现的时间格式</h2><ul>\n<li>字符串类型 <code>object</code></li>\n</ul>\n<blockquote>\n<p>一般是字符串类型，pandas 储存string时 使用 narray， 每一个object 是一个指针</p>\n</blockquote>\n<ul>\n<li>datetime 类型 <code>datetime64</code></li>\n</ul>\n<ul>\n<li>timedelta 类型</li>\n</ul>\n<blockquote>\n<p>表示时间差的数据类型</p>\n</blockquote>\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><ol>\n<li><code>object</code> 2 <code>datetime</code></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 方法1</span><br><span class=\"line\">df[1] = pd.to_datetime(df[1], format=&apos;%d.%m.%Y&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\"># 指定format，速度会加快很多。</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法2</span><br><span class=\"line\">dateStr = &quot;2019-02-03&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">myDate = datetime.strptime(dateStr, &quot;&quot;%Y-%m-%d&quot;&quot;)</span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>datetime</code> 2 <code>object</code></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df[&quot;time_list&quot;] = df[&quot;time_list&quot;].strftime(&quot;%Y-%m-%d&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">// Y 2019</span><br><span class=\"line\">// y  19</span><br></pre></td></tr></table></figure>\n<h2 id=\"datetime-相关操作\"><a href=\"#datetime-相关操作\" class=\"headerlink\" title=\"datetime 相关操作\"></a>datetime 相关操作</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 查看列元素的年，月，日，星期（整数型）</span><br><span class=\"line\">df[&quot;time&quot;].dt.year</span><br><span class=\"line\">df[&quot;time&quot;].dt.month</span><br><span class=\"line\">df[&quot;time&quot;].dt.day</span><br><span class=\"line\">df[&quot;time&quot;].dt.weekday  # 星期一是0</span><br><span class=\"line\"></span><br><span class=\"line\">// 一年中的第几天,第几周</span><br><span class=\"line\">df[&quot;time&quot;].dt.dayofyear</span><br><span class=\"line\">df[&quot;time&quot;].dt.weekofyear</span><br><span class=\"line\">// 查看列元素 某年的数据数量</span><br><span class=\"line\">df[df[&quot;time&quot;].dt.year == 2019].shape</span><br></pre></td></tr></table></figure>\n<h2 id=\"时间运算\"><a href=\"#时间运算\" class=\"headerlink\" title=\"时间运算\"></a>时间运算</h2><ol>\n<li>计算时间差</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 计算时间差， 结果为timedelta</span><br><span class=\"line\">df[&quot;时间差&quot;] = df[&quot;时间1&quot;] - df[&quot;时间2&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">// 转换成 天数差</span><br><span class=\"line\">df[&quot;时间差&quot;].days</span><br></pre></td></tr></table></figure>\n<ol>\n<li>计算未来日期</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// N天后的日期</span><br><span class=\"line\">// 天  days,   时 hours， 周 weeks</span><br><span class=\"line\">df[&quot;时间&quot;] = df[&quot;时间1&quot;] - timedelta(days=10)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"pandas-7-时间-amp-日期处理\"><a href=\"#pandas-7-时间-amp-日期处理\" class=\"headerlink\" title=\"pandas -7 时间&amp;日期处理\"></a>pandas -7 时间&amp;日期处理</h1><h2 id=\"pandas-常出现的时间格式\"><a href=\"#pandas-常出现的时间格式\" class=\"headerlink\" title=\"pandas 常出现的时间格式\"></a>pandas 常出现的时间格式</h2><ul>\n<li>字符串类型 <code>object</code></li>\n</ul>\n<blockquote>\n<p>一般是字符串类型，pandas 储存string时 使用 narray， 每一个object 是一个指针</p>\n</blockquote>\n<ul>\n<li>datetime 类型 <code>datetime64</code></li>\n</ul>\n<ul>\n<li>timedelta 类型</li>\n</ul>\n<blockquote>\n<p>表示时间差的数据类型</p>\n</blockquote>\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><ol>\n<li><code>object</code> 2 <code>datetime</code></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 方法1</span><br><span class=\"line\">df[1] = pd.to_datetime(df[1], format=&apos;%d.%m.%Y&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\"># 指定format，速度会加快很多。</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法2</span><br><span class=\"line\">dateStr = &quot;2019-02-03&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">myDate = datetime.strptime(dateStr, &quot;&quot;%Y-%m-%d&quot;&quot;)</span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>datetime</code> 2 <code>object</code></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df[&quot;time_list&quot;] = df[&quot;time_list&quot;].strftime(&quot;%Y-%m-%d&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">// Y 2019</span><br><span class=\"line\">// y  19</span><br></pre></td></tr></table></figure>\n<h2 id=\"datetime-相关操作\"><a href=\"#datetime-相关操作\" class=\"headerlink\" title=\"datetime 相关操作\"></a>datetime 相关操作</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 查看列元素的年，月，日，星期（整数型）</span><br><span class=\"line\">df[&quot;time&quot;].dt.year</span><br><span class=\"line\">df[&quot;time&quot;].dt.month</span><br><span class=\"line\">df[&quot;time&quot;].dt.day</span><br><span class=\"line\">df[&quot;time&quot;].dt.weekday  # 星期一是0</span><br><span class=\"line\"></span><br><span class=\"line\">// 一年中的第几天,第几周</span><br><span class=\"line\">df[&quot;time&quot;].dt.dayofyear</span><br><span class=\"line\">df[&quot;time&quot;].dt.weekofyear</span><br><span class=\"line\">// 查看列元素 某年的数据数量</span><br><span class=\"line\">df[df[&quot;time&quot;].dt.year == 2019].shape</span><br></pre></td></tr></table></figure>\n<h2 id=\"时间运算\"><a href=\"#时间运算\" class=\"headerlink\" title=\"时间运算\"></a>时间运算</h2><ol>\n<li>计算时间差</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 计算时间差， 结果为timedelta</span><br><span class=\"line\">df[&quot;时间差&quot;] = df[&quot;时间1&quot;] - df[&quot;时间2&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">// 转换成 天数差</span><br><span class=\"line\">df[&quot;时间差&quot;].days</span><br></pre></td></tr></table></figure>\n<ol>\n<li>计算未来日期</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// N天后的日期</span><br><span class=\"line\">// 天  days,   时 hours， 周 weeks</span><br><span class=\"line\">df[&quot;时间&quot;] = df[&quot;时间1&quot;] - timedelta(days=10)</span><br></pre></td></tr></table></figure>\n"},{"title":"pandas-5缺失值处理","mathjax":true,"date":"2019-08-09T01:33:30.000Z","_content":"\n# pandas -5 缺失值处理\n\n> 统计数据中存在缺失值是十分常见的问题, 而对于缺失值的处理，是数据挖掘的一个重要环节。pandas 有一系列的方法处理缺失值。\n\n## 缺失值的类型\n\n判断方法只记住万能的 `pd.isnull` 即可。\n\n> 数值\n\n\n      pd.isna\n      pd.isnull\n      np.isnan\n\n> 字符串\n\n\n      pd.isna\n      pd.isnull\n\n\n\n> 时间\n\n      pd.isna\n      pd.isnull\n      np.isnat\n\n\n## 缺失值的统计\n\n\n      df.isnull().sum()\n\n## 丢掉缺失值\n\n\n\t  // 某列有缺失值, 删除\n\t  df[ pd.isnull(df[\"columns\"])]\n\t  \n\t  // Series \n\t  df.columns.dropna()\n\t  \n\t  // DataFrame\n\t  // axis: axis=0 （默认）表示操作行，axis=1 表示操作列;\n\t\n\t  // how : any 表示一行/列有任意元素为空时即丢弃，all 一行/列所有值都为空时才丢弃。\n\t\n\t  // subset: 参数表示删除时只考虑的索引或列名。\n\t\n\t  // thresh: 比如 thresh=3，会在一行/列中至少有 3 个非空值时将其保留。\n\t  df.dropna(axis=0, how=\"any\", subset=[\"city\", \"sex\"])\n\n\n\n## 填充缺失值\n\n> 数据量少的情况下，直接丢掉不可取，可以适当补充数据。\n\n\n\n\t   // 前值填充 ffill     后值填充  bfill\n\t   df.columns.fillna(method = \"ffill\")\n\t   \n\t   // 实值填充\n\t   df.fillna(0)\n\t   \n\t   // 均值填充\n\t   df[\"columns\"].fillna(df[\"columns\"].mean(), inplace=True)\n\t   \n\t   // 众数\n\t   mode()[0]\n\t   \n\t   // 中位数\n\t   median()\n\n\n\n","source":"_posts/pandas-缺失值处理.md","raw":"---\ntitle: pandas-5缺失值处理\nmathjax: true\ndate: 2019-08-09 09:33:30\ncategories: pandas系列教程\ntags: pandas\n\n---\n\n# pandas -5 缺失值处理\n\n> 统计数据中存在缺失值是十分常见的问题, 而对于缺失值的处理，是数据挖掘的一个重要环节。pandas 有一系列的方法处理缺失值。\n\n## 缺失值的类型\n\n判断方法只记住万能的 `pd.isnull` 即可。\n\n> 数值\n\n\n      pd.isna\n      pd.isnull\n      np.isnan\n\n> 字符串\n\n\n      pd.isna\n      pd.isnull\n\n\n\n> 时间\n\n      pd.isna\n      pd.isnull\n      np.isnat\n\n\n## 缺失值的统计\n\n\n      df.isnull().sum()\n\n## 丢掉缺失值\n\n\n\t  // 某列有缺失值, 删除\n\t  df[ pd.isnull(df[\"columns\"])]\n\t  \n\t  // Series \n\t  df.columns.dropna()\n\t  \n\t  // DataFrame\n\t  // axis: axis=0 （默认）表示操作行，axis=1 表示操作列;\n\t\n\t  // how : any 表示一行/列有任意元素为空时即丢弃，all 一行/列所有值都为空时才丢弃。\n\t\n\t  // subset: 参数表示删除时只考虑的索引或列名。\n\t\n\t  // thresh: 比如 thresh=3，会在一行/列中至少有 3 个非空值时将其保留。\n\t  df.dropna(axis=0, how=\"any\", subset=[\"city\", \"sex\"])\n\n\n\n## 填充缺失值\n\n> 数据量少的情况下，直接丢掉不可取，可以适当补充数据。\n\n\n\n\t   // 前值填充 ffill     后值填充  bfill\n\t   df.columns.fillna(method = \"ffill\")\n\t   \n\t   // 实值填充\n\t   df.fillna(0)\n\t   \n\t   // 均值填充\n\t   df[\"columns\"].fillna(df[\"columns\"].mean(), inplace=True)\n\t   \n\t   // 众数\n\t   mode()[0]\n\t   \n\t   // 中位数\n\t   median()\n\n\n\n","slug":"pandas-缺失值处理","published":1,"updated":"2020-02-20T04:41:37.814Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8epheo001dt8plv6rpsqte","content":"<h1 id=\"pandas-5-缺失值处理\"><a href=\"#pandas-5-缺失值处理\" class=\"headerlink\" title=\"pandas -5 缺失值处理\"></a>pandas -5 缺失值处理</h1><blockquote>\n<p>统计数据中存在缺失值是十分常见的问题, 而对于缺失值的处理，是数据挖掘的一个重要环节。pandas 有一系列的方法处理缺失值。</p>\n</blockquote>\n<h2 id=\"缺失值的类型\"><a href=\"#缺失值的类型\" class=\"headerlink\" title=\"缺失值的类型\"></a>缺失值的类型</h2><p>判断方法只记住万能的 <code>pd.isnull</code> 即可。</p>\n<blockquote>\n<p>数值</p>\n</blockquote>\n<pre><code>  pd.isna\n  pd.isnull\n  np.isnan\n</code></pre><blockquote>\n<p>字符串</p>\n</blockquote>\n<pre><code>  pd.isna\n  pd.isnull\n</code></pre><blockquote>\n<p>时间</p>\n</blockquote>\n<pre><code>  pd.isna\n  pd.isnull\n  np.isnat\n</code></pre><h2 id=\"缺失值的统计\"><a href=\"#缺失值的统计\" class=\"headerlink\" title=\"缺失值的统计\"></a>缺失值的统计</h2><pre><code>  df.isnull().sum()\n</code></pre><h2 id=\"丢掉缺失值\"><a href=\"#丢掉缺失值\" class=\"headerlink\" title=\"丢掉缺失值\"></a>丢掉缺失值</h2><pre><code>  // 某列有缺失值, 删除\n  df[ pd.isnull(df[&quot;columns&quot;])]\n\n  // Series \n  df.columns.dropna()\n\n  // DataFrame\n  // axis: axis=0 （默认）表示操作行，axis=1 表示操作列;\n\n  // how : any 表示一行/列有任意元素为空时即丢弃，all 一行/列所有值都为空时才丢弃。\n\n  // subset: 参数表示删除时只考虑的索引或列名。\n\n  // thresh: 比如 thresh=3，会在一行/列中至少有 3 个非空值时将其保留。\n  df.dropna(axis=0, how=&quot;any&quot;, subset=[&quot;city&quot;, &quot;sex&quot;])\n</code></pre><h2 id=\"填充缺失值\"><a href=\"#填充缺失值\" class=\"headerlink\" title=\"填充缺失值\"></a>填充缺失值</h2><blockquote>\n<p>数据量少的情况下，直接丢掉不可取，可以适当补充数据。</p>\n</blockquote>\n<pre><code>   // 前值填充 ffill     后值填充  bfill\n   df.columns.fillna(method = &quot;ffill&quot;)\n\n   // 实值填充\n   df.fillna(0)\n\n   // 均值填充\n   df[&quot;columns&quot;].fillna(df[&quot;columns&quot;].mean(), inplace=True)\n\n   // 众数\n   mode()[0]\n\n   // 中位数\n   median()\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"pandas-5-缺失值处理\"><a href=\"#pandas-5-缺失值处理\" class=\"headerlink\" title=\"pandas -5 缺失值处理\"></a>pandas -5 缺失值处理</h1><blockquote>\n<p>统计数据中存在缺失值是十分常见的问题, 而对于缺失值的处理，是数据挖掘的一个重要环节。pandas 有一系列的方法处理缺失值。</p>\n</blockquote>\n<h2 id=\"缺失值的类型\"><a href=\"#缺失值的类型\" class=\"headerlink\" title=\"缺失值的类型\"></a>缺失值的类型</h2><p>判断方法只记住万能的 <code>pd.isnull</code> 即可。</p>\n<blockquote>\n<p>数值</p>\n</blockquote>\n<pre><code>  pd.isna\n  pd.isnull\n  np.isnan\n</code></pre><blockquote>\n<p>字符串</p>\n</blockquote>\n<pre><code>  pd.isna\n  pd.isnull\n</code></pre><blockquote>\n<p>时间</p>\n</blockquote>\n<pre><code>  pd.isna\n  pd.isnull\n  np.isnat\n</code></pre><h2 id=\"缺失值的统计\"><a href=\"#缺失值的统计\" class=\"headerlink\" title=\"缺失值的统计\"></a>缺失值的统计</h2><pre><code>  df.isnull().sum()\n</code></pre><h2 id=\"丢掉缺失值\"><a href=\"#丢掉缺失值\" class=\"headerlink\" title=\"丢掉缺失值\"></a>丢掉缺失值</h2><pre><code>  // 某列有缺失值, 删除\n  df[ pd.isnull(df[&quot;columns&quot;])]\n\n  // Series \n  df.columns.dropna()\n\n  // DataFrame\n  // axis: axis=0 （默认）表示操作行，axis=1 表示操作列;\n\n  // how : any 表示一行/列有任意元素为空时即丢弃，all 一行/列所有值都为空时才丢弃。\n\n  // subset: 参数表示删除时只考虑的索引或列名。\n\n  // thresh: 比如 thresh=3，会在一行/列中至少有 3 个非空值时将其保留。\n  df.dropna(axis=0, how=&quot;any&quot;, subset=[&quot;city&quot;, &quot;sex&quot;])\n</code></pre><h2 id=\"填充缺失值\"><a href=\"#填充缺失值\" class=\"headerlink\" title=\"填充缺失值\"></a>填充缺失值</h2><blockquote>\n<p>数据量少的情况下，直接丢掉不可取，可以适当补充数据。</p>\n</blockquote>\n<pre><code>   // 前值填充 ffill     后值填充  bfill\n   df.columns.fillna(method = &quot;ffill&quot;)\n\n   // 实值填充\n   df.fillna(0)\n\n   // 均值填充\n   df[&quot;columns&quot;].fillna(df[&quot;columns&quot;].mean(), inplace=True)\n\n   // 众数\n   mode()[0]\n\n   // 中位数\n   median()\n</code></pre>"},{"title":"redis学习-redis的价值","date":"2020-05-11T16:06:27.000Z","_content":"\n[toc]\n> 本系列文章整理摘抄自<Redis 开发与运维>\n# Redis 是什么？\n\nRedis 是一种 基于键值对的 `NOSQL` 内存数据库, 具有丰富的数据类型和基于内存的快速读写能力,单线程命令处理机制。\n\nRedis 的值类型有多种：\n\n- string\n- hash\n- list\n- set\n- zset (有序集合)\n- Bitmaps (位图)\n- HyperLogLog\n- GEO  (地理信息定位)\n\nRedis 提供了一下的附加功能：\n\n- 键的有效期\n- 发布订阅\n- 事务\n- Pipeline 流水线\n- Lua脚本\n- 可持久化（RDB 和 AOF 两种策略）\n\n\n# Redis 有哪些特点？\n\nRedis 有5大重要的特征：\n\n- **读写速度快**（读写速度可达10万/秒）\n    - 基于内存\n    - C 语言实现\n    - 单线程架构（IO多路模型），省却了线程间调度\n-  **基于键值对的字典服务器**\n-  **可持久化**\n-  **主从复制**\n-  **高可用 & 分布式**\n\n\n# Redis 应用场景有哪些？ \n\n- 缓存\n- 排行榜系统(提供列表和有序集合)\n- 计数器 （网站播放数，电商浏览数）\n- 社交网络（点赞，粉丝，共同爱好，推送，下拉刷新）\n- 消息队列\n- session 共享\n- 限制访问的次数\n\n# 为什么选择单线程？\n\n官方的解释：\n\n我们知道，运算和处理速度上，CPU >>> 内存 >>> 硬盘和网络。\n\n- 原因1：**单线程内存读写速度优于多线程的并发切换消耗**\n\nCPU并不是Redis的瓶颈，因为通常Redis要么受内存限制，要么受网络限制，而多线程的线程调度消耗的资源要比在内存读取数据大得多，所以选择了单线程 + IO 多路复用模型。\n\n- 原因2：**数据的一致性**\n\n单线程的操作，一定是线程安全的，并且避免了使用锁同步等。\n\n<font color=red size=4>为了最大程度地利用CPU，可以在同一服务器上启动多个Redis实例，并为每个实例绑定一个CPU.  (Linux 通过 `taskset -c 1,2,3 /etc/init.d/mysql start`)</font>\n\n# Redis 的不足之处？\n\n数据有冷热之分，热点数据可以放在Redis 中，加速读写，减少对后端数据库的访问压力。\n\n但是过于冷的数据，会浪费内存空间。\n\n\n# 与同类型的技术的横向对比？","source":"_posts/redis学习-redis的价值.md","raw":"---\ntitle: redis学习-redis的价值\ndate: 2020-05-12 00:06:27\ncategories: 缓存中间件\ntags: redis\n---\n\n[toc]\n> 本系列文章整理摘抄自<Redis 开发与运维>\n# Redis 是什么？\n\nRedis 是一种 基于键值对的 `NOSQL` 内存数据库, 具有丰富的数据类型和基于内存的快速读写能力,单线程命令处理机制。\n\nRedis 的值类型有多种：\n\n- string\n- hash\n- list\n- set\n- zset (有序集合)\n- Bitmaps (位图)\n- HyperLogLog\n- GEO  (地理信息定位)\n\nRedis 提供了一下的附加功能：\n\n- 键的有效期\n- 发布订阅\n- 事务\n- Pipeline 流水线\n- Lua脚本\n- 可持久化（RDB 和 AOF 两种策略）\n\n\n# Redis 有哪些特点？\n\nRedis 有5大重要的特征：\n\n- **读写速度快**（读写速度可达10万/秒）\n    - 基于内存\n    - C 语言实现\n    - 单线程架构（IO多路模型），省却了线程间调度\n-  **基于键值对的字典服务器**\n-  **可持久化**\n-  **主从复制**\n-  **高可用 & 分布式**\n\n\n# Redis 应用场景有哪些？ \n\n- 缓存\n- 排行榜系统(提供列表和有序集合)\n- 计数器 （网站播放数，电商浏览数）\n- 社交网络（点赞，粉丝，共同爱好，推送，下拉刷新）\n- 消息队列\n- session 共享\n- 限制访问的次数\n\n# 为什么选择单线程？\n\n官方的解释：\n\n我们知道，运算和处理速度上，CPU >>> 内存 >>> 硬盘和网络。\n\n- 原因1：**单线程内存读写速度优于多线程的并发切换消耗**\n\nCPU并不是Redis的瓶颈，因为通常Redis要么受内存限制，要么受网络限制，而多线程的线程调度消耗的资源要比在内存读取数据大得多，所以选择了单线程 + IO 多路复用模型。\n\n- 原因2：**数据的一致性**\n\n单线程的操作，一定是线程安全的，并且避免了使用锁同步等。\n\n<font color=red size=4>为了最大程度地利用CPU，可以在同一服务器上启动多个Redis实例，并为每个实例绑定一个CPU.  (Linux 通过 `taskset -c 1,2,3 /etc/init.d/mysql start`)</font>\n\n# Redis 的不足之处？\n\n数据有冷热之分，热点数据可以放在Redis 中，加速读写，减少对后端数据库的访问压力。\n\n但是过于冷的数据，会浪费内存空间。\n\n\n# 与同类型的技术的横向对比？","slug":"redis学习-redis的价值","published":1,"updated":"2020-05-15T16:08:18.775Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephes001ht8plrshu3hn4","content":"<p>[toc]</p>\n<blockquote>\n<p>本系列文章整理摘抄自<redis 开发与运维=\"\"></redis></p>\n<h1 id=\"Redis-是什么？\"><a href=\"#Redis-是什么？\" class=\"headerlink\" title=\"Redis 是什么？\"></a>Redis 是什么？</h1></blockquote>\n<p>Redis 是一种 基于键值对的 <code>NOSQL</code> 内存数据库, 具有丰富的数据类型和基于内存的快速读写能力,单线程命令处理机制。</p>\n<p>Redis 的值类型有多种：</p>\n<ul>\n<li>string</li>\n<li>hash</li>\n<li>list</li>\n<li>set</li>\n<li>zset (有序集合)</li>\n<li>Bitmaps (位图)</li>\n<li>HyperLogLog</li>\n<li>GEO  (地理信息定位)</li>\n</ul>\n<p>Redis 提供了一下的附加功能：</p>\n<ul>\n<li>键的有效期</li>\n<li>发布订阅</li>\n<li>事务</li>\n<li>Pipeline 流水线</li>\n<li>Lua脚本</li>\n<li>可持久化（RDB 和 AOF 两种策略）</li>\n</ul>\n<h1 id=\"Redis-有哪些特点？\"><a href=\"#Redis-有哪些特点？\" class=\"headerlink\" title=\"Redis 有哪些特点？\"></a>Redis 有哪些特点？</h1><p>Redis 有5大重要的特征：</p>\n<ul>\n<li><strong>读写速度快</strong>（读写速度可达10万/秒）<ul>\n<li>基于内存</li>\n<li>C 语言实现</li>\n<li>单线程架构（IO多路模型），省却了线程间调度</li>\n</ul>\n</li>\n<li><strong>基于键值对的字典服务器</strong></li>\n<li><strong>可持久化</strong></li>\n<li><strong>主从复制</strong></li>\n<li><strong>高可用 &amp; 分布式</strong></li>\n</ul>\n<h1 id=\"Redis-应用场景有哪些？\"><a href=\"#Redis-应用场景有哪些？\" class=\"headerlink\" title=\"Redis 应用场景有哪些？\"></a>Redis 应用场景有哪些？</h1><ul>\n<li>缓存</li>\n<li>排行榜系统(提供列表和有序集合)</li>\n<li>计数器 （网站播放数，电商浏览数）</li>\n<li>社交网络（点赞，粉丝，共同爱好，推送，下拉刷新）</li>\n<li>消息队列</li>\n<li>session 共享</li>\n<li>限制访问的次数</li>\n</ul>\n<h1 id=\"为什么选择单线程？\"><a href=\"#为什么选择单线程？\" class=\"headerlink\" title=\"为什么选择单线程？\"></a>为什么选择单线程？</h1><p>官方的解释：</p>\n<p>我们知道，运算和处理速度上，CPU &gt;&gt;&gt; 内存 &gt;&gt;&gt; 硬盘和网络。</p>\n<ul>\n<li>原因1：<strong>单线程内存读写速度优于多线程的并发切换消耗</strong></li>\n</ul>\n<p>CPU并不是Redis的瓶颈，因为通常Redis要么受内存限制，要么受网络限制，而多线程的线程调度消耗的资源要比在内存读取数据大得多，所以选择了单线程 + IO 多路复用模型。</p>\n<ul>\n<li>原因2：<strong>数据的一致性</strong></li>\n</ul>\n<p>单线程的操作，一定是线程安全的，并且避免了使用锁同步等。</p>\n<font color=\"red\" size=\"4\">为了最大程度地利用CPU，可以在同一服务器上启动多个Redis实例，并为每个实例绑定一个CPU.  (Linux 通过 `taskset -c 1,2,3 /etc/init.d/mysql start`)</font>\n\n<h1 id=\"Redis-的不足之处？\"><a href=\"#Redis-的不足之处？\" class=\"headerlink\" title=\"Redis 的不足之处？\"></a>Redis 的不足之处？</h1><p>数据有冷热之分，热点数据可以放在Redis 中，加速读写，减少对后端数据库的访问压力。</p>\n<p>但是过于冷的数据，会浪费内存空间。</p>\n<h1 id=\"与同类型的技术的横向对比？\"><a href=\"#与同类型的技术的横向对比？\" class=\"headerlink\" title=\"与同类型的技术的横向对比？\"></a>与同类型的技术的横向对比？</h1>","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<blockquote>\n<p>本系列文章整理摘抄自<redis 开发与运维=\"\"></redis></p>\n<h1 id=\"Redis-是什么？\"><a href=\"#Redis-是什么？\" class=\"headerlink\" title=\"Redis 是什么？\"></a>Redis 是什么？</h1></blockquote>\n<p>Redis 是一种 基于键值对的 <code>NOSQL</code> 内存数据库, 具有丰富的数据类型和基于内存的快速读写能力,单线程命令处理机制。</p>\n<p>Redis 的值类型有多种：</p>\n<ul>\n<li>string</li>\n<li>hash</li>\n<li>list</li>\n<li>set</li>\n<li>zset (有序集合)</li>\n<li>Bitmaps (位图)</li>\n<li>HyperLogLog</li>\n<li>GEO  (地理信息定位)</li>\n</ul>\n<p>Redis 提供了一下的附加功能：</p>\n<ul>\n<li>键的有效期</li>\n<li>发布订阅</li>\n<li>事务</li>\n<li>Pipeline 流水线</li>\n<li>Lua脚本</li>\n<li>可持久化（RDB 和 AOF 两种策略）</li>\n</ul>\n<h1 id=\"Redis-有哪些特点？\"><a href=\"#Redis-有哪些特点？\" class=\"headerlink\" title=\"Redis 有哪些特点？\"></a>Redis 有哪些特点？</h1><p>Redis 有5大重要的特征：</p>\n<ul>\n<li><strong>读写速度快</strong>（读写速度可达10万/秒）<ul>\n<li>基于内存</li>\n<li>C 语言实现</li>\n<li>单线程架构（IO多路模型），省却了线程间调度</li>\n</ul>\n</li>\n<li><strong>基于键值对的字典服务器</strong></li>\n<li><strong>可持久化</strong></li>\n<li><strong>主从复制</strong></li>\n<li><strong>高可用 &amp; 分布式</strong></li>\n</ul>\n<h1 id=\"Redis-应用场景有哪些？\"><a href=\"#Redis-应用场景有哪些？\" class=\"headerlink\" title=\"Redis 应用场景有哪些？\"></a>Redis 应用场景有哪些？</h1><ul>\n<li>缓存</li>\n<li>排行榜系统(提供列表和有序集合)</li>\n<li>计数器 （网站播放数，电商浏览数）</li>\n<li>社交网络（点赞，粉丝，共同爱好，推送，下拉刷新）</li>\n<li>消息队列</li>\n<li>session 共享</li>\n<li>限制访问的次数</li>\n</ul>\n<h1 id=\"为什么选择单线程？\"><a href=\"#为什么选择单线程？\" class=\"headerlink\" title=\"为什么选择单线程？\"></a>为什么选择单线程？</h1><p>官方的解释：</p>\n<p>我们知道，运算和处理速度上，CPU &gt;&gt;&gt; 内存 &gt;&gt;&gt; 硬盘和网络。</p>\n<ul>\n<li>原因1：<strong>单线程内存读写速度优于多线程的并发切换消耗</strong></li>\n</ul>\n<p>CPU并不是Redis的瓶颈，因为通常Redis要么受内存限制，要么受网络限制，而多线程的线程调度消耗的资源要比在内存读取数据大得多，所以选择了单线程 + IO 多路复用模型。</p>\n<ul>\n<li>原因2：<strong>数据的一致性</strong></li>\n</ul>\n<p>单线程的操作，一定是线程安全的，并且避免了使用锁同步等。</p>\n<font color=\"red\" size=\"4\">为了最大程度地利用CPU，可以在同一服务器上启动多个Redis实例，并为每个实例绑定一个CPU.  (Linux 通过 `taskset -c 1,2,3 /etc/init.d/mysql start`)</font>\n\n<h1 id=\"Redis-的不足之处？\"><a href=\"#Redis-的不足之处？\" class=\"headerlink\" title=\"Redis 的不足之处？\"></a>Redis 的不足之处？</h1><p>数据有冷热之分，热点数据可以放在Redis 中，加速读写，减少对后端数据库的访问压力。</p>\n<p>但是过于冷的数据，会浪费内存空间。</p>\n<h1 id=\"与同类型的技术的横向对比？\"><a href=\"#与同类型的技术的横向对比？\" class=\"headerlink\" title=\"与同类型的技术的横向对比？\"></a>与同类型的技术的横向对比？</h1>"},{"title":"redis学习-Jedis 使用","date":"2020-05-15T16:17:58.000Z","_content":"\n[toc] \n\n[toc]\n> 本系列文章整理摘抄自<Redis 开发与运维>\n\n# 客户端怎么和 Redis 服务器连接？\n\n客户端和 Redis 服务器的通信是 建立在 TCP 连接的基础上的。\n\n并且 Redis 制定了 RESP 序列化协议，是一个简单地通信约定。\n\n## Resp序列化协议\n\n`*<参数数量>\\r\\n$<参数1的字节数量>\\r\\n<参数1>\\r\\n$<参数2的字节数量>\\r\\n<参数2>\\r\\n`\n\n来给可视化一下：\n```\n*<参数数量>\\r\\n\n$<参数1的字节数量>\\r\\n\n<参数1>\\r\\n\n$<参数2的字节数量>\\r\\n\n<参数2>\\r\\n\n```\n\n其他可以参考该书章节。\n\n# Jedis 连接池的使用\n\n简单的API 介绍\n\n**获取 jedis连接**\n```\nJedis jedis = new Jedis(\"127.0.0.1\", 6379);\n\nJedis jedis = null;\ntry {\n    jedis = new Jedis(\"127.0.0.1\", 6379);\n    \n} catch (Exception e) {\n    logger.error(e.getMessage(),e);\n} finally {\n    if (jedis != null) {\n        jedis.close();\n    }\n}\n```\n\n\n```\n//  String\njedis.set(\"key\", \"value\");\njedis.get(\"key\")\n\n\n//  hset -字典\njedis.set(\"hash\", \"key1\", \"value1\");\njedis.set(\"hash\", \"key2\", \"value2\");\njedis.get(\"key1\")\n\n//  list -列表\njedis.rpush(\"mylist\", \"1\");\n\n\n// set -集合\njedis.sadd(\"set\", \"aaa\");\n\n....\n\n\n```\n\n## springboot 环境下的使用\n\n### 1. maven 依赖\n```\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>3.1.0</version>\n</dependency>\n\n\n<dependency>\n\t<groupId>org.slf4j</groupId>\n\t<artifactId>slf4j-log4j12</artifactId>\n\t<version>1.4.2</version>\n</dependency>\n\n<dependency>\n\t<groupId>log4j</groupId>\n\t<artifactId>log4j</artifactId>\n\t<version>1.2.14</version>\n</dependency>\n```\n\n### 2. 代码实现\n\n**配置类 -> 从 application.preperties 读取配置项，并且配置**\n```\n@Component\n@ConfigurationProperties(prefix = \"redis\")\npublic class RedisConfig {\n  // 私有属性 \n    \n  // 配置项\n  get... set...\n}\n```\n\n**poolFactory 工厂类创建 pool**\n```\n@Component\npublic class RedisPoolFactory {\n\n    // 注入配置项\n    @Autowired\n    RedisConfig redisConfig;\n\n    // Bean注解 ： 根据方法创建对象，类型是JedisPool\n    @Bean\n    public JedisPool JedisPoolFactory(){\n\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        \n        // 各种配置\n        poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle());\n        poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal());\n        poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxTotal()*1000);\n\n        JedisPool jedisPool = new JedisPool(poolConfig, redisConfig.getHost(),                                      redisConfig.getPort(),                                                  redisConfig.getTimeout()*1000,                                          redisConfig.getPassword(), 0);\n\n        return jedisPool;\n}\n```\n\n\n**Redis 服务类 开始封装各种服务**\n\n当然，也要为服务模块化，比如 `RedisUserService`, `RedisMiaoshaService`\n\n```\n@Service\n public class RedisService {\n    // 注入，@Bean 产生的jedisPool\n    @Autowired\n    JedisPool jedisPool;\n    \n    public <T> boolean set(IProfixForKey prefix, String key, T value){\n\n        Jedis resource = null;\n        try{\n            // 拿到连接\n            resource = jedisPool.getResource();\n            \n            // 封装一下key, 加上特点的头信息，例如： dbName:tableName:id\n            String strValue = beanToString(value);\n    \n            // 生成key\n            String realKey = prefix.getPrefix() + key;\n    \n            if (strValue == null || strValue.length() <= 0){\n                return false;\n            }\n            \n            // 设置\n            resource.set(realKey, strValue);\n    \n            return true;\n        }finally {\n            returnToPool(resource);\n        }\n\n    }\n }\n```\n\n\n## 非 spring 环境下的使用\n\n举个例子，不知道合不合适。\n\n**单例模式 来创建 JedisPool**\n```\npublic class JedisFactory {\n\n    private volatile  static JedisPool jedisPool;\n\n    private volatile static JedisPoolConfig poolConfig;\n    private volatile static String ip;\n    private volatile static int port;\n    private volatile static int timeout;\n    private volatile static String password;\n    private volatile static int database;\n\n    private JedisFactory() {\n\n        //JedisPoolConfig poolConfig, String ip, int port, int timeout, String password, int database\n        /* apache common-pool 工具\n        *\n        * JedisPoolConfig\n        * */\n        this.jedisPool = new JedisPool(poolConfig, ip, port, timeout , password, 0);\n    }\n\n\n    public static JedisPool getJedisPool(){\n\n        if (jedisPool == null){\n\n            synchronized (JedisFactory.class){\n\n                if (jedisPool == null){\n                    jedisPool = new JedisPool(JedisFactory.poolConfig, JedisFactory.ip, JedisFactory.port,\n                                              JedisFactory.timeout,  JedisFactory.password, JedisFactory.database);\n                }\n            }\n        }\n\n        return jedisPool;\n    }\n\n    public static void setJedisPoolConfig(JedisPoolConfig poolConfig, String ip, int port, int timeout, String password, int database){\n\n        System.out.println(\" 配置jedis 参数...\");\n        JedisFactory.poolConfig = poolConfig;\n        JedisFactory.ip = ip;\n        JedisFactory.port = port;\n        JedisFactory.timeout = timeout * 1000;\n        JedisFactory.password = password;\n        JedisFactory.database = database;\n\n    }\n}\n```\n\n**JedisService**\n\n```\n\npackage top.elgong.jedis;\n\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\n/*\n*\n*   解决redis 用到的\n* */\npublic class JedisService {\n\n    /**\n     *\n     * @param key\n     * @param value\n     */\n    public void set(String key, String value){\n        Jedis resource = null;\n        try{\n            JedisPool jedisPool = JedisFactory.getJedisPool();\n\n            resource = jedisPool.getResource();\n\n            resource.set(key, value);\n\n        }catch (Exception e){\n            e.printStackTrace();\n        }finally {\n\n            // 送回连接池中\n            if (resource != null){\n                resource.close();  // close 就是送回池子\n            }\n        }\n    }\n\n    /*\n    *\n    * */\n    public String get(String key){\n        Jedis resource = null;\n        String ret = null;\n        try{\n            JedisPool jedisPool = JedisFactory.getJedisPool();\n            resource = jedisPool.getResource();\n\n            ret = resource.get(key);\n\n\n        }catch (Exception e){\n            e.printStackTrace();\n        }finally {\n            // 送回连接池中\n            if (resource != null){\n                resource.close();  // close 就是送回池子\n            }\n        }\n\n        return ret;\n    }\n\n}\n\n```\n\n**test**\n```\npackage top.elgong.jedis;\n\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPoolConfig;\n\nimport java.time.LocalDateTime;\n\npublic class Test {\n\n    public static JedisService jedisService = new JedisService();\n    public static void main(String[] args) {\n\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        String ip = \"121.41.111.45\";\n        int port = 6379;\n        int timeout = 300;\n        String password = \"Gelqq666%\";\n        int database = 0;\n\n        JedisFactory.setJedisPoolConfig(poolConfig, ip, port, timeout, password, database);\n\n        jedisService.set(\"leetcode-java:jedis:test:key1\", \"haha-\" + LocalDateTime.now().toString());\n\n        String s = jedisService.get(\"leetcode-java:jedis:test:key1\");\n\n        System.out.println(s);\n    }\n}\n\n```\n\n# Jedis Pipline 的使用\n\n```\nJedis jedis = new Jedis(\"127.0.0.1\");\n\n// 1)生成pipeline对象\nPipeline pipeline = jedis.pipelined();\n\n// 2)pipeline执行命令， 注意此时命令并未真正执行\nfor (String key : keys) {\n    pipeline.del(key);\n}\n\n// 3)执行命令\npipeline.sync();\n```\n\n# Jedis Lua 脚本\n\n待补充。。","source":"_posts/redis学习-Jedis-使用.md","raw":"---\ntitle: redis学习-Jedis 使用\ndate: 2020-05-16 00:17:58\ncategories: 缓存中间件\ntags: redis, jedis\n---\n\n[toc] \n\n[toc]\n> 本系列文章整理摘抄自<Redis 开发与运维>\n\n# 客户端怎么和 Redis 服务器连接？\n\n客户端和 Redis 服务器的通信是 建立在 TCP 连接的基础上的。\n\n并且 Redis 制定了 RESP 序列化协议，是一个简单地通信约定。\n\n## Resp序列化协议\n\n`*<参数数量>\\r\\n$<参数1的字节数量>\\r\\n<参数1>\\r\\n$<参数2的字节数量>\\r\\n<参数2>\\r\\n`\n\n来给可视化一下：\n```\n*<参数数量>\\r\\n\n$<参数1的字节数量>\\r\\n\n<参数1>\\r\\n\n$<参数2的字节数量>\\r\\n\n<参数2>\\r\\n\n```\n\n其他可以参考该书章节。\n\n# Jedis 连接池的使用\n\n简单的API 介绍\n\n**获取 jedis连接**\n```\nJedis jedis = new Jedis(\"127.0.0.1\", 6379);\n\nJedis jedis = null;\ntry {\n    jedis = new Jedis(\"127.0.0.1\", 6379);\n    \n} catch (Exception e) {\n    logger.error(e.getMessage(),e);\n} finally {\n    if (jedis != null) {\n        jedis.close();\n    }\n}\n```\n\n\n```\n//  String\njedis.set(\"key\", \"value\");\njedis.get(\"key\")\n\n\n//  hset -字典\njedis.set(\"hash\", \"key1\", \"value1\");\njedis.set(\"hash\", \"key2\", \"value2\");\njedis.get(\"key1\")\n\n//  list -列表\njedis.rpush(\"mylist\", \"1\");\n\n\n// set -集合\njedis.sadd(\"set\", \"aaa\");\n\n....\n\n\n```\n\n## springboot 环境下的使用\n\n### 1. maven 依赖\n```\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>3.1.0</version>\n</dependency>\n\n\n<dependency>\n\t<groupId>org.slf4j</groupId>\n\t<artifactId>slf4j-log4j12</artifactId>\n\t<version>1.4.2</version>\n</dependency>\n\n<dependency>\n\t<groupId>log4j</groupId>\n\t<artifactId>log4j</artifactId>\n\t<version>1.2.14</version>\n</dependency>\n```\n\n### 2. 代码实现\n\n**配置类 -> 从 application.preperties 读取配置项，并且配置**\n```\n@Component\n@ConfigurationProperties(prefix = \"redis\")\npublic class RedisConfig {\n  // 私有属性 \n    \n  // 配置项\n  get... set...\n}\n```\n\n**poolFactory 工厂类创建 pool**\n```\n@Component\npublic class RedisPoolFactory {\n\n    // 注入配置项\n    @Autowired\n    RedisConfig redisConfig;\n\n    // Bean注解 ： 根据方法创建对象，类型是JedisPool\n    @Bean\n    public JedisPool JedisPoolFactory(){\n\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        \n        // 各种配置\n        poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle());\n        poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal());\n        poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxTotal()*1000);\n\n        JedisPool jedisPool = new JedisPool(poolConfig, redisConfig.getHost(),                                      redisConfig.getPort(),                                                  redisConfig.getTimeout()*1000,                                          redisConfig.getPassword(), 0);\n\n        return jedisPool;\n}\n```\n\n\n**Redis 服务类 开始封装各种服务**\n\n当然，也要为服务模块化，比如 `RedisUserService`, `RedisMiaoshaService`\n\n```\n@Service\n public class RedisService {\n    // 注入，@Bean 产生的jedisPool\n    @Autowired\n    JedisPool jedisPool;\n    \n    public <T> boolean set(IProfixForKey prefix, String key, T value){\n\n        Jedis resource = null;\n        try{\n            // 拿到连接\n            resource = jedisPool.getResource();\n            \n            // 封装一下key, 加上特点的头信息，例如： dbName:tableName:id\n            String strValue = beanToString(value);\n    \n            // 生成key\n            String realKey = prefix.getPrefix() + key;\n    \n            if (strValue == null || strValue.length() <= 0){\n                return false;\n            }\n            \n            // 设置\n            resource.set(realKey, strValue);\n    \n            return true;\n        }finally {\n            returnToPool(resource);\n        }\n\n    }\n }\n```\n\n\n## 非 spring 环境下的使用\n\n举个例子，不知道合不合适。\n\n**单例模式 来创建 JedisPool**\n```\npublic class JedisFactory {\n\n    private volatile  static JedisPool jedisPool;\n\n    private volatile static JedisPoolConfig poolConfig;\n    private volatile static String ip;\n    private volatile static int port;\n    private volatile static int timeout;\n    private volatile static String password;\n    private volatile static int database;\n\n    private JedisFactory() {\n\n        //JedisPoolConfig poolConfig, String ip, int port, int timeout, String password, int database\n        /* apache common-pool 工具\n        *\n        * JedisPoolConfig\n        * */\n        this.jedisPool = new JedisPool(poolConfig, ip, port, timeout , password, 0);\n    }\n\n\n    public static JedisPool getJedisPool(){\n\n        if (jedisPool == null){\n\n            synchronized (JedisFactory.class){\n\n                if (jedisPool == null){\n                    jedisPool = new JedisPool(JedisFactory.poolConfig, JedisFactory.ip, JedisFactory.port,\n                                              JedisFactory.timeout,  JedisFactory.password, JedisFactory.database);\n                }\n            }\n        }\n\n        return jedisPool;\n    }\n\n    public static void setJedisPoolConfig(JedisPoolConfig poolConfig, String ip, int port, int timeout, String password, int database){\n\n        System.out.println(\" 配置jedis 参数...\");\n        JedisFactory.poolConfig = poolConfig;\n        JedisFactory.ip = ip;\n        JedisFactory.port = port;\n        JedisFactory.timeout = timeout * 1000;\n        JedisFactory.password = password;\n        JedisFactory.database = database;\n\n    }\n}\n```\n\n**JedisService**\n\n```\n\npackage top.elgong.jedis;\n\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\n/*\n*\n*   解决redis 用到的\n* */\npublic class JedisService {\n\n    /**\n     *\n     * @param key\n     * @param value\n     */\n    public void set(String key, String value){\n        Jedis resource = null;\n        try{\n            JedisPool jedisPool = JedisFactory.getJedisPool();\n\n            resource = jedisPool.getResource();\n\n            resource.set(key, value);\n\n        }catch (Exception e){\n            e.printStackTrace();\n        }finally {\n\n            // 送回连接池中\n            if (resource != null){\n                resource.close();  // close 就是送回池子\n            }\n        }\n    }\n\n    /*\n    *\n    * */\n    public String get(String key){\n        Jedis resource = null;\n        String ret = null;\n        try{\n            JedisPool jedisPool = JedisFactory.getJedisPool();\n            resource = jedisPool.getResource();\n\n            ret = resource.get(key);\n\n\n        }catch (Exception e){\n            e.printStackTrace();\n        }finally {\n            // 送回连接池中\n            if (resource != null){\n                resource.close();  // close 就是送回池子\n            }\n        }\n\n        return ret;\n    }\n\n}\n\n```\n\n**test**\n```\npackage top.elgong.jedis;\n\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPoolConfig;\n\nimport java.time.LocalDateTime;\n\npublic class Test {\n\n    public static JedisService jedisService = new JedisService();\n    public static void main(String[] args) {\n\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        String ip = \"121.41.111.45\";\n        int port = 6379;\n        int timeout = 300;\n        String password = \"Gelqq666%\";\n        int database = 0;\n\n        JedisFactory.setJedisPoolConfig(poolConfig, ip, port, timeout, password, database);\n\n        jedisService.set(\"leetcode-java:jedis:test:key1\", \"haha-\" + LocalDateTime.now().toString());\n\n        String s = jedisService.get(\"leetcode-java:jedis:test:key1\");\n\n        System.out.println(s);\n    }\n}\n\n```\n\n# Jedis Pipline 的使用\n\n```\nJedis jedis = new Jedis(\"127.0.0.1\");\n\n// 1)生成pipeline对象\nPipeline pipeline = jedis.pipelined();\n\n// 2)pipeline执行命令， 注意此时命令并未真正执行\nfor (String key : keys) {\n    pipeline.del(key);\n}\n\n// 3)执行命令\npipeline.sync();\n```\n\n# Jedis Lua 脚本\n\n待补充。。","slug":"redis学习-Jedis-使用","published":1,"updated":"2020-05-15T16:18:37.101Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephev001jt8pld32fzlt4","content":"<p>[toc] </p>\n<p>[toc]</p>\n<blockquote>\n<p>本系列文章整理摘抄自<redis 开发与运维=\"\"></redis></p>\n</blockquote>\n<h1 id=\"客户端怎么和-Redis-服务器连接？\"><a href=\"#客户端怎么和-Redis-服务器连接？\" class=\"headerlink\" title=\"客户端怎么和 Redis 服务器连接？\"></a>客户端怎么和 Redis 服务器连接？</h1><p>客户端和 Redis 服务器的通信是 建立在 TCP 连接的基础上的。</p>\n<p>并且 Redis 制定了 RESP 序列化协议，是一个简单地通信约定。</p>\n<h2 id=\"Resp序列化协议\"><a href=\"#Resp序列化协议\" class=\"headerlink\" title=\"Resp序列化协议\"></a>Resp序列化协议</h2><p><code>*&lt;参数数量&gt;\\r\\n$&lt;参数1的字节数量&gt;\\r\\n&lt;参数1&gt;\\r\\n$&lt;参数2的字节数量&gt;\\r\\n&lt;参数2&gt;\\r\\n</code></p>\n<p>来给可视化一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*&lt;参数数量&gt;\\r\\n</span><br><span class=\"line\">$&lt;参数1的字节数量&gt;\\r\\n</span><br><span class=\"line\">&lt;参数1&gt;\\r\\n</span><br><span class=\"line\">$&lt;参数2的字节数量&gt;\\r\\n</span><br><span class=\"line\">&lt;参数2&gt;\\r\\n</span><br></pre></td></tr></table></figure></p>\n<p>其他可以参考该书章节。</p>\n<h1 id=\"Jedis-连接池的使用\"><a href=\"#Jedis-连接池的使用\" class=\"headerlink\" title=\"Jedis 连接池的使用\"></a>Jedis 连接池的使用</h1><p>简单的API 介绍</p>\n<p><strong>获取 jedis连接</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class=\"line\"></span><br><span class=\"line\">Jedis jedis = null;</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">    jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125; catch (Exception e) &#123;</span><br><span class=\"line\">    logger.error(e.getMessage(),e);</span><br><span class=\"line\">&#125; finally &#123;</span><br><span class=\"line\">    if (jedis != null) &#123;</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  String</span><br><span class=\"line\">jedis.set(&quot;key&quot;, &quot;value&quot;);</span><br><span class=\"line\">jedis.get(&quot;key&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//  hset -字典</span><br><span class=\"line\">jedis.set(&quot;hash&quot;, &quot;key1&quot;, &quot;value1&quot;);</span><br><span class=\"line\">jedis.set(&quot;hash&quot;, &quot;key2&quot;, &quot;value2&quot;);</span><br><span class=\"line\">jedis.get(&quot;key1&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">//  list -列表</span><br><span class=\"line\">jedis.rpush(&quot;mylist&quot;, &quot;1&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// set -集合</span><br><span class=\"line\">jedis.sadd(&quot;set&quot;, &quot;aaa&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">....</span><br></pre></td></tr></table></figure>\n<h2 id=\"springboot-环境下的使用\"><a href=\"#springboot-环境下的使用\" class=\"headerlink\" title=\"springboot 环境下的使用\"></a>springboot 环境下的使用</h2><h3 id=\"1-maven-依赖\"><a href=\"#1-maven-依赖\" class=\"headerlink\" title=\"1. maven 依赖\"></a>1. maven 依赖</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;1.4.2&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;1.2.14&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-代码实现\"><a href=\"#2-代码实现\" class=\"headerlink\" title=\"2. 代码实现\"></a>2. 代码实现</h3><p><strong>配置类 -&gt; 从 application.preperties 读取配置项，并且配置</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">@ConfigurationProperties(prefix = &quot;redis&quot;)</span><br><span class=\"line\">public class RedisConfig &#123;</span><br><span class=\"line\">  // 私有属性 </span><br><span class=\"line\">    </span><br><span class=\"line\">  // 配置项</span><br><span class=\"line\">  get... set...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>poolFactory 工厂类创建 pool</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public class RedisPoolFactory &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 注入配置项</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    RedisConfig redisConfig;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Bean注解 ： 根据方法创建对象，类型是JedisPool</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public JedisPool JedisPoolFactory()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        JedisPoolConfig poolConfig = new JedisPoolConfig();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 各种配置</span><br><span class=\"line\">        poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle());</span><br><span class=\"line\">        poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal());</span><br><span class=\"line\">        poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxTotal()*1000);</span><br><span class=\"line\"></span><br><span class=\"line\">        JedisPool jedisPool = new JedisPool(poolConfig, redisConfig.getHost(),                                      redisConfig.getPort(),                                                  redisConfig.getTimeout()*1000,                                          redisConfig.getPassword(), 0);</span><br><span class=\"line\"></span><br><span class=\"line\">        return jedisPool;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Redis 服务类 开始封装各种服务</strong></p>\n<p>当然，也要为服务模块化，比如 <code>RedisUserService</code>, <code>RedisMiaoshaService</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Service</span><br><span class=\"line\"> public class RedisService &#123;</span><br><span class=\"line\">    // 注入，@Bean 产生的jedisPool</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    JedisPool jedisPool;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public &lt;T&gt; boolean set(IProfixForKey prefix, String key, T value)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Jedis resource = null;</span><br><span class=\"line\">        try&#123;</span><br><span class=\"line\">            // 拿到连接</span><br><span class=\"line\">            resource = jedisPool.getResource();</span><br><span class=\"line\">            </span><br><span class=\"line\">            // 封装一下key, 加上特点的头信息，例如： dbName:tableName:id</span><br><span class=\"line\">            String strValue = beanToString(value);</span><br><span class=\"line\">    </span><br><span class=\"line\">            // 生成key</span><br><span class=\"line\">            String realKey = prefix.getPrefix() + key;</span><br><span class=\"line\">    </span><br><span class=\"line\">            if (strValue == null || strValue.length() &lt;= 0)&#123;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            // 设置</span><br><span class=\"line\">            resource.set(realKey, strValue);</span><br><span class=\"line\">    </span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;finally &#123;</span><br><span class=\"line\">            returnToPool(resource);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"非-spring-环境下的使用\"><a href=\"#非-spring-环境下的使用\" class=\"headerlink\" title=\"非 spring 环境下的使用\"></a>非 spring 环境下的使用</h2><p>举个例子，不知道合不合适。</p>\n<p><strong>单例模式 来创建 JedisPool</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class JedisFactory &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private volatile  static JedisPool jedisPool;</span><br><span class=\"line\"></span><br><span class=\"line\">    private volatile static JedisPoolConfig poolConfig;</span><br><span class=\"line\">    private volatile static String ip;</span><br><span class=\"line\">    private volatile static int port;</span><br><span class=\"line\">    private volatile static int timeout;</span><br><span class=\"line\">    private volatile static String password;</span><br><span class=\"line\">    private volatile static int database;</span><br><span class=\"line\"></span><br><span class=\"line\">    private JedisFactory() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        //JedisPoolConfig poolConfig, String ip, int port, int timeout, String password, int database</span><br><span class=\"line\">        /* apache common-pool 工具</span><br><span class=\"line\">        *</span><br><span class=\"line\">        * JedisPoolConfig</span><br><span class=\"line\">        * */</span><br><span class=\"line\">        this.jedisPool = new JedisPool(poolConfig, ip, port, timeout , password, 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public static JedisPool getJedisPool()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (jedisPool == null)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            synchronized (JedisFactory.class)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                if (jedisPool == null)&#123;</span><br><span class=\"line\">                    jedisPool = new JedisPool(JedisFactory.poolConfig, JedisFactory.ip, JedisFactory.port,</span><br><span class=\"line\">                                              JedisFactory.timeout,  JedisFactory.password, JedisFactory.database);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return jedisPool;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void setJedisPoolConfig(JedisPoolConfig poolConfig, String ip, int port, int timeout, String password, int database)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot; 配置jedis 参数...&quot;);</span><br><span class=\"line\">        JedisFactory.poolConfig = poolConfig;</span><br><span class=\"line\">        JedisFactory.ip = ip;</span><br><span class=\"line\">        JedisFactory.port = port;</span><br><span class=\"line\">        JedisFactory.timeout = timeout * 1000;</span><br><span class=\"line\">        JedisFactory.password = password;</span><br><span class=\"line\">        JedisFactory.database = database;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>JedisService</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">package top.elgong.jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">import redis.clients.jedis.Jedis;</span><br><span class=\"line\">import redis.clients.jedis.JedisPool;</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">*</span><br><span class=\"line\">*   解决redis 用到的</span><br><span class=\"line\">* */</span><br><span class=\"line\">public class JedisService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param key</span><br><span class=\"line\">     * @param value</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void set(String key, String value)&#123;</span><br><span class=\"line\">        Jedis resource = null;</span><br><span class=\"line\">        try&#123;</span><br><span class=\"line\">            JedisPool jedisPool = JedisFactory.getJedisPool();</span><br><span class=\"line\"></span><br><span class=\"line\">            resource = jedisPool.getResource();</span><br><span class=\"line\"></span><br><span class=\"line\">            resource.set(key, value);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;catch (Exception e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;finally &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            // 送回连接池中</span><br><span class=\"line\">            if (resource != null)&#123;</span><br><span class=\"line\">                resource.close();  // close 就是送回池子</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * */</span><br><span class=\"line\">    public String get(String key)&#123;</span><br><span class=\"line\">        Jedis resource = null;</span><br><span class=\"line\">        String ret = null;</span><br><span class=\"line\">        try&#123;</span><br><span class=\"line\">            JedisPool jedisPool = JedisFactory.getJedisPool();</span><br><span class=\"line\">            resource = jedisPool.getResource();</span><br><span class=\"line\"></span><br><span class=\"line\">            ret = resource.get(key);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;catch (Exception e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;finally &#123;</span><br><span class=\"line\">            // 送回连接池中</span><br><span class=\"line\">            if (resource != null)&#123;</span><br><span class=\"line\">                resource.close();  // close 就是送回池子</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>test</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package top.elgong.jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">import redis.clients.jedis.Jedis;</span><br><span class=\"line\">import redis.clients.jedis.JedisPoolConfig;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.time.LocalDateTime;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Test &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static JedisService jedisService = new JedisService();</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        JedisPoolConfig poolConfig = new JedisPoolConfig();</span><br><span class=\"line\">        String ip = &quot;121.41.111.45&quot;;</span><br><span class=\"line\">        int port = 6379;</span><br><span class=\"line\">        int timeout = 300;</span><br><span class=\"line\">        String password = &quot;Gelqq666%&quot;;</span><br><span class=\"line\">        int database = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">        JedisFactory.setJedisPoolConfig(poolConfig, ip, port, timeout, password, database);</span><br><span class=\"line\"></span><br><span class=\"line\">        jedisService.set(&quot;leetcode-java:jedis:test:key1&quot;, &quot;haha-&quot; + LocalDateTime.now().toString());</span><br><span class=\"line\"></span><br><span class=\"line\">        String s = jedisService.get(&quot;leetcode-java:jedis:test:key1&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Jedis-Pipline-的使用\"><a href=\"#Jedis-Pipline-的使用\" class=\"headerlink\" title=\"Jedis Pipline 的使用\"></a>Jedis Pipline 的使用</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Jedis jedis = new Jedis(&quot;127.0.0.1&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 1)生成pipeline对象</span><br><span class=\"line\">Pipeline pipeline = jedis.pipelined();</span><br><span class=\"line\"></span><br><span class=\"line\">// 2)pipeline执行命令， 注意此时命令并未真正执行</span><br><span class=\"line\">for (String key : keys) &#123;</span><br><span class=\"line\">    pipeline.del(key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 3)执行命令</span><br><span class=\"line\">pipeline.sync();</span><br></pre></td></tr></table></figure>\n<h1 id=\"Jedis-Lua-脚本\"><a href=\"#Jedis-Lua-脚本\" class=\"headerlink\" title=\"Jedis Lua 脚本\"></a>Jedis Lua 脚本</h1><p>待补充。。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc] </p>\n<p>[toc]</p>\n<blockquote>\n<p>本系列文章整理摘抄自<redis 开发与运维=\"\"></redis></p>\n</blockquote>\n<h1 id=\"客户端怎么和-Redis-服务器连接？\"><a href=\"#客户端怎么和-Redis-服务器连接？\" class=\"headerlink\" title=\"客户端怎么和 Redis 服务器连接？\"></a>客户端怎么和 Redis 服务器连接？</h1><p>客户端和 Redis 服务器的通信是 建立在 TCP 连接的基础上的。</p>\n<p>并且 Redis 制定了 RESP 序列化协议，是一个简单地通信约定。</p>\n<h2 id=\"Resp序列化协议\"><a href=\"#Resp序列化协议\" class=\"headerlink\" title=\"Resp序列化协议\"></a>Resp序列化协议</h2><p><code>*&lt;参数数量&gt;\\r\\n$&lt;参数1的字节数量&gt;\\r\\n&lt;参数1&gt;\\r\\n$&lt;参数2的字节数量&gt;\\r\\n&lt;参数2&gt;\\r\\n</code></p>\n<p>来给可视化一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*&lt;参数数量&gt;\\r\\n</span><br><span class=\"line\">$&lt;参数1的字节数量&gt;\\r\\n</span><br><span class=\"line\">&lt;参数1&gt;\\r\\n</span><br><span class=\"line\">$&lt;参数2的字节数量&gt;\\r\\n</span><br><span class=\"line\">&lt;参数2&gt;\\r\\n</span><br></pre></td></tr></table></figure></p>\n<p>其他可以参考该书章节。</p>\n<h1 id=\"Jedis-连接池的使用\"><a href=\"#Jedis-连接池的使用\" class=\"headerlink\" title=\"Jedis 连接池的使用\"></a>Jedis 连接池的使用</h1><p>简单的API 介绍</p>\n<p><strong>获取 jedis连接</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class=\"line\"></span><br><span class=\"line\">Jedis jedis = null;</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">    jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125; catch (Exception e) &#123;</span><br><span class=\"line\">    logger.error(e.getMessage(),e);</span><br><span class=\"line\">&#125; finally &#123;</span><br><span class=\"line\">    if (jedis != null) &#123;</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  String</span><br><span class=\"line\">jedis.set(&quot;key&quot;, &quot;value&quot;);</span><br><span class=\"line\">jedis.get(&quot;key&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//  hset -字典</span><br><span class=\"line\">jedis.set(&quot;hash&quot;, &quot;key1&quot;, &quot;value1&quot;);</span><br><span class=\"line\">jedis.set(&quot;hash&quot;, &quot;key2&quot;, &quot;value2&quot;);</span><br><span class=\"line\">jedis.get(&quot;key1&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">//  list -列表</span><br><span class=\"line\">jedis.rpush(&quot;mylist&quot;, &quot;1&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// set -集合</span><br><span class=\"line\">jedis.sadd(&quot;set&quot;, &quot;aaa&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">....</span><br></pre></td></tr></table></figure>\n<h2 id=\"springboot-环境下的使用\"><a href=\"#springboot-环境下的使用\" class=\"headerlink\" title=\"springboot 环境下的使用\"></a>springboot 环境下的使用</h2><h3 id=\"1-maven-依赖\"><a href=\"#1-maven-依赖\" class=\"headerlink\" title=\"1. maven 依赖\"></a>1. maven 依赖</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;1.4.2&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;1.2.14&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-代码实现\"><a href=\"#2-代码实现\" class=\"headerlink\" title=\"2. 代码实现\"></a>2. 代码实现</h3><p><strong>配置类 -&gt; 从 application.preperties 读取配置项，并且配置</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">@ConfigurationProperties(prefix = &quot;redis&quot;)</span><br><span class=\"line\">public class RedisConfig &#123;</span><br><span class=\"line\">  // 私有属性 </span><br><span class=\"line\">    </span><br><span class=\"line\">  // 配置项</span><br><span class=\"line\">  get... set...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>poolFactory 工厂类创建 pool</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public class RedisPoolFactory &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 注入配置项</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    RedisConfig redisConfig;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Bean注解 ： 根据方法创建对象，类型是JedisPool</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public JedisPool JedisPoolFactory()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        JedisPoolConfig poolConfig = new JedisPoolConfig();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 各种配置</span><br><span class=\"line\">        poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle());</span><br><span class=\"line\">        poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal());</span><br><span class=\"line\">        poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxTotal()*1000);</span><br><span class=\"line\"></span><br><span class=\"line\">        JedisPool jedisPool = new JedisPool(poolConfig, redisConfig.getHost(),                                      redisConfig.getPort(),                                                  redisConfig.getTimeout()*1000,                                          redisConfig.getPassword(), 0);</span><br><span class=\"line\"></span><br><span class=\"line\">        return jedisPool;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Redis 服务类 开始封装各种服务</strong></p>\n<p>当然，也要为服务模块化，比如 <code>RedisUserService</code>, <code>RedisMiaoshaService</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Service</span><br><span class=\"line\"> public class RedisService &#123;</span><br><span class=\"line\">    // 注入，@Bean 产生的jedisPool</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    JedisPool jedisPool;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public &lt;T&gt; boolean set(IProfixForKey prefix, String key, T value)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Jedis resource = null;</span><br><span class=\"line\">        try&#123;</span><br><span class=\"line\">            // 拿到连接</span><br><span class=\"line\">            resource = jedisPool.getResource();</span><br><span class=\"line\">            </span><br><span class=\"line\">            // 封装一下key, 加上特点的头信息，例如： dbName:tableName:id</span><br><span class=\"line\">            String strValue = beanToString(value);</span><br><span class=\"line\">    </span><br><span class=\"line\">            // 生成key</span><br><span class=\"line\">            String realKey = prefix.getPrefix() + key;</span><br><span class=\"line\">    </span><br><span class=\"line\">            if (strValue == null || strValue.length() &lt;= 0)&#123;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            // 设置</span><br><span class=\"line\">            resource.set(realKey, strValue);</span><br><span class=\"line\">    </span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;finally &#123;</span><br><span class=\"line\">            returnToPool(resource);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"非-spring-环境下的使用\"><a href=\"#非-spring-环境下的使用\" class=\"headerlink\" title=\"非 spring 环境下的使用\"></a>非 spring 环境下的使用</h2><p>举个例子，不知道合不合适。</p>\n<p><strong>单例模式 来创建 JedisPool</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class JedisFactory &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private volatile  static JedisPool jedisPool;</span><br><span class=\"line\"></span><br><span class=\"line\">    private volatile static JedisPoolConfig poolConfig;</span><br><span class=\"line\">    private volatile static String ip;</span><br><span class=\"line\">    private volatile static int port;</span><br><span class=\"line\">    private volatile static int timeout;</span><br><span class=\"line\">    private volatile static String password;</span><br><span class=\"line\">    private volatile static int database;</span><br><span class=\"line\"></span><br><span class=\"line\">    private JedisFactory() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        //JedisPoolConfig poolConfig, String ip, int port, int timeout, String password, int database</span><br><span class=\"line\">        /* apache common-pool 工具</span><br><span class=\"line\">        *</span><br><span class=\"line\">        * JedisPoolConfig</span><br><span class=\"line\">        * */</span><br><span class=\"line\">        this.jedisPool = new JedisPool(poolConfig, ip, port, timeout , password, 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public static JedisPool getJedisPool()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (jedisPool == null)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            synchronized (JedisFactory.class)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                if (jedisPool == null)&#123;</span><br><span class=\"line\">                    jedisPool = new JedisPool(JedisFactory.poolConfig, JedisFactory.ip, JedisFactory.port,</span><br><span class=\"line\">                                              JedisFactory.timeout,  JedisFactory.password, JedisFactory.database);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return jedisPool;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void setJedisPoolConfig(JedisPoolConfig poolConfig, String ip, int port, int timeout, String password, int database)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot; 配置jedis 参数...&quot;);</span><br><span class=\"line\">        JedisFactory.poolConfig = poolConfig;</span><br><span class=\"line\">        JedisFactory.ip = ip;</span><br><span class=\"line\">        JedisFactory.port = port;</span><br><span class=\"line\">        JedisFactory.timeout = timeout * 1000;</span><br><span class=\"line\">        JedisFactory.password = password;</span><br><span class=\"line\">        JedisFactory.database = database;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>JedisService</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">package top.elgong.jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">import redis.clients.jedis.Jedis;</span><br><span class=\"line\">import redis.clients.jedis.JedisPool;</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">*</span><br><span class=\"line\">*   解决redis 用到的</span><br><span class=\"line\">* */</span><br><span class=\"line\">public class JedisService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param key</span><br><span class=\"line\">     * @param value</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void set(String key, String value)&#123;</span><br><span class=\"line\">        Jedis resource = null;</span><br><span class=\"line\">        try&#123;</span><br><span class=\"line\">            JedisPool jedisPool = JedisFactory.getJedisPool();</span><br><span class=\"line\"></span><br><span class=\"line\">            resource = jedisPool.getResource();</span><br><span class=\"line\"></span><br><span class=\"line\">            resource.set(key, value);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;catch (Exception e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;finally &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            // 送回连接池中</span><br><span class=\"line\">            if (resource != null)&#123;</span><br><span class=\"line\">                resource.close();  // close 就是送回池子</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * */</span><br><span class=\"line\">    public String get(String key)&#123;</span><br><span class=\"line\">        Jedis resource = null;</span><br><span class=\"line\">        String ret = null;</span><br><span class=\"line\">        try&#123;</span><br><span class=\"line\">            JedisPool jedisPool = JedisFactory.getJedisPool();</span><br><span class=\"line\">            resource = jedisPool.getResource();</span><br><span class=\"line\"></span><br><span class=\"line\">            ret = resource.get(key);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;catch (Exception e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;finally &#123;</span><br><span class=\"line\">            // 送回连接池中</span><br><span class=\"line\">            if (resource != null)&#123;</span><br><span class=\"line\">                resource.close();  // close 就是送回池子</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>test</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package top.elgong.jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">import redis.clients.jedis.Jedis;</span><br><span class=\"line\">import redis.clients.jedis.JedisPoolConfig;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.time.LocalDateTime;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Test &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static JedisService jedisService = new JedisService();</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        JedisPoolConfig poolConfig = new JedisPoolConfig();</span><br><span class=\"line\">        String ip = &quot;121.41.111.45&quot;;</span><br><span class=\"line\">        int port = 6379;</span><br><span class=\"line\">        int timeout = 300;</span><br><span class=\"line\">        String password = &quot;Gelqq666%&quot;;</span><br><span class=\"line\">        int database = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">        JedisFactory.setJedisPoolConfig(poolConfig, ip, port, timeout, password, database);</span><br><span class=\"line\"></span><br><span class=\"line\">        jedisService.set(&quot;leetcode-java:jedis:test:key1&quot;, &quot;haha-&quot; + LocalDateTime.now().toString());</span><br><span class=\"line\"></span><br><span class=\"line\">        String s = jedisService.get(&quot;leetcode-java:jedis:test:key1&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Jedis-Pipline-的使用\"><a href=\"#Jedis-Pipline-的使用\" class=\"headerlink\" title=\"Jedis Pipline 的使用\"></a>Jedis Pipline 的使用</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Jedis jedis = new Jedis(&quot;127.0.0.1&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 1)生成pipeline对象</span><br><span class=\"line\">Pipeline pipeline = jedis.pipelined();</span><br><span class=\"line\"></span><br><span class=\"line\">// 2)pipeline执行命令， 注意此时命令并未真正执行</span><br><span class=\"line\">for (String key : keys) &#123;</span><br><span class=\"line\">    pipeline.del(key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 3)执行命令</span><br><span class=\"line\">pipeline.sync();</span><br></pre></td></tr></table></figure>\n<h1 id=\"Jedis-Lua-脚本\"><a href=\"#Jedis-Lua-脚本\" class=\"headerlink\" title=\"Jedis Lua 脚本\"></a>Jedis Lua 脚本</h1><p>待补充。。</p>\n"},{"title":"redis学习-缓存设计中要提前考虑的事情","date":"2020-05-15T16:16:33.000Z","_content":"\n[toc] \n\n[toc]\n> 本系列文章整理摘抄自<Redis 开发与运维>\n# 缓存设计前需要权衡成本和收益\n\n## 收益\n- **加速读写**\n- **降低后端负载**\n\n## 成本\n- **数据不一致性**\n    - 缓存层和存储层数据势必会有不一致的时间，需要考虑如何避免对业务造成的影响。 \n- **代码维护成本**\n    - redis 和 mysql 两方代码都要考虑。\n\n# 缓存如何更新？\n\n基于内存的缓存不可能将所有的数据都做缓存，一般针对的都是**热点数据**。热点数据具有时效性，过了一定时间将成为**非热点数据**。\n\n所以，缓存数据通常具有生命时长，到达指定的时间后，将被更新或者删除。\n\n熟悉缓存的常用更新策略，才能针对业务场景做出合理的选择。\n\n## 更新策略1： LRU/LFU/FIFO 算法\n\n通常缓存量超过了预设的最大值时，将会采取以上策略，具体由 `maxmemory-policy` 参数指定。\n\n**一致性最差。**\n\n## 更新策略2: 超时剔除\n\n通过给缓存数据设置过期时间，让其在过期时间后自动删除，例如Redis提供的`expire`命令。 \n\n**一致性取决于时间窗口。**\n\n## 更新策略3: 主动更新\n\n当堆数据一致性要求高时，在更新存储层数据后，需要立即更新缓存中的数据。\n\n**一致性最好。**\n\n\n## 最佳实践方案\n\n### 低一致性业务\n\n配置最大内存 + 淘汰策略\n\n### 高一致性业务\n\n超时剔除 + 主动更新\n\n\n# 缓存的粒度如何选？\n\n对于缓存数据库的内容时，要考虑缓存全部字段，或者部分字段。\n\n- 全部字段：\n    - 全部缓存占用空间过大\n    - 并不是所有字段都用的到\n- 部分字段：\n    - 未来可能用到新字段 \n\n\n# 缓存预热\n\n在系统刚上线，直接将数据加载进缓存系统，提前准备。\n\n# 缓存穿透问题（针对无效查询）\n\n## 概念描述\n\n缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不命中。\n\n## 产生的原因\n\n- 问题1：业务代码或者数据出现问题\n- 问题2：恶意攻击，爬虫造成的大量空命中\n\n## 造成的影响\n\n如果出现大量的缓存穿透，会对后端的数据库产生大流量的冲击，严重可使得数据库服务宕机。\n\n## 通用解决方案\n\n### 问题如何发现？\n统计**总调用数、 缓存层命中数、 存储层命中数**，如果发现大量存储层空命中， 可能就是出现了缓存穿透问题。\n\n### 问题如何预防？\n\n#### 问题1的解决. 缓存空对象 + 设置短过期时间\n\n实时性高。\n\n存储层不命中后，仍然将空对象保留到缓存层中，之后再访问这个数据将会从缓存中获取，这样就保护了后端数据源。 \n\n\n#### 问题2的解决. 布隆过滤器拦截（缓存层之前对存在的key做保存）\n\n实时性差。\n\n访问缓存层和存储层之前，将存在的key用布隆过滤器提前保存起来， 做第一层拦截\n\n\n# 缓存雪崩\n\n## 概念描述\n\n发生大规模的缓存失效的情况，或者缓存层宕机，大量流量冲入存储层。\n\n## 产生的原因\n\n缓存服务由于各种原因失效了。\n\n## 造成的影响\n\n数据库服务宕机。\n\n## 通用解决方案\n\n### 提前的规划： 保证缓存服务的高可用。\n\n主从 + 哨兵， 集群。\nRedis Sentinel和RedisCluster都实现了高可用\n\n### 出现雪崩时的处理：隔离组件做限流和降级处理\n\n- ehcache本地缓存 + Hystrix限流并降级,避免MySQL被搞死。\n- 加锁排队（并发量不高的情况下）\n\n**Hystrix限流并降级的流程**\n\n海量的用户请求出现：\n\n- 首先通过限流组件Hystrix限流（只有预定的请求进入存储层）\n- 对于未通过的流量，直接导到 预定的降级处理方案，比如友好的提示等待。\n\n### 3. 提前排演测试\n\n\n# 缓存击(针对失效数据)-热点数据高并发访问时，失效来不及重建\n\n## 概念描述\n\n当热点数据并发访问量非常大，由于之前设置了过期时间，失效后难以短时间重建。\n\n比如： 热点的娱乐新闻。\n\n## 产生的原因\n\n缓存服务由于各种原因失效了。\n\n## 造成的影响\n\n数据库服务宕机。\n\n## 通用解决方案\n\n### 1. 限制重建的线程数 - 互斥锁\n\n并不是所有的线程都需要去重建，第一个遇到的线程重建，其他线程等待即可。\n#### 互斥锁的实现1：通过setnx 和 expire命令实现\n\n```\nString get(String key) {\n    // 从Redis中获取数据\n    String value = redis.get(key);\n    // 如果value为空， 则开始重构缓存\n    if (value == null) {\n        // 只允许一个线程重构缓存， 使用nx， 并设置过期时间ex\n        String mutexKey = \"mutext:key:\" + key;\n        if (redis.set(mutexKey, \"1\", \"ex 180\", \"nx\")) {\n            // 从数据源获取数据\n            value = db.get(key);\n            // 回写Redis， 并设置过期时间\n            redis.setex(key, timeout, value);\n            // 删除key_mutex\n            redis.delete(mutexKey);\n        }/\n        / 其他线程休息50毫秒后重试\n        else {\n            Thread.sleep(50);\n            get(key);\n        }\n    }return value;\n}\n```\n\n#### 互斥锁的实现2：通过watch和Redis的事务命令实现\n\n\n### 2. 永不过期\n\n但是会出现数据不一致的情况。\n\n### 3. 错峰失效\n\n不要让热点数据集中失效，而是一批一批，分时间段的失效\n\n### 4. 失效后sleep(rand()) 这样不会所有请求都去立刻查db","source":"_posts/redis学习-缓存设计中要提前考虑的事情.md","raw":"---\ntitle: redis学习-缓存设计中要提前考虑的事情\ndate: 2020-05-16 00:16:33\ncategories: 缓存中间件\ntags: redis, 缓存雪崩， 缓存穿透， 缓存击穿\n---\n\n[toc] \n\n[toc]\n> 本系列文章整理摘抄自<Redis 开发与运维>\n# 缓存设计前需要权衡成本和收益\n\n## 收益\n- **加速读写**\n- **降低后端负载**\n\n## 成本\n- **数据不一致性**\n    - 缓存层和存储层数据势必会有不一致的时间，需要考虑如何避免对业务造成的影响。 \n- **代码维护成本**\n    - redis 和 mysql 两方代码都要考虑。\n\n# 缓存如何更新？\n\n基于内存的缓存不可能将所有的数据都做缓存，一般针对的都是**热点数据**。热点数据具有时效性，过了一定时间将成为**非热点数据**。\n\n所以，缓存数据通常具有生命时长，到达指定的时间后，将被更新或者删除。\n\n熟悉缓存的常用更新策略，才能针对业务场景做出合理的选择。\n\n## 更新策略1： LRU/LFU/FIFO 算法\n\n通常缓存量超过了预设的最大值时，将会采取以上策略，具体由 `maxmemory-policy` 参数指定。\n\n**一致性最差。**\n\n## 更新策略2: 超时剔除\n\n通过给缓存数据设置过期时间，让其在过期时间后自动删除，例如Redis提供的`expire`命令。 \n\n**一致性取决于时间窗口。**\n\n## 更新策略3: 主动更新\n\n当堆数据一致性要求高时，在更新存储层数据后，需要立即更新缓存中的数据。\n\n**一致性最好。**\n\n\n## 最佳实践方案\n\n### 低一致性业务\n\n配置最大内存 + 淘汰策略\n\n### 高一致性业务\n\n超时剔除 + 主动更新\n\n\n# 缓存的粒度如何选？\n\n对于缓存数据库的内容时，要考虑缓存全部字段，或者部分字段。\n\n- 全部字段：\n    - 全部缓存占用空间过大\n    - 并不是所有字段都用的到\n- 部分字段：\n    - 未来可能用到新字段 \n\n\n# 缓存预热\n\n在系统刚上线，直接将数据加载进缓存系统，提前准备。\n\n# 缓存穿透问题（针对无效查询）\n\n## 概念描述\n\n缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不命中。\n\n## 产生的原因\n\n- 问题1：业务代码或者数据出现问题\n- 问题2：恶意攻击，爬虫造成的大量空命中\n\n## 造成的影响\n\n如果出现大量的缓存穿透，会对后端的数据库产生大流量的冲击，严重可使得数据库服务宕机。\n\n## 通用解决方案\n\n### 问题如何发现？\n统计**总调用数、 缓存层命中数、 存储层命中数**，如果发现大量存储层空命中， 可能就是出现了缓存穿透问题。\n\n### 问题如何预防？\n\n#### 问题1的解决. 缓存空对象 + 设置短过期时间\n\n实时性高。\n\n存储层不命中后，仍然将空对象保留到缓存层中，之后再访问这个数据将会从缓存中获取，这样就保护了后端数据源。 \n\n\n#### 问题2的解决. 布隆过滤器拦截（缓存层之前对存在的key做保存）\n\n实时性差。\n\n访问缓存层和存储层之前，将存在的key用布隆过滤器提前保存起来， 做第一层拦截\n\n\n# 缓存雪崩\n\n## 概念描述\n\n发生大规模的缓存失效的情况，或者缓存层宕机，大量流量冲入存储层。\n\n## 产生的原因\n\n缓存服务由于各种原因失效了。\n\n## 造成的影响\n\n数据库服务宕机。\n\n## 通用解决方案\n\n### 提前的规划： 保证缓存服务的高可用。\n\n主从 + 哨兵， 集群。\nRedis Sentinel和RedisCluster都实现了高可用\n\n### 出现雪崩时的处理：隔离组件做限流和降级处理\n\n- ehcache本地缓存 + Hystrix限流并降级,避免MySQL被搞死。\n- 加锁排队（并发量不高的情况下）\n\n**Hystrix限流并降级的流程**\n\n海量的用户请求出现：\n\n- 首先通过限流组件Hystrix限流（只有预定的请求进入存储层）\n- 对于未通过的流量，直接导到 预定的降级处理方案，比如友好的提示等待。\n\n### 3. 提前排演测试\n\n\n# 缓存击(针对失效数据)-热点数据高并发访问时，失效来不及重建\n\n## 概念描述\n\n当热点数据并发访问量非常大，由于之前设置了过期时间，失效后难以短时间重建。\n\n比如： 热点的娱乐新闻。\n\n## 产生的原因\n\n缓存服务由于各种原因失效了。\n\n## 造成的影响\n\n数据库服务宕机。\n\n## 通用解决方案\n\n### 1. 限制重建的线程数 - 互斥锁\n\n并不是所有的线程都需要去重建，第一个遇到的线程重建，其他线程等待即可。\n#### 互斥锁的实现1：通过setnx 和 expire命令实现\n\n```\nString get(String key) {\n    // 从Redis中获取数据\n    String value = redis.get(key);\n    // 如果value为空， 则开始重构缓存\n    if (value == null) {\n        // 只允许一个线程重构缓存， 使用nx， 并设置过期时间ex\n        String mutexKey = \"mutext:key:\" + key;\n        if (redis.set(mutexKey, \"1\", \"ex 180\", \"nx\")) {\n            // 从数据源获取数据\n            value = db.get(key);\n            // 回写Redis， 并设置过期时间\n            redis.setex(key, timeout, value);\n            // 删除key_mutex\n            redis.delete(mutexKey);\n        }/\n        / 其他线程休息50毫秒后重试\n        else {\n            Thread.sleep(50);\n            get(key);\n        }\n    }return value;\n}\n```\n\n#### 互斥锁的实现2：通过watch和Redis的事务命令实现\n\n\n### 2. 永不过期\n\n但是会出现数据不一致的情况。\n\n### 3. 错峰失效\n\n不要让热点数据集中失效，而是一批一批，分时间段的失效\n\n### 4. 失效后sleep(rand()) 这样不会所有请求都去立刻查db","slug":"redis学习-缓存设计中要提前考虑的事情","published":1,"updated":"2020-05-15T16:17:30.654Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephf1001nt8pl8ijkhrqd","content":"<p>[toc] </p>\n<p>[toc]</p>\n<blockquote>\n<p>本系列文章整理摘抄自<redis 开发与运维=\"\"></redis></p>\n<h1 id=\"缓存设计前需要权衡成本和收益\"><a href=\"#缓存设计前需要权衡成本和收益\" class=\"headerlink\" title=\"缓存设计前需要权衡成本和收益\"></a>缓存设计前需要权衡成本和收益</h1></blockquote>\n<h2 id=\"收益\"><a href=\"#收益\" class=\"headerlink\" title=\"收益\"></a>收益</h2><ul>\n<li><strong>加速读写</strong></li>\n<li><strong>降低后端负载</strong></li>\n</ul>\n<h2 id=\"成本\"><a href=\"#成本\" class=\"headerlink\" title=\"成本\"></a>成本</h2><ul>\n<li><strong>数据不一致性</strong><ul>\n<li>缓存层和存储层数据势必会有不一致的时间，需要考虑如何避免对业务造成的影响。 </li>\n</ul>\n</li>\n<li><strong>代码维护成本</strong><ul>\n<li>redis 和 mysql 两方代码都要考虑。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"缓存如何更新？\"><a href=\"#缓存如何更新？\" class=\"headerlink\" title=\"缓存如何更新？\"></a>缓存如何更新？</h1><p>基于内存的缓存不可能将所有的数据都做缓存，一般针对的都是<strong>热点数据</strong>。热点数据具有时效性，过了一定时间将成为<strong>非热点数据</strong>。</p>\n<p>所以，缓存数据通常具有生命时长，到达指定的时间后，将被更新或者删除。</p>\n<p>熟悉缓存的常用更新策略，才能针对业务场景做出合理的选择。</p>\n<h2 id=\"更新策略1：-LRU-LFU-FIFO-算法\"><a href=\"#更新策略1：-LRU-LFU-FIFO-算法\" class=\"headerlink\" title=\"更新策略1： LRU/LFU/FIFO 算法\"></a>更新策略1： LRU/LFU/FIFO 算法</h2><p>通常缓存量超过了预设的最大值时，将会采取以上策略，具体由 <code>maxmemory-policy</code> 参数指定。</p>\n<p><strong>一致性最差。</strong></p>\n<h2 id=\"更新策略2-超时剔除\"><a href=\"#更新策略2-超时剔除\" class=\"headerlink\" title=\"更新策略2: 超时剔除\"></a>更新策略2: 超时剔除</h2><p>通过给缓存数据设置过期时间，让其在过期时间后自动删除，例如Redis提供的<code>expire</code>命令。 </p>\n<p><strong>一致性取决于时间窗口。</strong></p>\n<h2 id=\"更新策略3-主动更新\"><a href=\"#更新策略3-主动更新\" class=\"headerlink\" title=\"更新策略3: 主动更新\"></a>更新策略3: 主动更新</h2><p>当堆数据一致性要求高时，在更新存储层数据后，需要立即更新缓存中的数据。</p>\n<p><strong>一致性最好。</strong></p>\n<h2 id=\"最佳实践方案\"><a href=\"#最佳实践方案\" class=\"headerlink\" title=\"最佳实践方案\"></a>最佳实践方案</h2><h3 id=\"低一致性业务\"><a href=\"#低一致性业务\" class=\"headerlink\" title=\"低一致性业务\"></a>低一致性业务</h3><p>配置最大内存 + 淘汰策略</p>\n<h3 id=\"高一致性业务\"><a href=\"#高一致性业务\" class=\"headerlink\" title=\"高一致性业务\"></a>高一致性业务</h3><p>超时剔除 + 主动更新</p>\n<h1 id=\"缓存的粒度如何选？\"><a href=\"#缓存的粒度如何选？\" class=\"headerlink\" title=\"缓存的粒度如何选？\"></a>缓存的粒度如何选？</h1><p>对于缓存数据库的内容时，要考虑缓存全部字段，或者部分字段。</p>\n<ul>\n<li>全部字段：<ul>\n<li>全部缓存占用空间过大</li>\n<li>并不是所有字段都用的到</li>\n</ul>\n</li>\n<li>部分字段：<ul>\n<li>未来可能用到新字段 </li>\n</ul>\n</li>\n</ul>\n<h1 id=\"缓存预热\"><a href=\"#缓存预热\" class=\"headerlink\" title=\"缓存预热\"></a>缓存预热</h1><p>在系统刚上线，直接将数据加载进缓存系统，提前准备。</p>\n<h1 id=\"缓存穿透问题（针对无效查询）\"><a href=\"#缓存穿透问题（针对无效查询）\" class=\"headerlink\" title=\"缓存穿透问题（针对无效查询）\"></a>缓存穿透问题（针对无效查询）</h1><h2 id=\"概念描述\"><a href=\"#概念描述\" class=\"headerlink\" title=\"概念描述\"></a>概念描述</h2><p>缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不命中。</p>\n<h2 id=\"产生的原因\"><a href=\"#产生的原因\" class=\"headerlink\" title=\"产生的原因\"></a>产生的原因</h2><ul>\n<li>问题1：业务代码或者数据出现问题</li>\n<li>问题2：恶意攻击，爬虫造成的大量空命中</li>\n</ul>\n<h2 id=\"造成的影响\"><a href=\"#造成的影响\" class=\"headerlink\" title=\"造成的影响\"></a>造成的影响</h2><p>如果出现大量的缓存穿透，会对后端的数据库产生大流量的冲击，严重可使得数据库服务宕机。</p>\n<h2 id=\"通用解决方案\"><a href=\"#通用解决方案\" class=\"headerlink\" title=\"通用解决方案\"></a>通用解决方案</h2><h3 id=\"问题如何发现？\"><a href=\"#问题如何发现？\" class=\"headerlink\" title=\"问题如何发现？\"></a>问题如何发现？</h3><p>统计<strong>总调用数、 缓存层命中数、 存储层命中数</strong>，如果发现大量存储层空命中， 可能就是出现了缓存穿透问题。</p>\n<h3 id=\"问题如何预防？\"><a href=\"#问题如何预防？\" class=\"headerlink\" title=\"问题如何预防？\"></a>问题如何预防？</h3><h4 id=\"问题1的解决-缓存空对象-设置短过期时间\"><a href=\"#问题1的解决-缓存空对象-设置短过期时间\" class=\"headerlink\" title=\"问题1的解决. 缓存空对象 + 设置短过期时间\"></a>问题1的解决. 缓存空对象 + 设置短过期时间</h4><p>实时性高。</p>\n<p>存储层不命中后，仍然将空对象保留到缓存层中，之后再访问这个数据将会从缓存中获取，这样就保护了后端数据源。 </p>\n<h4 id=\"问题2的解决-布隆过滤器拦截（缓存层之前对存在的key做保存）\"><a href=\"#问题2的解决-布隆过滤器拦截（缓存层之前对存在的key做保存）\" class=\"headerlink\" title=\"问题2的解决. 布隆过滤器拦截（缓存层之前对存在的key做保存）\"></a>问题2的解决. 布隆过滤器拦截（缓存层之前对存在的key做保存）</h4><p>实时性差。</p>\n<p>访问缓存层和存储层之前，将存在的key用布隆过滤器提前保存起来， 做第一层拦截</p>\n<h1 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h1><h2 id=\"概念描述-1\"><a href=\"#概念描述-1\" class=\"headerlink\" title=\"概念描述\"></a>概念描述</h2><p>发生大规模的缓存失效的情况，或者缓存层宕机，大量流量冲入存储层。</p>\n<h2 id=\"产生的原因-1\"><a href=\"#产生的原因-1\" class=\"headerlink\" title=\"产生的原因\"></a>产生的原因</h2><p>缓存服务由于各种原因失效了。</p>\n<h2 id=\"造成的影响-1\"><a href=\"#造成的影响-1\" class=\"headerlink\" title=\"造成的影响\"></a>造成的影响</h2><p>数据库服务宕机。</p>\n<h2 id=\"通用解决方案-1\"><a href=\"#通用解决方案-1\" class=\"headerlink\" title=\"通用解决方案\"></a>通用解决方案</h2><h3 id=\"提前的规划：-保证缓存服务的高可用。\"><a href=\"#提前的规划：-保证缓存服务的高可用。\" class=\"headerlink\" title=\"提前的规划： 保证缓存服务的高可用。\"></a>提前的规划： 保证缓存服务的高可用。</h3><p>主从 + 哨兵， 集群。<br>Redis Sentinel和RedisCluster都实现了高可用</p>\n<h3 id=\"出现雪崩时的处理：隔离组件做限流和降级处理\"><a href=\"#出现雪崩时的处理：隔离组件做限流和降级处理\" class=\"headerlink\" title=\"出现雪崩时的处理：隔离组件做限流和降级处理\"></a>出现雪崩时的处理：隔离组件做限流和降级处理</h3><ul>\n<li>ehcache本地缓存 + Hystrix限流并降级,避免MySQL被搞死。</li>\n<li>加锁排队（并发量不高的情况下）</li>\n</ul>\n<p><strong>Hystrix限流并降级的流程</strong></p>\n<p>海量的用户请求出现：</p>\n<ul>\n<li>首先通过限流组件Hystrix限流（只有预定的请求进入存储层）</li>\n<li>对于未通过的流量，直接导到 预定的降级处理方案，比如友好的提示等待。</li>\n</ul>\n<h3 id=\"3-提前排演测试\"><a href=\"#3-提前排演测试\" class=\"headerlink\" title=\"3. 提前排演测试\"></a>3. 提前排演测试</h3><h1 id=\"缓存击-针对失效数据-热点数据高并发访问时，失效来不及重建\"><a href=\"#缓存击-针对失效数据-热点数据高并发访问时，失效来不及重建\" class=\"headerlink\" title=\"缓存击(针对失效数据)-热点数据高并发访问时，失效来不及重建\"></a>缓存击(针对失效数据)-热点数据高并发访问时，失效来不及重建</h1><h2 id=\"概念描述-2\"><a href=\"#概念描述-2\" class=\"headerlink\" title=\"概念描述\"></a>概念描述</h2><p>当热点数据并发访问量非常大，由于之前设置了过期时间，失效后难以短时间重建。</p>\n<p>比如： 热点的娱乐新闻。</p>\n<h2 id=\"产生的原因-2\"><a href=\"#产生的原因-2\" class=\"headerlink\" title=\"产生的原因\"></a>产生的原因</h2><p>缓存服务由于各种原因失效了。</p>\n<h2 id=\"造成的影响-2\"><a href=\"#造成的影响-2\" class=\"headerlink\" title=\"造成的影响\"></a>造成的影响</h2><p>数据库服务宕机。</p>\n<h2 id=\"通用解决方案-2\"><a href=\"#通用解决方案-2\" class=\"headerlink\" title=\"通用解决方案\"></a>通用解决方案</h2><h3 id=\"1-限制重建的线程数-互斥锁\"><a href=\"#1-限制重建的线程数-互斥锁\" class=\"headerlink\" title=\"1. 限制重建的线程数 - 互斥锁\"></a>1. 限制重建的线程数 - 互斥锁</h3><p>并不是所有的线程都需要去重建，第一个遇到的线程重建，其他线程等待即可。</p>\n<h4 id=\"互斥锁的实现1：通过setnx-和-expire命令实现\"><a href=\"#互斥锁的实现1：通过setnx-和-expire命令实现\" class=\"headerlink\" title=\"互斥锁的实现1：通过setnx 和 expire命令实现\"></a>互斥锁的实现1：通过setnx 和 expire命令实现</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String get(String key) &#123;</span><br><span class=\"line\">    // 从Redis中获取数据</span><br><span class=\"line\">    String value = redis.get(key);</span><br><span class=\"line\">    // 如果value为空， 则开始重构缓存</span><br><span class=\"line\">    if (value == null) &#123;</span><br><span class=\"line\">        // 只允许一个线程重构缓存， 使用nx， 并设置过期时间ex</span><br><span class=\"line\">        String mutexKey = &quot;mutext:key:&quot; + key;</span><br><span class=\"line\">        if (redis.set(mutexKey, &quot;1&quot;, &quot;ex 180&quot;, &quot;nx&quot;)) &#123;</span><br><span class=\"line\">            // 从数据源获取数据</span><br><span class=\"line\">            value = db.get(key);</span><br><span class=\"line\">            // 回写Redis， 并设置过期时间</span><br><span class=\"line\">            redis.setex(key, timeout, value);</span><br><span class=\"line\">            // 删除key_mutex</span><br><span class=\"line\">            redis.delete(mutexKey);</span><br><span class=\"line\">        &#125;/</span><br><span class=\"line\">        / 其他线程休息50毫秒后重试</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            Thread.sleep(50);</span><br><span class=\"line\">            get(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;return value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"互斥锁的实现2：通过watch和Redis的事务命令实现\"><a href=\"#互斥锁的实现2：通过watch和Redis的事务命令实现\" class=\"headerlink\" title=\"互斥锁的实现2：通过watch和Redis的事务命令实现\"></a>互斥锁的实现2：通过watch和Redis的事务命令实现</h4><h3 id=\"2-永不过期\"><a href=\"#2-永不过期\" class=\"headerlink\" title=\"2. 永不过期\"></a>2. 永不过期</h3><p>但是会出现数据不一致的情况。</p>\n<h3 id=\"3-错峰失效\"><a href=\"#3-错峰失效\" class=\"headerlink\" title=\"3. 错峰失效\"></a>3. 错峰失效</h3><p>不要让热点数据集中失效，而是一批一批，分时间段的失效</p>\n<h3 id=\"4-失效后sleep-rand-这样不会所有请求都去立刻查db\"><a href=\"#4-失效后sleep-rand-这样不会所有请求都去立刻查db\" class=\"headerlink\" title=\"4. 失效后sleep(rand()) 这样不会所有请求都去立刻查db\"></a>4. 失效后sleep(rand()) 这样不会所有请求都去立刻查db</h3>","site":{"data":{}},"excerpt":"","more":"<p>[toc] </p>\n<p>[toc]</p>\n<blockquote>\n<p>本系列文章整理摘抄自<redis 开发与运维=\"\"></redis></p>\n<h1 id=\"缓存设计前需要权衡成本和收益\"><a href=\"#缓存设计前需要权衡成本和收益\" class=\"headerlink\" title=\"缓存设计前需要权衡成本和收益\"></a>缓存设计前需要权衡成本和收益</h1></blockquote>\n<h2 id=\"收益\"><a href=\"#收益\" class=\"headerlink\" title=\"收益\"></a>收益</h2><ul>\n<li><strong>加速读写</strong></li>\n<li><strong>降低后端负载</strong></li>\n</ul>\n<h2 id=\"成本\"><a href=\"#成本\" class=\"headerlink\" title=\"成本\"></a>成本</h2><ul>\n<li><strong>数据不一致性</strong><ul>\n<li>缓存层和存储层数据势必会有不一致的时间，需要考虑如何避免对业务造成的影响。 </li>\n</ul>\n</li>\n<li><strong>代码维护成本</strong><ul>\n<li>redis 和 mysql 两方代码都要考虑。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"缓存如何更新？\"><a href=\"#缓存如何更新？\" class=\"headerlink\" title=\"缓存如何更新？\"></a>缓存如何更新？</h1><p>基于内存的缓存不可能将所有的数据都做缓存，一般针对的都是<strong>热点数据</strong>。热点数据具有时效性，过了一定时间将成为<strong>非热点数据</strong>。</p>\n<p>所以，缓存数据通常具有生命时长，到达指定的时间后，将被更新或者删除。</p>\n<p>熟悉缓存的常用更新策略，才能针对业务场景做出合理的选择。</p>\n<h2 id=\"更新策略1：-LRU-LFU-FIFO-算法\"><a href=\"#更新策略1：-LRU-LFU-FIFO-算法\" class=\"headerlink\" title=\"更新策略1： LRU/LFU/FIFO 算法\"></a>更新策略1： LRU/LFU/FIFO 算法</h2><p>通常缓存量超过了预设的最大值时，将会采取以上策略，具体由 <code>maxmemory-policy</code> 参数指定。</p>\n<p><strong>一致性最差。</strong></p>\n<h2 id=\"更新策略2-超时剔除\"><a href=\"#更新策略2-超时剔除\" class=\"headerlink\" title=\"更新策略2: 超时剔除\"></a>更新策略2: 超时剔除</h2><p>通过给缓存数据设置过期时间，让其在过期时间后自动删除，例如Redis提供的<code>expire</code>命令。 </p>\n<p><strong>一致性取决于时间窗口。</strong></p>\n<h2 id=\"更新策略3-主动更新\"><a href=\"#更新策略3-主动更新\" class=\"headerlink\" title=\"更新策略3: 主动更新\"></a>更新策略3: 主动更新</h2><p>当堆数据一致性要求高时，在更新存储层数据后，需要立即更新缓存中的数据。</p>\n<p><strong>一致性最好。</strong></p>\n<h2 id=\"最佳实践方案\"><a href=\"#最佳实践方案\" class=\"headerlink\" title=\"最佳实践方案\"></a>最佳实践方案</h2><h3 id=\"低一致性业务\"><a href=\"#低一致性业务\" class=\"headerlink\" title=\"低一致性业务\"></a>低一致性业务</h3><p>配置最大内存 + 淘汰策略</p>\n<h3 id=\"高一致性业务\"><a href=\"#高一致性业务\" class=\"headerlink\" title=\"高一致性业务\"></a>高一致性业务</h3><p>超时剔除 + 主动更新</p>\n<h1 id=\"缓存的粒度如何选？\"><a href=\"#缓存的粒度如何选？\" class=\"headerlink\" title=\"缓存的粒度如何选？\"></a>缓存的粒度如何选？</h1><p>对于缓存数据库的内容时，要考虑缓存全部字段，或者部分字段。</p>\n<ul>\n<li>全部字段：<ul>\n<li>全部缓存占用空间过大</li>\n<li>并不是所有字段都用的到</li>\n</ul>\n</li>\n<li>部分字段：<ul>\n<li>未来可能用到新字段 </li>\n</ul>\n</li>\n</ul>\n<h1 id=\"缓存预热\"><a href=\"#缓存预热\" class=\"headerlink\" title=\"缓存预热\"></a>缓存预热</h1><p>在系统刚上线，直接将数据加载进缓存系统，提前准备。</p>\n<h1 id=\"缓存穿透问题（针对无效查询）\"><a href=\"#缓存穿透问题（针对无效查询）\" class=\"headerlink\" title=\"缓存穿透问题（针对无效查询）\"></a>缓存穿透问题（针对无效查询）</h1><h2 id=\"概念描述\"><a href=\"#概念描述\" class=\"headerlink\" title=\"概念描述\"></a>概念描述</h2><p>缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不命中。</p>\n<h2 id=\"产生的原因\"><a href=\"#产生的原因\" class=\"headerlink\" title=\"产生的原因\"></a>产生的原因</h2><ul>\n<li>问题1：业务代码或者数据出现问题</li>\n<li>问题2：恶意攻击，爬虫造成的大量空命中</li>\n</ul>\n<h2 id=\"造成的影响\"><a href=\"#造成的影响\" class=\"headerlink\" title=\"造成的影响\"></a>造成的影响</h2><p>如果出现大量的缓存穿透，会对后端的数据库产生大流量的冲击，严重可使得数据库服务宕机。</p>\n<h2 id=\"通用解决方案\"><a href=\"#通用解决方案\" class=\"headerlink\" title=\"通用解决方案\"></a>通用解决方案</h2><h3 id=\"问题如何发现？\"><a href=\"#问题如何发现？\" class=\"headerlink\" title=\"问题如何发现？\"></a>问题如何发现？</h3><p>统计<strong>总调用数、 缓存层命中数、 存储层命中数</strong>，如果发现大量存储层空命中， 可能就是出现了缓存穿透问题。</p>\n<h3 id=\"问题如何预防？\"><a href=\"#问题如何预防？\" class=\"headerlink\" title=\"问题如何预防？\"></a>问题如何预防？</h3><h4 id=\"问题1的解决-缓存空对象-设置短过期时间\"><a href=\"#问题1的解决-缓存空对象-设置短过期时间\" class=\"headerlink\" title=\"问题1的解决. 缓存空对象 + 设置短过期时间\"></a>问题1的解决. 缓存空对象 + 设置短过期时间</h4><p>实时性高。</p>\n<p>存储层不命中后，仍然将空对象保留到缓存层中，之后再访问这个数据将会从缓存中获取，这样就保护了后端数据源。 </p>\n<h4 id=\"问题2的解决-布隆过滤器拦截（缓存层之前对存在的key做保存）\"><a href=\"#问题2的解决-布隆过滤器拦截（缓存层之前对存在的key做保存）\" class=\"headerlink\" title=\"问题2的解决. 布隆过滤器拦截（缓存层之前对存在的key做保存）\"></a>问题2的解决. 布隆过滤器拦截（缓存层之前对存在的key做保存）</h4><p>实时性差。</p>\n<p>访问缓存层和存储层之前，将存在的key用布隆过滤器提前保存起来， 做第一层拦截</p>\n<h1 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h1><h2 id=\"概念描述-1\"><a href=\"#概念描述-1\" class=\"headerlink\" title=\"概念描述\"></a>概念描述</h2><p>发生大规模的缓存失效的情况，或者缓存层宕机，大量流量冲入存储层。</p>\n<h2 id=\"产生的原因-1\"><a href=\"#产生的原因-1\" class=\"headerlink\" title=\"产生的原因\"></a>产生的原因</h2><p>缓存服务由于各种原因失效了。</p>\n<h2 id=\"造成的影响-1\"><a href=\"#造成的影响-1\" class=\"headerlink\" title=\"造成的影响\"></a>造成的影响</h2><p>数据库服务宕机。</p>\n<h2 id=\"通用解决方案-1\"><a href=\"#通用解决方案-1\" class=\"headerlink\" title=\"通用解决方案\"></a>通用解决方案</h2><h3 id=\"提前的规划：-保证缓存服务的高可用。\"><a href=\"#提前的规划：-保证缓存服务的高可用。\" class=\"headerlink\" title=\"提前的规划： 保证缓存服务的高可用。\"></a>提前的规划： 保证缓存服务的高可用。</h3><p>主从 + 哨兵， 集群。<br>Redis Sentinel和RedisCluster都实现了高可用</p>\n<h3 id=\"出现雪崩时的处理：隔离组件做限流和降级处理\"><a href=\"#出现雪崩时的处理：隔离组件做限流和降级处理\" class=\"headerlink\" title=\"出现雪崩时的处理：隔离组件做限流和降级处理\"></a>出现雪崩时的处理：隔离组件做限流和降级处理</h3><ul>\n<li>ehcache本地缓存 + Hystrix限流并降级,避免MySQL被搞死。</li>\n<li>加锁排队（并发量不高的情况下）</li>\n</ul>\n<p><strong>Hystrix限流并降级的流程</strong></p>\n<p>海量的用户请求出现：</p>\n<ul>\n<li>首先通过限流组件Hystrix限流（只有预定的请求进入存储层）</li>\n<li>对于未通过的流量，直接导到 预定的降级处理方案，比如友好的提示等待。</li>\n</ul>\n<h3 id=\"3-提前排演测试\"><a href=\"#3-提前排演测试\" class=\"headerlink\" title=\"3. 提前排演测试\"></a>3. 提前排演测试</h3><h1 id=\"缓存击-针对失效数据-热点数据高并发访问时，失效来不及重建\"><a href=\"#缓存击-针对失效数据-热点数据高并发访问时，失效来不及重建\" class=\"headerlink\" title=\"缓存击(针对失效数据)-热点数据高并发访问时，失效来不及重建\"></a>缓存击(针对失效数据)-热点数据高并发访问时，失效来不及重建</h1><h2 id=\"概念描述-2\"><a href=\"#概念描述-2\" class=\"headerlink\" title=\"概念描述\"></a>概念描述</h2><p>当热点数据并发访问量非常大，由于之前设置了过期时间，失效后难以短时间重建。</p>\n<p>比如： 热点的娱乐新闻。</p>\n<h2 id=\"产生的原因-2\"><a href=\"#产生的原因-2\" class=\"headerlink\" title=\"产生的原因\"></a>产生的原因</h2><p>缓存服务由于各种原因失效了。</p>\n<h2 id=\"造成的影响-2\"><a href=\"#造成的影响-2\" class=\"headerlink\" title=\"造成的影响\"></a>造成的影响</h2><p>数据库服务宕机。</p>\n<h2 id=\"通用解决方案-2\"><a href=\"#通用解决方案-2\" class=\"headerlink\" title=\"通用解决方案\"></a>通用解决方案</h2><h3 id=\"1-限制重建的线程数-互斥锁\"><a href=\"#1-限制重建的线程数-互斥锁\" class=\"headerlink\" title=\"1. 限制重建的线程数 - 互斥锁\"></a>1. 限制重建的线程数 - 互斥锁</h3><p>并不是所有的线程都需要去重建，第一个遇到的线程重建，其他线程等待即可。</p>\n<h4 id=\"互斥锁的实现1：通过setnx-和-expire命令实现\"><a href=\"#互斥锁的实现1：通过setnx-和-expire命令实现\" class=\"headerlink\" title=\"互斥锁的实现1：通过setnx 和 expire命令实现\"></a>互斥锁的实现1：通过setnx 和 expire命令实现</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String get(String key) &#123;</span><br><span class=\"line\">    // 从Redis中获取数据</span><br><span class=\"line\">    String value = redis.get(key);</span><br><span class=\"line\">    // 如果value为空， 则开始重构缓存</span><br><span class=\"line\">    if (value == null) &#123;</span><br><span class=\"line\">        // 只允许一个线程重构缓存， 使用nx， 并设置过期时间ex</span><br><span class=\"line\">        String mutexKey = &quot;mutext:key:&quot; + key;</span><br><span class=\"line\">        if (redis.set(mutexKey, &quot;1&quot;, &quot;ex 180&quot;, &quot;nx&quot;)) &#123;</span><br><span class=\"line\">            // 从数据源获取数据</span><br><span class=\"line\">            value = db.get(key);</span><br><span class=\"line\">            // 回写Redis， 并设置过期时间</span><br><span class=\"line\">            redis.setex(key, timeout, value);</span><br><span class=\"line\">            // 删除key_mutex</span><br><span class=\"line\">            redis.delete(mutexKey);</span><br><span class=\"line\">        &#125;/</span><br><span class=\"line\">        / 其他线程休息50毫秒后重试</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            Thread.sleep(50);</span><br><span class=\"line\">            get(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;return value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"互斥锁的实现2：通过watch和Redis的事务命令实现\"><a href=\"#互斥锁的实现2：通过watch和Redis的事务命令实现\" class=\"headerlink\" title=\"互斥锁的实现2：通过watch和Redis的事务命令实现\"></a>互斥锁的实现2：通过watch和Redis的事务命令实现</h4><h3 id=\"2-永不过期\"><a href=\"#2-永不过期\" class=\"headerlink\" title=\"2. 永不过期\"></a>2. 永不过期</h3><p>但是会出现数据不一致的情况。</p>\n<h3 id=\"3-错峰失效\"><a href=\"#3-错峰失效\" class=\"headerlink\" title=\"3. 错峰失效\"></a>3. 错峰失效</h3><p>不要让热点数据集中失效，而是一批一批，分时间段的失效</p>\n<h3 id=\"4-失效后sleep-rand-这样不会所有请求都去立刻查db\"><a href=\"#4-失效后sleep-rand-这样不会所有请求都去立刻查db\" class=\"headerlink\" title=\"4. 失效后sleep(rand()) 这样不会所有请求都去立刻查db\"></a>4. 失效后sleep(rand()) 这样不会所有请求都去立刻查db</h3>"},{"title":"redis学习-常用API","date":"2020-05-15T16:15:05.000Z","_content":"\n[toc]\n\n> 本系列文章整理摘抄自<Redis 开发与运维>\n# 全局命令\n\n## 1. 查看所有键 **keys**\n\n遍历所有的键，时间复杂度O(n), 线上禁止使用。\n```\nkeys *\n```\n\n## 2. 键总数 **dbsize**\n该指令直接获取Redis 内置的键总数变量， 时间复杂度 O(1)\n```\ndbsize\n```\n\n## 3. 键是否存在 **exist**\n\n存在返回1， 不存在返回0\n```\nexist key\n```\n## 4. 删除键 **del**\n\n```\ndel key1  key2  key3\n```\n\n## 5. 设置键过期 **expire**\n\n成功返回1\n```\n// expire key seconds\nset key helloword\nexpire key 10\n```\n\n## 6. 查询键过期 **ttl**\n- 返回 >0 : 剩余的过期时间\n- 返回 -1 : 键没设置过期时间\n- 返回 -2 ：键不存在\n```\nttl key\n```\n\n## 7. 键的类型  **type**\n若键不存在，返回 none\n```\ntype key\n```\n\n# 5种常用的数据类型\nRedis 是字典服务器，其中键都是字符串类型，并且数据结构也都是在字符串类型上构建的。\n\n而字符串类型的底层实现值可以为字符串，整数，浮点数，二进制。\n\n字符串类型最大不能超过 512MB.\n\n\n## 字符串\n\n### 常用命令\n\n#### 1. 设置值 set、setex、setnx、set .. xx\n\n==set 命令的参数：==\n- ex seconds: 秒过期\n- px milliseconds ： 毫秒过期\n- nx ：键必须不存在 （失败返回 0）\n- xx ：键必须存在\n```\n// set key value [ex seconds] [px milliseconds] [nx | xx]\n\nset hello world ex 60 \n\n```\n\n==设置时间:==\n\n```\nsetex key seconds value\n```\n\n==设置不存在的key==\n\n<font color=red size=5>setnx 可以作为分布式锁的一种实现方案</font>\n\n- 失败： 返回 0\n- 成功： 返回 1\n```\nsetnx key value\n```\n\n==设置存在的key==\n- 失败： 返回 nil\n- 成功： 返回 ok\n```\nset key value xx\n```\n\n#### 2. 获取值 get\n\n==获取键值==\n- 不存在： 返回 nil\n- 存在：   返回值\n```\nget key\n```\n\n#### 3. 批量设置值 mset\n\n<font color=red size=3>批量操作可以减少网络资源的浪费</font>\n```\nmset key1 value1   key2 value2    key3 value3\n```\n\n#### 4. 批量获取值 mget\n\n如果有空的， 该空值返回 nil\n```\nmget key1  key2  key3\n```\n\n#### 5. 计数操作 incr、decr、incrby(自增指定值)、decrby(自减指定值)\n\n<font color=red size=3>redis 的计数不是cas, 因为是单线程，不会出现冲突</font>\n- 不存在：  自动创建并返回1\n- 存在：    返回增后的值\n\n```\n// 自增\n//incr key\n\n```\n\n### 不常用命令\n\n#### 1. 追加值 append \n<font color=red size=3>可以对incr 的整数或者其他类型追加，因为它们都是string类型</font>\n\n```\n// append key  value\n```\n\n#### 2. 字符串的长度 strlen\n\n- 不存在：   返回 0 \n- 存在：     返回字符串长度\n```\n// strlen key\n```\n\n#### 3. 设置并且返回原值  getset\n\n```\n// getset key value\n```\n\n#### 4. 设置指定位置的字符\n\n```\n// setrange key offset value\n\n```\n\n#### 5. 获取部分字符串\n```\n// getrange key start end\n```\n\n### 内部编码\n\n字符串类型内部有3 种编码，\n\n- int :    8字节\n- embstr ：<= 39 字节的字符串\n- raw ：   > 39 字节的字符串\n\n查看类型的方法\n\n```\nobject  encoding key1\n```\n### 应用场景\n\n#### 1. 缓存\n<font color=red size=3>加速读写并减轻后端数据库的压力</font>\n\n推荐的key 定义规则：\n\n```\n// 业务名：对象名：id：[属性]\n\nmiaosha:item:itemId:price\n```\n\n#### 2. 计数\n\n实现业务上的快速技术、查询缓存，能够异步的写入数据库，减少数据库的访问压力。\n\n#### 3. session 共享\n\nweb 服务通常由多台服务器协同提供用户访问的服务，而用户登陆后的登陆信息如何保存？\n\n借助 Redis 缓存将 用户session 集中管理，当用户登陆和查询时，在 Redis 服务器更新或者查询即可。\n\n#### 4. 限速\n\n比如限制单位时间内验证码的次数。\n\n## 哈希\n\n### 常用命令\n\n#### 1. 设置值 hset & hsetnx (不存在才设置)\n\n**hset:**\n- 成功： 返回 1\n- 失败： 返回 0 \n\n**hsetnx**\n- 成功：\n- 失败：\n<font color=red size=3> 待验证</font>\n```\n// hashkey : value\nhset key hashKey value\n```\n\n#### 2. 获取值 hget\n\n不存在： 返回nil\n```\nhget key \n```\n\n#### 3. 删除值 hdel key field\n\n- 删除成功：返回 1\n- 删除失败：返回 0\n\n```\n// hset  mykey key1 value1\n// hset  mykey key2 value2\n\nhdel  mykey  key1\n// 删除后再查询会返回 nil\n```\n\n#### 4. 计算field 个数 hlen\n\n```\nhlen mykey \n\n```\n\n#### 5. 批量设置或者获取 hmset & hmget\n\n**hmset** \n- 成功返回 OK\n\n```\nhmset  mykey key3 value3  key4 value 4\n\n// 批量获取返回\n1) \"value1\"\n2) \"value2\"\n```\n\n#### 6. 判断field 是否存在 hexists\n- 存在： 返回 1\n- 不存在： 返回 0\n```\nhexists  mykey key3\n```\n\n#### 7. 获取所有的field, hkeys\n\n```\nhkeys mykey\n\n// 返回\n\n1) \"key2\"\n2) \"key1\"\n3) \"key3\"\n4) \"key4\"\n5) \"key5\"\n```\n\n#### 8. 获取所有的value， hvals mykey\n\n#### 9. 获取 k - v ： hgetall mykey\n\n<font color=red size=3>值太多时，会引起阻塞，线上可以 hscan  和 hmget</font>\n\n#### 10. values 的自增  hincrby hincrbyfloat\n```\nhincrby\n```\n\n#### 11. 计算value的字符串长度（需要Redis3.2以上） hstrlen\n\n```\nhstrlen mykey key1\n```\n\n### 内部编码\n\n哈希类型内部编码主要有两种：\n- ziplist （更省内存）（数量小于512且value 小于64字节时，默认使用）\n- hashtable  读写时间复杂度 O(1)\n\n\n### 应用场景\n\n#### 利用 hash 存储 数据库中的整行字段 \n\n\n## 列表\n\n- 列表用来储存多个有序的字符串。\n- 可以当队列和堆栈使用\n\n### 主要的操作：\n- 添加 `rpush & lpush`,  `linsert`\n- 删除 `lpop & rpop`, `lrem`, `ltrim`\n- 查找 `lrange`,   `lindex`, `llen`\n- 修改  `lset`\n- 阻塞 `blpop & brpop`\n\n\n#### 1. 添加 lpush & rpush, linsert\n```\n// 左，右插入\nlpush elgong.list  1\n\nrpush elgong.lsit  2\n\n// 指定位置插入\nlinsert  elgong.list  after| before  location  value\n```\n\n#### 2. 删除 rpop & lpop, lrem\n\n**lrem** 删除指定元素\n`lrem elgong.list  count  value`\n\n- value 为被删除的值\n- count > 0:  从左往右删除 count 个\n- count = 0:  全部删除\n- count < 0： 从右往左删除 count 个\n\n```\nrpop elgong.list\nlpop elgong.list\n\n// 删除指定的元素\n\n\n```\n\n#### 3. 查找 lrange ， lindex， llen\n```\n// 获取从左到右 所有元素\nlrange elgong.list 0  -1\n\n// 指定范围查找\nlrange elgong.list  start  end\n\n// 获取指定下标的元素, 索引为2\nlindex  elgong.list 2\n\n```\n\n#### 4. 修改 lset\n```\nlset key index newValue\n```\n\n#### 5. 阻塞 blpop & brpop\n\n有参数 timeout，\n\n如果timeout = 0， 一直阻塞\n```\n// 等到list有值时再返回\nblpop elgong.list  0\n\n// 阻塞最长3s\nblpop elgong.list  3\n```\n\n### 内部编码\n\n- ziplist （长度小于512， 单值 小于64 字节时默认采用）\n- linkedlist\n\n### 应用场景\n\n#### 1. 消息队列\n\n通过阻塞可以实现生产者消费者模式。\n\n## 集合\n\n\n\n### 内部编码\n\n### 应用场景\n\n## 有序集合\n\n\n### 常用命令\n\n### 不常用命令\n\n### 内部编码\n\n### 应用场景\n\n# 键的管理\n常用的指令入 del, exists, expire, type, object.\n\n## 6. 键的重命名 rename\n\n```\nrename elgong.list  newlist\n```\n\n## 7. 随机返回一个键 randomKey\n\n```\nrandomKey\n```\n\n## 8. 键过期时间\n\n\n## 9. 键的遍历\n```\n// 匹配\nkeys [j,r]edis\n// 输出： jedis 和 redis 中存在的\n```","source":"_posts/redis学习-常用API.md","raw":"---\ntitle: redis学习-常用API\ndate: 2020-05-16 00:15:05\ncategories: 缓存中间件\ntags: redis\n---\n\n[toc]\n\n> 本系列文章整理摘抄自<Redis 开发与运维>\n# 全局命令\n\n## 1. 查看所有键 **keys**\n\n遍历所有的键，时间复杂度O(n), 线上禁止使用。\n```\nkeys *\n```\n\n## 2. 键总数 **dbsize**\n该指令直接获取Redis 内置的键总数变量， 时间复杂度 O(1)\n```\ndbsize\n```\n\n## 3. 键是否存在 **exist**\n\n存在返回1， 不存在返回0\n```\nexist key\n```\n## 4. 删除键 **del**\n\n```\ndel key1  key2  key3\n```\n\n## 5. 设置键过期 **expire**\n\n成功返回1\n```\n// expire key seconds\nset key helloword\nexpire key 10\n```\n\n## 6. 查询键过期 **ttl**\n- 返回 >0 : 剩余的过期时间\n- 返回 -1 : 键没设置过期时间\n- 返回 -2 ：键不存在\n```\nttl key\n```\n\n## 7. 键的类型  **type**\n若键不存在，返回 none\n```\ntype key\n```\n\n# 5种常用的数据类型\nRedis 是字典服务器，其中键都是字符串类型，并且数据结构也都是在字符串类型上构建的。\n\n而字符串类型的底层实现值可以为字符串，整数，浮点数，二进制。\n\n字符串类型最大不能超过 512MB.\n\n\n## 字符串\n\n### 常用命令\n\n#### 1. 设置值 set、setex、setnx、set .. xx\n\n==set 命令的参数：==\n- ex seconds: 秒过期\n- px milliseconds ： 毫秒过期\n- nx ：键必须不存在 （失败返回 0）\n- xx ：键必须存在\n```\n// set key value [ex seconds] [px milliseconds] [nx | xx]\n\nset hello world ex 60 \n\n```\n\n==设置时间:==\n\n```\nsetex key seconds value\n```\n\n==设置不存在的key==\n\n<font color=red size=5>setnx 可以作为分布式锁的一种实现方案</font>\n\n- 失败： 返回 0\n- 成功： 返回 1\n```\nsetnx key value\n```\n\n==设置存在的key==\n- 失败： 返回 nil\n- 成功： 返回 ok\n```\nset key value xx\n```\n\n#### 2. 获取值 get\n\n==获取键值==\n- 不存在： 返回 nil\n- 存在：   返回值\n```\nget key\n```\n\n#### 3. 批量设置值 mset\n\n<font color=red size=3>批量操作可以减少网络资源的浪费</font>\n```\nmset key1 value1   key2 value2    key3 value3\n```\n\n#### 4. 批量获取值 mget\n\n如果有空的， 该空值返回 nil\n```\nmget key1  key2  key3\n```\n\n#### 5. 计数操作 incr、decr、incrby(自增指定值)、decrby(自减指定值)\n\n<font color=red size=3>redis 的计数不是cas, 因为是单线程，不会出现冲突</font>\n- 不存在：  自动创建并返回1\n- 存在：    返回增后的值\n\n```\n// 自增\n//incr key\n\n```\n\n### 不常用命令\n\n#### 1. 追加值 append \n<font color=red size=3>可以对incr 的整数或者其他类型追加，因为它们都是string类型</font>\n\n```\n// append key  value\n```\n\n#### 2. 字符串的长度 strlen\n\n- 不存在：   返回 0 \n- 存在：     返回字符串长度\n```\n// strlen key\n```\n\n#### 3. 设置并且返回原值  getset\n\n```\n// getset key value\n```\n\n#### 4. 设置指定位置的字符\n\n```\n// setrange key offset value\n\n```\n\n#### 5. 获取部分字符串\n```\n// getrange key start end\n```\n\n### 内部编码\n\n字符串类型内部有3 种编码，\n\n- int :    8字节\n- embstr ：<= 39 字节的字符串\n- raw ：   > 39 字节的字符串\n\n查看类型的方法\n\n```\nobject  encoding key1\n```\n### 应用场景\n\n#### 1. 缓存\n<font color=red size=3>加速读写并减轻后端数据库的压力</font>\n\n推荐的key 定义规则：\n\n```\n// 业务名：对象名：id：[属性]\n\nmiaosha:item:itemId:price\n```\n\n#### 2. 计数\n\n实现业务上的快速技术、查询缓存，能够异步的写入数据库，减少数据库的访问压力。\n\n#### 3. session 共享\n\nweb 服务通常由多台服务器协同提供用户访问的服务，而用户登陆后的登陆信息如何保存？\n\n借助 Redis 缓存将 用户session 集中管理，当用户登陆和查询时，在 Redis 服务器更新或者查询即可。\n\n#### 4. 限速\n\n比如限制单位时间内验证码的次数。\n\n## 哈希\n\n### 常用命令\n\n#### 1. 设置值 hset & hsetnx (不存在才设置)\n\n**hset:**\n- 成功： 返回 1\n- 失败： 返回 0 \n\n**hsetnx**\n- 成功：\n- 失败：\n<font color=red size=3> 待验证</font>\n```\n// hashkey : value\nhset key hashKey value\n```\n\n#### 2. 获取值 hget\n\n不存在： 返回nil\n```\nhget key \n```\n\n#### 3. 删除值 hdel key field\n\n- 删除成功：返回 1\n- 删除失败：返回 0\n\n```\n// hset  mykey key1 value1\n// hset  mykey key2 value2\n\nhdel  mykey  key1\n// 删除后再查询会返回 nil\n```\n\n#### 4. 计算field 个数 hlen\n\n```\nhlen mykey \n\n```\n\n#### 5. 批量设置或者获取 hmset & hmget\n\n**hmset** \n- 成功返回 OK\n\n```\nhmset  mykey key3 value3  key4 value 4\n\n// 批量获取返回\n1) \"value1\"\n2) \"value2\"\n```\n\n#### 6. 判断field 是否存在 hexists\n- 存在： 返回 1\n- 不存在： 返回 0\n```\nhexists  mykey key3\n```\n\n#### 7. 获取所有的field, hkeys\n\n```\nhkeys mykey\n\n// 返回\n\n1) \"key2\"\n2) \"key1\"\n3) \"key3\"\n4) \"key4\"\n5) \"key5\"\n```\n\n#### 8. 获取所有的value， hvals mykey\n\n#### 9. 获取 k - v ： hgetall mykey\n\n<font color=red size=3>值太多时，会引起阻塞，线上可以 hscan  和 hmget</font>\n\n#### 10. values 的自增  hincrby hincrbyfloat\n```\nhincrby\n```\n\n#### 11. 计算value的字符串长度（需要Redis3.2以上） hstrlen\n\n```\nhstrlen mykey key1\n```\n\n### 内部编码\n\n哈希类型内部编码主要有两种：\n- ziplist （更省内存）（数量小于512且value 小于64字节时，默认使用）\n- hashtable  读写时间复杂度 O(1)\n\n\n### 应用场景\n\n#### 利用 hash 存储 数据库中的整行字段 \n\n\n## 列表\n\n- 列表用来储存多个有序的字符串。\n- 可以当队列和堆栈使用\n\n### 主要的操作：\n- 添加 `rpush & lpush`,  `linsert`\n- 删除 `lpop & rpop`, `lrem`, `ltrim`\n- 查找 `lrange`,   `lindex`, `llen`\n- 修改  `lset`\n- 阻塞 `blpop & brpop`\n\n\n#### 1. 添加 lpush & rpush, linsert\n```\n// 左，右插入\nlpush elgong.list  1\n\nrpush elgong.lsit  2\n\n// 指定位置插入\nlinsert  elgong.list  after| before  location  value\n```\n\n#### 2. 删除 rpop & lpop, lrem\n\n**lrem** 删除指定元素\n`lrem elgong.list  count  value`\n\n- value 为被删除的值\n- count > 0:  从左往右删除 count 个\n- count = 0:  全部删除\n- count < 0： 从右往左删除 count 个\n\n```\nrpop elgong.list\nlpop elgong.list\n\n// 删除指定的元素\n\n\n```\n\n#### 3. 查找 lrange ， lindex， llen\n```\n// 获取从左到右 所有元素\nlrange elgong.list 0  -1\n\n// 指定范围查找\nlrange elgong.list  start  end\n\n// 获取指定下标的元素, 索引为2\nlindex  elgong.list 2\n\n```\n\n#### 4. 修改 lset\n```\nlset key index newValue\n```\n\n#### 5. 阻塞 blpop & brpop\n\n有参数 timeout，\n\n如果timeout = 0， 一直阻塞\n```\n// 等到list有值时再返回\nblpop elgong.list  0\n\n// 阻塞最长3s\nblpop elgong.list  3\n```\n\n### 内部编码\n\n- ziplist （长度小于512， 单值 小于64 字节时默认采用）\n- linkedlist\n\n### 应用场景\n\n#### 1. 消息队列\n\n通过阻塞可以实现生产者消费者模式。\n\n## 集合\n\n\n\n### 内部编码\n\n### 应用场景\n\n## 有序集合\n\n\n### 常用命令\n\n### 不常用命令\n\n### 内部编码\n\n### 应用场景\n\n# 键的管理\n常用的指令入 del, exists, expire, type, object.\n\n## 6. 键的重命名 rename\n\n```\nrename elgong.list  newlist\n```\n\n## 7. 随机返回一个键 randomKey\n\n```\nrandomKey\n```\n\n## 8. 键过期时间\n\n\n## 9. 键的遍历\n```\n// 匹配\nkeys [j,r]edis\n// 输出： jedis 和 redis 中存在的\n```","slug":"redis学习-常用API","published":1,"updated":"2020-05-15T16:15:53.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephfa001pt8pl9lzm89al","content":"<p>[toc]</p>\n<blockquote>\n<p>本系列文章整理摘抄自<redis 开发与运维=\"\"></redis></p>\n<h1 id=\"全局命令\"><a href=\"#全局命令\" class=\"headerlink\" title=\"全局命令\"></a>全局命令</h1></blockquote>\n<h2 id=\"1-查看所有键-keys\"><a href=\"#1-查看所有键-keys\" class=\"headerlink\" title=\"1. 查看所有键 keys\"></a>1. 查看所有键 <strong>keys</strong></h2><p>遍历所有的键，时间复杂度O(n), 线上禁止使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keys *</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-键总数-dbsize\"><a href=\"#2-键总数-dbsize\" class=\"headerlink\" title=\"2. 键总数 dbsize\"></a>2. 键总数 <strong>dbsize</strong></h2><p>该指令直接获取Redis 内置的键总数变量， 时间复杂度 O(1)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dbsize</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-键是否存在-exist\"><a href=\"#3-键是否存在-exist\" class=\"headerlink\" title=\"3. 键是否存在 exist\"></a>3. 键是否存在 <strong>exist</strong></h2><p>存在返回1， 不存在返回0<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exist key</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-删除键-del\"><a href=\"#4-删除键-del\" class=\"headerlink\" title=\"4. 删除键 del\"></a>4. 删除键 <strong>del</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">del key1  key2  key3</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-设置键过期-expire\"><a href=\"#5-设置键过期-expire\" class=\"headerlink\" title=\"5. 设置键过期 expire\"></a>5. 设置键过期 <strong>expire</strong></h2><p>成功返回1<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// expire key seconds</span><br><span class=\"line\">set key helloword</span><br><span class=\"line\">expire key 10</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-查询键过期-ttl\"><a href=\"#6-查询键过期-ttl\" class=\"headerlink\" title=\"6. 查询键过期 ttl\"></a>6. 查询键过期 <strong>ttl</strong></h2><ul>\n<li>返回 &gt;0 : 剩余的过期时间</li>\n<li>返回 -1 : 键没设置过期时间</li>\n<li>返回 -2 ：键不存在<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ttl key</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"7-键的类型-type\"><a href=\"#7-键的类型-type\" class=\"headerlink\" title=\"7. 键的类型  type\"></a>7. 键的类型  <strong>type</strong></h2><p>若键不存在，返回 none<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type key</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"5种常用的数据类型\"><a href=\"#5种常用的数据类型\" class=\"headerlink\" title=\"5种常用的数据类型\"></a>5种常用的数据类型</h1><p>Redis 是字典服务器，其中键都是字符串类型，并且数据结构也都是在字符串类型上构建的。</p>\n<p>而字符串类型的底层实现值可以为字符串，整数，浮点数，二进制。</p>\n<p>字符串类型最大不能超过 512MB.</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><h4 id=\"1-设置值-set、setex、setnx、set-xx\"><a href=\"#1-设置值-set、setex、setnx、set-xx\" class=\"headerlink\" title=\"1. 设置值 set、setex、setnx、set .. xx\"></a>1. 设置值 set、setex、setnx、set .. xx</h4><p>==set 命令的参数：==</p>\n<ul>\n<li>ex seconds: 秒过期</li>\n<li>px milliseconds ： 毫秒过期</li>\n<li>nx ：键必须不存在 （失败返回 0）</li>\n<li>xx ：键必须存在<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// set key value [ex seconds] [px milliseconds] [nx | xx]</span><br><span class=\"line\"></span><br><span class=\"line\">set hello world ex 60</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>==设置时间:==</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setex key seconds value</span><br></pre></td></tr></table></figure>\n<p>==设置不存在的key==</p>\n<font color=\"red\" size=\"5\">setnx 可以作为分布式锁的一种实现方案</font>\n\n<ul>\n<li>失败： 返回 0</li>\n<li>成功： 返回 1<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setnx key value</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>==设置存在的key==</p>\n<ul>\n<li>失败： 返回 nil</li>\n<li>成功： 返回 ok<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set key value xx</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-获取值-get\"><a href=\"#2-获取值-get\" class=\"headerlink\" title=\"2. 获取值 get\"></a>2. 获取值 get</h4><p>==获取键值==</p>\n<ul>\n<li>不存在： 返回 nil</li>\n<li>存在：   返回值<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get key</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"3-批量设置值-mset\"><a href=\"#3-批量设置值-mset\" class=\"headerlink\" title=\"3. 批量设置值 mset\"></a>3. 批量设置值 mset</h4><font color=\"red\" size=\"3\">批量操作可以减少网络资源的浪费</font>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mset key1 value1   key2 value2    key3 value3</span><br></pre></td></tr></table></figure>\n\n#### 4. 批量获取值 mget\n\n如果有空的， 该空值返回 nil\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mget key1  key2  key3</span><br></pre></td></tr></table></figure>\n\n#### 5. 计数操作 incr、decr、incrby(自增指定值)、decrby(自减指定值)\n\n<font color=\"red\" size=\"3\">redis 的计数不是cas, 因为是单线程，不会出现冲突</font>\n- 不存在：  自动创建并返回1\n- 存在：    返回增后的值\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 自增</span><br><span class=\"line\">//incr key</span><br></pre></td></tr></table></figure>\n\n### 不常用命令\n\n#### 1. 追加值 append \n<font color=\"red\" size=\"3\">可以对incr 的整数或者其他类型追加，因为它们都是string类型</font>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// append key  value</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-字符串的长度-strlen\"><a href=\"#2-字符串的长度-strlen\" class=\"headerlink\" title=\"2. 字符串的长度 strlen\"></a>2. 字符串的长度 strlen</h4><ul>\n<li>不存在：   返回 0 </li>\n<li>存在：     返回字符串长度<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// strlen key</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"3-设置并且返回原值-getset\"><a href=\"#3-设置并且返回原值-getset\" class=\"headerlink\" title=\"3. 设置并且返回原值  getset\"></a>3. 设置并且返回原值  getset</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// getset key value</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-设置指定位置的字符\"><a href=\"#4-设置指定位置的字符\" class=\"headerlink\" title=\"4. 设置指定位置的字符\"></a>4. 设置指定位置的字符</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// setrange key offset value</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-获取部分字符串\"><a href=\"#5-获取部分字符串\" class=\"headerlink\" title=\"5. 获取部分字符串\"></a>5. 获取部分字符串</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// getrange key start end</span><br></pre></td></tr></table></figure>\n<h3 id=\"内部编码\"><a href=\"#内部编码\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h3><p>字符串类型内部有3 种编码，</p>\n<ul>\n<li>int :    8字节</li>\n<li>embstr ：&lt;= 39 字节的字符串</li>\n<li>raw ：   &gt; 39 字节的字符串</li>\n</ul>\n<p>查看类型的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object  encoding key1</span><br></pre></td></tr></table></figure>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h4 id=\"1-缓存\"><a href=\"#1-缓存\" class=\"headerlink\" title=\"1. 缓存\"></a>1. 缓存</h4><font color=\"red\" size=\"3\">加速读写并减轻后端数据库的压力</font>\n\n<p>推荐的key 定义规则：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 业务名：对象名：id：[属性]</span><br><span class=\"line\"></span><br><span class=\"line\">miaosha:item:itemId:price</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-计数\"><a href=\"#2-计数\" class=\"headerlink\" title=\"2. 计数\"></a>2. 计数</h4><p>实现业务上的快速技术、查询缓存，能够异步的写入数据库，减少数据库的访问压力。</p>\n<h4 id=\"3-session-共享\"><a href=\"#3-session-共享\" class=\"headerlink\" title=\"3. session 共享\"></a>3. session 共享</h4><p>web 服务通常由多台服务器协同提供用户访问的服务，而用户登陆后的登陆信息如何保存？</p>\n<p>借助 Redis 缓存将 用户session 集中管理，当用户登陆和查询时，在 Redis 服务器更新或者查询即可。</p>\n<h4 id=\"4-限速\"><a href=\"#4-限速\" class=\"headerlink\" title=\"4. 限速\"></a>4. 限速</h4><p>比如限制单位时间内验证码的次数。</p>\n<h2 id=\"哈希\"><a href=\"#哈希\" class=\"headerlink\" title=\"哈希\"></a>哈希</h2><h3 id=\"常用命令-1\"><a href=\"#常用命令-1\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><h4 id=\"1-设置值-hset-amp-hsetnx-不存在才设置\"><a href=\"#1-设置值-hset-amp-hsetnx-不存在才设置\" class=\"headerlink\" title=\"1. 设置值 hset &amp; hsetnx (不存在才设置)\"></a>1. 设置值 hset &amp; hsetnx (不存在才设置)</h4><p><strong>hset:</strong></p>\n<ul>\n<li>成功： 返回 1</li>\n<li>失败： 返回 0 </li>\n</ul>\n<p><strong>hsetnx</strong></p>\n<ul>\n<li>成功：</li>\n<li>失败：<br><font color=\"red\" size=\"3\"> 待验证</font><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// hashkey : value</span><br><span class=\"line\">hset key hashKey value</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-获取值-hget\"><a href=\"#2-获取值-hget\" class=\"headerlink\" title=\"2. 获取值 hget\"></a>2. 获取值 hget</h4><p>不存在： 返回nil<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hget key</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-删除值-hdel-key-field\"><a href=\"#3-删除值-hdel-key-field\" class=\"headerlink\" title=\"3. 删除值 hdel key field\"></a>3. 删除值 hdel key field</h4><ul>\n<li>删除成功：返回 1</li>\n<li>删除失败：返回 0</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// hset  mykey key1 value1</span><br><span class=\"line\">// hset  mykey key2 value2</span><br><span class=\"line\"></span><br><span class=\"line\">hdel  mykey  key1</span><br><span class=\"line\">// 删除后再查询会返回 nil</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-计算field-个数-hlen\"><a href=\"#4-计算field-个数-hlen\" class=\"headerlink\" title=\"4. 计算field 个数 hlen\"></a>4. 计算field 个数 hlen</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hlen mykey</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-批量设置或者获取-hmset-amp-hmget\"><a href=\"#5-批量设置或者获取-hmset-amp-hmget\" class=\"headerlink\" title=\"5. 批量设置或者获取 hmset &amp; hmget\"></a>5. 批量设置或者获取 hmset &amp; hmget</h4><p><strong>hmset</strong> </p>\n<ul>\n<li>成功返回 OK</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hmset  mykey key3 value3  key4 value 4</span><br><span class=\"line\"></span><br><span class=\"line\">// 批量获取返回</span><br><span class=\"line\">1) &quot;value1&quot;</span><br><span class=\"line\">2) &quot;value2&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-判断field-是否存在-hexists\"><a href=\"#6-判断field-是否存在-hexists\" class=\"headerlink\" title=\"6. 判断field 是否存在 hexists\"></a>6. 判断field 是否存在 hexists</h4><ul>\n<li>存在： 返回 1</li>\n<li>不存在： 返回 0<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexists  mykey key3</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"7-获取所有的field-hkeys\"><a href=\"#7-获取所有的field-hkeys\" class=\"headerlink\" title=\"7. 获取所有的field, hkeys\"></a>7. 获取所有的field, hkeys</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hkeys mykey</span><br><span class=\"line\"></span><br><span class=\"line\">// 返回</span><br><span class=\"line\"></span><br><span class=\"line\">1) &quot;key2&quot;</span><br><span class=\"line\">2) &quot;key1&quot;</span><br><span class=\"line\">3) &quot;key3&quot;</span><br><span class=\"line\">4) &quot;key4&quot;</span><br><span class=\"line\">5) &quot;key5&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"8-获取所有的value，-hvals-mykey\"><a href=\"#8-获取所有的value，-hvals-mykey\" class=\"headerlink\" title=\"8. 获取所有的value， hvals mykey\"></a>8. 获取所有的value， hvals mykey</h4><h4 id=\"9-获取-k-v-：-hgetall-mykey\"><a href=\"#9-获取-k-v-：-hgetall-mykey\" class=\"headerlink\" title=\"9. 获取 k - v ： hgetall mykey\"></a>9. 获取 k - v ： hgetall mykey</h4><font color=\"red\" size=\"3\">值太多时，会引起阻塞，线上可以 hscan  和 hmget</font>\n\n<h4 id=\"10-values-的自增-hincrby-hincrbyfloat\"><a href=\"#10-values-的自增-hincrby-hincrbyfloat\" class=\"headerlink\" title=\"10. values 的自增  hincrby hincrbyfloat\"></a>10. values 的自增  hincrby hincrbyfloat</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hincrby</span><br></pre></td></tr></table></figure>\n<h4 id=\"11-计算value的字符串长度（需要Redis3-2以上）-hstrlen\"><a href=\"#11-计算value的字符串长度（需要Redis3-2以上）-hstrlen\" class=\"headerlink\" title=\"11. 计算value的字符串长度（需要Redis3.2以上） hstrlen\"></a>11. 计算value的字符串长度（需要Redis3.2以上） hstrlen</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hstrlen mykey key1</span><br></pre></td></tr></table></figure>\n<h3 id=\"内部编码-1\"><a href=\"#内部编码-1\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h3><p>哈希类型内部编码主要有两种：</p>\n<ul>\n<li>ziplist （更省内存）（数量小于512且value 小于64字节时，默认使用）</li>\n<li>hashtable  读写时间复杂度 O(1)</li>\n</ul>\n<h3 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h4 id=\"利用-hash-存储-数据库中的整行字段\"><a href=\"#利用-hash-存储-数据库中的整行字段\" class=\"headerlink\" title=\"利用 hash 存储 数据库中的整行字段\"></a>利用 hash 存储 数据库中的整行字段</h4><h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ul>\n<li>列表用来储存多个有序的字符串。</li>\n<li>可以当队列和堆栈使用</li>\n</ul>\n<h3 id=\"主要的操作：\"><a href=\"#主要的操作：\" class=\"headerlink\" title=\"主要的操作：\"></a>主要的操作：</h3><ul>\n<li>添加 <code>rpush &amp; lpush</code>,  <code>linsert</code></li>\n<li>删除 <code>lpop &amp; rpop</code>, <code>lrem</code>, <code>ltrim</code></li>\n<li>查找 <code>lrange</code>,   <code>lindex</code>, <code>llen</code></li>\n<li>修改  <code>lset</code></li>\n<li>阻塞 <code>blpop &amp; brpop</code></li>\n</ul>\n<h4 id=\"1-添加-lpush-amp-rpush-linsert\"><a href=\"#1-添加-lpush-amp-rpush-linsert\" class=\"headerlink\" title=\"1. 添加 lpush &amp; rpush, linsert\"></a>1. 添加 lpush &amp; rpush, linsert</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 左，右插入</span><br><span class=\"line\">lpush elgong.list  1</span><br><span class=\"line\"></span><br><span class=\"line\">rpush elgong.lsit  2</span><br><span class=\"line\"></span><br><span class=\"line\">// 指定位置插入</span><br><span class=\"line\">linsert  elgong.list  after| before  location  value</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-删除-rpop-amp-lpop-lrem\"><a href=\"#2-删除-rpop-amp-lpop-lrem\" class=\"headerlink\" title=\"2. 删除 rpop &amp; lpop, lrem\"></a>2. 删除 rpop &amp; lpop, lrem</h4><p><strong>lrem</strong> 删除指定元素<br><code>lrem elgong.list  count  value</code></p>\n<ul>\n<li>value 为被删除的值</li>\n<li>count &gt; 0:  从左往右删除 count 个</li>\n<li>count = 0:  全部删除</li>\n<li>count &lt; 0： 从右往左删除 count 个</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpop elgong.list</span><br><span class=\"line\">lpop elgong.list</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除指定的元素</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-查找-lrange-，-lindex，-llen\"><a href=\"#3-查找-lrange-，-lindex，-llen\" class=\"headerlink\" title=\"3. 查找 lrange ， lindex， llen\"></a>3. 查找 lrange ， lindex， llen</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获取从左到右 所有元素</span><br><span class=\"line\">lrange elgong.list 0  -1</span><br><span class=\"line\"></span><br><span class=\"line\">// 指定范围查找</span><br><span class=\"line\">lrange elgong.list  start  end</span><br><span class=\"line\"></span><br><span class=\"line\">// 获取指定下标的元素, 索引为2</span><br><span class=\"line\">lindex  elgong.list 2</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-修改-lset\"><a href=\"#4-修改-lset\" class=\"headerlink\" title=\"4. 修改 lset\"></a>4. 修改 lset</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lset key index newValue</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-阻塞-blpop-amp-brpop\"><a href=\"#5-阻塞-blpop-amp-brpop\" class=\"headerlink\" title=\"5. 阻塞 blpop &amp; brpop\"></a>5. 阻塞 blpop &amp; brpop</h4><p>有参数 timeout，</p>\n<p>如果timeout = 0， 一直阻塞<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 等到list有值时再返回</span><br><span class=\"line\">blpop elgong.list  0</span><br><span class=\"line\"></span><br><span class=\"line\">// 阻塞最长3s</span><br><span class=\"line\">blpop elgong.list  3</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"内部编码-2\"><a href=\"#内部编码-2\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h3><ul>\n<li>ziplist （长度小于512， 单值 小于64 字节时默认采用）</li>\n<li>linkedlist</li>\n</ul>\n<h3 id=\"应用场景-2\"><a href=\"#应用场景-2\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h4 id=\"1-消息队列\"><a href=\"#1-消息队列\" class=\"headerlink\" title=\"1. 消息队列\"></a>1. 消息队列</h4><p>通过阻塞可以实现生产者消费者模式。</p>\n<h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><h3 id=\"内部编码-3\"><a href=\"#内部编码-3\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h3><h3 id=\"应用场景-3\"><a href=\"#应用场景-3\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h2 id=\"有序集合\"><a href=\"#有序集合\" class=\"headerlink\" title=\"有序集合\"></a>有序集合</h2><h3 id=\"常用命令-2\"><a href=\"#常用命令-2\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><h3 id=\"不常用命令\"><a href=\"#不常用命令\" class=\"headerlink\" title=\"不常用命令\"></a>不常用命令</h3><h3 id=\"内部编码-4\"><a href=\"#内部编码-4\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h3><h3 id=\"应用场景-4\"><a href=\"#应用场景-4\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h1 id=\"键的管理\"><a href=\"#键的管理\" class=\"headerlink\" title=\"键的管理\"></a>键的管理</h1><p>常用的指令入 del, exists, expire, type, object.</p>\n<h2 id=\"6-键的重命名-rename\"><a href=\"#6-键的重命名-rename\" class=\"headerlink\" title=\"6. 键的重命名 rename\"></a>6. 键的重命名 rename</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rename elgong.list  newlist</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-随机返回一个键-randomKey\"><a href=\"#7-随机返回一个键-randomKey\" class=\"headerlink\" title=\"7. 随机返回一个键 randomKey\"></a>7. 随机返回一个键 randomKey</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">randomKey</span><br></pre></td></tr></table></figure>\n<h2 id=\"8-键过期时间\"><a href=\"#8-键过期时间\" class=\"headerlink\" title=\"8. 键过期时间\"></a>8. 键过期时间</h2><h2 id=\"9-键的遍历\"><a href=\"#9-键的遍历\" class=\"headerlink\" title=\"9. 键的遍历\"></a>9. 键的遍历</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 匹配</span><br><span class=\"line\">keys [j,r]edis</span><br><span class=\"line\">// 输出： jedis 和 redis 中存在的</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<blockquote>\n<p>本系列文章整理摘抄自<redis 开发与运维=\"\"></redis></p>\n<h1 id=\"全局命令\"><a href=\"#全局命令\" class=\"headerlink\" title=\"全局命令\"></a>全局命令</h1></blockquote>\n<h2 id=\"1-查看所有键-keys\"><a href=\"#1-查看所有键-keys\" class=\"headerlink\" title=\"1. 查看所有键 keys\"></a>1. 查看所有键 <strong>keys</strong></h2><p>遍历所有的键，时间复杂度O(n), 线上禁止使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keys *</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-键总数-dbsize\"><a href=\"#2-键总数-dbsize\" class=\"headerlink\" title=\"2. 键总数 dbsize\"></a>2. 键总数 <strong>dbsize</strong></h2><p>该指令直接获取Redis 内置的键总数变量， 时间复杂度 O(1)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dbsize</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-键是否存在-exist\"><a href=\"#3-键是否存在-exist\" class=\"headerlink\" title=\"3. 键是否存在 exist\"></a>3. 键是否存在 <strong>exist</strong></h2><p>存在返回1， 不存在返回0<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exist key</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-删除键-del\"><a href=\"#4-删除键-del\" class=\"headerlink\" title=\"4. 删除键 del\"></a>4. 删除键 <strong>del</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">del key1  key2  key3</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-设置键过期-expire\"><a href=\"#5-设置键过期-expire\" class=\"headerlink\" title=\"5. 设置键过期 expire\"></a>5. 设置键过期 <strong>expire</strong></h2><p>成功返回1<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// expire key seconds</span><br><span class=\"line\">set key helloword</span><br><span class=\"line\">expire key 10</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-查询键过期-ttl\"><a href=\"#6-查询键过期-ttl\" class=\"headerlink\" title=\"6. 查询键过期 ttl\"></a>6. 查询键过期 <strong>ttl</strong></h2><ul>\n<li>返回 &gt;0 : 剩余的过期时间</li>\n<li>返回 -1 : 键没设置过期时间</li>\n<li>返回 -2 ：键不存在<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ttl key</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"7-键的类型-type\"><a href=\"#7-键的类型-type\" class=\"headerlink\" title=\"7. 键的类型  type\"></a>7. 键的类型  <strong>type</strong></h2><p>若键不存在，返回 none<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type key</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"5种常用的数据类型\"><a href=\"#5种常用的数据类型\" class=\"headerlink\" title=\"5种常用的数据类型\"></a>5种常用的数据类型</h1><p>Redis 是字典服务器，其中键都是字符串类型，并且数据结构也都是在字符串类型上构建的。</p>\n<p>而字符串类型的底层实现值可以为字符串，整数，浮点数，二进制。</p>\n<p>字符串类型最大不能超过 512MB.</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><h4 id=\"1-设置值-set、setex、setnx、set-xx\"><a href=\"#1-设置值-set、setex、setnx、set-xx\" class=\"headerlink\" title=\"1. 设置值 set、setex、setnx、set .. xx\"></a>1. 设置值 set、setex、setnx、set .. xx</h4><p>==set 命令的参数：==</p>\n<ul>\n<li>ex seconds: 秒过期</li>\n<li>px milliseconds ： 毫秒过期</li>\n<li>nx ：键必须不存在 （失败返回 0）</li>\n<li>xx ：键必须存在<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// set key value [ex seconds] [px milliseconds] [nx | xx]</span><br><span class=\"line\"></span><br><span class=\"line\">set hello world ex 60</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>==设置时间:==</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setex key seconds value</span><br></pre></td></tr></table></figure>\n<p>==设置不存在的key==</p>\n<font color=\"red\" size=\"5\">setnx 可以作为分布式锁的一种实现方案</font>\n\n<ul>\n<li>失败： 返回 0</li>\n<li>成功： 返回 1<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setnx key value</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>==设置存在的key==</p>\n<ul>\n<li>失败： 返回 nil</li>\n<li>成功： 返回 ok<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set key value xx</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-获取值-get\"><a href=\"#2-获取值-get\" class=\"headerlink\" title=\"2. 获取值 get\"></a>2. 获取值 get</h4><p>==获取键值==</p>\n<ul>\n<li>不存在： 返回 nil</li>\n<li>存在：   返回值<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get key</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"3-批量设置值-mset\"><a href=\"#3-批量设置值-mset\" class=\"headerlink\" title=\"3. 批量设置值 mset\"></a>3. 批量设置值 mset</h4><font color=\"red\" size=\"3\">批量操作可以减少网络资源的浪费</font>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mset key1 value1   key2 value2    key3 value3</span><br></pre></td></tr></table></figure>\n\n#### 4. 批量获取值 mget\n\n如果有空的， 该空值返回 nil\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mget key1  key2  key3</span><br></pre></td></tr></table></figure>\n\n#### 5. 计数操作 incr、decr、incrby(自增指定值)、decrby(自减指定值)\n\n<font color=\"red\" size=\"3\">redis 的计数不是cas, 因为是单线程，不会出现冲突</font>\n- 不存在：  自动创建并返回1\n- 存在：    返回增后的值\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 自增</span><br><span class=\"line\">//incr key</span><br></pre></td></tr></table></figure>\n\n### 不常用命令\n\n#### 1. 追加值 append \n<font color=\"red\" size=\"3\">可以对incr 的整数或者其他类型追加，因为它们都是string类型</font>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// append key  value</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-字符串的长度-strlen\"><a href=\"#2-字符串的长度-strlen\" class=\"headerlink\" title=\"2. 字符串的长度 strlen\"></a>2. 字符串的长度 strlen</h4><ul>\n<li>不存在：   返回 0 </li>\n<li>存在：     返回字符串长度<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// strlen key</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"3-设置并且返回原值-getset\"><a href=\"#3-设置并且返回原值-getset\" class=\"headerlink\" title=\"3. 设置并且返回原值  getset\"></a>3. 设置并且返回原值  getset</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// getset key value</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-设置指定位置的字符\"><a href=\"#4-设置指定位置的字符\" class=\"headerlink\" title=\"4. 设置指定位置的字符\"></a>4. 设置指定位置的字符</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// setrange key offset value</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-获取部分字符串\"><a href=\"#5-获取部分字符串\" class=\"headerlink\" title=\"5. 获取部分字符串\"></a>5. 获取部分字符串</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// getrange key start end</span><br></pre></td></tr></table></figure>\n<h3 id=\"内部编码\"><a href=\"#内部编码\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h3><p>字符串类型内部有3 种编码，</p>\n<ul>\n<li>int :    8字节</li>\n<li>embstr ：&lt;= 39 字节的字符串</li>\n<li>raw ：   &gt; 39 字节的字符串</li>\n</ul>\n<p>查看类型的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object  encoding key1</span><br></pre></td></tr></table></figure>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h4 id=\"1-缓存\"><a href=\"#1-缓存\" class=\"headerlink\" title=\"1. 缓存\"></a>1. 缓存</h4><font color=\"red\" size=\"3\">加速读写并减轻后端数据库的压力</font>\n\n<p>推荐的key 定义规则：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 业务名：对象名：id：[属性]</span><br><span class=\"line\"></span><br><span class=\"line\">miaosha:item:itemId:price</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-计数\"><a href=\"#2-计数\" class=\"headerlink\" title=\"2. 计数\"></a>2. 计数</h4><p>实现业务上的快速技术、查询缓存，能够异步的写入数据库，减少数据库的访问压力。</p>\n<h4 id=\"3-session-共享\"><a href=\"#3-session-共享\" class=\"headerlink\" title=\"3. session 共享\"></a>3. session 共享</h4><p>web 服务通常由多台服务器协同提供用户访问的服务，而用户登陆后的登陆信息如何保存？</p>\n<p>借助 Redis 缓存将 用户session 集中管理，当用户登陆和查询时，在 Redis 服务器更新或者查询即可。</p>\n<h4 id=\"4-限速\"><a href=\"#4-限速\" class=\"headerlink\" title=\"4. 限速\"></a>4. 限速</h4><p>比如限制单位时间内验证码的次数。</p>\n<h2 id=\"哈希\"><a href=\"#哈希\" class=\"headerlink\" title=\"哈希\"></a>哈希</h2><h3 id=\"常用命令-1\"><a href=\"#常用命令-1\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><h4 id=\"1-设置值-hset-amp-hsetnx-不存在才设置\"><a href=\"#1-设置值-hset-amp-hsetnx-不存在才设置\" class=\"headerlink\" title=\"1. 设置值 hset &amp; hsetnx (不存在才设置)\"></a>1. 设置值 hset &amp; hsetnx (不存在才设置)</h4><p><strong>hset:</strong></p>\n<ul>\n<li>成功： 返回 1</li>\n<li>失败： 返回 0 </li>\n</ul>\n<p><strong>hsetnx</strong></p>\n<ul>\n<li>成功：</li>\n<li>失败：<br><font color=\"red\" size=\"3\"> 待验证</font><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// hashkey : value</span><br><span class=\"line\">hset key hashKey value</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-获取值-hget\"><a href=\"#2-获取值-hget\" class=\"headerlink\" title=\"2. 获取值 hget\"></a>2. 获取值 hget</h4><p>不存在： 返回nil<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hget key</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-删除值-hdel-key-field\"><a href=\"#3-删除值-hdel-key-field\" class=\"headerlink\" title=\"3. 删除值 hdel key field\"></a>3. 删除值 hdel key field</h4><ul>\n<li>删除成功：返回 1</li>\n<li>删除失败：返回 0</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// hset  mykey key1 value1</span><br><span class=\"line\">// hset  mykey key2 value2</span><br><span class=\"line\"></span><br><span class=\"line\">hdel  mykey  key1</span><br><span class=\"line\">// 删除后再查询会返回 nil</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-计算field-个数-hlen\"><a href=\"#4-计算field-个数-hlen\" class=\"headerlink\" title=\"4. 计算field 个数 hlen\"></a>4. 计算field 个数 hlen</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hlen mykey</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-批量设置或者获取-hmset-amp-hmget\"><a href=\"#5-批量设置或者获取-hmset-amp-hmget\" class=\"headerlink\" title=\"5. 批量设置或者获取 hmset &amp; hmget\"></a>5. 批量设置或者获取 hmset &amp; hmget</h4><p><strong>hmset</strong> </p>\n<ul>\n<li>成功返回 OK</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hmset  mykey key3 value3  key4 value 4</span><br><span class=\"line\"></span><br><span class=\"line\">// 批量获取返回</span><br><span class=\"line\">1) &quot;value1&quot;</span><br><span class=\"line\">2) &quot;value2&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-判断field-是否存在-hexists\"><a href=\"#6-判断field-是否存在-hexists\" class=\"headerlink\" title=\"6. 判断field 是否存在 hexists\"></a>6. 判断field 是否存在 hexists</h4><ul>\n<li>存在： 返回 1</li>\n<li>不存在： 返回 0<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexists  mykey key3</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"7-获取所有的field-hkeys\"><a href=\"#7-获取所有的field-hkeys\" class=\"headerlink\" title=\"7. 获取所有的field, hkeys\"></a>7. 获取所有的field, hkeys</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hkeys mykey</span><br><span class=\"line\"></span><br><span class=\"line\">// 返回</span><br><span class=\"line\"></span><br><span class=\"line\">1) &quot;key2&quot;</span><br><span class=\"line\">2) &quot;key1&quot;</span><br><span class=\"line\">3) &quot;key3&quot;</span><br><span class=\"line\">4) &quot;key4&quot;</span><br><span class=\"line\">5) &quot;key5&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"8-获取所有的value，-hvals-mykey\"><a href=\"#8-获取所有的value，-hvals-mykey\" class=\"headerlink\" title=\"8. 获取所有的value， hvals mykey\"></a>8. 获取所有的value， hvals mykey</h4><h4 id=\"9-获取-k-v-：-hgetall-mykey\"><a href=\"#9-获取-k-v-：-hgetall-mykey\" class=\"headerlink\" title=\"9. 获取 k - v ： hgetall mykey\"></a>9. 获取 k - v ： hgetall mykey</h4><font color=\"red\" size=\"3\">值太多时，会引起阻塞，线上可以 hscan  和 hmget</font>\n\n<h4 id=\"10-values-的自增-hincrby-hincrbyfloat\"><a href=\"#10-values-的自增-hincrby-hincrbyfloat\" class=\"headerlink\" title=\"10. values 的自增  hincrby hincrbyfloat\"></a>10. values 的自增  hincrby hincrbyfloat</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hincrby</span><br></pre></td></tr></table></figure>\n<h4 id=\"11-计算value的字符串长度（需要Redis3-2以上）-hstrlen\"><a href=\"#11-计算value的字符串长度（需要Redis3-2以上）-hstrlen\" class=\"headerlink\" title=\"11. 计算value的字符串长度（需要Redis3.2以上） hstrlen\"></a>11. 计算value的字符串长度（需要Redis3.2以上） hstrlen</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hstrlen mykey key1</span><br></pre></td></tr></table></figure>\n<h3 id=\"内部编码-1\"><a href=\"#内部编码-1\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h3><p>哈希类型内部编码主要有两种：</p>\n<ul>\n<li>ziplist （更省内存）（数量小于512且value 小于64字节时，默认使用）</li>\n<li>hashtable  读写时间复杂度 O(1)</li>\n</ul>\n<h3 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h4 id=\"利用-hash-存储-数据库中的整行字段\"><a href=\"#利用-hash-存储-数据库中的整行字段\" class=\"headerlink\" title=\"利用 hash 存储 数据库中的整行字段\"></a>利用 hash 存储 数据库中的整行字段</h4><h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ul>\n<li>列表用来储存多个有序的字符串。</li>\n<li>可以当队列和堆栈使用</li>\n</ul>\n<h3 id=\"主要的操作：\"><a href=\"#主要的操作：\" class=\"headerlink\" title=\"主要的操作：\"></a>主要的操作：</h3><ul>\n<li>添加 <code>rpush &amp; lpush</code>,  <code>linsert</code></li>\n<li>删除 <code>lpop &amp; rpop</code>, <code>lrem</code>, <code>ltrim</code></li>\n<li>查找 <code>lrange</code>,   <code>lindex</code>, <code>llen</code></li>\n<li>修改  <code>lset</code></li>\n<li>阻塞 <code>blpop &amp; brpop</code></li>\n</ul>\n<h4 id=\"1-添加-lpush-amp-rpush-linsert\"><a href=\"#1-添加-lpush-amp-rpush-linsert\" class=\"headerlink\" title=\"1. 添加 lpush &amp; rpush, linsert\"></a>1. 添加 lpush &amp; rpush, linsert</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 左，右插入</span><br><span class=\"line\">lpush elgong.list  1</span><br><span class=\"line\"></span><br><span class=\"line\">rpush elgong.lsit  2</span><br><span class=\"line\"></span><br><span class=\"line\">// 指定位置插入</span><br><span class=\"line\">linsert  elgong.list  after| before  location  value</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-删除-rpop-amp-lpop-lrem\"><a href=\"#2-删除-rpop-amp-lpop-lrem\" class=\"headerlink\" title=\"2. 删除 rpop &amp; lpop, lrem\"></a>2. 删除 rpop &amp; lpop, lrem</h4><p><strong>lrem</strong> 删除指定元素<br><code>lrem elgong.list  count  value</code></p>\n<ul>\n<li>value 为被删除的值</li>\n<li>count &gt; 0:  从左往右删除 count 个</li>\n<li>count = 0:  全部删除</li>\n<li>count &lt; 0： 从右往左删除 count 个</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpop elgong.list</span><br><span class=\"line\">lpop elgong.list</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除指定的元素</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-查找-lrange-，-lindex，-llen\"><a href=\"#3-查找-lrange-，-lindex，-llen\" class=\"headerlink\" title=\"3. 查找 lrange ， lindex， llen\"></a>3. 查找 lrange ， lindex， llen</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获取从左到右 所有元素</span><br><span class=\"line\">lrange elgong.list 0  -1</span><br><span class=\"line\"></span><br><span class=\"line\">// 指定范围查找</span><br><span class=\"line\">lrange elgong.list  start  end</span><br><span class=\"line\"></span><br><span class=\"line\">// 获取指定下标的元素, 索引为2</span><br><span class=\"line\">lindex  elgong.list 2</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-修改-lset\"><a href=\"#4-修改-lset\" class=\"headerlink\" title=\"4. 修改 lset\"></a>4. 修改 lset</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lset key index newValue</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-阻塞-blpop-amp-brpop\"><a href=\"#5-阻塞-blpop-amp-brpop\" class=\"headerlink\" title=\"5. 阻塞 blpop &amp; brpop\"></a>5. 阻塞 blpop &amp; brpop</h4><p>有参数 timeout，</p>\n<p>如果timeout = 0， 一直阻塞<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 等到list有值时再返回</span><br><span class=\"line\">blpop elgong.list  0</span><br><span class=\"line\"></span><br><span class=\"line\">// 阻塞最长3s</span><br><span class=\"line\">blpop elgong.list  3</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"内部编码-2\"><a href=\"#内部编码-2\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h3><ul>\n<li>ziplist （长度小于512， 单值 小于64 字节时默认采用）</li>\n<li>linkedlist</li>\n</ul>\n<h3 id=\"应用场景-2\"><a href=\"#应用场景-2\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h4 id=\"1-消息队列\"><a href=\"#1-消息队列\" class=\"headerlink\" title=\"1. 消息队列\"></a>1. 消息队列</h4><p>通过阻塞可以实现生产者消费者模式。</p>\n<h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><h3 id=\"内部编码-3\"><a href=\"#内部编码-3\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h3><h3 id=\"应用场景-3\"><a href=\"#应用场景-3\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h2 id=\"有序集合\"><a href=\"#有序集合\" class=\"headerlink\" title=\"有序集合\"></a>有序集合</h2><h3 id=\"常用命令-2\"><a href=\"#常用命令-2\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><h3 id=\"不常用命令\"><a href=\"#不常用命令\" class=\"headerlink\" title=\"不常用命令\"></a>不常用命令</h3><h3 id=\"内部编码-4\"><a href=\"#内部编码-4\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h3><h3 id=\"应用场景-4\"><a href=\"#应用场景-4\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h1 id=\"键的管理\"><a href=\"#键的管理\" class=\"headerlink\" title=\"键的管理\"></a>键的管理</h1><p>常用的指令入 del, exists, expire, type, object.</p>\n<h2 id=\"6-键的重命名-rename\"><a href=\"#6-键的重命名-rename\" class=\"headerlink\" title=\"6. 键的重命名 rename\"></a>6. 键的重命名 rename</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rename elgong.list  newlist</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-随机返回一个键-randomKey\"><a href=\"#7-随机返回一个键-randomKey\" class=\"headerlink\" title=\"7. 随机返回一个键 randomKey\"></a>7. 随机返回一个键 randomKey</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">randomKey</span><br></pre></td></tr></table></figure>\n<h2 id=\"8-键过期时间\"><a href=\"#8-键过期时间\" class=\"headerlink\" title=\"8. 键过期时间\"></a>8. 键过期时间</h2><h2 id=\"9-键的遍历\"><a href=\"#9-键的遍历\" class=\"headerlink\" title=\"9. 键的遍历\"></a>9. 键的遍历</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 匹配</span><br><span class=\"line\">keys [j,r]edis</span><br><span class=\"line\">// 输出： jedis 和 redis 中存在的</span><br></pre></td></tr></table></figure>"},{"title":"pandas-6重复值处理","mathjax":true,"date":"2019-08-09T07:26:52.000Z","_content":"\n# pandas -6 重复值处理\n\n> 如果你想找到或者删除 `DataFrame`中重复的行, 可以使用 `duplicated` 和 `drop_duplicates`\n\n## 查找重复值\n\n```\nexample:\n        col1  col2     c\n    0    one   x   -1.067137\n    1    one   y    0.309500\n    2    two   x   -0.211056\n    3    two   y   -1.842023\n    4    two   x   -0.390820\n    5  three   x   -1.964475\n    6   four   x    1.298329\nIn:\n    // 单列\n    df.duplicated(\"col1\", keep=\"first\")\n    \n    // 多列\n    // df.duplicated([\"col1\", \"col2\"], keep=\"first\")\n    \nOut:\n    0    False\n    1     True\n    2    False\n    3     True\n    4     True\n    5    False\n    6    False\n    dtype: bool\n    \n    // 默认 keep = \"first\",第一次出现的不算重复，返回False\n    // keep = \"last\", 最后出现的不算重复\n    // keep = False, 重复值均返回 True\n\n```\n\n## 删除重复值\n\n```\nIn:\n    df.drop_duplicates('col1')\n    \nOut:\n        col1  col2    c\n    0    one   x    -1.067137\n    2    two   x    -0.211056\n    5  three   x    -1.964475\n    6   four   x     1.298329\n\n```","source":"_posts/pandas-重复值处理.md","raw":"---\ntitle: pandas-6重复值处理\nmathjax: true\ndate: 2019-08-09 15:26:52\ncategories: pandas系列教程\ntags: pandas\n---\n\n# pandas -6 重复值处理\n\n> 如果你想找到或者删除 `DataFrame`中重复的行, 可以使用 `duplicated` 和 `drop_duplicates`\n\n## 查找重复值\n\n```\nexample:\n        col1  col2     c\n    0    one   x   -1.067137\n    1    one   y    0.309500\n    2    two   x   -0.211056\n    3    two   y   -1.842023\n    4    two   x   -0.390820\n    5  three   x   -1.964475\n    6   four   x    1.298329\nIn:\n    // 单列\n    df.duplicated(\"col1\", keep=\"first\")\n    \n    // 多列\n    // df.duplicated([\"col1\", \"col2\"], keep=\"first\")\n    \nOut:\n    0    False\n    1     True\n    2    False\n    3     True\n    4     True\n    5    False\n    6    False\n    dtype: bool\n    \n    // 默认 keep = \"first\",第一次出现的不算重复，返回False\n    // keep = \"last\", 最后出现的不算重复\n    // keep = False, 重复值均返回 True\n\n```\n\n## 删除重复值\n\n```\nIn:\n    df.drop_duplicates('col1')\n    \nOut:\n        col1  col2    c\n    0    one   x    -1.067137\n    2    two   x    -0.211056\n    5  three   x    -1.964475\n    6   four   x     1.298329\n\n```","slug":"pandas-重复值处理","published":1,"updated":"2020-02-20T04:41:37.815Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephfe001tt8plmtyukint","content":"<h1 id=\"pandas-6-重复值处理\"><a href=\"#pandas-6-重复值处理\" class=\"headerlink\" title=\"pandas -6 重复值处理\"></a>pandas -6 重复值处理</h1><blockquote>\n<p>如果你想找到或者删除 <code>DataFrame</code>中重复的行, 可以使用 <code>duplicated</code> 和 <code>drop_duplicates</code></p>\n</blockquote>\n<h2 id=\"查找重复值\"><a href=\"#查找重复值\" class=\"headerlink\" title=\"查找重复值\"></a>查找重复值</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example:</span><br><span class=\"line\">        col1  col2     c</span><br><span class=\"line\">    0    one   x   -1.067137</span><br><span class=\"line\">    1    one   y    0.309500</span><br><span class=\"line\">    2    two   x   -0.211056</span><br><span class=\"line\">    3    two   y   -1.842023</span><br><span class=\"line\">    4    two   x   -0.390820</span><br><span class=\"line\">    5  three   x   -1.964475</span><br><span class=\"line\">    6   four   x    1.298329</span><br><span class=\"line\">In:</span><br><span class=\"line\">    // 单列</span><br><span class=\"line\">    df.duplicated(&quot;col1&quot;, keep=&quot;first&quot;)</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 多列</span><br><span class=\"line\">    // df.duplicated([&quot;col1&quot;, &quot;col2&quot;], keep=&quot;first&quot;)</span><br><span class=\"line\">    </span><br><span class=\"line\">Out:</span><br><span class=\"line\">    0    False</span><br><span class=\"line\">    1     True</span><br><span class=\"line\">    2    False</span><br><span class=\"line\">    3     True</span><br><span class=\"line\">    4     True</span><br><span class=\"line\">    5    False</span><br><span class=\"line\">    6    False</span><br><span class=\"line\">    dtype: bool</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 默认 keep = &quot;first&quot;,第一次出现的不算重复，返回False</span><br><span class=\"line\">    // keep = &quot;last&quot;, 最后出现的不算重复</span><br><span class=\"line\">    // keep = False, 重复值均返回 True</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除重复值\"><a href=\"#删除重复值\" class=\"headerlink\" title=\"删除重复值\"></a>删除重复值</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In:</span><br><span class=\"line\">    df.drop_duplicates(&apos;col1&apos;)</span><br><span class=\"line\">    </span><br><span class=\"line\">Out:</span><br><span class=\"line\">        col1  col2    c</span><br><span class=\"line\">    0    one   x    -1.067137</span><br><span class=\"line\">    2    two   x    -0.211056</span><br><span class=\"line\">    5  three   x    -1.964475</span><br><span class=\"line\">    6   four   x     1.298329</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"pandas-6-重复值处理\"><a href=\"#pandas-6-重复值处理\" class=\"headerlink\" title=\"pandas -6 重复值处理\"></a>pandas -6 重复值处理</h1><blockquote>\n<p>如果你想找到或者删除 <code>DataFrame</code>中重复的行, 可以使用 <code>duplicated</code> 和 <code>drop_duplicates</code></p>\n</blockquote>\n<h2 id=\"查找重复值\"><a href=\"#查找重复值\" class=\"headerlink\" title=\"查找重复值\"></a>查找重复值</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example:</span><br><span class=\"line\">        col1  col2     c</span><br><span class=\"line\">    0    one   x   -1.067137</span><br><span class=\"line\">    1    one   y    0.309500</span><br><span class=\"line\">    2    two   x   -0.211056</span><br><span class=\"line\">    3    two   y   -1.842023</span><br><span class=\"line\">    4    two   x   -0.390820</span><br><span class=\"line\">    5  three   x   -1.964475</span><br><span class=\"line\">    6   four   x    1.298329</span><br><span class=\"line\">In:</span><br><span class=\"line\">    // 单列</span><br><span class=\"line\">    df.duplicated(&quot;col1&quot;, keep=&quot;first&quot;)</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 多列</span><br><span class=\"line\">    // df.duplicated([&quot;col1&quot;, &quot;col2&quot;], keep=&quot;first&quot;)</span><br><span class=\"line\">    </span><br><span class=\"line\">Out:</span><br><span class=\"line\">    0    False</span><br><span class=\"line\">    1     True</span><br><span class=\"line\">    2    False</span><br><span class=\"line\">    3     True</span><br><span class=\"line\">    4     True</span><br><span class=\"line\">    5    False</span><br><span class=\"line\">    6    False</span><br><span class=\"line\">    dtype: bool</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 默认 keep = &quot;first&quot;,第一次出现的不算重复，返回False</span><br><span class=\"line\">    // keep = &quot;last&quot;, 最后出现的不算重复</span><br><span class=\"line\">    // keep = False, 重复值均返回 True</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除重复值\"><a href=\"#删除重复值\" class=\"headerlink\" title=\"删除重复值\"></a>删除重复值</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In:</span><br><span class=\"line\">    df.drop_duplicates(&apos;col1&apos;)</span><br><span class=\"line\">    </span><br><span class=\"line\">Out:</span><br><span class=\"line\">        col1  col2    c</span><br><span class=\"line\">    0    one   x    -1.067137</span><br><span class=\"line\">    2    two   x    -0.211056</span><br><span class=\"line\">    5  three   x    -1.964475</span><br><span class=\"line\">    6   four   x     1.298329</span><br></pre></td></tr></table></figure>"},{"title":"决策树2-ID3算法","mathjax":true,"date":"2019-09-12T11:04:01.000Z","_content":"\n# 决策树-2 ID3算法\n\n> 决策树-1基本概念中已经提到了ID3算法，这篇博客再梳理一遍，算法描述部分搬运了统计学习方法的内容，更详细内容可以参考这本书。\n\n### ID3 算法的思路\n- 输入：训练集 `D`, 特征集 `A`， 阈值 `ε`；\n- 分叉：最优属性划分依据是<font color=\"#FF0000\"> 最大信息增益；</font> \n- 结束条件：用完所有特征，特征信息增益很小，树的深度超过限制；\n- 返回：一颗树`T`。\n\n### ID3 算法描述\n\n> 这里的描述可作为编程实现时的指导，树的建立过程是递归实现。\n```python\n\ndef ID3Tree(D, A，ε ):\n\n    if  D 的实例属于同类别 K ||  特征集 A 特征空:\n    \n        1. 决策树 T为单结点树\n        2. 标记类别 K (数量最多的类别)\n        return  T\n\n    else:\n        1. 计算所有特征相对于 D 的信息增益\n        2. 找到信息增益最大特征 Amax\n        \n        if Amax  小于 阈值 ε:\n            1. 决策树 T为单结点树\n            2. 标记类别 K (数量最多的类别)\n            return  T\n        else:\n            依照特征 Amax 的每一个取值 ai，划分数据集Di, 并且标记Di类别，构建子节点\n            \n            # 递归\n            对每个结点Di，以Di为训练集， A-Amax为特征集，递归调用 ID3Tree()\n            return 由结点和子结点构成的树\n```\n\n\n\n\n\n\n\n\n\n","source":"_posts/决策树2-ID3算法.md","raw":"---\ntitle: 决策树2-ID3算法\nmathjax: true\ndate: 2019-09-12 19:04:01\ncategories: 机器学习方法\ntags: ID3\n\n---\n\n# 决策树-2 ID3算法\n\n> 决策树-1基本概念中已经提到了ID3算法，这篇博客再梳理一遍，算法描述部分搬运了统计学习方法的内容，更详细内容可以参考这本书。\n\n### ID3 算法的思路\n- 输入：训练集 `D`, 特征集 `A`， 阈值 `ε`；\n- 分叉：最优属性划分依据是<font color=\"#FF0000\"> 最大信息增益；</font> \n- 结束条件：用完所有特征，特征信息增益很小，树的深度超过限制；\n- 返回：一颗树`T`。\n\n### ID3 算法描述\n\n> 这里的描述可作为编程实现时的指导，树的建立过程是递归实现。\n```python\n\ndef ID3Tree(D, A，ε ):\n\n    if  D 的实例属于同类别 K ||  特征集 A 特征空:\n    \n        1. 决策树 T为单结点树\n        2. 标记类别 K (数量最多的类别)\n        return  T\n\n    else:\n        1. 计算所有特征相对于 D 的信息增益\n        2. 找到信息增益最大特征 Amax\n        \n        if Amax  小于 阈值 ε:\n            1. 决策树 T为单结点树\n            2. 标记类别 K (数量最多的类别)\n            return  T\n        else:\n            依照特征 Amax 的每一个取值 ai，划分数据集Di, 并且标记Di类别，构建子节点\n            \n            # 递归\n            对每个结点Di，以Di为训练集， A-Amax为特征集，递归调用 ID3Tree()\n            return 由结点和子结点构成的树\n```\n\n\n\n\n\n\n\n\n\n","slug":"决策树2-ID3算法","published":1,"updated":"2020-02-20T04:41:37.817Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephfk001vt8pl5va2i3xy","content":"<h1 id=\"决策树-2-ID3算法\"><a href=\"#决策树-2-ID3算法\" class=\"headerlink\" title=\"决策树-2 ID3算法\"></a>决策树-2 ID3算法</h1><blockquote>\n<p>决策树-1基本概念中已经提到了ID3算法，这篇博客再梳理一遍，算法描述部分搬运了统计学习方法的内容，更详细内容可以参考这本书。</p>\n</blockquote>\n<h3 id=\"ID3-算法的思路\"><a href=\"#ID3-算法的思路\" class=\"headerlink\" title=\"ID3 算法的思路\"></a>ID3 算法的思路</h3><ul>\n<li>输入：训练集 <code>D</code>, 特征集 <code>A</code>， 阈值 <code>ε</code>；</li>\n<li>分叉：最优属性划分依据是<font color=\"#FF0000\"> 最大信息增益；</font> </li>\n<li>结束条件：用完所有特征，特征信息增益很小，树的深度超过限制；</li>\n<li>返回：一颗树<code>T</code>。</li>\n</ul>\n<h3 id=\"ID3-算法描述\"><a href=\"#ID3-算法描述\" class=\"headerlink\" title=\"ID3 算法描述\"></a>ID3 算法描述</h3><blockquote>\n<p>这里的描述可作为编程实现时的指导，树的建立过程是递归实现。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">ID3Tree</span><span class=\"params\">(D, A，ε )</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>  D 的实例属于同类别 K ||  特征集 A 特征空:</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"number\">1.</span> 决策树 T为单结点树</span><br><span class=\"line\">        <span class=\"number\">2.</span> 标记类别 K (数量最多的类别)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  T</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"number\">1.</span> 计算所有特征相对于 D 的信息增益</span><br><span class=\"line\">        <span class=\"number\">2.</span> 找到信息增益最大特征 Amax</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> Amax  小于 阈值 ε:</span><br><span class=\"line\">            <span class=\"number\">1.</span> 决策树 T为单结点树</span><br><span class=\"line\">            <span class=\"number\">2.</span> 标记类别 K (数量最多的类别)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>  T</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            依照特征 Amax 的每一个取值 ai，划分数据集Di, 并且标记Di类别，构建子节点</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 递归</span></span><br><span class=\"line\">            对每个结点Di，以Di为训练集， A-Amax为特征集，递归调用 ID3Tree()</span><br><span class=\"line\">            <span class=\"keyword\">return</span> 由结点和子结点构成的树</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"决策树-2-ID3算法\"><a href=\"#决策树-2-ID3算法\" class=\"headerlink\" title=\"决策树-2 ID3算法\"></a>决策树-2 ID3算法</h1><blockquote>\n<p>决策树-1基本概念中已经提到了ID3算法，这篇博客再梳理一遍，算法描述部分搬运了统计学习方法的内容，更详细内容可以参考这本书。</p>\n</blockquote>\n<h3 id=\"ID3-算法的思路\"><a href=\"#ID3-算法的思路\" class=\"headerlink\" title=\"ID3 算法的思路\"></a>ID3 算法的思路</h3><ul>\n<li>输入：训练集 <code>D</code>, 特征集 <code>A</code>， 阈值 <code>ε</code>；</li>\n<li>分叉：最优属性划分依据是<font color=\"#FF0000\"> 最大信息增益；</font> </li>\n<li>结束条件：用完所有特征，特征信息增益很小，树的深度超过限制；</li>\n<li>返回：一颗树<code>T</code>。</li>\n</ul>\n<h3 id=\"ID3-算法描述\"><a href=\"#ID3-算法描述\" class=\"headerlink\" title=\"ID3 算法描述\"></a>ID3 算法描述</h3><blockquote>\n<p>这里的描述可作为编程实现时的指导，树的建立过程是递归实现。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">ID3Tree</span><span class=\"params\">(D, A，ε )</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>  D 的实例属于同类别 K ||  特征集 A 特征空:</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"number\">1.</span> 决策树 T为单结点树</span><br><span class=\"line\">        <span class=\"number\">2.</span> 标记类别 K (数量最多的类别)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  T</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"number\">1.</span> 计算所有特征相对于 D 的信息增益</span><br><span class=\"line\">        <span class=\"number\">2.</span> 找到信息增益最大特征 Amax</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> Amax  小于 阈值 ε:</span><br><span class=\"line\">            <span class=\"number\">1.</span> 决策树 T为单结点树</span><br><span class=\"line\">            <span class=\"number\">2.</span> 标记类别 K (数量最多的类别)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>  T</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            依照特征 Amax 的每一个取值 ai，划分数据集Di, 并且标记Di类别，构建子节点</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 递归</span></span><br><span class=\"line\">            对每个结点Di，以Di为训练集， A-Amax为特征集，递归调用 ID3Tree()</span><br><span class=\"line\">            <span class=\"keyword\">return</span> 由结点和子结点构成的树</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n"},{"layout":"w","title":"决策树3-CART分类回归树","date":"2019-09-12T10:58:19.000Z","_content":"\n# CART-分类回归树\n\n### CART 算法的思路\n\n> 特征选择：最优属性划分依据是<font color=\"#FF0000\"> 基尼系数（分类）/平方误差（回归）；</font> \n\n> CART 树是二叉树结构。\n\n主要就两步骤：\n\n1. 树的生成 \n2. 树的剪枝\n\n### 分类树\n\n> 分类树与ID3, C4.5的流程一致。\n\n\n### 回归树\n\n> 回归树选择最佳划分属性和划分点时的依据是 `平方误差`。\n\n一张图即可理解。\n\n![logo](决策树3-CART分类回归树/CART.png)\n\n与分类树的主要区别是选择最佳属性的评价指标变了。根据最小化均方误差的原则选择。\n\n\n\n","source":"_posts/决策树3-CART分类回归树.md","raw":"---\nlayout: w\ntitle: 决策树3-CART分类回归树\ndate: 2019-09-12 18:58:19\ncategories: 机器学习方法\ntags: CART树\n---\n\n# CART-分类回归树\n\n### CART 算法的思路\n\n> 特征选择：最优属性划分依据是<font color=\"#FF0000\"> 基尼系数（分类）/平方误差（回归）；</font> \n\n> CART 树是二叉树结构。\n\n主要就两步骤：\n\n1. 树的生成 \n2. 树的剪枝\n\n### 分类树\n\n> 分类树与ID3, C4.5的流程一致。\n\n\n### 回归树\n\n> 回归树选择最佳划分属性和划分点时的依据是 `平方误差`。\n\n一张图即可理解。\n\n![logo](决策树3-CART分类回归树/CART.png)\n\n与分类树的主要区别是选择最佳属性的评价指标变了。根据最小化均方误差的原则选择。\n\n\n\n","slug":"决策树3-CART分类回归树","published":1,"updated":"2020-02-20T04:41:37.818Z","comments":1,"photos":[],"link":"","_id":"cka8ephfp001zt8plr6kb09rp","content":"<h1 id=\"CART-分类回归树\"><a href=\"#CART-分类回归树\" class=\"headerlink\" title=\"CART-分类回归树\"></a>CART-分类回归树</h1><h3 id=\"CART-算法的思路\"><a href=\"#CART-算法的思路\" class=\"headerlink\" title=\"CART 算法的思路\"></a>CART 算法的思路</h3><blockquote>\n<p>特征选择：最优属性划分依据是<font color=\"#FF0000\"> 基尼系数（分类）/平方误差（回归）；</font> </p>\n<p>CART 树是二叉树结构。</p>\n</blockquote>\n<p>主要就两步骤：</p>\n<ol>\n<li>树的生成 </li>\n<li>树的剪枝</li>\n</ol>\n<h3 id=\"分类树\"><a href=\"#分类树\" class=\"headerlink\" title=\"分类树\"></a>分类树</h3><blockquote>\n<p>分类树与ID3, C4.5的流程一致。</p>\n</blockquote>\n<h3 id=\"回归树\"><a href=\"#回归树\" class=\"headerlink\" title=\"回归树\"></a>回归树</h3><blockquote>\n<p>回归树选择最佳划分属性和划分点时的依据是 <code>平方误差</code>。</p>\n</blockquote>\n<p>一张图即可理解。</p>\n<p><img src=\"/2019/09/12/决策树3-CART分类回归树/CART.png\" alt=\"logo\"></p>\n<p>与分类树的主要区别是选择最佳属性的评价指标变了。根据最小化均方误差的原则选择。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CART-分类回归树\"><a href=\"#CART-分类回归树\" class=\"headerlink\" title=\"CART-分类回归树\"></a>CART-分类回归树</h1><h3 id=\"CART-算法的思路\"><a href=\"#CART-算法的思路\" class=\"headerlink\" title=\"CART 算法的思路\"></a>CART 算法的思路</h3><blockquote>\n<p>特征选择：最优属性划分依据是<font color=\"#FF0000\"> 基尼系数（分类）/平方误差（回归）；</font> </p>\n<p>CART 树是二叉树结构。</p>\n</blockquote>\n<p>主要就两步骤：</p>\n<ol>\n<li>树的生成 </li>\n<li>树的剪枝</li>\n</ol>\n<h3 id=\"分类树\"><a href=\"#分类树\" class=\"headerlink\" title=\"分类树\"></a>分类树</h3><blockquote>\n<p>分类树与ID3, C4.5的流程一致。</p>\n</blockquote>\n<h3 id=\"回归树\"><a href=\"#回归树\" class=\"headerlink\" title=\"回归树\"></a>回归树</h3><blockquote>\n<p>回归树选择最佳划分属性和划分点时的依据是 <code>平方误差</code>。</p>\n</blockquote>\n<p>一张图即可理解。</p>\n<p><img src=\"/2019/09/12/决策树3-CART分类回归树/CART.png\" alt=\"logo\"></p>\n<p>与分类树的主要区别是选择最佳属性的评价指标变了。根据最小化均方误差的原则选择。</p>\n"},{"title":"将博客搬至CSDN","date":"2020-04-22T04:21:03.000Z","_content":"\n\n\n\n\n本文为满足将博客内容搬迁至csdn 的审核要求。","source":"_posts/将博客搬至CSDN.md","raw":"---\ntitle: 将博客搬至CSDN\ndate: 2020-04-22 12:21:03\ncategories: 闲聊\ntags: 闲聊\n---\n\n\n\n\n\n本文为满足将博客内容搬迁至csdn 的审核要求。","slug":"将博客搬至CSDN","published":1,"updated":"2020-04-22T04:22:27.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephfu0021t8pl6i9oanlj","content":"<p>本文为满足将博客内容搬迁至csdn 的审核要求。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文为满足将博客内容搬迁至csdn 的审核要求。</p>\n"},{"title":"机器学习模型的偏差与方差","mathjax":true,"date":"2019-08-01T08:43:19.000Z","_content":"\n# 机器学习的方差与偏差\n\n> 方差与偏差，总是迷迷糊糊的，每次看了就会，过了就忘。今天看到一个非常棒的解释，迫不及待马上整理下来了。\n\n\n## 机器学习的目标函数\n机器学习模型学习的是数据集的条件概率分布，得到一个决策函数。整个学习过程围绕着最小化（或者最大化）目标函数进行优化参数，目标函数的通常形式的定义是：\n\n\n    Obj = L(θ) + λΩ(θ)\n    \n`L(θ)` 是损失函数，衡量模型对训练集拟合程度的好坏(对应偏差)；\n\n` Ω(θ)` 是正则项，是衡量模型的复杂程度（对应方差）；\n\n<font color=\"#FF0000\"> 目标函数定义为损失函数和正则项两部分，是为了平衡模型的偏差和方差（Bias Variance Trade-off）。</font> \n\n\n\n## 偏差与学习器\n\n> 偏差描述了 <font color=\"#FF0000\">学习器的拟合能力</font> （对训练集的）。\n\n学习器在训练集表现越好，损失越低，则模型的偏差越小。\n\n\n## 方差与学习器\n\n> 方差描述了 <font color=\"#FF0000\"> 学习器的泛化能力</font>(对测试集)。\n\n学习器在测试集表现越好，则模型的方差越低。\n\n\n## 偏差与方差之间的关系\n\n> 我们最想要的是低偏差，低方差的模型，然而现实很难达到两者都极致的低。有时候需要用提高偏差来降低方差，毕竟模型的泛化能力十分重要。\n\n当损失函数达到极小值，模型对训练集的拟合达到了最佳效果，==对应着低偏差==，而这种情况下，往往对训练集的特点学的过于细微，而缺乏泛化能力。\n\n根据 ==奥坎姆剃刀原则==, 同样准确率，模型越简单越好，所以通过正则化等方式，削弱模型的拟合能力，降低过拟合的风险。通过提高偏差，来主动降低方差。\n\n最终我们要平衡方差与偏差，从而得到一个合理的模型。\n\n   \n![biasvariance](机器学习模型的偏差与方差/biasvariance.png)\n\n## 调整方差与偏差的方法\n\n待补充。。。","source":"_posts/机器学习模型的偏差与方差.md","raw":"---\ntitle: 机器学习模型的偏差与方差\nmathjax: true\ndate: 2019-08-01 16:43:19\ncategories: 机器学习方法\ntags: 方差与偏差\n---\n\n# 机器学习的方差与偏差\n\n> 方差与偏差，总是迷迷糊糊的，每次看了就会，过了就忘。今天看到一个非常棒的解释，迫不及待马上整理下来了。\n\n\n## 机器学习的目标函数\n机器学习模型学习的是数据集的条件概率分布，得到一个决策函数。整个学习过程围绕着最小化（或者最大化）目标函数进行优化参数，目标函数的通常形式的定义是：\n\n\n    Obj = L(θ) + λΩ(θ)\n    \n`L(θ)` 是损失函数，衡量模型对训练集拟合程度的好坏(对应偏差)；\n\n` Ω(θ)` 是正则项，是衡量模型的复杂程度（对应方差）；\n\n<font color=\"#FF0000\"> 目标函数定义为损失函数和正则项两部分，是为了平衡模型的偏差和方差（Bias Variance Trade-off）。</font> \n\n\n\n## 偏差与学习器\n\n> 偏差描述了 <font color=\"#FF0000\">学习器的拟合能力</font> （对训练集的）。\n\n学习器在训练集表现越好，损失越低，则模型的偏差越小。\n\n\n## 方差与学习器\n\n> 方差描述了 <font color=\"#FF0000\"> 学习器的泛化能力</font>(对测试集)。\n\n学习器在测试集表现越好，则模型的方差越低。\n\n\n## 偏差与方差之间的关系\n\n> 我们最想要的是低偏差，低方差的模型，然而现实很难达到两者都极致的低。有时候需要用提高偏差来降低方差，毕竟模型的泛化能力十分重要。\n\n当损失函数达到极小值，模型对训练集的拟合达到了最佳效果，==对应着低偏差==，而这种情况下，往往对训练集的特点学的过于细微，而缺乏泛化能力。\n\n根据 ==奥坎姆剃刀原则==, 同样准确率，模型越简单越好，所以通过正则化等方式，削弱模型的拟合能力，降低过拟合的风险。通过提高偏差，来主动降低方差。\n\n最终我们要平衡方差与偏差，从而得到一个合理的模型。\n\n   \n![biasvariance](机器学习模型的偏差与方差/biasvariance.png)\n\n## 调整方差与偏差的方法\n\n待补充。。。","slug":"机器学习模型的偏差与方差","published":1,"updated":"2020-02-20T04:41:37.825Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephfz0024t8ple85uc2uc","content":"<h1 id=\"机器学习的方差与偏差\"><a href=\"#机器学习的方差与偏差\" class=\"headerlink\" title=\"机器学习的方差与偏差\"></a>机器学习的方差与偏差</h1><blockquote>\n<p>方差与偏差，总是迷迷糊糊的，每次看了就会，过了就忘。今天看到一个非常棒的解释，迫不及待马上整理下来了。</p>\n</blockquote>\n<h2 id=\"机器学习的目标函数\"><a href=\"#机器学习的目标函数\" class=\"headerlink\" title=\"机器学习的目标函数\"></a>机器学习的目标函数</h2><p>机器学习模型学习的是数据集的条件概率分布，得到一个决策函数。整个学习过程围绕着最小化（或者最大化）目标函数进行优化参数，目标函数的通常形式的定义是：</p>\n<pre><code>Obj = L(θ) + λΩ(θ)\n</code></pre><p><code>L(θ)</code> 是损失函数，衡量模型对训练集拟合程度的好坏(对应偏差)；</p>\n<p><code>Ω(θ)</code> 是正则项，是衡量模型的复杂程度（对应方差）；</p>\n<font color=\"#FF0000\"> 目标函数定义为损失函数和正则项两部分，是为了平衡模型的偏差和方差（Bias Variance Trade-off）。</font> \n\n\n\n<h2 id=\"偏差与学习器\"><a href=\"#偏差与学习器\" class=\"headerlink\" title=\"偏差与学习器\"></a>偏差与学习器</h2><blockquote>\n<p>偏差描述了 <font color=\"#FF0000\">学习器的拟合能力</font> （对训练集的）。</p>\n</blockquote>\n<p>学习器在训练集表现越好，损失越低，则模型的偏差越小。</p>\n<h2 id=\"方差与学习器\"><a href=\"#方差与学习器\" class=\"headerlink\" title=\"方差与学习器\"></a>方差与学习器</h2><blockquote>\n<p>方差描述了 <font color=\"#FF0000\"> 学习器的泛化能力</font>(对测试集)。</p>\n</blockquote>\n<p>学习器在测试集表现越好，则模型的方差越低。</p>\n<h2 id=\"偏差与方差之间的关系\"><a href=\"#偏差与方差之间的关系\" class=\"headerlink\" title=\"偏差与方差之间的关系\"></a>偏差与方差之间的关系</h2><blockquote>\n<p>我们最想要的是低偏差，低方差的模型，然而现实很难达到两者都极致的低。有时候需要用提高偏差来降低方差，毕竟模型的泛化能力十分重要。</p>\n</blockquote>\n<p>当损失函数达到极小值，模型对训练集的拟合达到了最佳效果，==对应着低偏差==，而这种情况下，往往对训练集的特点学的过于细微，而缺乏泛化能力。</p>\n<p>根据 ==奥坎姆剃刀原则==, 同样准确率，模型越简单越好，所以通过正则化等方式，削弱模型的拟合能力，降低过拟合的风险。通过提高偏差，来主动降低方差。</p>\n<p>最终我们要平衡方差与偏差，从而得到一个合理的模型。</p>\n<p><img src=\"/2019/08/01/机器学习模型的偏差与方差/biasvariance.png\" alt=\"biasvariance\"></p>\n<h2 id=\"调整方差与偏差的方法\"><a href=\"#调整方差与偏差的方法\" class=\"headerlink\" title=\"调整方差与偏差的方法\"></a>调整方差与偏差的方法</h2><p>待补充。。。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"机器学习的方差与偏差\"><a href=\"#机器学习的方差与偏差\" class=\"headerlink\" title=\"机器学习的方差与偏差\"></a>机器学习的方差与偏差</h1><blockquote>\n<p>方差与偏差，总是迷迷糊糊的，每次看了就会，过了就忘。今天看到一个非常棒的解释，迫不及待马上整理下来了。</p>\n</blockquote>\n<h2 id=\"机器学习的目标函数\"><a href=\"#机器学习的目标函数\" class=\"headerlink\" title=\"机器学习的目标函数\"></a>机器学习的目标函数</h2><p>机器学习模型学习的是数据集的条件概率分布，得到一个决策函数。整个学习过程围绕着最小化（或者最大化）目标函数进行优化参数，目标函数的通常形式的定义是：</p>\n<pre><code>Obj = L(θ) + λΩ(θ)\n</code></pre><p><code>L(θ)</code> 是损失函数，衡量模型对训练集拟合程度的好坏(对应偏差)；</p>\n<p><code>Ω(θ)</code> 是正则项，是衡量模型的复杂程度（对应方差）；</p>\n<font color=\"#FF0000\"> 目标函数定义为损失函数和正则项两部分，是为了平衡模型的偏差和方差（Bias Variance Trade-off）。</font> \n\n\n\n<h2 id=\"偏差与学习器\"><a href=\"#偏差与学习器\" class=\"headerlink\" title=\"偏差与学习器\"></a>偏差与学习器</h2><blockquote>\n<p>偏差描述了 <font color=\"#FF0000\">学习器的拟合能力</font> （对训练集的）。</p>\n</blockquote>\n<p>学习器在训练集表现越好，损失越低，则模型的偏差越小。</p>\n<h2 id=\"方差与学习器\"><a href=\"#方差与学习器\" class=\"headerlink\" title=\"方差与学习器\"></a>方差与学习器</h2><blockquote>\n<p>方差描述了 <font color=\"#FF0000\"> 学习器的泛化能力</font>(对测试集)。</p>\n</blockquote>\n<p>学习器在测试集表现越好，则模型的方差越低。</p>\n<h2 id=\"偏差与方差之间的关系\"><a href=\"#偏差与方差之间的关系\" class=\"headerlink\" title=\"偏差与方差之间的关系\"></a>偏差与方差之间的关系</h2><blockquote>\n<p>我们最想要的是低偏差，低方差的模型，然而现实很难达到两者都极致的低。有时候需要用提高偏差来降低方差，毕竟模型的泛化能力十分重要。</p>\n</blockquote>\n<p>当损失函数达到极小值，模型对训练集的拟合达到了最佳效果，==对应着低偏差==，而这种情况下，往往对训练集的特点学的过于细微，而缺乏泛化能力。</p>\n<p>根据 ==奥坎姆剃刀原则==, 同样准确率，模型越简单越好，所以通过正则化等方式，削弱模型的拟合能力，降低过拟合的风险。通过提高偏差，来主动降低方差。</p>\n<p>最终我们要平衡方差与偏差，从而得到一个合理的模型。</p>\n<p><img src=\"/2019/08/01/机器学习模型的偏差与方差/biasvariance.png\" alt=\"biasvariance\"></p>\n<h2 id=\"调整方差与偏差的方法\"><a href=\"#调整方差与偏差的方法\" class=\"headerlink\" title=\"调整方差与偏差的方法\"></a>调整方差与偏差的方法</h2><p>待补充。。。</p>\n"},{"title":"决策树1-基本概念","date":"2019-04-20T10:09:10.000Z","_content":"\n\n# 决策树1- 基本概念\n\n## 决策树\n\n![logo](决策树-1基本概念/tree.png)\n\n上图来自西瓜书，是决策树的一种树形。生成决策树的过程，不断的**根据样本的属性( 样本的某个特征 )划分样本子集**。每个结点选择当前最优的属性作为划分依据，将样本集合不断的划分成更小的子集合，直到子集合中样本类别一致时或者没有可以划分的属性值时，则停止划分，标记为叶结点(叶节点代表一个类别)。\n\n简单的介绍一下决策树的组成元素:\n\n1. 根节点:  所有的训练样本\n2. 内部节点:   对应某一个划分属性\n3. 叶节点：   对应某一种决策结果\n4. 判定测试序列：   某个样本在节点中传递的路径\n\n所有节点都包含着不同数量的样本。\n\n> 以上是分类树的例子，决策树也可以用作回归任务，如CART算法。决策树是GBDT,Xgboost等更高级结构的基础，所以尽量要掌握决策树的原理。\n\n\n## 决策树算法的基本流程\n\n假设有一个数据集，其中的每个样本有多种特征，每个特征有不同的取值。通过这个数据集来生成一个决策树的一般流程可以归纳为:\n\n- 特征选择\n\n> 特征选择就是决策树分叉时，依据新节点的\"纯度\"，选择最优的划分属性;\n\n- 决策树生成\n\n> 树不断的分叉，直到样本的属性用光，或者树的深度达到了预定值，则结束分叉;\n\n- 剪枝\n\n> 如果一直树杈分下去，一定能够使得所有的样本都正确的归类，但这样会产生对训练集的过拟合，泛化能力变差，可以通过剪枝操作来改善泛化能力。\n\n通过这三步，就可以生成一颗决策树了。下面来学习一下具体怎么进行特征的选择和剪枝。\n\n\n## 如何选择最优的划分属性(分类树)?\n\n> 决策树不断分叉的原因，是尽可能的让不同类别的样本划分到不同的节点，同类别的样本划分到同一个节点。而选择最优的划分属性（特征）的过程，相当于是遍历计算出所有特征的结果，找到能使分叉后子集合最 \"纯\" 的特征，就是最优的划分属性了。\n所以，该如何定义 \"纯\" ，需要借助信息论中 \"信息熵\" 的概念了。\n\n**熵** :  表示随机变量不确定性的度量,也就是混乱程度的一种度量。\n\n假定数据集 `D` 中第 `K` 类样本所占的比例为 $$p_{k}$$,则信息熵定义为:\n\n$$\n\\operatorname{Ent}(D)=-\\sum_{k=1}^{N} p_{k} \\log _{2} p_{k}\n$$\n\n数据集包含的<font color=\"#FF0000\">类别越少时越纯，`Ent(D)`也越小。</font> \n\n### 法1: 信息增益\n\n==ID3算法用到信息增益==\n\n> 直白的讲就是决策树分叉前的信息熵减去分叉后的信息熵。\n\n> 信息增益最大的特征就是最佳划分属性。\n\n假定分叉前样本集 `D` 中的特征 `a` 有 `V`个可能的取值 $$\\left\\{a^{1}, a^{2}, \\ldots, a^{V}\\right\\}$$ ,当选择 `a` 做划分属性时，会分`V`个节点，每个节点上的子样本集合为 $$D^{v}$$,同时为不同节点赋权重(按照样本的比例)，于是信息增益为: \n\n$$\\operatorname{Gain}(D, a)=\\operatorname{Ent}(D)-\\sum_{v=1}^{V} \\frac{\\left|D^{v}\\right|}{|D|} \\operatorname{Ent}\\left(D^{v}\\right)$$\n\n减数部分也叫<font color=\"#FF0000\"> 条件熵 </font>\n\n<font color=\"#FF0000\">缺点:</font> 分叉时偏好取值较多的属性。\n\n<font color=\"#FF0000\">原因分析:</font>\n\n1. 取值多的特征，样本更分散，所有得到的新节点\"纯度\" 趋于更高，熵更低，而划分前的增益不变的情况下，该特征增益更大。\n2. 比如，当特征的可能取值数量正好等于样本数量，那条件熵几乎为0，该特征一定会被选择。\n\n### 法2: 信息增益率\n\n==C4.5算法用到信息增率==\n\n> 相当于在法1基础上，增加了惩罚系数，可取值越多，系数越大。\n\n$$Gain\\_ratio\\left( D,a \\right) =\\frac{Gain\\left( D,a \\right)}{IV\\left( a \\right)}$$\n\n$$\\mathrm{IV}(a)=-\\sum_{v=1}^{V} \\frac{\\left|D^{v}\\right|}{|D|} \\log _{2} \\frac{\\left|D^{v}\\right|}{|D|}$$\n\n\n`IV(a)` 是属性 `a` 的 \"固有值\"，内部属性。\n\n<font color=\"#FF0000\">缺点:</font> 分叉时偏好取值较少的属性。\n\n\n### 法3：基尼指数\n\n==CART决策树算法用到基尼指数==\n\n> 反应从节点样本集合中随机抽取两个样本，类别不一致的概率。CART决策树默认为二叉树。\n\n基尼值的定义:\n\n$$\n\\operatorname{Gini}(D)=\\sum_{k=1}^{|y|} \\sum_{k^{\\prime}=k} p_{k} p_{k^{\\prime}}\n$$\n\n\n$$=\\sum_{k=1}^{|y|} p_{k}\\left(1-P_{k}\\right)$$\n\n$$=1-\\sum_{k=1}^{|\\mathcal{Y}|} p_{k}^{2}$$\n\n\n选择特征 `A` 的情况下，针对 `A` 所有可能取值 `a`, 分别计算基尼指数：\n\n$$Gini\\_index\\left( D,a \\right) =\\sum_{v=1}^V{\\frac{\\left| D^v \\right|}{|D|}}\\text{}Gini\\left( D^v \\right) $$\n\n选择基尼指数最小的特征和切分点，作为最优划分属性。\n\n\n\n三种决策树模型：\n\n算法 | 特征选择标准\n---|---\nID3 | 信息增益\nC4.5 | 信息增益率\nCART | 基尼指数\n\n\n\n## 对抗过拟合 -- 剪枝处理\n\n> 分支太多，容易过拟合，泛化能力变差。所以要适当剪枝，常用方法是**预剪枝**和**后剪枝**\n\n> 剪枝操作包括的点也很多，这里只是简单描述一下，详细的参考未来的博客。[www.elgong.top](www.elgong.top)\n\n### 预剪枝\n\n\n1. 预剪枝是在决策树生成的过程中，对每个结点在划分前先估计，根据划分前后验证集的精度，来决定是否划分；\n\n\n2. 只能估计当前结点可划分性，不能预测到未来节点划分的必要性，是贪心算法；\n\n\n3. 容易造成欠拟合。\n\n### 后剪枝\n\n1. 先生成完整的树，再从叶结点往回计算，根据验证集精度是否提升决定是否剪枝；\n\n\n2. 泛化能力往往优于预剪枝，欠拟合风险小；\n\n\n3. 时间开销大。\n\n\n## 属性为连续值时？\n\n> C4.5 算法采用二分法将连续值离散化\n\n> 与离散属性不同，连续的属性可以在后代节点中再次使用\n\n\n\n## 当数据中含有缺失值时？\n\n处理方法：\n\n通过无缺失数据计算出三个参数：\n\n1. 无缺失样本占总样本比例 \n2. 无缺失样中 `K类别` 占比 `pk`\n3. 无缺失样本中 `v 属性`样本占比 `rv`\n\n对单样本增加一个权值 `Wx`, 无缺失样本的`Wx = 1`，  有缺失样本的`Wx = rv*Wx `。\n\n在计算分支时，**同一样本以不同的概率划分到不同的子节点中**\n\n- 当样本的属性已知：则把该样本划分进对应的子节点，权值=1；\n\n\n- 当样本的该属性缺失：则把该样本同时划入所有的子节点，样本权值需要更新为`Wx = rv*Wx。\n\n\n## 决策树的优缺点\n\n==优点==：\n\n- 便于理解和可视化；\n- 训练需要的数据少，不需要对数据进行规范化；\n- 可同时处理数值型，类别型数据；\n- 是白盒模型，可解释；\n\n==缺点==：\n\n- 容易产生过于复杂的模型 -> 泛化能力差 （剪枝，限制叶节点所需要的最小样本数，最大深度）\n- 决策树不稳定，微小变化会产生不同的树（集成多棵树可以缓解）\n- 难学NP问题（启发式学习）\n- 异或，奇偶，很难被学习到\n\n\n\n","source":"_posts/决策树-1基本概念.md","raw":"---\ntitle: 决策树1-基本概念\ndate: 2019-04-20 18:09:10\ncategories: 机器学习方法\ntags: 决策树\n---\n\n\n# 决策树1- 基本概念\n\n## 决策树\n\n![logo](决策树-1基本概念/tree.png)\n\n上图来自西瓜书，是决策树的一种树形。生成决策树的过程，不断的**根据样本的属性( 样本的某个特征 )划分样本子集**。每个结点选择当前最优的属性作为划分依据，将样本集合不断的划分成更小的子集合，直到子集合中样本类别一致时或者没有可以划分的属性值时，则停止划分，标记为叶结点(叶节点代表一个类别)。\n\n简单的介绍一下决策树的组成元素:\n\n1. 根节点:  所有的训练样本\n2. 内部节点:   对应某一个划分属性\n3. 叶节点：   对应某一种决策结果\n4. 判定测试序列：   某个样本在节点中传递的路径\n\n所有节点都包含着不同数量的样本。\n\n> 以上是分类树的例子，决策树也可以用作回归任务，如CART算法。决策树是GBDT,Xgboost等更高级结构的基础，所以尽量要掌握决策树的原理。\n\n\n## 决策树算法的基本流程\n\n假设有一个数据集，其中的每个样本有多种特征，每个特征有不同的取值。通过这个数据集来生成一个决策树的一般流程可以归纳为:\n\n- 特征选择\n\n> 特征选择就是决策树分叉时，依据新节点的\"纯度\"，选择最优的划分属性;\n\n- 决策树生成\n\n> 树不断的分叉，直到样本的属性用光，或者树的深度达到了预定值，则结束分叉;\n\n- 剪枝\n\n> 如果一直树杈分下去，一定能够使得所有的样本都正确的归类，但这样会产生对训练集的过拟合，泛化能力变差，可以通过剪枝操作来改善泛化能力。\n\n通过这三步，就可以生成一颗决策树了。下面来学习一下具体怎么进行特征的选择和剪枝。\n\n\n## 如何选择最优的划分属性(分类树)?\n\n> 决策树不断分叉的原因，是尽可能的让不同类别的样本划分到不同的节点，同类别的样本划分到同一个节点。而选择最优的划分属性（特征）的过程，相当于是遍历计算出所有特征的结果，找到能使分叉后子集合最 \"纯\" 的特征，就是最优的划分属性了。\n所以，该如何定义 \"纯\" ，需要借助信息论中 \"信息熵\" 的概念了。\n\n**熵** :  表示随机变量不确定性的度量,也就是混乱程度的一种度量。\n\n假定数据集 `D` 中第 `K` 类样本所占的比例为 $$p_{k}$$,则信息熵定义为:\n\n$$\n\\operatorname{Ent}(D)=-\\sum_{k=1}^{N} p_{k} \\log _{2} p_{k}\n$$\n\n数据集包含的<font color=\"#FF0000\">类别越少时越纯，`Ent(D)`也越小。</font> \n\n### 法1: 信息增益\n\n==ID3算法用到信息增益==\n\n> 直白的讲就是决策树分叉前的信息熵减去分叉后的信息熵。\n\n> 信息增益最大的特征就是最佳划分属性。\n\n假定分叉前样本集 `D` 中的特征 `a` 有 `V`个可能的取值 $$\\left\\{a^{1}, a^{2}, \\ldots, a^{V}\\right\\}$$ ,当选择 `a` 做划分属性时，会分`V`个节点，每个节点上的子样本集合为 $$D^{v}$$,同时为不同节点赋权重(按照样本的比例)，于是信息增益为: \n\n$$\\operatorname{Gain}(D, a)=\\operatorname{Ent}(D)-\\sum_{v=1}^{V} \\frac{\\left|D^{v}\\right|}{|D|} \\operatorname{Ent}\\left(D^{v}\\right)$$\n\n减数部分也叫<font color=\"#FF0000\"> 条件熵 </font>\n\n<font color=\"#FF0000\">缺点:</font> 分叉时偏好取值较多的属性。\n\n<font color=\"#FF0000\">原因分析:</font>\n\n1. 取值多的特征，样本更分散，所有得到的新节点\"纯度\" 趋于更高，熵更低，而划分前的增益不变的情况下，该特征增益更大。\n2. 比如，当特征的可能取值数量正好等于样本数量，那条件熵几乎为0，该特征一定会被选择。\n\n### 法2: 信息增益率\n\n==C4.5算法用到信息增率==\n\n> 相当于在法1基础上，增加了惩罚系数，可取值越多，系数越大。\n\n$$Gain\\_ratio\\left( D,a \\right) =\\frac{Gain\\left( D,a \\right)}{IV\\left( a \\right)}$$\n\n$$\\mathrm{IV}(a)=-\\sum_{v=1}^{V} \\frac{\\left|D^{v}\\right|}{|D|} \\log _{2} \\frac{\\left|D^{v}\\right|}{|D|}$$\n\n\n`IV(a)` 是属性 `a` 的 \"固有值\"，内部属性。\n\n<font color=\"#FF0000\">缺点:</font> 分叉时偏好取值较少的属性。\n\n\n### 法3：基尼指数\n\n==CART决策树算法用到基尼指数==\n\n> 反应从节点样本集合中随机抽取两个样本，类别不一致的概率。CART决策树默认为二叉树。\n\n基尼值的定义:\n\n$$\n\\operatorname{Gini}(D)=\\sum_{k=1}^{|y|} \\sum_{k^{\\prime}=k} p_{k} p_{k^{\\prime}}\n$$\n\n\n$$=\\sum_{k=1}^{|y|} p_{k}\\left(1-P_{k}\\right)$$\n\n$$=1-\\sum_{k=1}^{|\\mathcal{Y}|} p_{k}^{2}$$\n\n\n选择特征 `A` 的情况下，针对 `A` 所有可能取值 `a`, 分别计算基尼指数：\n\n$$Gini\\_index\\left( D,a \\right) =\\sum_{v=1}^V{\\frac{\\left| D^v \\right|}{|D|}}\\text{}Gini\\left( D^v \\right) $$\n\n选择基尼指数最小的特征和切分点，作为最优划分属性。\n\n\n\n三种决策树模型：\n\n算法 | 特征选择标准\n---|---\nID3 | 信息增益\nC4.5 | 信息增益率\nCART | 基尼指数\n\n\n\n## 对抗过拟合 -- 剪枝处理\n\n> 分支太多，容易过拟合，泛化能力变差。所以要适当剪枝，常用方法是**预剪枝**和**后剪枝**\n\n> 剪枝操作包括的点也很多，这里只是简单描述一下，详细的参考未来的博客。[www.elgong.top](www.elgong.top)\n\n### 预剪枝\n\n\n1. 预剪枝是在决策树生成的过程中，对每个结点在划分前先估计，根据划分前后验证集的精度，来决定是否划分；\n\n\n2. 只能估计当前结点可划分性，不能预测到未来节点划分的必要性，是贪心算法；\n\n\n3. 容易造成欠拟合。\n\n### 后剪枝\n\n1. 先生成完整的树，再从叶结点往回计算，根据验证集精度是否提升决定是否剪枝；\n\n\n2. 泛化能力往往优于预剪枝，欠拟合风险小；\n\n\n3. 时间开销大。\n\n\n## 属性为连续值时？\n\n> C4.5 算法采用二分法将连续值离散化\n\n> 与离散属性不同，连续的属性可以在后代节点中再次使用\n\n\n\n## 当数据中含有缺失值时？\n\n处理方法：\n\n通过无缺失数据计算出三个参数：\n\n1. 无缺失样本占总样本比例 \n2. 无缺失样中 `K类别` 占比 `pk`\n3. 无缺失样本中 `v 属性`样本占比 `rv`\n\n对单样本增加一个权值 `Wx`, 无缺失样本的`Wx = 1`，  有缺失样本的`Wx = rv*Wx `。\n\n在计算分支时，**同一样本以不同的概率划分到不同的子节点中**\n\n- 当样本的属性已知：则把该样本划分进对应的子节点，权值=1；\n\n\n- 当样本的该属性缺失：则把该样本同时划入所有的子节点，样本权值需要更新为`Wx = rv*Wx。\n\n\n## 决策树的优缺点\n\n==优点==：\n\n- 便于理解和可视化；\n- 训练需要的数据少，不需要对数据进行规范化；\n- 可同时处理数值型，类别型数据；\n- 是白盒模型，可解释；\n\n==缺点==：\n\n- 容易产生过于复杂的模型 -> 泛化能力差 （剪枝，限制叶节点所需要的最小样本数，最大深度）\n- 决策树不稳定，微小变化会产生不同的树（集成多棵树可以缓解）\n- 难学NP问题（启发式学习）\n- 异或，奇偶，很难被学习到\n\n\n\n","slug":"决策树-1基本概念","published":1,"updated":"2020-02-20T06:39:22.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephg50027t8plqxez0dqn","content":"<h1 id=\"决策树1-基本概念\"><a href=\"#决策树1-基本概念\" class=\"headerlink\" title=\"决策树1- 基本概念\"></a>决策树1- 基本概念</h1><h2 id=\"决策树\"><a href=\"#决策树\" class=\"headerlink\" title=\"决策树\"></a>决策树</h2><p><img src=\"/2019/04/20/决策树-1基本概念/tree.png\" alt=\"logo\"></p>\n<p>上图来自西瓜书，是决策树的一种树形。生成决策树的过程，不断的<strong>根据样本的属性( 样本的某个特征 )划分样本子集</strong>。每个结点选择当前最优的属性作为划分依据，将样本集合不断的划分成更小的子集合，直到子集合中样本类别一致时或者没有可以划分的属性值时，则停止划分，标记为叶结点(叶节点代表一个类别)。</p>\n<p>简单的介绍一下决策树的组成元素:</p>\n<ol>\n<li>根节点:  所有的训练样本</li>\n<li>内部节点:   对应某一个划分属性</li>\n<li>叶节点：   对应某一种决策结果</li>\n<li>判定测试序列：   某个样本在节点中传递的路径</li>\n</ol>\n<p>所有节点都包含着不同数量的样本。</p>\n<blockquote>\n<p>以上是分类树的例子，决策树也可以用作回归任务，如CART算法。决策树是GBDT,Xgboost等更高级结构的基础，所以尽量要掌握决策树的原理。</p>\n</blockquote>\n<h2 id=\"决策树算法的基本流程\"><a href=\"#决策树算法的基本流程\" class=\"headerlink\" title=\"决策树算法的基本流程\"></a>决策树算法的基本流程</h2><p>假设有一个数据集，其中的每个样本有多种特征，每个特征有不同的取值。通过这个数据集来生成一个决策树的一般流程可以归纳为:</p>\n<ul>\n<li>特征选择</li>\n</ul>\n<blockquote>\n<p>特征选择就是决策树分叉时，依据新节点的”纯度”，选择最优的划分属性;</p>\n</blockquote>\n<ul>\n<li>决策树生成</li>\n</ul>\n<blockquote>\n<p>树不断的分叉，直到样本的属性用光，或者树的深度达到了预定值，则结束分叉;</p>\n</blockquote>\n<ul>\n<li>剪枝</li>\n</ul>\n<blockquote>\n<p>如果一直树杈分下去，一定能够使得所有的样本都正确的归类，但这样会产生对训练集的过拟合，泛化能力变差，可以通过剪枝操作来改善泛化能力。</p>\n</blockquote>\n<p>通过这三步，就可以生成一颗决策树了。下面来学习一下具体怎么进行特征的选择和剪枝。</p>\n<h2 id=\"如何选择最优的划分属性-分类树\"><a href=\"#如何选择最优的划分属性-分类树\" class=\"headerlink\" title=\"如何选择最优的划分属性(分类树)?\"></a>如何选择最优的划分属性(分类树)?</h2><blockquote>\n<p>决策树不断分叉的原因，是尽可能的让不同类别的样本划分到不同的节点，同类别的样本划分到同一个节点。而选择最优的划分属性（特征）的过程，相当于是遍历计算出所有特征的结果，找到能使分叉后子集合最 “纯” 的特征，就是最优的划分属性了。<br>所以，该如何定义 “纯” ，需要借助信息论中 “信息熵” 的概念了。</p>\n</blockquote>\n<p><strong>熵</strong> :  表示随机变量不确定性的度量,也就是混乱程度的一种度量。</p>\n<p>假定数据集 <code>D</code> 中第 <code>K</code> 类样本所占的比例为 <script type=\"math/tex\">p_{k}</script>,则信息熵定义为:</p>\n<script type=\"math/tex; mode=display\">\n\\operatorname{Ent}(D)=-\\sum_{k=1}^{N} p_{k} \\log _{2} p_{k}</script><p>数据集包含的<font color=\"#FF0000\">类别越少时越纯，<code>Ent(D)</code>也越小。</font> </p>\n<h3 id=\"法1-信息增益\"><a href=\"#法1-信息增益\" class=\"headerlink\" title=\"法1: 信息增益\"></a>法1: 信息增益</h3><p>==ID3算法用到信息增益==</p>\n<blockquote>\n<p>直白的讲就是决策树分叉前的信息熵减去分叉后的信息熵。</p>\n<p>信息增益最大的特征就是最佳划分属性。</p>\n</blockquote>\n<p>假定分叉前样本集 <code>D</code> 中的特征 <code>a</code> 有 <code>V</code>个可能的取值 <script type=\"math/tex\">\\left\\{a^{1}, a^{2}, \\ldots, a^{V}\\right\\}</script> ,当选择 <code>a</code> 做划分属性时，会分<code>V</code>个节点，每个节点上的子样本集合为 <script type=\"math/tex\">D^{v}</script>,同时为不同节点赋权重(按照样本的比例)，于是信息增益为: </p>\n<script type=\"math/tex; mode=display\">\\operatorname{Gain}(D, a)=\\operatorname{Ent}(D)-\\sum_{v=1}^{V} \\frac{\\left|D^{v}\\right|}{|D|} \\operatorname{Ent}\\left(D^{v}\\right)</script><p>减数部分也叫<font color=\"#FF0000\"> 条件熵 </font></p>\n<font color=\"#FF0000\">缺点:</font> 分叉时偏好取值较多的属性。\n\n<font color=\"#FF0000\">原因分析:</font>\n\n<ol>\n<li>取值多的特征，样本更分散，所有得到的新节点”纯度” 趋于更高，熵更低，而划分前的增益不变的情况下，该特征增益更大。</li>\n<li>比如，当特征的可能取值数量正好等于样本数量，那条件熵几乎为0，该特征一定会被选择。</li>\n</ol>\n<h3 id=\"法2-信息增益率\"><a href=\"#法2-信息增益率\" class=\"headerlink\" title=\"法2: 信息增益率\"></a>法2: 信息增益率</h3><p>==C4.5算法用到信息增率==</p>\n<blockquote>\n<p>相当于在法1基础上，增加了惩罚系数，可取值越多，系数越大。</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">Gain\\_ratio\\left( D,a \\right) =\\frac{Gain\\left( D,a \\right)}{IV\\left( a \\right)}</script><script type=\"math/tex; mode=display\">\\mathrm{IV}(a)=-\\sum_{v=1}^{V} \\frac{\\left|D^{v}\\right|}{|D|} \\log _{2} \\frac{\\left|D^{v}\\right|}{|D|}</script><p><code>IV(a)</code> 是属性 <code>a</code> 的 “固有值”，内部属性。</p>\n<p><font color=\"#FF0000\">缺点:</font> 分叉时偏好取值较少的属性。</p>\n<h3 id=\"法3：基尼指数\"><a href=\"#法3：基尼指数\" class=\"headerlink\" title=\"法3：基尼指数\"></a>法3：基尼指数</h3><p>==CART决策树算法用到基尼指数==</p>\n<blockquote>\n<p>反应从节点样本集合中随机抽取两个样本，类别不一致的概率。CART决策树默认为二叉树。</p>\n</blockquote>\n<p>基尼值的定义:</p>\n<script type=\"math/tex; mode=display\">\n\\operatorname{Gini}(D)=\\sum_{k=1}^{|y|} \\sum_{k^{\\prime}=k} p_{k} p_{k^{\\prime}}</script><script type=\"math/tex; mode=display\">=\\sum_{k=1}^{|y|} p_{k}\\left(1-P_{k}\\right)</script><script type=\"math/tex; mode=display\">=1-\\sum_{k=1}^{|\\mathcal{Y}|} p_{k}^{2}</script><p>选择特征 <code>A</code> 的情况下，针对 <code>A</code> 所有可能取值 <code>a</code>, 分别计算基尼指数：</p>\n<script type=\"math/tex; mode=display\">Gini\\_index\\left( D,a \\right) =\\sum_{v=1}^V{\\frac{\\left| D^v \\right|}{|D|}}\\text{}Gini\\left( D^v \\right)</script><p>选择基尼指数最小的特征和切分点，作为最优划分属性。</p>\n<p>三种决策树模型：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>算法</th>\n<th>特征选择标准</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ID3</td>\n<td>信息增益</td>\n</tr>\n<tr>\n<td>C4.5</td>\n<td>信息增益率</td>\n</tr>\n<tr>\n<td>CART</td>\n<td>基尼指数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"对抗过拟合-—-剪枝处理\"><a href=\"#对抗过拟合-—-剪枝处理\" class=\"headerlink\" title=\"对抗过拟合 — 剪枝处理\"></a>对抗过拟合 — 剪枝处理</h2><blockquote>\n<p>分支太多，容易过拟合，泛化能力变差。所以要适当剪枝，常用方法是<strong>预剪枝</strong>和<strong>后剪枝</strong></p>\n<p>剪枝操作包括的点也很多，这里只是简单描述一下，详细的参考未来的博客。<a href=\"www.elgong.top\">www.elgong.top</a></p>\n</blockquote>\n<h3 id=\"预剪枝\"><a href=\"#预剪枝\" class=\"headerlink\" title=\"预剪枝\"></a>预剪枝</h3><ol>\n<li>预剪枝是在决策树生成的过程中，对每个结点在划分前先估计，根据划分前后验证集的精度，来决定是否划分；</li>\n</ol>\n<ol>\n<li>只能估计当前结点可划分性，不能预测到未来节点划分的必要性，是贪心算法；</li>\n</ol>\n<ol>\n<li>容易造成欠拟合。</li>\n</ol>\n<h3 id=\"后剪枝\"><a href=\"#后剪枝\" class=\"headerlink\" title=\"后剪枝\"></a>后剪枝</h3><ol>\n<li>先生成完整的树，再从叶结点往回计算，根据验证集精度是否提升决定是否剪枝；</li>\n</ol>\n<ol>\n<li>泛化能力往往优于预剪枝，欠拟合风险小；</li>\n</ol>\n<ol>\n<li>时间开销大。</li>\n</ol>\n<h2 id=\"属性为连续值时？\"><a href=\"#属性为连续值时？\" class=\"headerlink\" title=\"属性为连续值时？\"></a>属性为连续值时？</h2><blockquote>\n<p>C4.5 算法采用二分法将连续值离散化</p>\n<p>与离散属性不同，连续的属性可以在后代节点中再次使用</p>\n</blockquote>\n<h2 id=\"当数据中含有缺失值时？\"><a href=\"#当数据中含有缺失值时？\" class=\"headerlink\" title=\"当数据中含有缺失值时？\"></a>当数据中含有缺失值时？</h2><p>处理方法：</p>\n<p>通过无缺失数据计算出三个参数：</p>\n<ol>\n<li>无缺失样本占总样本比例 </li>\n<li>无缺失样中 <code>K类别</code> 占比 <code>pk</code></li>\n<li>无缺失样本中 <code>v 属性</code>样本占比 <code>rv</code></li>\n</ol>\n<p>对单样本增加一个权值 <code>Wx</code>, 无缺失样本的<code>Wx = 1</code>，  有缺失样本的<code>Wx = rv*Wx</code>。</p>\n<p>在计算分支时，<strong>同一样本以不同的概率划分到不同的子节点中</strong></p>\n<ul>\n<li>当样本的属性已知：则把该样本划分进对应的子节点，权值=1；</li>\n</ul>\n<ul>\n<li>当样本的该属性缺失：则把该样本同时划入所有的子节点，样本权值需要更新为`Wx = rv*Wx。</li>\n</ul>\n<h2 id=\"决策树的优缺点\"><a href=\"#决策树的优缺点\" class=\"headerlink\" title=\"决策树的优缺点\"></a>决策树的优缺点</h2><p>==优点==：</p>\n<ul>\n<li>便于理解和可视化；</li>\n<li>训练需要的数据少，不需要对数据进行规范化；</li>\n<li>可同时处理数值型，类别型数据；</li>\n<li>是白盒模型，可解释；</li>\n</ul>\n<p>==缺点==：</p>\n<ul>\n<li>容易产生过于复杂的模型 -&gt; 泛化能力差 （剪枝，限制叶节点所需要的最小样本数，最大深度）</li>\n<li>决策树不稳定，微小变化会产生不同的树（集成多棵树可以缓解）</li>\n<li>难学NP问题（启发式学习）</li>\n<li>异或，奇偶，很难被学习到</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"决策树1-基本概念\"><a href=\"#决策树1-基本概念\" class=\"headerlink\" title=\"决策树1- 基本概念\"></a>决策树1- 基本概念</h1><h2 id=\"决策树\"><a href=\"#决策树\" class=\"headerlink\" title=\"决策树\"></a>决策树</h2><p><img src=\"/2019/04/20/决策树-1基本概念/tree.png\" alt=\"logo\"></p>\n<p>上图来自西瓜书，是决策树的一种树形。生成决策树的过程，不断的<strong>根据样本的属性( 样本的某个特征 )划分样本子集</strong>。每个结点选择当前最优的属性作为划分依据，将样本集合不断的划分成更小的子集合，直到子集合中样本类别一致时或者没有可以划分的属性值时，则停止划分，标记为叶结点(叶节点代表一个类别)。</p>\n<p>简单的介绍一下决策树的组成元素:</p>\n<ol>\n<li>根节点:  所有的训练样本</li>\n<li>内部节点:   对应某一个划分属性</li>\n<li>叶节点：   对应某一种决策结果</li>\n<li>判定测试序列：   某个样本在节点中传递的路径</li>\n</ol>\n<p>所有节点都包含着不同数量的样本。</p>\n<blockquote>\n<p>以上是分类树的例子，决策树也可以用作回归任务，如CART算法。决策树是GBDT,Xgboost等更高级结构的基础，所以尽量要掌握决策树的原理。</p>\n</blockquote>\n<h2 id=\"决策树算法的基本流程\"><a href=\"#决策树算法的基本流程\" class=\"headerlink\" title=\"决策树算法的基本流程\"></a>决策树算法的基本流程</h2><p>假设有一个数据集，其中的每个样本有多种特征，每个特征有不同的取值。通过这个数据集来生成一个决策树的一般流程可以归纳为:</p>\n<ul>\n<li>特征选择</li>\n</ul>\n<blockquote>\n<p>特征选择就是决策树分叉时，依据新节点的”纯度”，选择最优的划分属性;</p>\n</blockquote>\n<ul>\n<li>决策树生成</li>\n</ul>\n<blockquote>\n<p>树不断的分叉，直到样本的属性用光，或者树的深度达到了预定值，则结束分叉;</p>\n</blockquote>\n<ul>\n<li>剪枝</li>\n</ul>\n<blockquote>\n<p>如果一直树杈分下去，一定能够使得所有的样本都正确的归类，但这样会产生对训练集的过拟合，泛化能力变差，可以通过剪枝操作来改善泛化能力。</p>\n</blockquote>\n<p>通过这三步，就可以生成一颗决策树了。下面来学习一下具体怎么进行特征的选择和剪枝。</p>\n<h2 id=\"如何选择最优的划分属性-分类树\"><a href=\"#如何选择最优的划分属性-分类树\" class=\"headerlink\" title=\"如何选择最优的划分属性(分类树)?\"></a>如何选择最优的划分属性(分类树)?</h2><blockquote>\n<p>决策树不断分叉的原因，是尽可能的让不同类别的样本划分到不同的节点，同类别的样本划分到同一个节点。而选择最优的划分属性（特征）的过程，相当于是遍历计算出所有特征的结果，找到能使分叉后子集合最 “纯” 的特征，就是最优的划分属性了。<br>所以，该如何定义 “纯” ，需要借助信息论中 “信息熵” 的概念了。</p>\n</blockquote>\n<p><strong>熵</strong> :  表示随机变量不确定性的度量,也就是混乱程度的一种度量。</p>\n<p>假定数据集 <code>D</code> 中第 <code>K</code> 类样本所占的比例为 <script type=\"math/tex\">p_{k}</script>,则信息熵定义为:</p>\n<script type=\"math/tex; mode=display\">\n\\operatorname{Ent}(D)=-\\sum_{k=1}^{N} p_{k} \\log _{2} p_{k}</script><p>数据集包含的<font color=\"#FF0000\">类别越少时越纯，<code>Ent(D)</code>也越小。</font> </p>\n<h3 id=\"法1-信息增益\"><a href=\"#法1-信息增益\" class=\"headerlink\" title=\"法1: 信息增益\"></a>法1: 信息增益</h3><p>==ID3算法用到信息增益==</p>\n<blockquote>\n<p>直白的讲就是决策树分叉前的信息熵减去分叉后的信息熵。</p>\n<p>信息增益最大的特征就是最佳划分属性。</p>\n</blockquote>\n<p>假定分叉前样本集 <code>D</code> 中的特征 <code>a</code> 有 <code>V</code>个可能的取值 <script type=\"math/tex\">\\left\\{a^{1}, a^{2}, \\ldots, a^{V}\\right\\}</script> ,当选择 <code>a</code> 做划分属性时，会分<code>V</code>个节点，每个节点上的子样本集合为 <script type=\"math/tex\">D^{v}</script>,同时为不同节点赋权重(按照样本的比例)，于是信息增益为: </p>\n<script type=\"math/tex; mode=display\">\\operatorname{Gain}(D, a)=\\operatorname{Ent}(D)-\\sum_{v=1}^{V} \\frac{\\left|D^{v}\\right|}{|D|} \\operatorname{Ent}\\left(D^{v}\\right)</script><p>减数部分也叫<font color=\"#FF0000\"> 条件熵 </font></p>\n<font color=\"#FF0000\">缺点:</font> 分叉时偏好取值较多的属性。\n\n<font color=\"#FF0000\">原因分析:</font>\n\n<ol>\n<li>取值多的特征，样本更分散，所有得到的新节点”纯度” 趋于更高，熵更低，而划分前的增益不变的情况下，该特征增益更大。</li>\n<li>比如，当特征的可能取值数量正好等于样本数量，那条件熵几乎为0，该特征一定会被选择。</li>\n</ol>\n<h3 id=\"法2-信息增益率\"><a href=\"#法2-信息增益率\" class=\"headerlink\" title=\"法2: 信息增益率\"></a>法2: 信息增益率</h3><p>==C4.5算法用到信息增率==</p>\n<blockquote>\n<p>相当于在法1基础上，增加了惩罚系数，可取值越多，系数越大。</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">Gain\\_ratio\\left( D,a \\right) =\\frac{Gain\\left( D,a \\right)}{IV\\left( a \\right)}</script><script type=\"math/tex; mode=display\">\\mathrm{IV}(a)=-\\sum_{v=1}^{V} \\frac{\\left|D^{v}\\right|}{|D|} \\log _{2} \\frac{\\left|D^{v}\\right|}{|D|}</script><p><code>IV(a)</code> 是属性 <code>a</code> 的 “固有值”，内部属性。</p>\n<p><font color=\"#FF0000\">缺点:</font> 分叉时偏好取值较少的属性。</p>\n<h3 id=\"法3：基尼指数\"><a href=\"#法3：基尼指数\" class=\"headerlink\" title=\"法3：基尼指数\"></a>法3：基尼指数</h3><p>==CART决策树算法用到基尼指数==</p>\n<blockquote>\n<p>反应从节点样本集合中随机抽取两个样本，类别不一致的概率。CART决策树默认为二叉树。</p>\n</blockquote>\n<p>基尼值的定义:</p>\n<script type=\"math/tex; mode=display\">\n\\operatorname{Gini}(D)=\\sum_{k=1}^{|y|} \\sum_{k^{\\prime}=k} p_{k} p_{k^{\\prime}}</script><script type=\"math/tex; mode=display\">=\\sum_{k=1}^{|y|} p_{k}\\left(1-P_{k}\\right)</script><script type=\"math/tex; mode=display\">=1-\\sum_{k=1}^{|\\mathcal{Y}|} p_{k}^{2}</script><p>选择特征 <code>A</code> 的情况下，针对 <code>A</code> 所有可能取值 <code>a</code>, 分别计算基尼指数：</p>\n<script type=\"math/tex; mode=display\">Gini\\_index\\left( D,a \\right) =\\sum_{v=1}^V{\\frac{\\left| D^v \\right|}{|D|}}\\text{}Gini\\left( D^v \\right)</script><p>选择基尼指数最小的特征和切分点，作为最优划分属性。</p>\n<p>三种决策树模型：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>算法</th>\n<th>特征选择标准</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ID3</td>\n<td>信息增益</td>\n</tr>\n<tr>\n<td>C4.5</td>\n<td>信息增益率</td>\n</tr>\n<tr>\n<td>CART</td>\n<td>基尼指数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"对抗过拟合-—-剪枝处理\"><a href=\"#对抗过拟合-—-剪枝处理\" class=\"headerlink\" title=\"对抗过拟合 — 剪枝处理\"></a>对抗过拟合 — 剪枝处理</h2><blockquote>\n<p>分支太多，容易过拟合，泛化能力变差。所以要适当剪枝，常用方法是<strong>预剪枝</strong>和<strong>后剪枝</strong></p>\n<p>剪枝操作包括的点也很多，这里只是简单描述一下，详细的参考未来的博客。<a href=\"www.elgong.top\">www.elgong.top</a></p>\n</blockquote>\n<h3 id=\"预剪枝\"><a href=\"#预剪枝\" class=\"headerlink\" title=\"预剪枝\"></a>预剪枝</h3><ol>\n<li>预剪枝是在决策树生成的过程中，对每个结点在划分前先估计，根据划分前后验证集的精度，来决定是否划分；</li>\n</ol>\n<ol>\n<li>只能估计当前结点可划分性，不能预测到未来节点划分的必要性，是贪心算法；</li>\n</ol>\n<ol>\n<li>容易造成欠拟合。</li>\n</ol>\n<h3 id=\"后剪枝\"><a href=\"#后剪枝\" class=\"headerlink\" title=\"后剪枝\"></a>后剪枝</h3><ol>\n<li>先生成完整的树，再从叶结点往回计算，根据验证集精度是否提升决定是否剪枝；</li>\n</ol>\n<ol>\n<li>泛化能力往往优于预剪枝，欠拟合风险小；</li>\n</ol>\n<ol>\n<li>时间开销大。</li>\n</ol>\n<h2 id=\"属性为连续值时？\"><a href=\"#属性为连续值时？\" class=\"headerlink\" title=\"属性为连续值时？\"></a>属性为连续值时？</h2><blockquote>\n<p>C4.5 算法采用二分法将连续值离散化</p>\n<p>与离散属性不同，连续的属性可以在后代节点中再次使用</p>\n</blockquote>\n<h2 id=\"当数据中含有缺失值时？\"><a href=\"#当数据中含有缺失值时？\" class=\"headerlink\" title=\"当数据中含有缺失值时？\"></a>当数据中含有缺失值时？</h2><p>处理方法：</p>\n<p>通过无缺失数据计算出三个参数：</p>\n<ol>\n<li>无缺失样本占总样本比例 </li>\n<li>无缺失样中 <code>K类别</code> 占比 <code>pk</code></li>\n<li>无缺失样本中 <code>v 属性</code>样本占比 <code>rv</code></li>\n</ol>\n<p>对单样本增加一个权值 <code>Wx</code>, 无缺失样本的<code>Wx = 1</code>，  有缺失样本的<code>Wx = rv*Wx</code>。</p>\n<p>在计算分支时，<strong>同一样本以不同的概率划分到不同的子节点中</strong></p>\n<ul>\n<li>当样本的属性已知：则把该样本划分进对应的子节点，权值=1；</li>\n</ul>\n<ul>\n<li>当样本的该属性缺失：则把该样本同时划入所有的子节点，样本权值需要更新为`Wx = rv*Wx。</li>\n</ul>\n<h2 id=\"决策树的优缺点\"><a href=\"#决策树的优缺点\" class=\"headerlink\" title=\"决策树的优缺点\"></a>决策树的优缺点</h2><p>==优点==：</p>\n<ul>\n<li>便于理解和可视化；</li>\n<li>训练需要的数据少，不需要对数据进行规范化；</li>\n<li>可同时处理数值型，类别型数据；</li>\n<li>是白盒模型，可解释；</li>\n</ul>\n<p>==缺点==：</p>\n<ul>\n<li>容易产生过于复杂的模型 -&gt; 泛化能力差 （剪枝，限制叶节点所需要的最小样本数，最大深度）</li>\n<li>决策树不稳定，微小变化会产生不同的树（集成多棵树可以缓解）</li>\n<li>难学NP问题（启发式学习）</li>\n<li>异或，奇偶，很难被学习到</li>\n</ul>\n"},{"title":"华为软挑2019","date":"2019-04-01T10:19:34.000Z","copyright":null,"_content":"\n# 参加软挑的一些感悟\n## 写在前边的话\n　　\n\n> 我本科一直在做嵌入式相关的项目,这是第一次参加软件类的竞赛,不得不说过程确实很刺激,最后止步杭厦赛区50强也很是遗憾,明明很接近,最后输在了代码效率上,本地成绩很好的 `python代码` ,上传测评运行时间超限（官测环境比本地性能好，普遍情况是用时远超本地，其中华为云主机集体宕机半小时，很多人测过的最优代码，最后再上传就超时了[https://bbs.huaweicloud.com/forum/thread-16237-1-1.html](https://bbs.huaweicloud.com/forum/thread-16237-1-1.html)）。超限原因主要两点，一是自己在实现调度器时的代码臃肿，二是正式赛数据量大增。但进入32强的不少组并没有实现调度器，完全 `随机时间发车+单车路径最优规划` , 感觉很(￣_,￣ )。这比赛不实现调度器，意义少了一半，再用上这种偷鸡方法，没觉出来还有啥意义。唉，菜鸡就是菜鸡。总之，这次经历对我还是有不少积极的影响的，下面就总结一下吧。\n\n\n## 题目解读\n本次比赛主要做的是 `动态路网下多车辆调度问题`, <font color=\"red\"><big>参赛者合理安排数万车辆在合理时间从出发点到达各自的目的地，程序上传至官方服务器，运行后得出 **所有车辆出发时间和规划的路径** ，将在官方调度器中进行调度，完成车辆调度用时即为最终成绩。</big></font>具体是比赛任务书中花了很大篇幅讲了官方调度器的规则，并且论坛前期几乎天天在更新规则补充，最终完全准确实现的队伍只见过一个，其他很对队伍是很接近，但总有差别。我们自己实现的调度器，调度时间完全对的上，但是所有车辆调度总时间总是差了一些。分析原因有以下两点:   \n \n1. 我们实现的调度规则还有与官方一些差异；（但是我们实现的和部分队伍对比的结果完全一致，但和官网就有差异，猜测可能有些规则官方描述的有些差异，或者某细节被我们忽略了）\n2. python 即使版本相同，但是在不同机器上结果确实有差异，这个也被官方证实了[https://bbs.huaweicloud.com/forum/thread-15889-1-1.html](https://bbs.huaweicloud.com/forum/thread-15889-1-1.html)。\n\n总体上参考任务书，下面只简单梳理一下思路（这里默认已经熟悉了任务书）：\n\n下面先附上官方伪代码\n\n        for(/* 按时间片处理 */) {\n\n           foreach(roads) {\n\n                /* 调整所有道路上在道路上的车辆，让道路上车辆前进，只要不出路口且可以到达终止状态的车辆\n                 * 分别标记出来等待的车辆（要出路口的车辆，或者因为要出路口的车辆阻挡而不能前进的车辆）\n                 * 和终止状态的车辆（在该车道内可以经过这一次调度可以行驶其最大可行驶距离的车辆）*/\n                driveAllCarJustOnRoadToEndState(allChannle);/* 对所有车道进行调整 */\n\n                /* driveAllCarJustOnRoadToEndState该处理内的算法与性能自行考虑 */\n           }\n\n            \n            while(/* all car in road run into end state */){\n\n                /* driveAllWaitCar() */\n\n                foreach(crosses){\n\n                    foreach(roads){\n\n\t\t\t\t\t\twhile(/* wait car on the road */){\n\n\t\t\t\t\t\t    Direction dir = getDirection();\n\n\t\t\t\t\t\t    Car car = getCarFromRoad(road, dir);\n\n\t\t\t\t\t\t    if (conflict）{\n\t\t\t\t\t\t    \tbreak;\n\t\t\t\t\t\t    }\n\n\t\t\t    channle = car.getChannel();\n\t\t\t    \n\t\t\t    /* 这里只指因下一道路有等待车辆阻挡而导致该车辆无法进入的情况 */\n\t\t\t    /* 其他情况均返回true,比如下一车道满无法进入（全是终态），或才是下一车道限速不能进入，该车辆停留在其当前车道最前方 */\n\t\t\t    /* 该车辆也是移动至其所在车道最前方，只有有车辆由等待变以终止，就对其车道后续车辆状态进行调整 */\n    \t\t    if(!car.moveToNextRoad()) {\n    \t\t        break;\n    \t\t    }\n\t\t\t    \n\t\t\t    /* driveAllCarJustOnRoadToEndState该处理内的算法与性能自行考虑 */\n\n\t\t\t    driveAllCarJustOnRoadToEndState(channel);\n\t\t\t\t\t}\n\t\t    \t}\n              }\n            }\n\n            /* 车库中的车辆上路行驶 */\n            driveCarInGarage();\n        }\n\n\n\n- 要调度的车辆分两种：<font color=\"red\"><big>路上的车和要上路的车</big></font>\n\n\n- 每个时间片<font color=\"red\">先处理路上车，在处理上路车</font>\n\n\n- 路上的车处理步骤： <font color=\"red\"><big>step1标记状态， step2 移动车辆 </big></font>\n\n\n- 车的状态：每个时间片（一个时间片指的是所有车辆一次调度完成）路上车辆有三种状态，未调度过的车是\t`无状态`， 调度过但是由于阻挡或者其他原因不能移动的车标记为 `等待状态`， 调度过并且完成移动的车标记为 `终态`。\n\n\n- step1: 怎样标记状态？\n\n\n\t- 这个时间片车辆最大行驶速度能超过该道路长度（超过了但不一定就能进入下一条道路），直接标记为`等待状态`\n\t- 这个时间片车辆最大行驶速度不能超过该道路长度，但是前方有车辆挡住自己将要走的路，直接标记为`等待状态`\n\t- 这个时间片车辆最大行驶速度不能超过该道路长度，并且前方没车辆挡住自己，**移动该车**，直接标记为`终止状态`\n\n\n- step2: 按什么顺序调度车辆？\n\n\t- 路上的车：\n\t\t- 处理次序：\n\t\t\t- 按照ID升序反复遍历**路口**，直到所有车辆变成终态\n\t\t\t- 对每个路口，按照ID升序遍历朝向这个路口的**道路**（也反复遍历，直到所有车进入终止状态，或者被阻挡无法移动）\n\t\t\t- 每个道路上有多条线，按照**优先级顺序**处理车辆，只有第一优先级车辆完成调度，才能调度优先级低的车。\n\t\t\t- 不过马路而被标记等待的车，不受优先级限制，阻挡车辆离开，这种车立马跟上\n\t- 上路的车：\n\t\t- 上路车按照ID升序处理\n\t\t- 规划的时间因为前方无空位而未上路的车，顺延到下一时刻优先上路，即不参与下一时刻车辆ID升序发车。\n\n\n- 哪些车参与**优先级**的排序？\n\n\n\t要过马路的车和车速超过当前道路剩余长度，但是根据任务书10-5条，不能进入下一道路的车都参与优先级排序。\n\n大概就这些了，其他更细微的只能遇到才想起来了。\n\n\n## 思路总结\n> 这里只总结一下初赛的思路。\n\n这个比赛就是合理安排车辆调度，以最短时间让所有车都到达终点。所以要找到合适的方法让车辆快速充满道路而不至于 `锁死`,`锁死`也是赛题的最难点。 道路上流动的车越多，越容易出现锁死情况；道路上流动的车越少，最终调度时间就越长。所以优化的目标变成了<font color=\"red\"><big>保证不死锁的情况下，让更多的车在道路上流动起来</big></font>。\n\n### 什么是死锁？\n死锁指的是，某个时间片道路上的车辆由于循环等待（形成了环形等待情况），导致无法再进一步调度任何车辆，导致调度失败，成绩为0。**体现在调度器里**，就是step2 反复调度路口时，等待状态的车辆数量不再减少，即锁死了。\n\n### 怎么避免死锁？\n唯一可以避免的方法是完全实现调度器，和官方调度器一致，就可以准确判断到锁死，并且在规划道路时动态规划新路，解开环形等待的死亡链。可惜大家完全模拟出来调度器的几乎没有（据我一直水群了解到的情况看，是这样，不排除潜水大佬真的实现了）。\n所以呢，大部分人都是想尽办法的尽量减少锁死，无法完全避免，下面会举例几种方法。\n\n### 有不完全正确调度器的解决方案\n\n1. 单车最优路径静态规划 + 遇锁死时对部分车动态规划\n\n      > 如果调度器不太一致时，就当某道路调度同一车辆多次，就给这个车强制规划新路径。\n\n2. 单车最优路径静态规划 + 遇锁死时把锁死车辆从路上删除，未来重新发车\n\n3. 分批次发车 + 每个批次单独规划路径 + 动态路阻 + 锁死车辆动态规划\n\n    > 这个是效果比较好的一种方法，练习赛后期成绩能进入前15名的方法。动态路阻指的是道路情况拥堵，这里选择了几个因素：\n    > \n    > 动态路阻 = 这个批次经过该道路车辆数量*a + abs(道路限速 - 车速)*b + （1 - 道路中路线数/最大线数）*c\n    >  \n    > 路阻每个批次都清除一次，这样在调度器不准确的情况下很大程度上抑制了死锁的发生，当时采用这种方法之后，每个批次发车量明显可以提高很多。这里a，b，c是需要调节的参数。\n\n### 没有调度器的解决方案\n\n如果没实现调度器，也有一些不错的方法，但是不算偷鸡。这里把路网当成计算机的网络，网络的带宽就是道路的线数，我们想让网络传输最大量的数据，但是网络本身承载能力有限制，我们要找到均衡流量的方法，让网络上流动的流量尽可能的均衡，这样再找到合适的参数，即网络最适合的承载车辆数目，保证网络流量不超过这个限制，也可以减少死锁的情况。即 **分批次发车 + 每个批次单独规划路径 + 动态路阻**\n\n### 还有一种不太有意义的方法\n\n这种也被很多人叫做偷鸡方法，就是 **单车路径最优规划 + 随机时间发车**，然后就是调调调。这种方法优势是答案生成快，可以反复调无数次。而实现调度器的同学，基本半小时才能调一次参数，因为模拟调度的过程比较费时间，又加上动态路径规划，时间代价大大提高。\n\n\n### 对单车的寻路算法\n\n想当然的觉得地图是平面的，因为官方给的任务书全是平面图，并且每个路口对应的四个街道都是有方向的，所以对路口直接建立了坐标系，有了每个点的方位坐标信息，也就很自然的选择了A*算法。结果没想到，最后正式赛当天出现的地图是这。。。样。。。的。。。，出现了高空立交桥，这还算直行吗。开始不知道地图变了样子，结果递归建坐标系的部分爆了bug，改了半天，卒了。后来看到群里可视化后的效果是下图，吐血了，赶紧换了Dijkstra算法。这两个算法有时间再总结。\n\n![logo](华为软挑/huawei.jpg)\n\n## 我们组的结果\n\n结果就是止步初赛了，调度器 + 动态规划 + 动态路阻 + 。。。+ python 真是很费时间，本地要15分钟勉强出结果，服务器上直接超时。 放弃了调度器和动态规划， 只用了动态路阻，最后所剩时间不多了，只调了几次参数就到时间了。 \n\n\n## 比赛的经验与教训\n\n1. 比赛运行环境一定要保证和官方一致，不然结果会出现不一致。\n2. 如果还是这种复杂规则的情况，不要再选择python，速度确实有问题，代码能力差的人体现的更明显~、~、\n3. 好好理解题目在行动。\n\n## 感悟\n\n结果有点惨淡，但是这段时间确实收获了很多，也多亏了两位队友的倾力相助，以及师兄的思路指导。郭同学为团队提供了大部分算法上的思路和代码；丁同学从开始比赛到最后一天，也一直在和我讨论着调度以及算法，纠正了我很多错误的理解，比赛的日子也是近段时间来最开心的日子，期待大家下一次的合作。画江湖之绿皮车将要回归。。。\n","source":"_posts/华为软挑.md","raw":"---\ntitle: 华为软挑2019\ndate: 2019-04-01 18:19:34\ncategories: 竞赛\ntags: 华为软挑初赛\ncopyright: \n---\n\n# 参加软挑的一些感悟\n## 写在前边的话\n　　\n\n> 我本科一直在做嵌入式相关的项目,这是第一次参加软件类的竞赛,不得不说过程确实很刺激,最后止步杭厦赛区50强也很是遗憾,明明很接近,最后输在了代码效率上,本地成绩很好的 `python代码` ,上传测评运行时间超限（官测环境比本地性能好，普遍情况是用时远超本地，其中华为云主机集体宕机半小时，很多人测过的最优代码，最后再上传就超时了[https://bbs.huaweicloud.com/forum/thread-16237-1-1.html](https://bbs.huaweicloud.com/forum/thread-16237-1-1.html)）。超限原因主要两点，一是自己在实现调度器时的代码臃肿，二是正式赛数据量大增。但进入32强的不少组并没有实现调度器，完全 `随机时间发车+单车路径最优规划` , 感觉很(￣_,￣ )。这比赛不实现调度器，意义少了一半，再用上这种偷鸡方法，没觉出来还有啥意义。唉，菜鸡就是菜鸡。总之，这次经历对我还是有不少积极的影响的，下面就总结一下吧。\n\n\n## 题目解读\n本次比赛主要做的是 `动态路网下多车辆调度问题`, <font color=\"red\"><big>参赛者合理安排数万车辆在合理时间从出发点到达各自的目的地，程序上传至官方服务器，运行后得出 **所有车辆出发时间和规划的路径** ，将在官方调度器中进行调度，完成车辆调度用时即为最终成绩。</big></font>具体是比赛任务书中花了很大篇幅讲了官方调度器的规则，并且论坛前期几乎天天在更新规则补充，最终完全准确实现的队伍只见过一个，其他很对队伍是很接近，但总有差别。我们自己实现的调度器，调度时间完全对的上，但是所有车辆调度总时间总是差了一些。分析原因有以下两点:   \n \n1. 我们实现的调度规则还有与官方一些差异；（但是我们实现的和部分队伍对比的结果完全一致，但和官网就有差异，猜测可能有些规则官方描述的有些差异，或者某细节被我们忽略了）\n2. python 即使版本相同，但是在不同机器上结果确实有差异，这个也被官方证实了[https://bbs.huaweicloud.com/forum/thread-15889-1-1.html](https://bbs.huaweicloud.com/forum/thread-15889-1-1.html)。\n\n总体上参考任务书，下面只简单梳理一下思路（这里默认已经熟悉了任务书）：\n\n下面先附上官方伪代码\n\n        for(/* 按时间片处理 */) {\n\n           foreach(roads) {\n\n                /* 调整所有道路上在道路上的车辆，让道路上车辆前进，只要不出路口且可以到达终止状态的车辆\n                 * 分别标记出来等待的车辆（要出路口的车辆，或者因为要出路口的车辆阻挡而不能前进的车辆）\n                 * 和终止状态的车辆（在该车道内可以经过这一次调度可以行驶其最大可行驶距离的车辆）*/\n                driveAllCarJustOnRoadToEndState(allChannle);/* 对所有车道进行调整 */\n\n                /* driveAllCarJustOnRoadToEndState该处理内的算法与性能自行考虑 */\n           }\n\n            \n            while(/* all car in road run into end state */){\n\n                /* driveAllWaitCar() */\n\n                foreach(crosses){\n\n                    foreach(roads){\n\n\t\t\t\t\t\twhile(/* wait car on the road */){\n\n\t\t\t\t\t\t    Direction dir = getDirection();\n\n\t\t\t\t\t\t    Car car = getCarFromRoad(road, dir);\n\n\t\t\t\t\t\t    if (conflict）{\n\t\t\t\t\t\t    \tbreak;\n\t\t\t\t\t\t    }\n\n\t\t\t    channle = car.getChannel();\n\t\t\t    \n\t\t\t    /* 这里只指因下一道路有等待车辆阻挡而导致该车辆无法进入的情况 */\n\t\t\t    /* 其他情况均返回true,比如下一车道满无法进入（全是终态），或才是下一车道限速不能进入，该车辆停留在其当前车道最前方 */\n\t\t\t    /* 该车辆也是移动至其所在车道最前方，只有有车辆由等待变以终止，就对其车道后续车辆状态进行调整 */\n    \t\t    if(!car.moveToNextRoad()) {\n    \t\t        break;\n    \t\t    }\n\t\t\t    \n\t\t\t    /* driveAllCarJustOnRoadToEndState该处理内的算法与性能自行考虑 */\n\n\t\t\t    driveAllCarJustOnRoadToEndState(channel);\n\t\t\t\t\t}\n\t\t    \t}\n              }\n            }\n\n            /* 车库中的车辆上路行驶 */\n            driveCarInGarage();\n        }\n\n\n\n- 要调度的车辆分两种：<font color=\"red\"><big>路上的车和要上路的车</big></font>\n\n\n- 每个时间片<font color=\"red\">先处理路上车，在处理上路车</font>\n\n\n- 路上的车处理步骤： <font color=\"red\"><big>step1标记状态， step2 移动车辆 </big></font>\n\n\n- 车的状态：每个时间片（一个时间片指的是所有车辆一次调度完成）路上车辆有三种状态，未调度过的车是\t`无状态`， 调度过但是由于阻挡或者其他原因不能移动的车标记为 `等待状态`， 调度过并且完成移动的车标记为 `终态`。\n\n\n- step1: 怎样标记状态？\n\n\n\t- 这个时间片车辆最大行驶速度能超过该道路长度（超过了但不一定就能进入下一条道路），直接标记为`等待状态`\n\t- 这个时间片车辆最大行驶速度不能超过该道路长度，但是前方有车辆挡住自己将要走的路，直接标记为`等待状态`\n\t- 这个时间片车辆最大行驶速度不能超过该道路长度，并且前方没车辆挡住自己，**移动该车**，直接标记为`终止状态`\n\n\n- step2: 按什么顺序调度车辆？\n\n\t- 路上的车：\n\t\t- 处理次序：\n\t\t\t- 按照ID升序反复遍历**路口**，直到所有车辆变成终态\n\t\t\t- 对每个路口，按照ID升序遍历朝向这个路口的**道路**（也反复遍历，直到所有车进入终止状态，或者被阻挡无法移动）\n\t\t\t- 每个道路上有多条线，按照**优先级顺序**处理车辆，只有第一优先级车辆完成调度，才能调度优先级低的车。\n\t\t\t- 不过马路而被标记等待的车，不受优先级限制，阻挡车辆离开，这种车立马跟上\n\t- 上路的车：\n\t\t- 上路车按照ID升序处理\n\t\t- 规划的时间因为前方无空位而未上路的车，顺延到下一时刻优先上路，即不参与下一时刻车辆ID升序发车。\n\n\n- 哪些车参与**优先级**的排序？\n\n\n\t要过马路的车和车速超过当前道路剩余长度，但是根据任务书10-5条，不能进入下一道路的车都参与优先级排序。\n\n大概就这些了，其他更细微的只能遇到才想起来了。\n\n\n## 思路总结\n> 这里只总结一下初赛的思路。\n\n这个比赛就是合理安排车辆调度，以最短时间让所有车都到达终点。所以要找到合适的方法让车辆快速充满道路而不至于 `锁死`,`锁死`也是赛题的最难点。 道路上流动的车越多，越容易出现锁死情况；道路上流动的车越少，最终调度时间就越长。所以优化的目标变成了<font color=\"red\"><big>保证不死锁的情况下，让更多的车在道路上流动起来</big></font>。\n\n### 什么是死锁？\n死锁指的是，某个时间片道路上的车辆由于循环等待（形成了环形等待情况），导致无法再进一步调度任何车辆，导致调度失败，成绩为0。**体现在调度器里**，就是step2 反复调度路口时，等待状态的车辆数量不再减少，即锁死了。\n\n### 怎么避免死锁？\n唯一可以避免的方法是完全实现调度器，和官方调度器一致，就可以准确判断到锁死，并且在规划道路时动态规划新路，解开环形等待的死亡链。可惜大家完全模拟出来调度器的几乎没有（据我一直水群了解到的情况看，是这样，不排除潜水大佬真的实现了）。\n所以呢，大部分人都是想尽办法的尽量减少锁死，无法完全避免，下面会举例几种方法。\n\n### 有不完全正确调度器的解决方案\n\n1. 单车最优路径静态规划 + 遇锁死时对部分车动态规划\n\n      > 如果调度器不太一致时，就当某道路调度同一车辆多次，就给这个车强制规划新路径。\n\n2. 单车最优路径静态规划 + 遇锁死时把锁死车辆从路上删除，未来重新发车\n\n3. 分批次发车 + 每个批次单独规划路径 + 动态路阻 + 锁死车辆动态规划\n\n    > 这个是效果比较好的一种方法，练习赛后期成绩能进入前15名的方法。动态路阻指的是道路情况拥堵，这里选择了几个因素：\n    > \n    > 动态路阻 = 这个批次经过该道路车辆数量*a + abs(道路限速 - 车速)*b + （1 - 道路中路线数/最大线数）*c\n    >  \n    > 路阻每个批次都清除一次，这样在调度器不准确的情况下很大程度上抑制了死锁的发生，当时采用这种方法之后，每个批次发车量明显可以提高很多。这里a，b，c是需要调节的参数。\n\n### 没有调度器的解决方案\n\n如果没实现调度器，也有一些不错的方法，但是不算偷鸡。这里把路网当成计算机的网络，网络的带宽就是道路的线数，我们想让网络传输最大量的数据，但是网络本身承载能力有限制，我们要找到均衡流量的方法，让网络上流动的流量尽可能的均衡，这样再找到合适的参数，即网络最适合的承载车辆数目，保证网络流量不超过这个限制，也可以减少死锁的情况。即 **分批次发车 + 每个批次单独规划路径 + 动态路阻**\n\n### 还有一种不太有意义的方法\n\n这种也被很多人叫做偷鸡方法，就是 **单车路径最优规划 + 随机时间发车**，然后就是调调调。这种方法优势是答案生成快，可以反复调无数次。而实现调度器的同学，基本半小时才能调一次参数，因为模拟调度的过程比较费时间，又加上动态路径规划，时间代价大大提高。\n\n\n### 对单车的寻路算法\n\n想当然的觉得地图是平面的，因为官方给的任务书全是平面图，并且每个路口对应的四个街道都是有方向的，所以对路口直接建立了坐标系，有了每个点的方位坐标信息，也就很自然的选择了A*算法。结果没想到，最后正式赛当天出现的地图是这。。。样。。。的。。。，出现了高空立交桥，这还算直行吗。开始不知道地图变了样子，结果递归建坐标系的部分爆了bug，改了半天，卒了。后来看到群里可视化后的效果是下图，吐血了，赶紧换了Dijkstra算法。这两个算法有时间再总结。\n\n![logo](华为软挑/huawei.jpg)\n\n## 我们组的结果\n\n结果就是止步初赛了，调度器 + 动态规划 + 动态路阻 + 。。。+ python 真是很费时间，本地要15分钟勉强出结果，服务器上直接超时。 放弃了调度器和动态规划， 只用了动态路阻，最后所剩时间不多了，只调了几次参数就到时间了。 \n\n\n## 比赛的经验与教训\n\n1. 比赛运行环境一定要保证和官方一致，不然结果会出现不一致。\n2. 如果还是这种复杂规则的情况，不要再选择python，速度确实有问题，代码能力差的人体现的更明显~、~、\n3. 好好理解题目在行动。\n\n## 感悟\n\n结果有点惨淡，但是这段时间确实收获了很多，也多亏了两位队友的倾力相助，以及师兄的思路指导。郭同学为团队提供了大部分算法上的思路和代码；丁同学从开始比赛到最后一天，也一直在和我讨论着调度以及算法，纠正了我很多错误的理解，比赛的日子也是近段时间来最开心的日子，期待大家下一次的合作。画江湖之绿皮车将要回归。。。\n","slug":"华为软挑","published":1,"updated":"2020-02-20T04:41:37.820Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephg9002at8plb17f3da8","content":"<h1 id=\"参加软挑的一些感悟\"><a href=\"#参加软挑的一些感悟\" class=\"headerlink\" title=\"参加软挑的一些感悟\"></a>参加软挑的一些感悟</h1><h2 id=\"写在前边的话\"><a href=\"#写在前边的话\" class=\"headerlink\" title=\"写在前边的话\"></a>写在前边的话</h2><p>　　</p>\n<blockquote>\n<p>我本科一直在做嵌入式相关的项目,这是第一次参加软件类的竞赛,不得不说过程确实很刺激,最后止步杭厦赛区50强也很是遗憾,明明很接近,最后输在了代码效率上,本地成绩很好的 <code>python代码</code> ,上传测评运行时间超限（官测环境比本地性能好，普遍情况是用时远超本地，其中华为云主机集体宕机半小时，很多人测过的最优代码，最后再上传就超时了<a href=\"https://bbs.huaweicloud.com/forum/thread-16237-1-1.html\" target=\"_blank\" rel=\"noopener\">https://bbs.huaweicloud.com/forum/thread-16237-1-1.html</a>）。超限原因主要两点，一是自己在实现调度器时的代码臃肿，二是正式赛数据量大增。但进入32强的不少组并没有实现调度器，完全 <code>随机时间发车+单车路径最优规划</code> , 感觉很(￣_,￣ )。这比赛不实现调度器，意义少了一半，再用上这种偷鸡方法，没觉出来还有啥意义。唉，菜鸡就是菜鸡。总之，这次经历对我还是有不少积极的影响的，下面就总结一下吧。</p>\n</blockquote>\n<h2 id=\"题目解读\"><a href=\"#题目解读\" class=\"headerlink\" title=\"题目解读\"></a>题目解读</h2><p>本次比赛主要做的是 <code>动态路网下多车辆调度问题</code>, <font color=\"red\"><big>参赛者合理安排数万车辆在合理时间从出发点到达各自的目的地，程序上传至官方服务器，运行后得出 <strong>所有车辆出发时间和规划的路径</strong> ，将在官方调度器中进行调度，完成车辆调度用时即为最终成绩。</big></font>具体是比赛任务书中花了很大篇幅讲了官方调度器的规则，并且论坛前期几乎天天在更新规则补充，最终完全准确实现的队伍只见过一个，其他很对队伍是很接近，但总有差别。我们自己实现的调度器，调度时间完全对的上，但是所有车辆调度总时间总是差了一些。分析原因有以下两点:   </p>\n<ol>\n<li>我们实现的调度规则还有与官方一些差异；（但是我们实现的和部分队伍对比的结果完全一致，但和官网就有差异，猜测可能有些规则官方描述的有些差异，或者某细节被我们忽略了）</li>\n<li>python 即使版本相同，但是在不同机器上结果确实有差异，这个也被官方证实了<a href=\"https://bbs.huaweicloud.com/forum/thread-15889-1-1.html\" target=\"_blank\" rel=\"noopener\">https://bbs.huaweicloud.com/forum/thread-15889-1-1.html</a>。</li>\n</ol>\n<p>总体上参考任务书，下面只简单梳理一下思路（这里默认已经熟悉了任务书）：</p>\n<p>下面先附上官方伪代码</p>\n<pre><code>    for(/* 按时间片处理 */) {\n\n       foreach(roads) {\n\n            /* 调整所有道路上在道路上的车辆，让道路上车辆前进，只要不出路口且可以到达终止状态的车辆\n             * 分别标记出来等待的车辆（要出路口的车辆，或者因为要出路口的车辆阻挡而不能前进的车辆）\n             * 和终止状态的车辆（在该车道内可以经过这一次调度可以行驶其最大可行驶距离的车辆）*/\n            driveAllCarJustOnRoadToEndState(allChannle);/* 对所有车道进行调整 */\n\n            /* driveAllCarJustOnRoadToEndState该处理内的算法与性能自行考虑 */\n       }\n\n\n        while(/* all car in road run into end state */){\n\n            /* driveAllWaitCar() */\n\n            foreach(crosses){\n\n                foreach(roads){\n\n                    while(/* wait car on the road */){\n\n                        Direction dir = getDirection();\n\n                        Car car = getCarFromRoad(road, dir);\n\n                        if (conflict）{\n                            break;\n                        }\n\n            channle = car.getChannel();\n\n            /* 这里只指因下一道路有等待车辆阻挡而导致该车辆无法进入的情况 */\n            /* 其他情况均返回true,比如下一车道满无法进入（全是终态），或才是下一车道限速不能进入，该车辆停留在其当前车道最前方 */\n            /* 该车辆也是移动至其所在车道最前方，只有有车辆由等待变以终止，就对其车道后续车辆状态进行调整 */\n            if(!car.moveToNextRoad()) {\n                break;\n            }\n\n            /* driveAllCarJustOnRoadToEndState该处理内的算法与性能自行考虑 */\n\n            driveAllCarJustOnRoadToEndState(channel);\n                }\n            }\n          }\n        }\n\n        /* 车库中的车辆上路行驶 */\n        driveCarInGarage();\n    }\n</code></pre><ul>\n<li>要调度的车辆分两种：<font color=\"red\"><big>路上的车和要上路的车</big></font></li>\n</ul>\n<ul>\n<li>每个时间片<font color=\"red\">先处理路上车，在处理上路车</font></li>\n</ul>\n<ul>\n<li>路上的车处理步骤： <font color=\"red\"><big>step1标记状态， step2 移动车辆 </big></font></li>\n</ul>\n<ul>\n<li>车的状态：每个时间片（一个时间片指的是所有车辆一次调度完成）路上车辆有三种状态，未调度过的车是    <code>无状态</code>， 调度过但是由于阻挡或者其他原因不能移动的车标记为 <code>等待状态</code>， 调度过并且完成移动的车标记为 <code>终态</code>。</li>\n</ul>\n<ul>\n<li>step1: 怎样标记状态？</li>\n</ul>\n<pre><code>- 这个时间片车辆最大行驶速度能超过该道路长度（超过了但不一定就能进入下一条道路），直接标记为`等待状态`\n- 这个时间片车辆最大行驶速度不能超过该道路长度，但是前方有车辆挡住自己将要走的路，直接标记为`等待状态`\n- 这个时间片车辆最大行驶速度不能超过该道路长度，并且前方没车辆挡住自己，**移动该车**，直接标记为`终止状态`\n</code></pre><ul>\n<li><p>step2: 按什么顺序调度车辆？</p>\n<ul>\n<li>路上的车：<ul>\n<li>处理次序：<ul>\n<li>按照ID升序反复遍历<strong>路口</strong>，直到所有车辆变成终态</li>\n<li>对每个路口，按照ID升序遍历朝向这个路口的<strong>道路</strong>（也反复遍历，直到所有车进入终止状态，或者被阻挡无法移动）</li>\n<li>每个道路上有多条线，按照<strong>优先级顺序</strong>处理车辆，只有第一优先级车辆完成调度，才能调度优先级低的车。</li>\n<li>不过马路而被标记等待的车，不受优先级限制，阻挡车辆离开，这种车立马跟上</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>上路的车：<ul>\n<li>上路车按照ID升序处理</li>\n<li>规划的时间因为前方无空位而未上路的车，顺延到下一时刻优先上路，即不参与下一时刻车辆ID升序发车。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>哪些车参与<strong>优先级</strong>的排序？</li>\n</ul>\n<pre><code>要过马路的车和车速超过当前道路剩余长度，但是根据任务书10-5条，不能进入下一道路的车都参与优先级排序。\n</code></pre><p>大概就这些了，其他更细微的只能遇到才想起来了。</p>\n<h2 id=\"思路总结\"><a href=\"#思路总结\" class=\"headerlink\" title=\"思路总结\"></a>思路总结</h2><blockquote>\n<p>这里只总结一下初赛的思路。</p>\n</blockquote>\n<p>这个比赛就是合理安排车辆调度，以最短时间让所有车都到达终点。所以要找到合适的方法让车辆快速充满道路而不至于 <code>锁死</code>,<code>锁死</code>也是赛题的最难点。 道路上流动的车越多，越容易出现锁死情况；道路上流动的车越少，最终调度时间就越长。所以优化的目标变成了<font color=\"red\"><big>保证不死锁的情况下，让更多的车在道路上流动起来</big></font>。</p>\n<h3 id=\"什么是死锁？\"><a href=\"#什么是死锁？\" class=\"headerlink\" title=\"什么是死锁？\"></a>什么是死锁？</h3><p>死锁指的是，某个时间片道路上的车辆由于循环等待（形成了环形等待情况），导致无法再进一步调度任何车辆，导致调度失败，成绩为0。<strong>体现在调度器里</strong>，就是step2 反复调度路口时，等待状态的车辆数量不再减少，即锁死了。</p>\n<h3 id=\"怎么避免死锁？\"><a href=\"#怎么避免死锁？\" class=\"headerlink\" title=\"怎么避免死锁？\"></a>怎么避免死锁？</h3><p>唯一可以避免的方法是完全实现调度器，和官方调度器一致，就可以准确判断到锁死，并且在规划道路时动态规划新路，解开环形等待的死亡链。可惜大家完全模拟出来调度器的几乎没有（据我一直水群了解到的情况看，是这样，不排除潜水大佬真的实现了）。<br>所以呢，大部分人都是想尽办法的尽量减少锁死，无法完全避免，下面会举例几种方法。</p>\n<h3 id=\"有不完全正确调度器的解决方案\"><a href=\"#有不完全正确调度器的解决方案\" class=\"headerlink\" title=\"有不完全正确调度器的解决方案\"></a>有不完全正确调度器的解决方案</h3><ol>\n<li><p>单车最优路径静态规划 + 遇锁死时对部分车动态规划</p>\n<blockquote>\n<p>如果调度器不太一致时，就当某道路调度同一车辆多次，就给这个车强制规划新路径。</p>\n</blockquote>\n</li>\n<li><p>单车最优路径静态规划 + 遇锁死时把锁死车辆从路上删除，未来重新发车</p>\n</li>\n<li><p>分批次发车 + 每个批次单独规划路径 + 动态路阻 + 锁死车辆动态规划</p>\n<blockquote>\n<p>这个是效果比较好的一种方法，练习赛后期成绩能进入前15名的方法。动态路阻指的是道路情况拥堵，这里选择了几个因素：</p>\n<p>动态路阻 = 这个批次经过该道路车辆数量<em>a + abs(道路限速 - 车速)</em>b + （1 - 道路中路线数/最大线数）*c</p>\n<p>路阻每个批次都清除一次，这样在调度器不准确的情况下很大程度上抑制了死锁的发生，当时采用这种方法之后，每个批次发车量明显可以提高很多。这里a，b，c是需要调节的参数。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"没有调度器的解决方案\"><a href=\"#没有调度器的解决方案\" class=\"headerlink\" title=\"没有调度器的解决方案\"></a>没有调度器的解决方案</h3><p>如果没实现调度器，也有一些不错的方法，但是不算偷鸡。这里把路网当成计算机的网络，网络的带宽就是道路的线数，我们想让网络传输最大量的数据，但是网络本身承载能力有限制，我们要找到均衡流量的方法，让网络上流动的流量尽可能的均衡，这样再找到合适的参数，即网络最适合的承载车辆数目，保证网络流量不超过这个限制，也可以减少死锁的情况。即 <strong>分批次发车 + 每个批次单独规划路径 + 动态路阻</strong></p>\n<h3 id=\"还有一种不太有意义的方法\"><a href=\"#还有一种不太有意义的方法\" class=\"headerlink\" title=\"还有一种不太有意义的方法\"></a>还有一种不太有意义的方法</h3><p>这种也被很多人叫做偷鸡方法，就是 <strong>单车路径最优规划 + 随机时间发车</strong>，然后就是调调调。这种方法优势是答案生成快，可以反复调无数次。而实现调度器的同学，基本半小时才能调一次参数，因为模拟调度的过程比较费时间，又加上动态路径规划，时间代价大大提高。</p>\n<h3 id=\"对单车的寻路算法\"><a href=\"#对单车的寻路算法\" class=\"headerlink\" title=\"对单车的寻路算法\"></a>对单车的寻路算法</h3><p>想当然的觉得地图是平面的，因为官方给的任务书全是平面图，并且每个路口对应的四个街道都是有方向的，所以对路口直接建立了坐标系，有了每个点的方位坐标信息，也就很自然的选择了A*算法。结果没想到，最后正式赛当天出现的地图是这。。。样。。。的。。。，出现了高空立交桥，这还算直行吗。开始不知道地图变了样子，结果递归建坐标系的部分爆了bug，改了半天，卒了。后来看到群里可视化后的效果是下图，吐血了，赶紧换了Dijkstra算法。这两个算法有时间再总结。</p>\n<p><img src=\"/2019/04/01/华为软挑/huawei.jpg\" alt=\"logo\"></p>\n<h2 id=\"我们组的结果\"><a href=\"#我们组的结果\" class=\"headerlink\" title=\"我们组的结果\"></a>我们组的结果</h2><p>结果就是止步初赛了，调度器 + 动态规划 + 动态路阻 + 。。。+ python 真是很费时间，本地要15分钟勉强出结果，服务器上直接超时。 放弃了调度器和动态规划， 只用了动态路阻，最后所剩时间不多了，只调了几次参数就到时间了。 </p>\n<h2 id=\"比赛的经验与教训\"><a href=\"#比赛的经验与教训\" class=\"headerlink\" title=\"比赛的经验与教训\"></a>比赛的经验与教训</h2><ol>\n<li>比赛运行环境一定要保证和官方一致，不然结果会出现不一致。</li>\n<li>如果还是这种复杂规则的情况，不要再选择python，速度确实有问题，代码能力差的人体现的更明显~、~、</li>\n<li>好好理解题目在行动。</li>\n</ol>\n<h2 id=\"感悟\"><a href=\"#感悟\" class=\"headerlink\" title=\"感悟\"></a>感悟</h2><p>结果有点惨淡，但是这段时间确实收获了很多，也多亏了两位队友的倾力相助，以及师兄的思路指导。郭同学为团队提供了大部分算法上的思路和代码；丁同学从开始比赛到最后一天，也一直在和我讨论着调度以及算法，纠正了我很多错误的理解，比赛的日子也是近段时间来最开心的日子，期待大家下一次的合作。画江湖之绿皮车将要回归。。。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"参加软挑的一些感悟\"><a href=\"#参加软挑的一些感悟\" class=\"headerlink\" title=\"参加软挑的一些感悟\"></a>参加软挑的一些感悟</h1><h2 id=\"写在前边的话\"><a href=\"#写在前边的话\" class=\"headerlink\" title=\"写在前边的话\"></a>写在前边的话</h2><p>　　</p>\n<blockquote>\n<p>我本科一直在做嵌入式相关的项目,这是第一次参加软件类的竞赛,不得不说过程确实很刺激,最后止步杭厦赛区50强也很是遗憾,明明很接近,最后输在了代码效率上,本地成绩很好的 <code>python代码</code> ,上传测评运行时间超限（官测环境比本地性能好，普遍情况是用时远超本地，其中华为云主机集体宕机半小时，很多人测过的最优代码，最后再上传就超时了<a href=\"https://bbs.huaweicloud.com/forum/thread-16237-1-1.html\" target=\"_blank\" rel=\"noopener\">https://bbs.huaweicloud.com/forum/thread-16237-1-1.html</a>）。超限原因主要两点，一是自己在实现调度器时的代码臃肿，二是正式赛数据量大增。但进入32强的不少组并没有实现调度器，完全 <code>随机时间发车+单车路径最优规划</code> , 感觉很(￣_,￣ )。这比赛不实现调度器，意义少了一半，再用上这种偷鸡方法，没觉出来还有啥意义。唉，菜鸡就是菜鸡。总之，这次经历对我还是有不少积极的影响的，下面就总结一下吧。</p>\n</blockquote>\n<h2 id=\"题目解读\"><a href=\"#题目解读\" class=\"headerlink\" title=\"题目解读\"></a>题目解读</h2><p>本次比赛主要做的是 <code>动态路网下多车辆调度问题</code>, <font color=\"red\"><big>参赛者合理安排数万车辆在合理时间从出发点到达各自的目的地，程序上传至官方服务器，运行后得出 <strong>所有车辆出发时间和规划的路径</strong> ，将在官方调度器中进行调度，完成车辆调度用时即为最终成绩。</big></font>具体是比赛任务书中花了很大篇幅讲了官方调度器的规则，并且论坛前期几乎天天在更新规则补充，最终完全准确实现的队伍只见过一个，其他很对队伍是很接近，但总有差别。我们自己实现的调度器，调度时间完全对的上，但是所有车辆调度总时间总是差了一些。分析原因有以下两点:   </p>\n<ol>\n<li>我们实现的调度规则还有与官方一些差异；（但是我们实现的和部分队伍对比的结果完全一致，但和官网就有差异，猜测可能有些规则官方描述的有些差异，或者某细节被我们忽略了）</li>\n<li>python 即使版本相同，但是在不同机器上结果确实有差异，这个也被官方证实了<a href=\"https://bbs.huaweicloud.com/forum/thread-15889-1-1.html\" target=\"_blank\" rel=\"noopener\">https://bbs.huaweicloud.com/forum/thread-15889-1-1.html</a>。</li>\n</ol>\n<p>总体上参考任务书，下面只简单梳理一下思路（这里默认已经熟悉了任务书）：</p>\n<p>下面先附上官方伪代码</p>\n<pre><code>    for(/* 按时间片处理 */) {\n\n       foreach(roads) {\n\n            /* 调整所有道路上在道路上的车辆，让道路上车辆前进，只要不出路口且可以到达终止状态的车辆\n             * 分别标记出来等待的车辆（要出路口的车辆，或者因为要出路口的车辆阻挡而不能前进的车辆）\n             * 和终止状态的车辆（在该车道内可以经过这一次调度可以行驶其最大可行驶距离的车辆）*/\n            driveAllCarJustOnRoadToEndState(allChannle);/* 对所有车道进行调整 */\n\n            /* driveAllCarJustOnRoadToEndState该处理内的算法与性能自行考虑 */\n       }\n\n\n        while(/* all car in road run into end state */){\n\n            /* driveAllWaitCar() */\n\n            foreach(crosses){\n\n                foreach(roads){\n\n                    while(/* wait car on the road */){\n\n                        Direction dir = getDirection();\n\n                        Car car = getCarFromRoad(road, dir);\n\n                        if (conflict）{\n                            break;\n                        }\n\n            channle = car.getChannel();\n\n            /* 这里只指因下一道路有等待车辆阻挡而导致该车辆无法进入的情况 */\n            /* 其他情况均返回true,比如下一车道满无法进入（全是终态），或才是下一车道限速不能进入，该车辆停留在其当前车道最前方 */\n            /* 该车辆也是移动至其所在车道最前方，只有有车辆由等待变以终止，就对其车道后续车辆状态进行调整 */\n            if(!car.moveToNextRoad()) {\n                break;\n            }\n\n            /* driveAllCarJustOnRoadToEndState该处理内的算法与性能自行考虑 */\n\n            driveAllCarJustOnRoadToEndState(channel);\n                }\n            }\n          }\n        }\n\n        /* 车库中的车辆上路行驶 */\n        driveCarInGarage();\n    }\n</code></pre><ul>\n<li>要调度的车辆分两种：<font color=\"red\"><big>路上的车和要上路的车</big></font></li>\n</ul>\n<ul>\n<li>每个时间片<font color=\"red\">先处理路上车，在处理上路车</font></li>\n</ul>\n<ul>\n<li>路上的车处理步骤： <font color=\"red\"><big>step1标记状态， step2 移动车辆 </big></font></li>\n</ul>\n<ul>\n<li>车的状态：每个时间片（一个时间片指的是所有车辆一次调度完成）路上车辆有三种状态，未调度过的车是    <code>无状态</code>， 调度过但是由于阻挡或者其他原因不能移动的车标记为 <code>等待状态</code>， 调度过并且完成移动的车标记为 <code>终态</code>。</li>\n</ul>\n<ul>\n<li>step1: 怎样标记状态？</li>\n</ul>\n<pre><code>- 这个时间片车辆最大行驶速度能超过该道路长度（超过了但不一定就能进入下一条道路），直接标记为`等待状态`\n- 这个时间片车辆最大行驶速度不能超过该道路长度，但是前方有车辆挡住自己将要走的路，直接标记为`等待状态`\n- 这个时间片车辆最大行驶速度不能超过该道路长度，并且前方没车辆挡住自己，**移动该车**，直接标记为`终止状态`\n</code></pre><ul>\n<li><p>step2: 按什么顺序调度车辆？</p>\n<ul>\n<li>路上的车：<ul>\n<li>处理次序：<ul>\n<li>按照ID升序反复遍历<strong>路口</strong>，直到所有车辆变成终态</li>\n<li>对每个路口，按照ID升序遍历朝向这个路口的<strong>道路</strong>（也反复遍历，直到所有车进入终止状态，或者被阻挡无法移动）</li>\n<li>每个道路上有多条线，按照<strong>优先级顺序</strong>处理车辆，只有第一优先级车辆完成调度，才能调度优先级低的车。</li>\n<li>不过马路而被标记等待的车，不受优先级限制，阻挡车辆离开，这种车立马跟上</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>上路的车：<ul>\n<li>上路车按照ID升序处理</li>\n<li>规划的时间因为前方无空位而未上路的车，顺延到下一时刻优先上路，即不参与下一时刻车辆ID升序发车。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>哪些车参与<strong>优先级</strong>的排序？</li>\n</ul>\n<pre><code>要过马路的车和车速超过当前道路剩余长度，但是根据任务书10-5条，不能进入下一道路的车都参与优先级排序。\n</code></pre><p>大概就这些了，其他更细微的只能遇到才想起来了。</p>\n<h2 id=\"思路总结\"><a href=\"#思路总结\" class=\"headerlink\" title=\"思路总结\"></a>思路总结</h2><blockquote>\n<p>这里只总结一下初赛的思路。</p>\n</blockquote>\n<p>这个比赛就是合理安排车辆调度，以最短时间让所有车都到达终点。所以要找到合适的方法让车辆快速充满道路而不至于 <code>锁死</code>,<code>锁死</code>也是赛题的最难点。 道路上流动的车越多，越容易出现锁死情况；道路上流动的车越少，最终调度时间就越长。所以优化的目标变成了<font color=\"red\"><big>保证不死锁的情况下，让更多的车在道路上流动起来</big></font>。</p>\n<h3 id=\"什么是死锁？\"><a href=\"#什么是死锁？\" class=\"headerlink\" title=\"什么是死锁？\"></a>什么是死锁？</h3><p>死锁指的是，某个时间片道路上的车辆由于循环等待（形成了环形等待情况），导致无法再进一步调度任何车辆，导致调度失败，成绩为0。<strong>体现在调度器里</strong>，就是step2 反复调度路口时，等待状态的车辆数量不再减少，即锁死了。</p>\n<h3 id=\"怎么避免死锁？\"><a href=\"#怎么避免死锁？\" class=\"headerlink\" title=\"怎么避免死锁？\"></a>怎么避免死锁？</h3><p>唯一可以避免的方法是完全实现调度器，和官方调度器一致，就可以准确判断到锁死，并且在规划道路时动态规划新路，解开环形等待的死亡链。可惜大家完全模拟出来调度器的几乎没有（据我一直水群了解到的情况看，是这样，不排除潜水大佬真的实现了）。<br>所以呢，大部分人都是想尽办法的尽量减少锁死，无法完全避免，下面会举例几种方法。</p>\n<h3 id=\"有不完全正确调度器的解决方案\"><a href=\"#有不完全正确调度器的解决方案\" class=\"headerlink\" title=\"有不完全正确调度器的解决方案\"></a>有不完全正确调度器的解决方案</h3><ol>\n<li><p>单车最优路径静态规划 + 遇锁死时对部分车动态规划</p>\n<blockquote>\n<p>如果调度器不太一致时，就当某道路调度同一车辆多次，就给这个车强制规划新路径。</p>\n</blockquote>\n</li>\n<li><p>单车最优路径静态规划 + 遇锁死时把锁死车辆从路上删除，未来重新发车</p>\n</li>\n<li><p>分批次发车 + 每个批次单独规划路径 + 动态路阻 + 锁死车辆动态规划</p>\n<blockquote>\n<p>这个是效果比较好的一种方法，练习赛后期成绩能进入前15名的方法。动态路阻指的是道路情况拥堵，这里选择了几个因素：</p>\n<p>动态路阻 = 这个批次经过该道路车辆数量<em>a + abs(道路限速 - 车速)</em>b + （1 - 道路中路线数/最大线数）*c</p>\n<p>路阻每个批次都清除一次，这样在调度器不准确的情况下很大程度上抑制了死锁的发生，当时采用这种方法之后，每个批次发车量明显可以提高很多。这里a，b，c是需要调节的参数。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"没有调度器的解决方案\"><a href=\"#没有调度器的解决方案\" class=\"headerlink\" title=\"没有调度器的解决方案\"></a>没有调度器的解决方案</h3><p>如果没实现调度器，也有一些不错的方法，但是不算偷鸡。这里把路网当成计算机的网络，网络的带宽就是道路的线数，我们想让网络传输最大量的数据，但是网络本身承载能力有限制，我们要找到均衡流量的方法，让网络上流动的流量尽可能的均衡，这样再找到合适的参数，即网络最适合的承载车辆数目，保证网络流量不超过这个限制，也可以减少死锁的情况。即 <strong>分批次发车 + 每个批次单独规划路径 + 动态路阻</strong></p>\n<h3 id=\"还有一种不太有意义的方法\"><a href=\"#还有一种不太有意义的方法\" class=\"headerlink\" title=\"还有一种不太有意义的方法\"></a>还有一种不太有意义的方法</h3><p>这种也被很多人叫做偷鸡方法，就是 <strong>单车路径最优规划 + 随机时间发车</strong>，然后就是调调调。这种方法优势是答案生成快，可以反复调无数次。而实现调度器的同学，基本半小时才能调一次参数，因为模拟调度的过程比较费时间，又加上动态路径规划，时间代价大大提高。</p>\n<h3 id=\"对单车的寻路算法\"><a href=\"#对单车的寻路算法\" class=\"headerlink\" title=\"对单车的寻路算法\"></a>对单车的寻路算法</h3><p>想当然的觉得地图是平面的，因为官方给的任务书全是平面图，并且每个路口对应的四个街道都是有方向的，所以对路口直接建立了坐标系，有了每个点的方位坐标信息，也就很自然的选择了A*算法。结果没想到，最后正式赛当天出现的地图是这。。。样。。。的。。。，出现了高空立交桥，这还算直行吗。开始不知道地图变了样子，结果递归建坐标系的部分爆了bug，改了半天，卒了。后来看到群里可视化后的效果是下图，吐血了，赶紧换了Dijkstra算法。这两个算法有时间再总结。</p>\n<p><img src=\"/2019/04/01/华为软挑/huawei.jpg\" alt=\"logo\"></p>\n<h2 id=\"我们组的结果\"><a href=\"#我们组的结果\" class=\"headerlink\" title=\"我们组的结果\"></a>我们组的结果</h2><p>结果就是止步初赛了，调度器 + 动态规划 + 动态路阻 + 。。。+ python 真是很费时间，本地要15分钟勉强出结果，服务器上直接超时。 放弃了调度器和动态规划， 只用了动态路阻，最后所剩时间不多了，只调了几次参数就到时间了。 </p>\n<h2 id=\"比赛的经验与教训\"><a href=\"#比赛的经验与教训\" class=\"headerlink\" title=\"比赛的经验与教训\"></a>比赛的经验与教训</h2><ol>\n<li>比赛运行环境一定要保证和官方一致，不然结果会出现不一致。</li>\n<li>如果还是这种复杂规则的情况，不要再选择python，速度确实有问题，代码能力差的人体现的更明显~、~、</li>\n<li>好好理解题目在行动。</li>\n</ol>\n<h2 id=\"感悟\"><a href=\"#感悟\" class=\"headerlink\" title=\"感悟\"></a>感悟</h2><p>结果有点惨淡，但是这段时间确实收获了很多，也多亏了两位队友的倾力相助，以及师兄的思路指导。郭同学为团队提供了大部分算法上的思路和代码；丁同学从开始比赛到最后一天，也一直在和我讨论着调度以及算法，纠正了我很多错误的理解，比赛的日子也是近段时间来最开心的日子，期待大家下一次的合作。画江湖之绿皮车将要回归。。。</p>\n"},{"title":"蓄水池抽样算法","date":"2020-04-19T09:18:21.000Z","_content":"\n# 一、预备知识\n\nJava 随机数生成的方法：\n\n`java.util.Random`\n\n\n```java\n/*\n  Main.java \n*/\npublic class Main {\n\n    public static void main(String[] args) {\n\n        // 指定随机种子，默认以时间为种子\n        Random random = new Random(2048);\n\n        // 生成 0 ~ 99 之间的整数\n        System.out.println( random.nextInt(100));\n\n        // 生成 0 ~ 1.0 之间的小数\n        System.out.println( random.nextDouble());\n\n        // 生成 布尔\n        System.out.println( random.nextBoolean());\n\n    }\n}\n\n```\n\n\n\n# 二、海量数据随机采样K个的需求\n\n从固定区间内随机采样数据十分简单，直接调用 `random.nextInt()` 就可以。\n\n**但如果是长度未知的海量数据流呢？该如何实现等概率采样？**\n\n​\t\t答：蓄水池采样算法就是一种解决方案。\n\n\n\n# 三、实现原理（从未知长度的海量数据随机采样K个元素）\n\n## 3.1 **举例说明：从未知流中随机选择一个元素(K = 1)的实现方法**\n\n- **当数据流中只有一个数据**：\n    - 直接返回该数据\n- **当数据流中有两个数据**：\n    - D0，D1 中随机选择一个。 概率均为 1/2\n- **当数据流中有三个数据**\n    - Step1 : 处理 D0, D1 时 先保留一个，概率分别为 1/2\n    - Step2 :处理 D3 时, 1/3 的概率保留D3, 1 - 1/3 的概率保留 Step1 中的结果\n- **递推下去**      \n\n\n## 3.2 **解析：假设流的长度只有3**\n\n数据 D1 被采样概率：（1/2）* (2/3) = 1/3\n数据 D2 被采样概率：（1/2）*(2/3) = 1/3\n数据 D3 被采样概率：  1/3\n\n\n## 3.3 算法描述\n\n- 先选取数据流中的前k个元素，保存在池子pool中；\n- 从第j（k + 1 <= j <= n）个元素开始\n    - 每次先以概率 p = k/j选择是否让第j个元素留下；\n        - 若j被选中，则从A中随机选择一个元素并用该元素j替换它\n        - 否则直接淘汰该元素；\n- 重复步骤2直到结束，最后集合A中剩下的就是保证随机抽取的k个元素。\n\n# 四、代码\n\n\n```\n    private int[] sampling(int K) {\n        int[] pool = new int[K];\n        \n        // 前 K 个元素直接放入数组中\n        for (int i = 0; i < K; i++) { \n            pool[i] = stream[i];\n        }\n\n        for (int i = K; i < N; i++) { // K + 1 个元素开始进行概率采样\n            int r = random.nextInt(i + 1);\n            // 这里其实就是k/j的体现\n            if (r < K) {\n                pool[r] = stream[i];\n            }\n        }\n\n        return pool;\n    }\n\n```\n\n\n\n# 五、leetcode 题目：\n\n[T1. 随机数索引](https://leetcode-cn.com/problems/random-pick-index/)\n\n```java\n/*\n\n 蓄水池算法：\n    只对重复值采用蓄水池算法\n    出现次数     概率\n    1            1\n    2            1/2\n    3            1/3\n    4            1/4\n*/\nclass Solution {\n\n    private int[] nums;\n    public Solution(int[] nums) {\n        this.nums = nums;\n    }\n    \n    public int pick(int target) {\n        int index = getIndex(nums, target);\n        return index;\n    }\n\n    private int getIndex(int[] nums, int target){\n        // 统计出现的次数\n        int count = 0;\n        int index = -1;\n\n        Random random = new Random();\n\n        for (int i = 0; i < nums.length; i++){\n\n            if (target == nums[i]){\n                \n                if (index == -1){\n                    index = i;\n                    continue;\n                }\n                count += 1;\n\n                int r = random.nextInt(count + 1);\n\n                if (r == 0){\n                    index = i;\n                }\n            \n            }\n        }\n\n        return index;\n    }\n}\n```\n\n\n\n\n[T2. 链表中随机选择节点](https://leetcode-cn.com/problems/linked-list-random-node/)\n\n```java\nclass Solution {\n\n    /** @param head The linked list's head.\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\n    private ListNode head;    \n    public Solution(ListNode head) {\n        this.head = head;\n    }\n    \n    /** Returns a random node's value. */\n    public int getRandom() {\n        int count = 0;\n        ListNode now = head;\n        int ret = -1;\n        Random random = new Random();\n\n        while (now != null){\n            \n            count += 1;\n\n            if (ret == -1){\n                \n                ret = now.val;\n                now = now.next;\n                continue;\n            }\n            int rm = random.nextInt(count );\n\n\n            if (rm == 0){\n                ret =  now.val;\n            }\n\n            now = now.next;\n            \n\n        }\n\n        return ret;\n    }\n}\n\n```\n\n","source":"_posts/蓄水池抽样算法.md","raw":"---\ntitle: 蓄水池抽样算法\ndate: 2020-04-19 17:18:21\ncategories: 算法与数据结构\ntags: 蓄水池抽样算法 海量数据随机采样\n---\n\n# 一、预备知识\n\nJava 随机数生成的方法：\n\n`java.util.Random`\n\n\n```java\n/*\n  Main.java \n*/\npublic class Main {\n\n    public static void main(String[] args) {\n\n        // 指定随机种子，默认以时间为种子\n        Random random = new Random(2048);\n\n        // 生成 0 ~ 99 之间的整数\n        System.out.println( random.nextInt(100));\n\n        // 生成 0 ~ 1.0 之间的小数\n        System.out.println( random.nextDouble());\n\n        // 生成 布尔\n        System.out.println( random.nextBoolean());\n\n    }\n}\n\n```\n\n\n\n# 二、海量数据随机采样K个的需求\n\n从固定区间内随机采样数据十分简单，直接调用 `random.nextInt()` 就可以。\n\n**但如果是长度未知的海量数据流呢？该如何实现等概率采样？**\n\n​\t\t答：蓄水池采样算法就是一种解决方案。\n\n\n\n# 三、实现原理（从未知长度的海量数据随机采样K个元素）\n\n## 3.1 **举例说明：从未知流中随机选择一个元素(K = 1)的实现方法**\n\n- **当数据流中只有一个数据**：\n    - 直接返回该数据\n- **当数据流中有两个数据**：\n    - D0，D1 中随机选择一个。 概率均为 1/2\n- **当数据流中有三个数据**\n    - Step1 : 处理 D0, D1 时 先保留一个，概率分别为 1/2\n    - Step2 :处理 D3 时, 1/3 的概率保留D3, 1 - 1/3 的概率保留 Step1 中的结果\n- **递推下去**      \n\n\n## 3.2 **解析：假设流的长度只有3**\n\n数据 D1 被采样概率：（1/2）* (2/3) = 1/3\n数据 D2 被采样概率：（1/2）*(2/3) = 1/3\n数据 D3 被采样概率：  1/3\n\n\n## 3.3 算法描述\n\n- 先选取数据流中的前k个元素，保存在池子pool中；\n- 从第j（k + 1 <= j <= n）个元素开始\n    - 每次先以概率 p = k/j选择是否让第j个元素留下；\n        - 若j被选中，则从A中随机选择一个元素并用该元素j替换它\n        - 否则直接淘汰该元素；\n- 重复步骤2直到结束，最后集合A中剩下的就是保证随机抽取的k个元素。\n\n# 四、代码\n\n\n```\n    private int[] sampling(int K) {\n        int[] pool = new int[K];\n        \n        // 前 K 个元素直接放入数组中\n        for (int i = 0; i < K; i++) { \n            pool[i] = stream[i];\n        }\n\n        for (int i = K; i < N; i++) { // K + 1 个元素开始进行概率采样\n            int r = random.nextInt(i + 1);\n            // 这里其实就是k/j的体现\n            if (r < K) {\n                pool[r] = stream[i];\n            }\n        }\n\n        return pool;\n    }\n\n```\n\n\n\n# 五、leetcode 题目：\n\n[T1. 随机数索引](https://leetcode-cn.com/problems/random-pick-index/)\n\n```java\n/*\n\n 蓄水池算法：\n    只对重复值采用蓄水池算法\n    出现次数     概率\n    1            1\n    2            1/2\n    3            1/3\n    4            1/4\n*/\nclass Solution {\n\n    private int[] nums;\n    public Solution(int[] nums) {\n        this.nums = nums;\n    }\n    \n    public int pick(int target) {\n        int index = getIndex(nums, target);\n        return index;\n    }\n\n    private int getIndex(int[] nums, int target){\n        // 统计出现的次数\n        int count = 0;\n        int index = -1;\n\n        Random random = new Random();\n\n        for (int i = 0; i < nums.length; i++){\n\n            if (target == nums[i]){\n                \n                if (index == -1){\n                    index = i;\n                    continue;\n                }\n                count += 1;\n\n                int r = random.nextInt(count + 1);\n\n                if (r == 0){\n                    index = i;\n                }\n            \n            }\n        }\n\n        return index;\n    }\n}\n```\n\n\n\n\n[T2. 链表中随机选择节点](https://leetcode-cn.com/problems/linked-list-random-node/)\n\n```java\nclass Solution {\n\n    /** @param head The linked list's head.\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\n    private ListNode head;    \n    public Solution(ListNode head) {\n        this.head = head;\n    }\n    \n    /** Returns a random node's value. */\n    public int getRandom() {\n        int count = 0;\n        ListNode now = head;\n        int ret = -1;\n        Random random = new Random();\n\n        while (now != null){\n            \n            count += 1;\n\n            if (ret == -1){\n                \n                ret = now.val;\n                now = now.next;\n                continue;\n            }\n            int rm = random.nextInt(count );\n\n\n            if (rm == 0){\n                ret =  now.val;\n            }\n\n            now = now.next;\n            \n\n        }\n\n        return ret;\n    }\n}\n\n```\n\n","slug":"蓄水池抽样算法","published":1,"updated":"2020-04-21T01:52:30.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephgc002dt8pl6eirnbnw","content":"<h1 id=\"一、预备知识\"><a href=\"#一、预备知识\" class=\"headerlink\" title=\"一、预备知识\"></a>一、预备知识</h1><p>Java 随机数生成的方法：</p>\n<p><code>java.util.Random</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  Main.java </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 指定随机种子，默认以时间为种子</span></span><br><span class=\"line\">        Random random = <span class=\"keyword\">new</span> Random(<span class=\"number\">2048</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 生成 0 ~ 99 之间的整数</span></span><br><span class=\"line\">        System.out.println( random.nextInt(<span class=\"number\">100</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 生成 0 ~ 1.0 之间的小数</span></span><br><span class=\"line\">        System.out.println( random.nextDouble());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 生成 布尔</span></span><br><span class=\"line\">        System.out.println( random.nextBoolean());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"二、海量数据随机采样K个的需求\"><a href=\"#二、海量数据随机采样K个的需求\" class=\"headerlink\" title=\"二、海量数据随机采样K个的需求\"></a>二、海量数据随机采样K个的需求</h1><p>从固定区间内随机采样数据十分简单，直接调用 <code>random.nextInt()</code> 就可以。</p>\n<p><strong>但如果是长度未知的海量数据流呢？该如何实现等概率采样？</strong></p>\n<p>​        答：蓄水池采样算法就是一种解决方案。</p>\n<h1 id=\"三、实现原理（从未知长度的海量数据随机采样K个元素）\"><a href=\"#三、实现原理（从未知长度的海量数据随机采样K个元素）\" class=\"headerlink\" title=\"三、实现原理（从未知长度的海量数据随机采样K个元素）\"></a>三、实现原理（从未知长度的海量数据随机采样K个元素）</h1><h2 id=\"3-1-举例说明：从未知流中随机选择一个元素-K-1-的实现方法\"><a href=\"#3-1-举例说明：从未知流中随机选择一个元素-K-1-的实现方法\" class=\"headerlink\" title=\"3.1 举例说明：从未知流中随机选择一个元素(K = 1)的实现方法\"></a>3.1 <strong>举例说明：从未知流中随机选择一个元素(K = 1)的实现方法</strong></h2><ul>\n<li><strong>当数据流中只有一个数据</strong>：<ul>\n<li>直接返回该数据</li>\n</ul>\n</li>\n<li><strong>当数据流中有两个数据</strong>：<ul>\n<li>D0，D1 中随机选择一个。 概率均为 1/2</li>\n</ul>\n</li>\n<li><strong>当数据流中有三个数据</strong><ul>\n<li>Step1 : 处理 D0, D1 时 先保留一个，概率分别为 1/2</li>\n<li>Step2 :处理 D3 时, 1/3 的概率保留D3, 1 - 1/3 的概率保留 Step1 中的结果</li>\n</ul>\n</li>\n<li><strong>递推下去</strong>      </li>\n</ul>\n<h2 id=\"3-2-解析：假设流的长度只有3\"><a href=\"#3-2-解析：假设流的长度只有3\" class=\"headerlink\" title=\"3.2 解析：假设流的长度只有3\"></a>3.2 <strong>解析：假设流的长度只有3</strong></h2><p>数据 D1 被采样概率：（1/2）<em> (2/3) = 1/3<br>数据 D2 被采样概率：（1/2）</em>(2/3) = 1/3<br>数据 D3 被采样概率：  1/3</p>\n<h2 id=\"3-3-算法描述\"><a href=\"#3-3-算法描述\" class=\"headerlink\" title=\"3.3 算法描述\"></a>3.3 算法描述</h2><ul>\n<li>先选取数据流中的前k个元素，保存在池子pool中；</li>\n<li>从第j（k + 1 &lt;= j &lt;= n）个元素开始<ul>\n<li>每次先以概率 p = k/j选择是否让第j个元素留下；<ul>\n<li>若j被选中，则从A中随机选择一个元素并用该元素j替换它</li>\n<li>否则直接淘汰该元素；</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>重复步骤2直到结束，最后集合A中剩下的就是保证随机抽取的k个元素。</li>\n</ul>\n<h1 id=\"四、代码\"><a href=\"#四、代码\" class=\"headerlink\" title=\"四、代码\"></a>四、代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int[] sampling(int K) &#123;</span><br><span class=\"line\">    int[] pool = new int[K];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 前 K 个元素直接放入数组中</span><br><span class=\"line\">    for (int i = 0; i &lt; K; i++) &#123; </span><br><span class=\"line\">        pool[i] = stream[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (int i = K; i &lt; N; i++) &#123; // K + 1 个元素开始进行概率采样</span><br><span class=\"line\">        int r = random.nextInt(i + 1);</span><br><span class=\"line\">        // 这里其实就是k/j的体现</span><br><span class=\"line\">        if (r &lt; K) &#123;</span><br><span class=\"line\">            pool[r] = stream[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return pool;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"五、leetcode-题目：\"><a href=\"#五、leetcode-题目：\" class=\"headerlink\" title=\"五、leetcode 题目：\"></a>五、leetcode 题目：</h1><p><a href=\"https://leetcode-cn.com/problems/random-pick-index/\" target=\"_blank\" rel=\"noopener\">T1. 随机数索引</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> 蓄水池算法：</span></span><br><span class=\"line\"><span class=\"comment\">    只对重复值采用蓄水池算法</span></span><br><span class=\"line\"><span class=\"comment\">    出现次数     概率</span></span><br><span class=\"line\"><span class=\"comment\">    1            1</span></span><br><span class=\"line\"><span class=\"comment\">    2            1/2</span></span><br><span class=\"line\"><span class=\"comment\">    3            1/3</span></span><br><span class=\"line\"><span class=\"comment\">    4            1/4</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] nums;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Solution</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.nums = nums;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">pick</span><span class=\"params\">(<span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = getIndex(nums, target);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 统计出现的次数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target == nums[i])&#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (index == -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                    index = i;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                count += <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">int</span> r = random.nextInt(count + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    index = i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://leetcode-cn.com/problems/linked-list-random-node/\" target=\"_blank\" rel=\"noopener\">T2. 链表中随机选择节点</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** <span class=\"doctag\">@param</span> head The linked list's head.</span></span><br><span class=\"line\"><span class=\"comment\">        Note that the head is guaranteed to be not null, so it contains at least one node. */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ListNode head;    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Solution</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.head = head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Returns a random node's value. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getRandom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ListNode now = head;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (now != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            count += <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ret == -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                ret = now.val;</span><br><span class=\"line\">                now = now.next;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> rm = random.nextInt(count );</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rm == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                ret =  now.val;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            now = now.next;</span><br><span class=\"line\">            </span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、预备知识\"><a href=\"#一、预备知识\" class=\"headerlink\" title=\"一、预备知识\"></a>一、预备知识</h1><p>Java 随机数生成的方法：</p>\n<p><code>java.util.Random</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  Main.java </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 指定随机种子，默认以时间为种子</span></span><br><span class=\"line\">        Random random = <span class=\"keyword\">new</span> Random(<span class=\"number\">2048</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 生成 0 ~ 99 之间的整数</span></span><br><span class=\"line\">        System.out.println( random.nextInt(<span class=\"number\">100</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 生成 0 ~ 1.0 之间的小数</span></span><br><span class=\"line\">        System.out.println( random.nextDouble());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 生成 布尔</span></span><br><span class=\"line\">        System.out.println( random.nextBoolean());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"二、海量数据随机采样K个的需求\"><a href=\"#二、海量数据随机采样K个的需求\" class=\"headerlink\" title=\"二、海量数据随机采样K个的需求\"></a>二、海量数据随机采样K个的需求</h1><p>从固定区间内随机采样数据十分简单，直接调用 <code>random.nextInt()</code> 就可以。</p>\n<p><strong>但如果是长度未知的海量数据流呢？该如何实现等概率采样？</strong></p>\n<p>​        答：蓄水池采样算法就是一种解决方案。</p>\n<h1 id=\"三、实现原理（从未知长度的海量数据随机采样K个元素）\"><a href=\"#三、实现原理（从未知长度的海量数据随机采样K个元素）\" class=\"headerlink\" title=\"三、实现原理（从未知长度的海量数据随机采样K个元素）\"></a>三、实现原理（从未知长度的海量数据随机采样K个元素）</h1><h2 id=\"3-1-举例说明：从未知流中随机选择一个元素-K-1-的实现方法\"><a href=\"#3-1-举例说明：从未知流中随机选择一个元素-K-1-的实现方法\" class=\"headerlink\" title=\"3.1 举例说明：从未知流中随机选择一个元素(K = 1)的实现方法\"></a>3.1 <strong>举例说明：从未知流中随机选择一个元素(K = 1)的实现方法</strong></h2><ul>\n<li><strong>当数据流中只有一个数据</strong>：<ul>\n<li>直接返回该数据</li>\n</ul>\n</li>\n<li><strong>当数据流中有两个数据</strong>：<ul>\n<li>D0，D1 中随机选择一个。 概率均为 1/2</li>\n</ul>\n</li>\n<li><strong>当数据流中有三个数据</strong><ul>\n<li>Step1 : 处理 D0, D1 时 先保留一个，概率分别为 1/2</li>\n<li>Step2 :处理 D3 时, 1/3 的概率保留D3, 1 - 1/3 的概率保留 Step1 中的结果</li>\n</ul>\n</li>\n<li><strong>递推下去</strong>      </li>\n</ul>\n<h2 id=\"3-2-解析：假设流的长度只有3\"><a href=\"#3-2-解析：假设流的长度只有3\" class=\"headerlink\" title=\"3.2 解析：假设流的长度只有3\"></a>3.2 <strong>解析：假设流的长度只有3</strong></h2><p>数据 D1 被采样概率：（1/2）<em> (2/3) = 1/3<br>数据 D2 被采样概率：（1/2）</em>(2/3) = 1/3<br>数据 D3 被采样概率：  1/3</p>\n<h2 id=\"3-3-算法描述\"><a href=\"#3-3-算法描述\" class=\"headerlink\" title=\"3.3 算法描述\"></a>3.3 算法描述</h2><ul>\n<li>先选取数据流中的前k个元素，保存在池子pool中；</li>\n<li>从第j（k + 1 &lt;= j &lt;= n）个元素开始<ul>\n<li>每次先以概率 p = k/j选择是否让第j个元素留下；<ul>\n<li>若j被选中，则从A中随机选择一个元素并用该元素j替换它</li>\n<li>否则直接淘汰该元素；</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>重复步骤2直到结束，最后集合A中剩下的就是保证随机抽取的k个元素。</li>\n</ul>\n<h1 id=\"四、代码\"><a href=\"#四、代码\" class=\"headerlink\" title=\"四、代码\"></a>四、代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int[] sampling(int K) &#123;</span><br><span class=\"line\">    int[] pool = new int[K];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 前 K 个元素直接放入数组中</span><br><span class=\"line\">    for (int i = 0; i &lt; K; i++) &#123; </span><br><span class=\"line\">        pool[i] = stream[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (int i = K; i &lt; N; i++) &#123; // K + 1 个元素开始进行概率采样</span><br><span class=\"line\">        int r = random.nextInt(i + 1);</span><br><span class=\"line\">        // 这里其实就是k/j的体现</span><br><span class=\"line\">        if (r &lt; K) &#123;</span><br><span class=\"line\">            pool[r] = stream[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return pool;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"五、leetcode-题目：\"><a href=\"#五、leetcode-题目：\" class=\"headerlink\" title=\"五、leetcode 题目：\"></a>五、leetcode 题目：</h1><p><a href=\"https://leetcode-cn.com/problems/random-pick-index/\" target=\"_blank\" rel=\"noopener\">T1. 随机数索引</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> 蓄水池算法：</span></span><br><span class=\"line\"><span class=\"comment\">    只对重复值采用蓄水池算法</span></span><br><span class=\"line\"><span class=\"comment\">    出现次数     概率</span></span><br><span class=\"line\"><span class=\"comment\">    1            1</span></span><br><span class=\"line\"><span class=\"comment\">    2            1/2</span></span><br><span class=\"line\"><span class=\"comment\">    3            1/3</span></span><br><span class=\"line\"><span class=\"comment\">    4            1/4</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] nums;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Solution</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.nums = nums;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">pick</span><span class=\"params\">(<span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = getIndex(nums, target);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getIndex</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 统计出现的次数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target == nums[i])&#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (index == -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                    index = i;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                count += <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">int</span> r = random.nextInt(count + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    index = i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://leetcode-cn.com/problems/linked-list-random-node/\" target=\"_blank\" rel=\"noopener\">T2. 链表中随机选择节点</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** <span class=\"doctag\">@param</span> head The linked list's head.</span></span><br><span class=\"line\"><span class=\"comment\">        Note that the head is guaranteed to be not null, so it contains at least one node. */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ListNode head;    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Solution</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.head = head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Returns a random node's value. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getRandom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ListNode now = head;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (now != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            count += <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ret == -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                ret = now.val;</span><br><span class=\"line\">                now = now.next;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> rm = random.nextInt(count );</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rm == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                ret =  now.val;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            now = now.next;</span><br><span class=\"line\">            </span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"欢迎来我的小屋！","date":"2019-01-18T06:54:22.000Z","_content":"## 欢迎来到我的小屋做客\n\n","source":"_posts/欢迎来我的小屋.md","raw":"---\ntitle: 欢迎来我的小屋！\ndate: 2019-01-18 14:54:22\ncategories: 闲聊\ntags: 闲聊\n---\n## 欢迎来到我的小屋做客\n\n","slug":"欢迎来我的小屋","published":1,"updated":"2020-04-20T05:58:47.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephgh002ft8pl40tbdy3q","content":"<h2 id=\"欢迎来到我的小屋做客\"><a href=\"#欢迎来到我的小屋做客\" class=\"headerlink\" title=\"欢迎来到我的小屋做客\"></a>欢迎来到我的小屋做客</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"欢迎来到我的小屋做客\"><a href=\"#欢迎来到我的小屋做客\" class=\"headerlink\" title=\"欢迎来到我的小屋做客\"></a>欢迎来到我的小屋做客</h2>"},{"title":"虚拟机类加载机制","date":"2019-04-14T06:11:58.000Z","copyright":true,"password":null,"_content":"\n\n# 虚拟机类加载机制\n\n## 绑定\n> 绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来。\n\n- 静态绑定\n\n\t\n\n> 前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现java当中的方法只有`final，static，private和构造方法` 是前期绑定的。\n\n- 动态绑定\n\n\t\n\n> 运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。\n\n\n\n\n## 类加载机制\n\n\n类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：**加载、验证、准备、解析、初始化、使用和卸载** 七个阶段，前五个阶段属于类加载的过程。这是开始顺序，每个阶段可能交错。\n\n\n\n### step1：加载\n\n#### 加载阶段，虚拟机完成的任务：\n\n- 通过一个类的全限定名来获取起定义的二进制字节流。\n\n> 二进制字节流来源： Class文件，Jar包、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等；\n\n\n- 将该字节流的静态存储结构转换为方法区的运行时数据结构。\n\n\n- 在Java堆中声称一个代表这个类的 java.lang.Class对象，作为对方法区中这些对象的入口。\n\n#### 三种主要的类加载器？\n\n>  类加载机制采用了委托模式。 类加载器与类本身一同确定这个类在Java 虚拟机中的唯一性。\n\n1. 启动类加载器 *Bootstrap ClassLoader*\n\n> 该加载器由C++实现，不属于类，负责加载 ` /JDK/JRE/lib/rt.jar`，主要加载 JVM 工作需要的类；\n\n2. 扩展类加载器 *Extension ClassLoader*\n> Bootstrp loader 加载 ExtClassLoader,\n\t该加载器由sun.misc.Launcher$ExtClassLoader 实现，它负责加载`/JDK\\JRE\\lib\\ext目录中的类，自己的类打包jar放入也可以；\n3. 应用程序类加载器 *Application ClassLoader*\n> Bootstrp loader加载完ExtClassLoader后，就会加载AppClassLoader,并且将AppClassLoader的父加载器指定为 ExtClassLoader， 负责加载classpath所指定的位置的类。\n\n4. 自定义类加载器\n\n> 如果要自定义类加载器，需要继承 `应用程序类加载器`\n\n#### 三者如何协调工作？\n\n类加载机制采用了委托模式。启动类加载器加载其他类加载器，当需要加载类时，**优先父类加载器工作**。\n\n>   双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。\n\n\n### step2：验证\n\n#### 验证的目的？\n\n保证`class 文件`的字节流符号JVM 虚拟机的要求，不危害虚拟机自身安全。虽然 Java 源码编译不会产生如数组越界之类的错误，但`class 文件`可以被编辑。\n\n#### 都需要哪些验证？\n\n- 文件格式验证\n\n> **验证字节流是否符合 `class文件规范`**（如开头是否为魔数`0xCAFEBABE`， 主次版本号是否可以被当前虚拟机处理等）\n\n\n- 元数据验证\n\n> ** 验证字节码描述的信息是否符合Java 语言规范**（如类的继承实现是否符合语法规范）\n- 字节码验证\n\n> 该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。\n\n\n- 符号引用验证\n\n> 发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。\n\n### step3： 准备\n\n 准备阶段是正式为**类变量**（静态变量）分配内存并设置类变量初始值的阶段，**这些内存都将在方法区中分配**。注意的是：\n\n1. 只为类变量分配内存；\n\n\n2. static 类变量初始值为默认初始值，而不是程序中的值；\n\n\n\tpublic static int value = 3；  // 实际初始值为0\n3. 同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值；\n\n    public static final int value = 3；  // 实际初始值为3\n\n\n### step4： 解析\n\n> 解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。\n\n\n>  解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。\n\n\n### step5： 初始化\n\n> 真正开始执行类中定义的Java程序代码,初始化阶段是执行类构造器<clinit>()方法的过程。\n\n类构造器 `<clinit>()` 执行规则：\n\n1. 按照在源文件中出现的顺序收集`类变量` 和 ` 静态语句块 static{ }`;\n2. 静态语句块中只能访问定义在之前的变量，而在块后定义的变量只能被赋值，但不能被访问；\n3. 优先构造父类；\n4. 父类中的 ` 静态语句块 static{ }` 优先于子类中的变量赋值操作；\n5. 不是必须的，当类或者接口中没有静态语句块或者没有变量赋值，则可以不生成`<clinit>()`；\n\n\n## 双亲委派被破坏 3种情况下\n\n- 第一次： JDK1.2之前还没有双亲委派，但是有用户自定义类加载器（通过`loadClass（）`加载），为了兼容老版本，设计者添加了 ` protected findClass()`，直接调用用户`loadClass（）`方法；\n\n\n- 第二次：原则上 **越基础的类由越上层的加载器进行加载**,但是有些情况下基础类需要调用用户的代码。如**JNDI, JDBC，JCE,JAXB，JBI**,这时候引入了`线程上下文加载器`；\n\n- 第三次：“代码热替换”和“模块热部署”出现，希望程序中的功能模块像键盘鼠标一样直接更换，而不是重启。**OSGi** 是这个标准化模块，具体还没看。。。\n","source":"_posts/虚拟机类加载机制.md","raw":"---\ntitle: 虚拟机类加载机制\ndate: 2019-04-14 14:11:58\ncategories: 深入理解Java 虚拟机\ntags: Java类加载机制\ncopyright: True\npassword:\n---\n\n\n# 虚拟机类加载机制\n\n## 绑定\n> 绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来。\n\n- 静态绑定\n\n\t\n\n> 前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现java当中的方法只有`final，static，private和构造方法` 是前期绑定的。\n\n- 动态绑定\n\n\t\n\n> 运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。\n\n\n\n\n## 类加载机制\n\n\n类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：**加载、验证、准备、解析、初始化、使用和卸载** 七个阶段，前五个阶段属于类加载的过程。这是开始顺序，每个阶段可能交错。\n\n\n\n### step1：加载\n\n#### 加载阶段，虚拟机完成的任务：\n\n- 通过一个类的全限定名来获取起定义的二进制字节流。\n\n> 二进制字节流来源： Class文件，Jar包、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等；\n\n\n- 将该字节流的静态存储结构转换为方法区的运行时数据结构。\n\n\n- 在Java堆中声称一个代表这个类的 java.lang.Class对象，作为对方法区中这些对象的入口。\n\n#### 三种主要的类加载器？\n\n>  类加载机制采用了委托模式。 类加载器与类本身一同确定这个类在Java 虚拟机中的唯一性。\n\n1. 启动类加载器 *Bootstrap ClassLoader*\n\n> 该加载器由C++实现，不属于类，负责加载 ` /JDK/JRE/lib/rt.jar`，主要加载 JVM 工作需要的类；\n\n2. 扩展类加载器 *Extension ClassLoader*\n> Bootstrp loader 加载 ExtClassLoader,\n\t该加载器由sun.misc.Launcher$ExtClassLoader 实现，它负责加载`/JDK\\JRE\\lib\\ext目录中的类，自己的类打包jar放入也可以；\n3. 应用程序类加载器 *Application ClassLoader*\n> Bootstrp loader加载完ExtClassLoader后，就会加载AppClassLoader,并且将AppClassLoader的父加载器指定为 ExtClassLoader， 负责加载classpath所指定的位置的类。\n\n4. 自定义类加载器\n\n> 如果要自定义类加载器，需要继承 `应用程序类加载器`\n\n#### 三者如何协调工作？\n\n类加载机制采用了委托模式。启动类加载器加载其他类加载器，当需要加载类时，**优先父类加载器工作**。\n\n>   双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。\n\n\n### step2：验证\n\n#### 验证的目的？\n\n保证`class 文件`的字节流符号JVM 虚拟机的要求，不危害虚拟机自身安全。虽然 Java 源码编译不会产生如数组越界之类的错误，但`class 文件`可以被编辑。\n\n#### 都需要哪些验证？\n\n- 文件格式验证\n\n> **验证字节流是否符合 `class文件规范`**（如开头是否为魔数`0xCAFEBABE`， 主次版本号是否可以被当前虚拟机处理等）\n\n\n- 元数据验证\n\n> ** 验证字节码描述的信息是否符合Java 语言规范**（如类的继承实现是否符合语法规范）\n- 字节码验证\n\n> 该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。\n\n\n- 符号引用验证\n\n> 发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。\n\n### step3： 准备\n\n 准备阶段是正式为**类变量**（静态变量）分配内存并设置类变量初始值的阶段，**这些内存都将在方法区中分配**。注意的是：\n\n1. 只为类变量分配内存；\n\n\n2. static 类变量初始值为默认初始值，而不是程序中的值；\n\n\n\tpublic static int value = 3；  // 实际初始值为0\n3. 同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值；\n\n    public static final int value = 3；  // 实际初始值为3\n\n\n### step4： 解析\n\n> 解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。\n\n\n>  解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。\n\n\n### step5： 初始化\n\n> 真正开始执行类中定义的Java程序代码,初始化阶段是执行类构造器<clinit>()方法的过程。\n\n类构造器 `<clinit>()` 执行规则：\n\n1. 按照在源文件中出现的顺序收集`类变量` 和 ` 静态语句块 static{ }`;\n2. 静态语句块中只能访问定义在之前的变量，而在块后定义的变量只能被赋值，但不能被访问；\n3. 优先构造父类；\n4. 父类中的 ` 静态语句块 static{ }` 优先于子类中的变量赋值操作；\n5. 不是必须的，当类或者接口中没有静态语句块或者没有变量赋值，则可以不生成`<clinit>()`；\n\n\n## 双亲委派被破坏 3种情况下\n\n- 第一次： JDK1.2之前还没有双亲委派，但是有用户自定义类加载器（通过`loadClass（）`加载），为了兼容老版本，设计者添加了 ` protected findClass()`，直接调用用户`loadClass（）`方法；\n\n\n- 第二次：原则上 **越基础的类由越上层的加载器进行加载**,但是有些情况下基础类需要调用用户的代码。如**JNDI, JDBC，JCE,JAXB，JBI**,这时候引入了`线程上下文加载器`；\n\n- 第三次：“代码热替换”和“模块热部署”出现，希望程序中的功能模块像键盘鼠标一样直接更换，而不是重启。**OSGi** 是这个标准化模块，具体还没看。。。\n","slug":"虚拟机类加载机制","published":1,"updated":"2020-02-20T06:58:27.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephgm002it8pldfjfmmzf","content":"<h1 id=\"虚拟机类加载机制\"><a href=\"#虚拟机类加载机制\" class=\"headerlink\" title=\"虚拟机类加载机制\"></a>虚拟机类加载机制</h1><h2 id=\"绑定\"><a href=\"#绑定\" class=\"headerlink\" title=\"绑定\"></a>绑定</h2><blockquote>\n<p>绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来。</p>\n</blockquote>\n<ul>\n<li>静态绑定</li>\n</ul>\n<blockquote>\n<p>前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现java当中的方法只有<code>final，static，private和构造方法</code> 是前期绑定的。</p>\n</blockquote>\n<ul>\n<li>动态绑定</li>\n</ul>\n<blockquote>\n<p>运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。</p>\n</blockquote>\n<h2 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：<strong>加载、验证、准备、解析、初始化、使用和卸载</strong> 七个阶段，前五个阶段属于类加载的过程。这是开始顺序，每个阶段可能交错。</p>\n<h3 id=\"step1：加载\"><a href=\"#step1：加载\" class=\"headerlink\" title=\"step1：加载\"></a>step1：加载</h3><h4 id=\"加载阶段，虚拟机完成的任务：\"><a href=\"#加载阶段，虚拟机完成的任务：\" class=\"headerlink\" title=\"加载阶段，虚拟机完成的任务：\"></a>加载阶段，虚拟机完成的任务：</h4><ul>\n<li>通过一个类的全限定名来获取起定义的二进制字节流。</li>\n</ul>\n<blockquote>\n<p>二进制字节流来源： Class文件，Jar包、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等；</p>\n</blockquote>\n<ul>\n<li>将该字节流的静态存储结构转换为方法区的运行时数据结构。</li>\n</ul>\n<ul>\n<li>在Java堆中声称一个代表这个类的 java.lang.Class对象，作为对方法区中这些对象的入口。</li>\n</ul>\n<h4 id=\"三种主要的类加载器？\"><a href=\"#三种主要的类加载器？\" class=\"headerlink\" title=\"三种主要的类加载器？\"></a>三种主要的类加载器？</h4><blockquote>\n<p> 类加载机制采用了委托模式。 类加载器与类本身一同确定这个类在Java 虚拟机中的唯一性。</p>\n</blockquote>\n<ol>\n<li>启动类加载器 <em>Bootstrap ClassLoader</em></li>\n</ol>\n<blockquote>\n<p>该加载器由C++实现，不属于类，负责加载 <code>/JDK/JRE/lib/rt.jar</code>，主要加载 JVM 工作需要的类；</p>\n</blockquote>\n<ol>\n<li>扩展类加载器 <em>Extension ClassLoader</em><blockquote>\n<p>Bootstrp loader 加载 ExtClassLoader,<br> 该加载器由sun.misc.Launcher$ExtClassLoader 实现，它负责加载`/JDK\\JRE\\lib\\ext目录中的类，自己的类打包jar放入也可以；</p>\n</blockquote>\n</li>\n<li><p>应用程序类加载器 <em>Application ClassLoader</em></p>\n<blockquote>\n<p>Bootstrp loader加载完ExtClassLoader后，就会加载AppClassLoader,并且将AppClassLoader的父加载器指定为 ExtClassLoader， 负责加载classpath所指定的位置的类。</p>\n</blockquote>\n</li>\n<li><p>自定义类加载器</p>\n</li>\n</ol>\n<blockquote>\n<p>如果要自定义类加载器，需要继承 <code>应用程序类加载器</code></p>\n</blockquote>\n<h4 id=\"三者如何协调工作？\"><a href=\"#三者如何协调工作？\" class=\"headerlink\" title=\"三者如何协调工作？\"></a>三者如何协调工作？</h4><p>类加载机制采用了委托模式。启动类加载器加载其他类加载器，当需要加载类时，<strong>优先父类加载器工作</strong>。</p>\n<blockquote>\n<p>  双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>\n</blockquote>\n<h3 id=\"step2：验证\"><a href=\"#step2：验证\" class=\"headerlink\" title=\"step2：验证\"></a>step2：验证</h3><h4 id=\"验证的目的？\"><a href=\"#验证的目的？\" class=\"headerlink\" title=\"验证的目的？\"></a>验证的目的？</h4><p>保证<code>class 文件</code>的字节流符号JVM 虚拟机的要求，不危害虚拟机自身安全。虽然 Java 源码编译不会产生如数组越界之类的错误，但<code>class 文件</code>可以被编辑。</p>\n<h4 id=\"都需要哪些验证？\"><a href=\"#都需要哪些验证？\" class=\"headerlink\" title=\"都需要哪些验证？\"></a>都需要哪些验证？</h4><ul>\n<li>文件格式验证</li>\n</ul>\n<blockquote>\n<p><strong>验证字节流是否符合 <code>class文件规范</code></strong>（如开头是否为魔数<code>0xCAFEBABE</code>， 主次版本号是否可以被当前虚拟机处理等）</p>\n</blockquote>\n<ul>\n<li>元数据验证</li>\n</ul>\n<blockquote>\n<p><strong> 验证字节码描述的信息是否符合Java 语言规范</strong>（如类的继承实现是否符合语法规范）</p>\n<ul>\n<li>字节码验证</li>\n</ul>\n<p>该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</p>\n</blockquote>\n<ul>\n<li>符号引用验证</li>\n</ul>\n<blockquote>\n<p>发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。</p>\n</blockquote>\n<h3 id=\"step3：-准备\"><a href=\"#step3：-准备\" class=\"headerlink\" title=\"step3： 准备\"></a>step3： 准备</h3><p> 准备阶段是正式为<strong>类变量</strong>（静态变量）分配内存并设置类变量初始值的阶段，<strong>这些内存都将在方法区中分配</strong>。注意的是：</p>\n<ol>\n<li>只为类变量分配内存；</li>\n</ol>\n<ol>\n<li>static 类变量初始值为默认初始值，而不是程序中的值；</li>\n</ol>\n<pre><code>public static int value = 3；  // 实际初始值为0\n</code></pre><ol>\n<li><p>同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值；</p>\n<p> public static final int value = 3；  // 实际初始值为3</p>\n</li>\n</ol>\n<h3 id=\"step4：-解析\"><a href=\"#step4：-解析\" class=\"headerlink\" title=\"step4： 解析\"></a>step4： 解析</h3><blockquote>\n<p>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。</p>\n<p> 解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。</p>\n</blockquote>\n<h3 id=\"step5：-初始化\"><a href=\"#step5：-初始化\" class=\"headerlink\" title=\"step5： 初始化\"></a>step5： 初始化</h3><blockquote>\n<p>真正开始执行类中定义的Java程序代码,初始化阶段是执行类构造器<clinit>()方法的过程。</clinit></p>\n</blockquote>\n<p>类构造器 <code>&lt;clinit&gt;()</code> 执行规则：</p>\n<ol>\n<li>按照在源文件中出现的顺序收集<code>类变量</code> 和 <code>静态语句块 static{ }</code>;</li>\n<li>静态语句块中只能访问定义在之前的变量，而在块后定义的变量只能被赋值，但不能被访问；</li>\n<li>优先构造父类；</li>\n<li>父类中的 <code>静态语句块 static{ }</code> 优先于子类中的变量赋值操作；</li>\n<li>不是必须的，当类或者接口中没有静态语句块或者没有变量赋值，则可以不生成<code>&lt;clinit&gt;()</code>；</li>\n</ol>\n<h2 id=\"双亲委派被破坏-3种情况下\"><a href=\"#双亲委派被破坏-3种情况下\" class=\"headerlink\" title=\"双亲委派被破坏 3种情况下\"></a>双亲委派被破坏 3种情况下</h2><ul>\n<li>第一次： JDK1.2之前还没有双亲委派，但是有用户自定义类加载器（通过<code>loadClass（）</code>加载），为了兼容老版本，设计者添加了 <code>protected findClass()</code>，直接调用用户<code>loadClass（）</code>方法；</li>\n</ul>\n<ul>\n<li><p>第二次：原则上 <strong>越基础的类由越上层的加载器进行加载</strong>,但是有些情况下基础类需要调用用户的代码。如<strong>JNDI, JDBC，JCE,JAXB，JBI</strong>,这时候引入了<code>线程上下文加载器</code>；</p>\n</li>\n<li><p>第三次：“代码热替换”和“模块热部署”出现，希望程序中的功能模块像键盘鼠标一样直接更换，而不是重启。<strong>OSGi</strong> 是这个标准化模块，具体还没看。。。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"虚拟机类加载机制\"><a href=\"#虚拟机类加载机制\" class=\"headerlink\" title=\"虚拟机类加载机制\"></a>虚拟机类加载机制</h1><h2 id=\"绑定\"><a href=\"#绑定\" class=\"headerlink\" title=\"绑定\"></a>绑定</h2><blockquote>\n<p>绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来。</p>\n</blockquote>\n<ul>\n<li>静态绑定</li>\n</ul>\n<blockquote>\n<p>前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现java当中的方法只有<code>final，static，private和构造方法</code> 是前期绑定的。</p>\n</blockquote>\n<ul>\n<li>动态绑定</li>\n</ul>\n<blockquote>\n<p>运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。</p>\n</blockquote>\n<h2 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：<strong>加载、验证、准备、解析、初始化、使用和卸载</strong> 七个阶段，前五个阶段属于类加载的过程。这是开始顺序，每个阶段可能交错。</p>\n<h3 id=\"step1：加载\"><a href=\"#step1：加载\" class=\"headerlink\" title=\"step1：加载\"></a>step1：加载</h3><h4 id=\"加载阶段，虚拟机完成的任务：\"><a href=\"#加载阶段，虚拟机完成的任务：\" class=\"headerlink\" title=\"加载阶段，虚拟机完成的任务：\"></a>加载阶段，虚拟机完成的任务：</h4><ul>\n<li>通过一个类的全限定名来获取起定义的二进制字节流。</li>\n</ul>\n<blockquote>\n<p>二进制字节流来源： Class文件，Jar包、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等；</p>\n</blockquote>\n<ul>\n<li>将该字节流的静态存储结构转换为方法区的运行时数据结构。</li>\n</ul>\n<ul>\n<li>在Java堆中声称一个代表这个类的 java.lang.Class对象，作为对方法区中这些对象的入口。</li>\n</ul>\n<h4 id=\"三种主要的类加载器？\"><a href=\"#三种主要的类加载器？\" class=\"headerlink\" title=\"三种主要的类加载器？\"></a>三种主要的类加载器？</h4><blockquote>\n<p> 类加载机制采用了委托模式。 类加载器与类本身一同确定这个类在Java 虚拟机中的唯一性。</p>\n</blockquote>\n<ol>\n<li>启动类加载器 <em>Bootstrap ClassLoader</em></li>\n</ol>\n<blockquote>\n<p>该加载器由C++实现，不属于类，负责加载 <code>/JDK/JRE/lib/rt.jar</code>，主要加载 JVM 工作需要的类；</p>\n</blockquote>\n<ol>\n<li>扩展类加载器 <em>Extension ClassLoader</em><blockquote>\n<p>Bootstrp loader 加载 ExtClassLoader,<br> 该加载器由sun.misc.Launcher$ExtClassLoader 实现，它负责加载`/JDK\\JRE\\lib\\ext目录中的类，自己的类打包jar放入也可以；</p>\n</blockquote>\n</li>\n<li><p>应用程序类加载器 <em>Application ClassLoader</em></p>\n<blockquote>\n<p>Bootstrp loader加载完ExtClassLoader后，就会加载AppClassLoader,并且将AppClassLoader的父加载器指定为 ExtClassLoader， 负责加载classpath所指定的位置的类。</p>\n</blockquote>\n</li>\n<li><p>自定义类加载器</p>\n</li>\n</ol>\n<blockquote>\n<p>如果要自定义类加载器，需要继承 <code>应用程序类加载器</code></p>\n</blockquote>\n<h4 id=\"三者如何协调工作？\"><a href=\"#三者如何协调工作？\" class=\"headerlink\" title=\"三者如何协调工作？\"></a>三者如何协调工作？</h4><p>类加载机制采用了委托模式。启动类加载器加载其他类加载器，当需要加载类时，<strong>优先父类加载器工作</strong>。</p>\n<blockquote>\n<p>  双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>\n</blockquote>\n<h3 id=\"step2：验证\"><a href=\"#step2：验证\" class=\"headerlink\" title=\"step2：验证\"></a>step2：验证</h3><h4 id=\"验证的目的？\"><a href=\"#验证的目的？\" class=\"headerlink\" title=\"验证的目的？\"></a>验证的目的？</h4><p>保证<code>class 文件</code>的字节流符号JVM 虚拟机的要求，不危害虚拟机自身安全。虽然 Java 源码编译不会产生如数组越界之类的错误，但<code>class 文件</code>可以被编辑。</p>\n<h4 id=\"都需要哪些验证？\"><a href=\"#都需要哪些验证？\" class=\"headerlink\" title=\"都需要哪些验证？\"></a>都需要哪些验证？</h4><ul>\n<li>文件格式验证</li>\n</ul>\n<blockquote>\n<p><strong>验证字节流是否符合 <code>class文件规范</code></strong>（如开头是否为魔数<code>0xCAFEBABE</code>， 主次版本号是否可以被当前虚拟机处理等）</p>\n</blockquote>\n<ul>\n<li>元数据验证</li>\n</ul>\n<blockquote>\n<p><strong> 验证字节码描述的信息是否符合Java 语言规范</strong>（如类的继承实现是否符合语法规范）</p>\n<ul>\n<li>字节码验证</li>\n</ul>\n<p>该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</p>\n</blockquote>\n<ul>\n<li>符号引用验证</li>\n</ul>\n<blockquote>\n<p>发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。</p>\n</blockquote>\n<h3 id=\"step3：-准备\"><a href=\"#step3：-准备\" class=\"headerlink\" title=\"step3： 准备\"></a>step3： 准备</h3><p> 准备阶段是正式为<strong>类变量</strong>（静态变量）分配内存并设置类变量初始值的阶段，<strong>这些内存都将在方法区中分配</strong>。注意的是：</p>\n<ol>\n<li>只为类变量分配内存；</li>\n</ol>\n<ol>\n<li>static 类变量初始值为默认初始值，而不是程序中的值；</li>\n</ol>\n<pre><code>public static int value = 3；  // 实际初始值为0\n</code></pre><ol>\n<li><p>同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值；</p>\n<p> public static final int value = 3；  // 实际初始值为3</p>\n</li>\n</ol>\n<h3 id=\"step4：-解析\"><a href=\"#step4：-解析\" class=\"headerlink\" title=\"step4： 解析\"></a>step4： 解析</h3><blockquote>\n<p>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。</p>\n<p> 解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。</p>\n</blockquote>\n<h3 id=\"step5：-初始化\"><a href=\"#step5：-初始化\" class=\"headerlink\" title=\"step5： 初始化\"></a>step5： 初始化</h3><blockquote>\n<p>真正开始执行类中定义的Java程序代码,初始化阶段是执行类构造器<clinit>()方法的过程。</clinit></p>\n</blockquote>\n<p>类构造器 <code>&lt;clinit&gt;()</code> 执行规则：</p>\n<ol>\n<li>按照在源文件中出现的顺序收集<code>类变量</code> 和 <code>静态语句块 static{ }</code>;</li>\n<li>静态语句块中只能访问定义在之前的变量，而在块后定义的变量只能被赋值，但不能被访问；</li>\n<li>优先构造父类；</li>\n<li>父类中的 <code>静态语句块 static{ }</code> 优先于子类中的变量赋值操作；</li>\n<li>不是必须的，当类或者接口中没有静态语句块或者没有变量赋值，则可以不生成<code>&lt;clinit&gt;()</code>；</li>\n</ol>\n<h2 id=\"双亲委派被破坏-3种情况下\"><a href=\"#双亲委派被破坏-3种情况下\" class=\"headerlink\" title=\"双亲委派被破坏 3种情况下\"></a>双亲委派被破坏 3种情况下</h2><ul>\n<li>第一次： JDK1.2之前还没有双亲委派，但是有用户自定义类加载器（通过<code>loadClass（）</code>加载），为了兼容老版本，设计者添加了 <code>protected findClass()</code>，直接调用用户<code>loadClass（）</code>方法；</li>\n</ul>\n<ul>\n<li><p>第二次：原则上 <strong>越基础的类由越上层的加载器进行加载</strong>,但是有些情况下基础类需要调用用户的代码。如<strong>JNDI, JDBC，JCE,JAXB，JBI</strong>,这时候引入了<code>线程上下文加载器</code>；</p>\n</li>\n<li><p>第三次：“代码热替换”和“模块热部署”出现，希望程序中的功能模块像键盘鼠标一样直接更换，而不是重启。<strong>OSGi</strong> 是这个标准化模块，具体还没看。。。</p>\n</li>\n</ul>\n"},{"title":"评价指标 ROC与AUC","mathjax":true,"date":"2019-07-20T07:10:00.000Z","_content":"\n## 非均衡分类问题\n\n> 非均衡分类问题指的是每个类别的错误代价不同。\n\n> 比如疾病检测中,有病患者诊断健康的代价，要比健康人诊断成有病（可能性）造成的影响更为严重。\n\n> 对于常用的预测模型，通常是有预测的概率值，我们找到一个合适的截断点作为正负类别的界限。显然再不同的任务下，截断点选择是不同的。我们使用Precison 和Recall的新度量指标来针对特定任务下选择合适的截断值。\n\n\n真实标签 | 预测为正 | 预测为反\n---|---|---\n正例 | TP | FN\n反例 | FP | TN\n\n\n\n- Precison(查准率)：\n\n```\n    P = TP/(TP+FP)\n```\n\n- Recall(召回率)：\n\n```\n    R = TP/(TP+FN)\n```\n\n> 当正负样本不不均衡,人为修改测试集中的正负比例时, P-R曲线波动很大，但是ROC曲线变化很小。\n\n## ROC 曲线\n\n> 可以研究学习器的泛化性能。\n## 加图\n- 横坐标：真阳率，正例被正确预测的概率\n\n```\n    FPR = FP/(TN+FP)\n```\n- 纵坐标：假阳率，负例被预测错误的概率\n```\n    TPR = TP/(TP+FN)\n```\n**==理解四点一线==**：\n- (0, 0):  FP = TP = 0, 所有样本预测为负\n- (1, 1):  FP = TP = 1, 所有样本预测为正\n- (1, 0):  FP = 1, TP = 0, 所有正样本预测为负\n- (0, 1):  FP = 0, TP = 1, 完美预测\n- 对角线：随机猜测的值。\n\n\n## AUC值\n\nAUC(Area under Curve) 被定义为ROC曲线的下侧面积。一般在(0.5~1)之间。\n\n### 计算方法\n\n1. 几何角度\n> 直接计算曲线下的面积，梯形\n\n2. 概率角度\n> 任取一对正负样本对，正样本score大于负样本score的概率\n\n\n### python 实现\n\n\n\n[链接](http://zhuzhuyule.xyz)\n\n```\n\timport numpy as np\n\tfrom sklearn.metrics import roc_curve\n\tfrom sklearn.metrics import auc\n\tfrom time import time\n\t\n\t# y:     标签\n\t# pred： 预测值\n\tdef myAUC(y, pred):\n\t\n\t    auc = 0.0\n\t    p_list = []  # 正负例的索引\n\t    n_list = []\n\t    for i, y_ in enumerate(y):\n\t        if y_ == 1:\n\t            p_list.append(i)\n\t        else:\n\t            n_list.append(i)\n\t    # 构成p-n对\n\t    p_n = [(i,j) for i in p_list for j in n_list]\n\t    \n\t    pn_len = len(p_n)\n\t    for tup in p_n:\n\t        if pred[tup[0]] > pred[tup[1]]:\n\t            auc += 1\n\t        elif pred[tup[0]] == pred[tup[1]]:\n\t            auc += 0.5\n\t    auc = auc/pn_len\n\t    return auc\n\t\n\t\n\t## 产生一组数据\n\ty = np.array([1,0,0,0,1,0,1,0,])\n\tpred = np.array([0.9, 0.8, 0.3, 0.1,0.4,0.9,0.66,0.7])\n\t\n\t## sklearn 结果\n\tfpr, tpr, thresholds = roc_curve(y, pred, pos_label=1)\n\t\n\ttim = time()\n\tprint(\"sklearn AUC:\",auc(fpr, tpr))\n\tprint(\"sklearn AUC time:\", time()-tim)\n\t\n\t\n\t## myAUC 结果\n\ttim = time()\n\tprint(\"\\nmyAUC:\",myAUC(y,pred))\n\tprint(\"myAUC time:\", time()-tim)\n\n```","source":"_posts/评价指标-ROC与AUC.md","raw":"---\ntitle: 评价指标 ROC与AUC\nmathjax: true\ndate: 2019-07-20 15:10:00\ncategories: 机器学习方法\ntags: ROC\n---\n\n## 非均衡分类问题\n\n> 非均衡分类问题指的是每个类别的错误代价不同。\n\n> 比如疾病检测中,有病患者诊断健康的代价，要比健康人诊断成有病（可能性）造成的影响更为严重。\n\n> 对于常用的预测模型，通常是有预测的概率值，我们找到一个合适的截断点作为正负类别的界限。显然再不同的任务下，截断点选择是不同的。我们使用Precison 和Recall的新度量指标来针对特定任务下选择合适的截断值。\n\n\n真实标签 | 预测为正 | 预测为反\n---|---|---\n正例 | TP | FN\n反例 | FP | TN\n\n\n\n- Precison(查准率)：\n\n```\n    P = TP/(TP+FP)\n```\n\n- Recall(召回率)：\n\n```\n    R = TP/(TP+FN)\n```\n\n> 当正负样本不不均衡,人为修改测试集中的正负比例时, P-R曲线波动很大，但是ROC曲线变化很小。\n\n## ROC 曲线\n\n> 可以研究学习器的泛化性能。\n## 加图\n- 横坐标：真阳率，正例被正确预测的概率\n\n```\n    FPR = FP/(TN+FP)\n```\n- 纵坐标：假阳率，负例被预测错误的概率\n```\n    TPR = TP/(TP+FN)\n```\n**==理解四点一线==**：\n- (0, 0):  FP = TP = 0, 所有样本预测为负\n- (1, 1):  FP = TP = 1, 所有样本预测为正\n- (1, 0):  FP = 1, TP = 0, 所有正样本预测为负\n- (0, 1):  FP = 0, TP = 1, 完美预测\n- 对角线：随机猜测的值。\n\n\n## AUC值\n\nAUC(Area under Curve) 被定义为ROC曲线的下侧面积。一般在(0.5~1)之间。\n\n### 计算方法\n\n1. 几何角度\n> 直接计算曲线下的面积，梯形\n\n2. 概率角度\n> 任取一对正负样本对，正样本score大于负样本score的概率\n\n\n### python 实现\n\n\n\n[链接](http://zhuzhuyule.xyz)\n\n```\n\timport numpy as np\n\tfrom sklearn.metrics import roc_curve\n\tfrom sklearn.metrics import auc\n\tfrom time import time\n\t\n\t# y:     标签\n\t# pred： 预测值\n\tdef myAUC(y, pred):\n\t\n\t    auc = 0.0\n\t    p_list = []  # 正负例的索引\n\t    n_list = []\n\t    for i, y_ in enumerate(y):\n\t        if y_ == 1:\n\t            p_list.append(i)\n\t        else:\n\t            n_list.append(i)\n\t    # 构成p-n对\n\t    p_n = [(i,j) for i in p_list for j in n_list]\n\t    \n\t    pn_len = len(p_n)\n\t    for tup in p_n:\n\t        if pred[tup[0]] > pred[tup[1]]:\n\t            auc += 1\n\t        elif pred[tup[0]] == pred[tup[1]]:\n\t            auc += 0.5\n\t    auc = auc/pn_len\n\t    return auc\n\t\n\t\n\t## 产生一组数据\n\ty = np.array([1,0,0,0,1,0,1,0,])\n\tpred = np.array([0.9, 0.8, 0.3, 0.1,0.4,0.9,0.66,0.7])\n\t\n\t## sklearn 结果\n\tfpr, tpr, thresholds = roc_curve(y, pred, pos_label=1)\n\t\n\ttim = time()\n\tprint(\"sklearn AUC:\",auc(fpr, tpr))\n\tprint(\"sklearn AUC time:\", time()-tim)\n\t\n\t\n\t## myAUC 结果\n\ttim = time()\n\tprint(\"\\nmyAUC:\",myAUC(y,pred))\n\tprint(\"myAUC time:\", time()-tim)\n\n```","slug":"评价指标-ROC与AUC","published":1,"updated":"2020-02-20T06:39:39.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephgp002kt8plh1z8mplo","content":"<h2 id=\"非均衡分类问题\"><a href=\"#非均衡分类问题\" class=\"headerlink\" title=\"非均衡分类问题\"></a>非均衡分类问题</h2><blockquote>\n<p>非均衡分类问题指的是每个类别的错误代价不同。</p>\n<p>比如疾病检测中,有病患者诊断健康的代价，要比健康人诊断成有病（可能性）造成的影响更为严重。</p>\n<p>对于常用的预测模型，通常是有预测的概率值，我们找到一个合适的截断点作为正负类别的界限。显然再不同的任务下，截断点选择是不同的。我们使用Precison 和Recall的新度量指标来针对特定任务下选择合适的截断值。</p>\n</blockquote>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>真实标签</th>\n<th>预测为正</th>\n<th>预测为反</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>正例</td>\n<td>TP</td>\n<td>FN</td>\n</tr>\n<tr>\n<td>反例</td>\n<td>FP</td>\n<td>TN</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>Precison(查准率)：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P = TP/(TP+FP)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Recall(召回率)：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R = TP/(TP+FN)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当正负样本不不均衡,人为修改测试集中的正负比例时, P-R曲线波动很大，但是ROC曲线变化很小。</p>\n</blockquote>\n<h2 id=\"ROC-曲线\"><a href=\"#ROC-曲线\" class=\"headerlink\" title=\"ROC 曲线\"></a>ROC 曲线</h2><blockquote>\n<p>可以研究学习器的泛化性能。</p>\n<h2 id=\"加图\"><a href=\"#加图\" class=\"headerlink\" title=\"加图\"></a>加图</h2><ul>\n<li>横坐标：真阳率，正例被正确预测的概率</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FPR = FP/(TN+FP)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>纵坐标：假阳率，负例被预测错误的概率<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TPR = TP/(TP+FN)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>==理解四点一线==</strong>：</p>\n<ul>\n<li>(0, 0):  FP = TP = 0, 所有样本预测为负</li>\n<li>(1, 1):  FP = TP = 1, 所有样本预测为正</li>\n<li>(1, 0):  FP = 1, TP = 0, 所有正样本预测为负</li>\n<li>(0, 1):  FP = 0, TP = 1, 完美预测</li>\n<li>对角线：随机猜测的值。</li>\n</ul>\n<h2 id=\"AUC值\"><a href=\"#AUC值\" class=\"headerlink\" title=\"AUC值\"></a>AUC值</h2><p>AUC(Area under Curve) 被定义为ROC曲线的下侧面积。一般在(0.5~1)之间。</p>\n<h3 id=\"计算方法\"><a href=\"#计算方法\" class=\"headerlink\" title=\"计算方法\"></a>计算方法</h3><ol>\n<li><p>几何角度</p>\n<blockquote>\n<p>直接计算曲线下的面积，梯形</p>\n</blockquote>\n</li>\n<li><p>概率角度</p>\n<blockquote>\n<p>任取一对正负样本对，正样本score大于负样本score的概率</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"python-实现\"><a href=\"#python-实现\" class=\"headerlink\" title=\"python 实现\"></a>python 实现</h3><p><a href=\"http://zhuzhuyule.xyz\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import numpy as np</span><br><span class=\"line\">from sklearn.metrics import roc_curve</span><br><span class=\"line\">from sklearn.metrics import auc</span><br><span class=\"line\">from time import time</span><br><span class=\"line\"></span><br><span class=\"line\"># y:     标签</span><br><span class=\"line\"># pred： 预测值</span><br><span class=\"line\">def myAUC(y, pred):</span><br><span class=\"line\"></span><br><span class=\"line\">    auc = 0.0</span><br><span class=\"line\">    p_list = []  # 正负例的索引</span><br><span class=\"line\">    n_list = []</span><br><span class=\"line\">    for i, y_ in enumerate(y):</span><br><span class=\"line\">        if y_ == 1:</span><br><span class=\"line\">            p_list.append(i)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            n_list.append(i)</span><br><span class=\"line\">    # 构成p-n对</span><br><span class=\"line\">    p_n = [(i,j) for i in p_list for j in n_list]</span><br><span class=\"line\">    </span><br><span class=\"line\">    pn_len = len(p_n)</span><br><span class=\"line\">    for tup in p_n:</span><br><span class=\"line\">        if pred[tup[0]] &gt; pred[tup[1]]:</span><br><span class=\"line\">            auc += 1</span><br><span class=\"line\">        elif pred[tup[0]] == pred[tup[1]]:</span><br><span class=\"line\">            auc += 0.5</span><br><span class=\"line\">    auc = auc/pn_len</span><br><span class=\"line\">    return auc</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 产生一组数据</span><br><span class=\"line\">y = np.array([1,0,0,0,1,0,1,0,])</span><br><span class=\"line\">pred = np.array([0.9, 0.8, 0.3, 0.1,0.4,0.9,0.66,0.7])</span><br><span class=\"line\"></span><br><span class=\"line\">## sklearn 结果</span><br><span class=\"line\">fpr, tpr, thresholds = roc_curve(y, pred, pos_label=1)</span><br><span class=\"line\"></span><br><span class=\"line\">tim = time()</span><br><span class=\"line\">print(&quot;sklearn AUC:&quot;,auc(fpr, tpr))</span><br><span class=\"line\">print(&quot;sklearn AUC time:&quot;, time()-tim)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## myAUC 结果</span><br><span class=\"line\">tim = time()</span><br><span class=\"line\">print(&quot;\\nmyAUC:&quot;,myAUC(y,pred))</span><br><span class=\"line\">print(&quot;myAUC time:&quot;, time()-tim)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"非均衡分类问题\"><a href=\"#非均衡分类问题\" class=\"headerlink\" title=\"非均衡分类问题\"></a>非均衡分类问题</h2><blockquote>\n<p>非均衡分类问题指的是每个类别的错误代价不同。</p>\n<p>比如疾病检测中,有病患者诊断健康的代价，要比健康人诊断成有病（可能性）造成的影响更为严重。</p>\n<p>对于常用的预测模型，通常是有预测的概率值，我们找到一个合适的截断点作为正负类别的界限。显然再不同的任务下，截断点选择是不同的。我们使用Precison 和Recall的新度量指标来针对特定任务下选择合适的截断值。</p>\n</blockquote>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>真实标签</th>\n<th>预测为正</th>\n<th>预测为反</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>正例</td>\n<td>TP</td>\n<td>FN</td>\n</tr>\n<tr>\n<td>反例</td>\n<td>FP</td>\n<td>TN</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>Precison(查准率)：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P = TP/(TP+FP)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Recall(召回率)：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R = TP/(TP+FN)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当正负样本不不均衡,人为修改测试集中的正负比例时, P-R曲线波动很大，但是ROC曲线变化很小。</p>\n</blockquote>\n<h2 id=\"ROC-曲线\"><a href=\"#ROC-曲线\" class=\"headerlink\" title=\"ROC 曲线\"></a>ROC 曲线</h2><blockquote>\n<p>可以研究学习器的泛化性能。</p>\n<h2 id=\"加图\"><a href=\"#加图\" class=\"headerlink\" title=\"加图\"></a>加图</h2><ul>\n<li>横坐标：真阳率，正例被正确预测的概率</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FPR = FP/(TN+FP)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>纵坐标：假阳率，负例被预测错误的概率<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TPR = TP/(TP+FN)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>==理解四点一线==</strong>：</p>\n<ul>\n<li>(0, 0):  FP = TP = 0, 所有样本预测为负</li>\n<li>(1, 1):  FP = TP = 1, 所有样本预测为正</li>\n<li>(1, 0):  FP = 1, TP = 0, 所有正样本预测为负</li>\n<li>(0, 1):  FP = 0, TP = 1, 完美预测</li>\n<li>对角线：随机猜测的值。</li>\n</ul>\n<h2 id=\"AUC值\"><a href=\"#AUC值\" class=\"headerlink\" title=\"AUC值\"></a>AUC值</h2><p>AUC(Area under Curve) 被定义为ROC曲线的下侧面积。一般在(0.5~1)之间。</p>\n<h3 id=\"计算方法\"><a href=\"#计算方法\" class=\"headerlink\" title=\"计算方法\"></a>计算方法</h3><ol>\n<li><p>几何角度</p>\n<blockquote>\n<p>直接计算曲线下的面积，梯形</p>\n</blockquote>\n</li>\n<li><p>概率角度</p>\n<blockquote>\n<p>任取一对正负样本对，正样本score大于负样本score的概率</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"python-实现\"><a href=\"#python-实现\" class=\"headerlink\" title=\"python 实现\"></a>python 实现</h3><p><a href=\"http://zhuzhuyule.xyz\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import numpy as np</span><br><span class=\"line\">from sklearn.metrics import roc_curve</span><br><span class=\"line\">from sklearn.metrics import auc</span><br><span class=\"line\">from time import time</span><br><span class=\"line\"></span><br><span class=\"line\"># y:     标签</span><br><span class=\"line\"># pred： 预测值</span><br><span class=\"line\">def myAUC(y, pred):</span><br><span class=\"line\"></span><br><span class=\"line\">    auc = 0.0</span><br><span class=\"line\">    p_list = []  # 正负例的索引</span><br><span class=\"line\">    n_list = []</span><br><span class=\"line\">    for i, y_ in enumerate(y):</span><br><span class=\"line\">        if y_ == 1:</span><br><span class=\"line\">            p_list.append(i)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            n_list.append(i)</span><br><span class=\"line\">    # 构成p-n对</span><br><span class=\"line\">    p_n = [(i,j) for i in p_list for j in n_list]</span><br><span class=\"line\">    </span><br><span class=\"line\">    pn_len = len(p_n)</span><br><span class=\"line\">    for tup in p_n:</span><br><span class=\"line\">        if pred[tup[0]] &gt; pred[tup[1]]:</span><br><span class=\"line\">            auc += 1</span><br><span class=\"line\">        elif pred[tup[0]] == pred[tup[1]]:</span><br><span class=\"line\">            auc += 0.5</span><br><span class=\"line\">    auc = auc/pn_len</span><br><span class=\"line\">    return auc</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 产生一组数据</span><br><span class=\"line\">y = np.array([1,0,0,0,1,0,1,0,])</span><br><span class=\"line\">pred = np.array([0.9, 0.8, 0.3, 0.1,0.4,0.9,0.66,0.7])</span><br><span class=\"line\"></span><br><span class=\"line\">## sklearn 结果</span><br><span class=\"line\">fpr, tpr, thresholds = roc_curve(y, pred, pos_label=1)</span><br><span class=\"line\"></span><br><span class=\"line\">tim = time()</span><br><span class=\"line\">print(&quot;sklearn AUC:&quot;,auc(fpr, tpr))</span><br><span class=\"line\">print(&quot;sklearn AUC time:&quot;, time()-tim)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## myAUC 结果</span><br><span class=\"line\">tim = time()</span><br><span class=\"line\">print(&quot;\\nmyAUC:&quot;,myAUC(y,pred))</span><br><span class=\"line\">print(&quot;myAUC time:&quot;, time()-tim)</span><br></pre></td></tr></table></figure>"},{"title":"计算机基础学习笔记","date":"2019-12-16T05:47:07.000Z","top":true,"_content":"\n# Computer-Basics-Notes-Links\n\n[github地址]( https://github.com/elgong/Computer-Basics-Notes-Links )\n\n# 学习笔记\n\n> 我在学习计算机基础的过程中整理了一部分笔记，但都比较零散，有些稍微连贯的内容已经整理为博客，而大部分还没来得及整理成md格式，我先整理出链接。为了尽可能的清晰展示笔记脉络，下文将分门别类的列出，有需要请自取。\n> 笔记内容大部分都是参考了网上的博客以及书籍，整理笔记的习惯也是刚刚养成的，从开始整理笔记后，发现自己对于做过的东西，能够随着笔记很快的回忆起来，遇到一些问题能够快速从笔记里找到答案也是比较舒服的。笔记是用有道云分享的，我未来仍然会继续梳理这些笔记，如果有任何的错误或者意见，麻烦您联系我哈。\n\n## 第一章  计算机基础篇\n\n> 基础部分是一些语言相关的知识点。\n\n### 1.1 Java 相关\n\n#### 面向对象\n\n- [Java面向对象-多态](http://note.youdao.com/noteshare?id=f869167b77cb73b67478290ffdcf45bc&sub=06694CB1F00B45CBA1D4BD1A4B62320C)\n\n#### 部分源码分析\n\n- [java.lang.Object 类](http://note.youdao.com/noteshare?id=def11ef6e833a11434137d6fec1c834a&sub=DD0083BFCFE14839A721700413B41F38)\n\n- [java.lang.Integer等基本类型包装类](http://note.youdao.com/noteshare?id=fb941f5b4a01adf474496df328542a91&sub=02C7EDC387984E3BADE744B9280EA1E6)\n\n#### 接口和抽象类\n\n- [接口和抽象类的概念](http://note.youdao.com/noteshare?id=7bdd684a91766f6b448e5328f1fed251&sub=0DEE02584D22485EACF337D5F846ACCE0)\n\n- [java.io.Serializable接口](http://note.youdao.com/noteshare?id=eb3b5e1f37828c301015c1fcc48b2ee9&sub=B77DF9D467AE48948C63CEE6D7B51FB5)\n\n- [java.lang.AbstractStringBuilder](http://note.youdao.com/noteshare?id=af26732dc5f501e490a3f57c6b46333c&sub=1E9132AF928342728B68D66845201D05)\n\n- [java.lang.CharSequence接口](http://note.youdao.com/noteshare?id=62429dcbeb51676d855b0c46d89ea67b&sub=7D9CC78E517B46A19C567A567DDA0C1E)\n\n- [java.lang.Comparable 接口](http://note.youdao.com/noteshare?id=4309c54f9e557075dc953a25a1e9aea4&sub=4AF6A4102AD6494F884069B5F75DB663)\n\n- [java.lang.Iterable 接口](http://note.youdao.com/noteshare?id=d7525d979bbcfac0ad602e0f90124a39&sub=9B8E20EC1E924C988EB9DEC3C059FE4F)\n\n#### 集合类\n\n- [Java集合的结构](http://note.youdao.com/noteshare?id=3f13ce83c60473cb2d03ac7d500b3771&sub=77608E57EC404A3D925D5BADFABA9F0C)\n\n- [java.util.Arrays工具类](http://note.youdao.com/noteshare?id=8d5718ecf80ea7c1cd144c848afb556f&sub=D12BF9FEA9B54873871F5BDC532FB46A)\n\n- [java.util.Collections 工具类](http://note.youdao.com/noteshare?id=55f2b8f2004cc365aa3200283f918642&sub=373C38673F3D4233869F2FA181CF6C77)\n\n- [集合类之间的转换](http://note.youdao.com/noteshare?id=2d1b0ca8f6ee80acab26bac64e65752b&sub=BC00717F11EC48DBAA3187C99E27FB67)\n\n##### Collection\n\n- [java.util.Collection 接口](http://note.youdao.com/noteshare?id=cf4402932c37eeda65d2cb48b771fa85&sub=38A358238D644B009E8D35E85BC3958A)\n\n- [java.util.List 接口](http://note.youdao.com/noteshare?id=35066dabdc8838cbf4a81a6064d3a278&sub=B08F3371DAF94E0A8577E14A355948F7)\n\n- [java.util.ArrayList 类](http://note.youdao.com/noteshare?id=ac00534071924ed6812c3087ff89522d&sub=7CF204D01C2846469F874ABE719F122E)\n\n- [java.util.LinkedList 类](http://note.youdao.com/noteshare?id=24e53ad8811d97e37ae725caef30e87c&sub=3580B9F523B14B9A8346594FAB7428B7)\n\n- [java.util.Vector类-线程安全](http://note.youdao.com/noteshare?id=3fefcc71bac40f731582cda7de9680a9&sub=FD48F85901CA48C2A1FDBFB356072932)\n\n- [java.util.Stack类-线程安全](http://note.youdao.com/noteshare?id=7ca967ab85ba51315d576614e4debb88&sub=D7FB8F63F9524697A2B6C92EBC997759)\n\n- [java.util.Queue 接口](http://note.youdao.com/noteshare?id=e69b12c5f34e8999a63f901e66cf6349&sub=378BBC5185DD4901949BA8D6CC586117)\n\n- [java.util.Deque 接口](http://note.youdao.com/noteshare?id=70bcfde9362d131a6cc9769df7c6a195&sub=4CCDF46A03F64701B726C3B5B17EE5C7)\n\n- [java.util.ArrayDeque 类](http://note.youdao.com/noteshare?id=a8e52263383bbff56bba83c4437e62a5&sub=273730F39B6345348B400731471932CD)\n\n- [java.util.PriorityQueue 类](http://note.youdao.com/noteshare?id=d5807c6cbb3dfcd1c6a6fa2587f2a53a&sub=8DB19EF833FF477C8241702AB6C728D4)\n\n- [java.util.Set 接口](http://note.youdao.com/noteshare?id=78367406564a757c47fbb5fd74ab4118&sub=CD2FAD0FE2EE433EAFEB76285A06D389)\n\n- [java.util.HashSet 类](http://note.youdao.com/noteshare?id=473ccb760a498a837a6fca3373b1f6d1&sub=EF96DCB65AD1431BBCFBB52F21896643)\n\n##### Map\n\n- [java.util.Map 接口](http://note.youdao.com/noteshare?id=8066dded44e4cba4a621fe78ed94c4a9&sub=B9652D8B6D7940FFB5C92A5106BCC277)\n\n- [java.util.TreeMap 类](http://note.youdao.com/noteshare?id=de517d176afdc4e3d0c9887c437bee17&sub=459B4CAF65FF4D67BFBE91DCED6E050E)\n\n- [java.util.HashMap 类](http://note.youdao.com/noteshare?id=791e29ca757ab1dedb8f80d872c940b1&sub=70D9B6BA82AF4889ACAD0A52F18C456D)\n\n- [java.util.HashSet 类](http://note.youdao.com/noteshare?id=473ccb760a498a837a6fca3373b1f6d1&sub=EF96DCB65AD1431BBCFBB52F21896643)\n\n\n\n\n\n#### IO 模型与IO流\n\n- [标准步骤：](http://note.youdao.com/noteshare?id=658c32dde4ecf6c8525649914d0f8560&sub=FF09583558E14D2BA25680647013CBA3)\n\n- [针对oj系统中的输入问题](http://note.youdao.com/noteshare?id=3dec994dd95a401eed7aabdfb1c5c15f&sub=CAB6771BB0F044F895A705B8AB7514BC)\n\n- [java IO之AutoCloseable接口](http://note.youdao.com/noteshare?id=1a496522d91fa47b4f3132aa97228ab7&sub=CD032B0A9E714FE9ABB2BE05B49CEE75)\n\n- [IO篇1-Java IO模型](http://note.youdao.com/noteshare?id=e496eb1243c65be077e6193400f6209d&sub=5594861B9BE845BFAFB4BD14D7DE49D4)\n\n- [IO篇2-Java NIO](http://note.youdao.com/noteshare?id=8ef12e2d0ce1d93b444eb430ba110fe3&sub=B6822523990E474D869C822BFCD5DFB2)\n\n- [IO篇3-Java NIO 零拷贝](http://note.youdao.com/noteshare?id=2e291882966fc1b4d7f3efafdd39d32e&sub=CE23D5FE57DC45709F74AFEB3A49F22E)\n\n- [IO篇4-Linux 内核的 select&epoll](http://note.youdao.com/noteshare?id=07cbfb2c33782cd85f62e05ff298740d&sub=CC14B7D2EBB64930A3E7E8C4241EBD83)\n\n#### 多线程与并发\n\n- [synchronized 锁的JVM中实现原理-偏向](http://note.youdao.com/noteshare?id=b7407e24b468fd58df564afcbf749183&sub=954EE84618B44B6FAFE4931E4F691873)\n\n- [线程的创建](http://note.youdao.com/noteshare?id=0f69c79fd2c666de113882fd3ac72abf&sub=61118765FB1F4B85B048C652460A5768)\n\n- [线程间的通信](http://note.youdao.com/noteshare?id=49735f35157748a107270cb85fbb867c&sub=0D34816A0AA24981B0B61EB87A64C8D4)\n\n- [线程的生命周期](http://note.youdao.com/noteshare?id=12aac80f35ab764277a810af76852cb2&sub=4A4D685F065F46B9B60D9703CEE04D29)\n\n- [对象和变量的并发访问（可见性，原子性)](http://note.youdao.com/noteshare?id=8d401fdafcc6c5712042fa06f6e3850b&sub=96CD2BBFE5914F089493A803A5B7D020)\n\n- [java.util.concurrent.locks包 ](http://note.youdao.com/noteshare?id=ed1aa8d1cf7688f52c1598735165a2dc&sub=15233B8FCFFB4E11AC6167CE4BF4077E)\n\n- [J.U.C多线程1-Executor 框架的梳理](http://note.youdao.com/noteshare?id=291668d9a729451d6c913b3137c9640f&sub=B28DDF08EC1F4457BFF740A9D8869FE5)\n\n- [J.U.C多线程2-ThreadPoolExecutor线程](http://note.youdao.com/noteshare?id=5b0658b7d6383586ef61f9c80ef3d249&sub=CE01D9FD424D45BCA78F88E1A0149C0D)\n\n- [实现BlockingQueue接口的阻塞队列](http://note.youdao.com/noteshare?id=cb9e9ac4838bfdbb7e23f67711f2a84a&sub=859FFFFB9E664A18BB2DBE355F094405)\n\n- [J.U.C多线程3-CAS比较和交换 ](http://note.youdao.com/noteshare?id=19714d2d692039c32ebba2ee3e4829e0&sub=2F7585F44D7E4DBE84E9487A24766668)\n\n- [J.U.C多线程3-AQS 同步器框架的梳理](http://note.youdao.com/noteshare?id=6a89441511d69a3bced7209ba47b736b&sub=4A1DC26FB09D4E0C9D6086E37FDEAD6B)\n\n- [J.U.C多线程4-AQS框架的应用](http://note.youdao.com/noteshare?id=4ef9100e71f2628636a4bff9b73fe882&sub=7998ABD160384F36A606B72FB7493232)\n\n\n\n#### 其他\n\n- [泛型（泛型接口、泛型类、泛型方法）](http://note.youdao.com/noteshare?id=d30458d5aac2da6b78824e51dbd982a5&sub=1C451DD2DB6F4481AB58D42E0AA63C44)\n\n- [字符串类型-String,StringBuilder](http://note.youdao.com/noteshare?id=d7092de3662bbf7b0d73b15313fbab0f&sub=95A433A8DC2A4E6FBCF8B54D4767BC40)\n\n- [java 编码规范- google](http://note.youdao.com/noteshare?id=9b7abb4a2896be59b9ed6629d028a5c6&sub=4C6D630F214D45DCA01450F1907C6266)\n\n- [Java8- Lambda 表达式](http://note.youdao.com/noteshare?id=a3af60be0ecf53e817c4954ab4b3f2dd&sub=80F0D1E1017E4522B63882A48BE17CF2)\n\n- [动手实现ArrayList](http://note.youdao.com/noteshare?id=29117a52793f44078077602c6f47252f&sub=9B5D88DF10A94DCD968EA4C8263241C9)\n\n- [java 知识点梳理](http://note.youdao.com/noteshare?id=893e0088e06c4e3cd1073a6abeb7bda4&sub=AE4EBC77232149368BEFD526D435B452)\n\n- [Java 刷题遇到的问题](http://note.youdao.com/noteshare?id=2b866c01ebed8c2f6594e3357ae349be&sub=AA305E3F95724374B5A3C5D96D654270)\n\n- [基本数据类型and 初始化](http://note.youdao.com/noteshare?id=7c544d8a0a428eb5c142c36e771c5fac&sub=1DE4594384FD444F9C705D73C3A26556)\n\n\n\n#### jvm 虚拟机\n\n- [jvm1-内存模型-运行时数据区](http://note.youdao.com/noteshare?id=4be4640b0d30a46e8e4936fca48fc4da&sub=E4ACF7E445F4469FB7C49A184325AA3A)\n\n- [jvm2-类加载机制](http://note.youdao.com/noteshare?id=044b5c8d572a50aa43f7476075feacd6&sub=CB5ACEE22D7C4B119E920A983456E348)\n\n- [jvm3-对象的创建过程](http://note.youdao.com/noteshare?id=38a77fc1b5541c7443a42bb8936ad699&sub=AC6273A6423A45D49DF9D7BA2C02D087)\n\n- [jvm4-垃圾回收机制 ](http://note.youdao.com/noteshare?id=85b9df0570061425d77cd09d542758a3&sub=C25619379B2547F5A492FB6900FA53F9)\n\n- [自定义类加载器实现热部署，热替换](http://note.youdao.com/noteshare?id=3f927397764ecb9a72e25d53d1a8447e&sub=DB8BF7AF904E4224A287A4B22D114460)\n\n\n\n#### 其他\n\n- [反射](http://note.youdao.com/noteshare?id=6f70c51df350a1da3b7353b5f0876ba1&sub=A890AA4181A64A17B14D21040C1A9724)\n\n- [Java 动态代理](http://note.youdao.com/noteshare?id=cfb346b9be695d57572367fd3143531e&sub=DE178E988586406F87227AC75BD725CE)\n\n\n\n\n### 1.2 数据库相关\n\n#### 数据库的安装\n\n- [windwos 环境中 mysql 数据库安装](http://note.youdao.com/noteshare?id=eec529b536dfe09cbbb2d2305a9cec2c&sub=DB98C14DBC15458ABE1B8461CD4C6988)\n\n- [ubuntu 环境中 mysql 安装](http://note.youdao.com/noteshare?id=32e1a61698644f735e5ae33a0d285bee&sub=WEB845b970c5cb400fcf42e04843dbd70af)\n\n#### 学习笔记\n\n- [JDBC 使用](http://note.youdao.com/noteshare?id=c98cc599b42b416ea2bd0aec7fd11fff&sub=833E6D40B97E4F2F98EFD56C010FE4C7)\n\n- [mysql必知必会](http://note.youdao.com/noteshare?id=71dd174ad72a6cca26ae011637d4a705&sub=E3BE9112006D4380953846BA1E446964)\n\n- [数据库-三大范式](http://note.youdao.com/noteshare?id=4d74a6536781f195ffb428a0aa74fabe&sub=9A407FE68AB54120B18950BEE5500BAF)\n\n- [数据库ER图基础](http://note.youdao.com/noteshare?id=78c16d370ba2bf4d06fd1d253072d582&sub=6B15DEFDC24B4353A5820B68A5FB2C05)\n\n- [mysql必知必会1-DDL数据定义语言](http://note.youdao.com/noteshare?id=f0c534778c8fde528be10f4ffdb2c03b&sub=336222838CDC4F249C1210E24D3701AD)\n\n- [mysql必知必会2-DML数据操作语句](http://note.youdao.com/noteshare?id=360395368205af6b9cd43b67c17200af&sub=3BAEE4ACEA0F4FC2A40AB4DC39965766)\n\n- [mysql必知必会3-TCL事务控制语言](http://note.youdao.com/noteshare?id=3a8535b5bdf8fbe6b46b85a8f6ab707e&sub=0C9D47245F604624A95E1982D45157F2)\n\n- [mysql必知必会4-数据类型和约束](http://note.youdao.com/noteshare?id=5a66c81500067c3bafc11fb31cc56cd6&sub=6ADA92683A36438EB254D18AE729A6FA)\n\n- [mysql必知必会5-视图](http://note.youdao.com/noteshare?id=8b1f73787548684951c21dea07576331&sub=E95C55AAF40F4378B7A14176911B4B81)\n\n- [mysql必知必会6-变量，存储过程，函数....](http://note.youdao.com/noteshare?id=d71e1773bdfb453b885ec8280980823e&sub=B0AFAE28DCC94DF09AE25F420927921E)\n\n- [mysql必知必会7](http://note.youdao.com/noteshare?id=71dd174ad72a6cca26ae011637d4a705&sub=E3BE9112006D4380953846BA1E446964)\n\n- [索引优化1-索引的概念 ](http://note.youdao.com/noteshare?id=003c0cce526f2a71945614993d250377&sub=56317DB968F04FE3BCC0D482D083C877)\n\n- [索引优化2-Mysql索引的底层实现 ](http://note.youdao.com/noteshare?id=a527e1fa83cc6b429814c2f8710b891c&sub=9B9BDA5A138144B5A5A5E5C4BE6CE1D1)\n\n- [索引优化3- explain 查看执行计划 ](http://note.youdao.com/noteshare?id=f35d29b727ca3a228bfad4aac0a9e9e6&sub=53F88FCDB69547E895DAD25A7D402035)\n\n- [Sql语句优化-查询截取分析 ](http://note.youdao.com/noteshare?id=a83b6505ac7dbb6b3c69afd1860b8ccb&sub=C419B2D7DA254E589E0F449A60544A1C)\n\n- [mysql-数据库锁的机制和原理 ](http://note.youdao.com/noteshare?id=f8935a502a43186c1c821ad33ccc2c6d&sub=5D286DE5F8304B8BA7290255DBF15C0C)\n\n\n\n\n\n### 1.3 计算机网络相关\n\n- [互联网协议入门1-模型分层](http://note.youdao.com/noteshare?id=92e3adba9198d367e976bcc3f772d149&sub=7F7B0D8B9F3E4D7996815384809C35EA)\n\n- [互联网协议入门2-访问网页的过程](http://note.youdao.com/noteshare?id=8c41ad2717d4deee47f83841e49d755b&sub=C0C042EE387F4A0096F427CE6F391887)\n\n- [互联网协议入门3-TCP协议详细内容](http://note.youdao.com/noteshare?id=e7f3f660c5df2335b7eccb7be89ce514&sub=A775AFCC161A4388859120A340BDC6CB)\n\n- [互联网协议入门4-Http协议（应用层)](http://note.youdao.com/noteshare?id=71031b3ed61c6e8bd302a8577f6c396f&sub=0F5DF1F408844E7184F3A6BB5F868F89)\n\n### 1.4 Python 相关\n\n- [Anaconda 使用](http://note.youdao.com/noteshare?id=398da3b52370f6976e9a67cb3be4cd24&sub=WEBf9be5147ccbf73c569b46bb2a5ffe942)\n\n- [python 性能优化](http://note.youdao.com/noteshare?id=a813207158a22cfa902dbeba640bdf87&sub=E61484FE7B0D4D999DF1A462FA780049)\n\n- [python 内存管理](http://note.youdao.com/noteshare?id=dde4ed2eb6eea6c45926d251689e3d4e&sub=4A1EA0D89E634DEC9DD294C13012EFCA)\n\n- [python 包管理](http://note.youdao.com/noteshare?id=9146e0886cac1bdaec8cce2e5081cfe0&sub=060F7616DF954602BB641EC52D0F6110)\n\n- [知识积累](http://note.youdao.com/noteshare?id=3724fe43398de6c5fbd75dd8c452987e&sub=7837405EB49045FF8C22156022261A94)\n\n- [python 数据模型](http://note.youdao.com/noteshare?id=bfbf2eb0c5bccf64974fe260e1bdf131&sub=A8906CE9DF0E47F19377CD49BF2DFA6F)\n\n- [Set 集合  交并差运算](http://note.youdao.com/noteshare?id=0f7309f661031855b1e257072ceab9b9&sub=E6CAEE5B6F7043779DF1F3A95923DC0F)\n\n#### pandas 包\n\n- [pandas](http://note.youdao.com/noteshare?id=f191fc11a263f303532d40c02c1f2161&sub=3F6F9858E4DA4B7A9245F66557B15AB4)\n\n- [pandas-1数据结构](http://note.youdao.com/noteshare?id=64c2febf14a2e0f96bcbc868375500b9&sub=0B21232330E442118F68ADFB44DECA6E)\n\n- [pandas-2索引和选择数据](http://note.youdao.com/noteshare?id=7b8a86d71c5321171292fa000666efc8&sub=A1102303D97F4E2D836A588F4882C5E2)\n\n- [pandas-分层和多级索引](http://note.youdao.com/noteshare?id=02c6e6a9916d2f600153fa5402395c29&sub=0CF2D73FB22140A29F3838CF6EF299B9)\n\n- [pandas-4分组与聚合](http://note.youdao.com/noteshare?id=b8d6c15c3d603261cee9b6771732c5a5&sub=WEB9f17e5d4ecb0520c9c27c8145f3450dc)\n\n- [pandas-5缺失值处理](http://note.youdao.com/noteshare?id=57496ba2051b12d778ac17612d871354&sub=62AE7AB578AF4B3A9D630676179C8CA0)\n\n- [pandas-6重复值处理](http://note.youdao.com/noteshare?id=f16646b876ddb2c5ec482e316ca881dd&sub=8024BDCE94B4455FA20514234C7233C0)\n\n- [pandas-7时间处理](http://note.youdao.com/noteshare?id=5210591266c5f2472eab6bdb0e1adc7e&sub=7B85239BB0C74343830F3EBBC34F43A0)\n\n\n### 1.5 数据结构与算法相关\n\n#### 链表\n\n- [链表入门-单链表](http://note.youdao.com/noteshare?id=77d45fd3df6dc9821a505972246afc67&sub=CBBC8BE4E72147248464A2C136D8A893)\n\n- [双向链表](http://note.youdao.com/noteshare?id=2038af6c36c144a0005d3f7cb7cbd6e1&sub=19BC0DEA04654C51970F77E363746D36)\n\n#### 树结构\n\n- [树结构1-二叉树的种类 ](http://note.youdao.com/noteshare?id=3d87798249099424c8f688932e054d34&sub=962de575938af485eb5896712a3fa88bhttp://note.youdao.com/noteshare?id=3d87798249099424c8f688932e054d34&sub=962de575938af485eb5896712a3fa88b)\n\n- [树结构2-二叉树的四种遍历](http://note.youdao.com/noteshare?id=a93bf51802eb22ed23e7f01baeecdfd9&sub=C2561C42F8354E2787F3F58DC19CC2F5)\n\n- [树结构3- 二叉排序树 ](http://note.youdao.com/noteshare?id=6595e3f3a04494d53c79ac4f14156b45&sub=36364C54AB334D5B85B1871D6758FFF7)\n\n- [树结构4- 完全二叉树-堆排序 ](http://note.youdao.com/noteshare?id=ff1c7f5f5c5439a5bcf29746bafacd8e&sub=524DD42459CF4A43AB7CD89A74D83BAB)\n\n- [树结构5-红黑树 ](http://note.youdao.com/noteshare?id=28a1554677d3108539d237ed2dbfb3a9&sub=6917ECACABFC4BE99B0840940E1492C3)\n\n\n#### 栈\n\n- [栈 - Stack](http://note.youdao.com/noteshare?id=32bb87989cc88c68f94b697a2309e577&sub=CB4F1BAE4B48482B895E4B334EC920B7)\n\n#### 动态规划\n\n- [动态规划-DP](http://note.youdao.com/noteshare?id=2bf63868f3e17320b15a68783a6f1d89&sub=35032594A3AB441EB7DB3344B71213EF)\n\n- [DFS和回溯算法- 暴力搜索的优化方案](http://note.youdao.com/noteshare?id=47da45a5509c7f21f5905c65ec87c12d&sub=E525698B083343B382EFC767181A2755)\n\n#### 一般算法\n\n- [二分查找](http://note.youdao.com/noteshare?id=6139197ff7cc443d83b73f578ced01d2&sub=3671B7672DA341359DF0C57DAA5114E3)\n\n- [最大公约数与最小公倍数](http://note.youdao.com/noteshare?id=417cd36012151f1465f6b179a68c2559&sub=39B0B9975CC34C589CCCF7A4A619E921)\n\n- [素数和合数](http://note.youdao.com/noteshare?id=b9bb5b1c7a7f968392ca087beb53a288&sub=7AC07884471A4FFBAC433400CC8DD668)\n\n- [排序算法-Java版](http://note.youdao.com/noteshare?id=900f90e3d481dcabbd5ce22df8452e4b&sub=2A9F48EDC9824721A63091F213AE84DF)\n\n- [蓄水池采样算法](http://note.youdao.com/noteshare?id=34e1f4c6bbc849e28017b14d1aa1ed3d&sub=04B030FDEA424189A387F2B149670138)\n\n\n### 1.6 设计模式\n\n- [单例模式](http://note.youdao.com/noteshare?id=9b725da8bd83d6d2fa6628449036fa76&sub=61D7D7C472CC4F6FA40978D2EEE3F253)\n\n- [汇总 ](http://note.youdao.com/noteshare?id=3258d6710e66d885a3a213d45eea14be&sub=9E8B81697FD248EDBAAB8B203ACDD4B9)\n\n\n\n## 第二章  计算机提高篇\n\n> 提高篇是一些具体的学习方向，我学的比较杂。\n\n### 2.1 机器学习与数据挖掘\n\n- [特征工程中的问题](http://note.youdao.com/noteshare?id=a2a581480ef2d48c22c8972e2c1289ea&sub=WEBe5a19e45418f24614a27d5c871dbeef6)\n\n#### 决策树\n\n- [决策树-1基本概念](http://note.youdao.com/noteshare?id=72d77f019bd4fc8cde5d77f1479213a3&sub=3A0C8DB3DE554ED5B70179B18DEBDB6F)\n\n- [决策树-2 ID3算法](http://note.youdao.com/noteshare?id=6b4b7d196688d64889da3563eb4b194d&sub=E48B826F34CB41769382CA5DD11DE54F)\n\n- [决策树-3 CART分类回归树](http://note.youdao.com/noteshare?id=51ba5d9d9611ae2284c2612d5f38b721&sub=C40D67A492D4428EB698D146897932F2)\n\n- [CART 分类回归树](http://note.youdao.com/noteshare?id=8fd42b53e1a611131199f17d399820c7&sub=F7FA6EBCE1CC4A95875DD83B2CF9C551)\n\n- [sklearn 决策树使用技巧](http://note.youdao.com/noteshare?id=d5d006e5d1680bb1b93f6cdc68973b60&sub=C12A5DC3350C49CA8862D51287908CE4)\n\n- [sklearn整理-决策树](http://note.youdao.com/noteshare?id=3a209c356ed655acacf08699cef27150&sub=E0880A97A8264449BD714025A98BFE52)\n\n#### 神经网络\n\n- [常见的神经网络](http://note.youdao.com/noteshare?id=d1d1a974ade3ab72cd8ff9fbab061e78&sub=6C8F11DB78FA417AA9F4D0DA30351077)\n\n#### 集成学习\n\n- [集成学习提升算法-Adaboost](http://note.youdao.com/noteshare?id=fb4b442794aac472bdd7663b026a2dab&sub=939B2AAEB6F94E32ABAD4A54B8AF1358)\n\n- [XGBoost -python package introduction](http://note.youdao.com/noteshare?id=eb03f9b12281363b052e0ed071833b13&sub=WEBb2a9d589fb05754f76c2b2af09a826c1)\n\n- [梯度提升树-GBDT](http://note.youdao.com/noteshare?id=2039180d0a9ad5b39339c93e8c70040d&sub=9C48D93E6A1E4C1186E6F37EF222F528)\n\n- [sklearn整理-集成学习-随机森林](http://note.youdao.com/noteshare?id=e4ac54bae64eb94641594ad5f4a2cd6d&sub=8232CAC65C0A4FDC9EDED033B6A4770F)\n\n#### 模型评价\n\n- [ROC与AUC](http://note.youdao.com/noteshare?id=c76dbbe346dbd32a62cd4303f7bf4864&sub=753D4CFE21084BA78B0506697A415A0C)\n\n- [机器学习的方差与偏差](http://note.youdao.com/noteshare?id=030f5d8884e6a0914891ebf2289318fa&sub=28D75EDB51044316AB154021B0EB6BEA)\n\n#### 参与的一些竞赛\n\n- [ali-新人实战赛o2o优惠券使用预测](http://note.youdao.com/noteshare?id=1d8176b82fc84b0a3906fbd53979041c&sub=305B25CE269F45DCA311DBE8C20DAF67)\n\n\n- [ccf-2019](http://note.youdao.com/noteshare?id=5b2fa1c8320743190649812b394b3ed5&sub=27291314B2C74B09ABF8619277EE8A5E)\n\n- [dc-2019-商品购买转化率预测](http://note.youdao.com/noteshare?id=52c517d38463d99b24672f0195ecabfe&sub=WEBf24a84a951b3b16a0685ed029a28b960)\n\n- [竞赛提升方法-tricks](http://note.youdao.com/noteshare?id=2fd9687a7cb8c10210bf738536dd8021&sub=AE7E1B49101546F093C7C2B993A736A3)\n\n\n- [sklearn 脑图](http://note.youdao.com/noteshare?id=f43a977d8705582da02c202f295dadcc&sub=74C22A94ABB74B309807A886F50A5863)\n\n### 2.2 大数据与Hadoop\n\n#### 多台机器的分布式环境安装\n\n- [1.hadoop分布式集群安装](http://note.youdao.com/noteshare?id=e284c332fb9766d6487d925c4381ae22&sub=E4980D34F8A347DC9C1E2C23C5A48D17)\n\n#### RPC\n\n- [Hadoop RPC](http://note.youdao.com/noteshare?id=773c4878eaec8cc266c5074691a3d780&sub=68CE094D754C46CDA96C8CFA00401DF2)\n\n#### mapreduce 实验\n\n- [实验1.  多表关联](http://note.youdao.com/noteshare?id=710757567d678841cb43e891531c63b9&sub=BA97FAC420754425A2FE07E67D6B6EAD)\n\n- [实验2.  最高温度统计](http://note.youdao.com/noteshare?id=7c251c3514764eb58fdad72de78bf6a5&sub=FF9F53C4D1A04E008FA61A85A9CE0F01)\n\n- [实验3.  单表关联](http://note.youdao.com/noteshare?id=226bf0abd5e44ed6eae69f5250024bcf&sub=5EE9A40650BB4AD2A661C65DFBC57FC5)\n\n\n### 2.3 VUE\n\n#### VUE 安装\n\n- [开发环境搭建](http://note.youdao.com/noteshare?id=c60a733187bef04fa0404429eb2d1f30&sub=3F4FE35DF8E349A395F8C4C19AA7BBE4)\n\n### 2.4 Spring 框架\n\n- [Spring-1控制反转（IOC）和依赖注入](http://note.youdao.com/noteshare?id=7181c4a539cade23a864c8e970b05833&sub=771654DC28474896BAB711DD289A052C)\n\n- [Spring-2AOP 面向切面编程-基于动态代](http://note.youdao.com/noteshare?id=32da7b7e487b45fd4fde7906fb9436a1&sub=BAF8F0AE43DB42B399AC14B01FE74689)\n\n- [Spring-3事务管理Transaction Manager](http://note.youdao.com/noteshare?id=2caa6adcf719adaba44ad57fcad131e4&sub=8E30EF145E8A4972867B5476DF2DD607)\n\n\n## 第三章  工具使用\n\n- [vscode 使用记录](http://note.youdao.com/noteshare?id=82f292615812b23fec6c7ce9fcc35ec4&sub=6FC7D088767948388F03769F13A2C971)\n\n\n\n## 第四章  收藏的书籍\n\n- [书籍收藏](http://note.youdao.com/noteshare?id=57e1d26f1f078dc70a5b18392b29a841)\n\n","source":"_posts/计算机基础学习笔记.md","raw":"---\ntitle: 计算机基础学习笔记\ndate: 2019-12-16 13:47:07\ncategories: 计算机基础梳理\ntags: 学习笔记\ntop: True\n---\n\n# Computer-Basics-Notes-Links\n\n[github地址]( https://github.com/elgong/Computer-Basics-Notes-Links )\n\n# 学习笔记\n\n> 我在学习计算机基础的过程中整理了一部分笔记，但都比较零散，有些稍微连贯的内容已经整理为博客，而大部分还没来得及整理成md格式，我先整理出链接。为了尽可能的清晰展示笔记脉络，下文将分门别类的列出，有需要请自取。\n> 笔记内容大部分都是参考了网上的博客以及书籍，整理笔记的习惯也是刚刚养成的，从开始整理笔记后，发现自己对于做过的东西，能够随着笔记很快的回忆起来，遇到一些问题能够快速从笔记里找到答案也是比较舒服的。笔记是用有道云分享的，我未来仍然会继续梳理这些笔记，如果有任何的错误或者意见，麻烦您联系我哈。\n\n## 第一章  计算机基础篇\n\n> 基础部分是一些语言相关的知识点。\n\n### 1.1 Java 相关\n\n#### 面向对象\n\n- [Java面向对象-多态](http://note.youdao.com/noteshare?id=f869167b77cb73b67478290ffdcf45bc&sub=06694CB1F00B45CBA1D4BD1A4B62320C)\n\n#### 部分源码分析\n\n- [java.lang.Object 类](http://note.youdao.com/noteshare?id=def11ef6e833a11434137d6fec1c834a&sub=DD0083BFCFE14839A721700413B41F38)\n\n- [java.lang.Integer等基本类型包装类](http://note.youdao.com/noteshare?id=fb941f5b4a01adf474496df328542a91&sub=02C7EDC387984E3BADE744B9280EA1E6)\n\n#### 接口和抽象类\n\n- [接口和抽象类的概念](http://note.youdao.com/noteshare?id=7bdd684a91766f6b448e5328f1fed251&sub=0DEE02584D22485EACF337D5F846ACCE0)\n\n- [java.io.Serializable接口](http://note.youdao.com/noteshare?id=eb3b5e1f37828c301015c1fcc48b2ee9&sub=B77DF9D467AE48948C63CEE6D7B51FB5)\n\n- [java.lang.AbstractStringBuilder](http://note.youdao.com/noteshare?id=af26732dc5f501e490a3f57c6b46333c&sub=1E9132AF928342728B68D66845201D05)\n\n- [java.lang.CharSequence接口](http://note.youdao.com/noteshare?id=62429dcbeb51676d855b0c46d89ea67b&sub=7D9CC78E517B46A19C567A567DDA0C1E)\n\n- [java.lang.Comparable 接口](http://note.youdao.com/noteshare?id=4309c54f9e557075dc953a25a1e9aea4&sub=4AF6A4102AD6494F884069B5F75DB663)\n\n- [java.lang.Iterable 接口](http://note.youdao.com/noteshare?id=d7525d979bbcfac0ad602e0f90124a39&sub=9B8E20EC1E924C988EB9DEC3C059FE4F)\n\n#### 集合类\n\n- [Java集合的结构](http://note.youdao.com/noteshare?id=3f13ce83c60473cb2d03ac7d500b3771&sub=77608E57EC404A3D925D5BADFABA9F0C)\n\n- [java.util.Arrays工具类](http://note.youdao.com/noteshare?id=8d5718ecf80ea7c1cd144c848afb556f&sub=D12BF9FEA9B54873871F5BDC532FB46A)\n\n- [java.util.Collections 工具类](http://note.youdao.com/noteshare?id=55f2b8f2004cc365aa3200283f918642&sub=373C38673F3D4233869F2FA181CF6C77)\n\n- [集合类之间的转换](http://note.youdao.com/noteshare?id=2d1b0ca8f6ee80acab26bac64e65752b&sub=BC00717F11EC48DBAA3187C99E27FB67)\n\n##### Collection\n\n- [java.util.Collection 接口](http://note.youdao.com/noteshare?id=cf4402932c37eeda65d2cb48b771fa85&sub=38A358238D644B009E8D35E85BC3958A)\n\n- [java.util.List 接口](http://note.youdao.com/noteshare?id=35066dabdc8838cbf4a81a6064d3a278&sub=B08F3371DAF94E0A8577E14A355948F7)\n\n- [java.util.ArrayList 类](http://note.youdao.com/noteshare?id=ac00534071924ed6812c3087ff89522d&sub=7CF204D01C2846469F874ABE719F122E)\n\n- [java.util.LinkedList 类](http://note.youdao.com/noteshare?id=24e53ad8811d97e37ae725caef30e87c&sub=3580B9F523B14B9A8346594FAB7428B7)\n\n- [java.util.Vector类-线程安全](http://note.youdao.com/noteshare?id=3fefcc71bac40f731582cda7de9680a9&sub=FD48F85901CA48C2A1FDBFB356072932)\n\n- [java.util.Stack类-线程安全](http://note.youdao.com/noteshare?id=7ca967ab85ba51315d576614e4debb88&sub=D7FB8F63F9524697A2B6C92EBC997759)\n\n- [java.util.Queue 接口](http://note.youdao.com/noteshare?id=e69b12c5f34e8999a63f901e66cf6349&sub=378BBC5185DD4901949BA8D6CC586117)\n\n- [java.util.Deque 接口](http://note.youdao.com/noteshare?id=70bcfde9362d131a6cc9769df7c6a195&sub=4CCDF46A03F64701B726C3B5B17EE5C7)\n\n- [java.util.ArrayDeque 类](http://note.youdao.com/noteshare?id=a8e52263383bbff56bba83c4437e62a5&sub=273730F39B6345348B400731471932CD)\n\n- [java.util.PriorityQueue 类](http://note.youdao.com/noteshare?id=d5807c6cbb3dfcd1c6a6fa2587f2a53a&sub=8DB19EF833FF477C8241702AB6C728D4)\n\n- [java.util.Set 接口](http://note.youdao.com/noteshare?id=78367406564a757c47fbb5fd74ab4118&sub=CD2FAD0FE2EE433EAFEB76285A06D389)\n\n- [java.util.HashSet 类](http://note.youdao.com/noteshare?id=473ccb760a498a837a6fca3373b1f6d1&sub=EF96DCB65AD1431BBCFBB52F21896643)\n\n##### Map\n\n- [java.util.Map 接口](http://note.youdao.com/noteshare?id=8066dded44e4cba4a621fe78ed94c4a9&sub=B9652D8B6D7940FFB5C92A5106BCC277)\n\n- [java.util.TreeMap 类](http://note.youdao.com/noteshare?id=de517d176afdc4e3d0c9887c437bee17&sub=459B4CAF65FF4D67BFBE91DCED6E050E)\n\n- [java.util.HashMap 类](http://note.youdao.com/noteshare?id=791e29ca757ab1dedb8f80d872c940b1&sub=70D9B6BA82AF4889ACAD0A52F18C456D)\n\n- [java.util.HashSet 类](http://note.youdao.com/noteshare?id=473ccb760a498a837a6fca3373b1f6d1&sub=EF96DCB65AD1431BBCFBB52F21896643)\n\n\n\n\n\n#### IO 模型与IO流\n\n- [标准步骤：](http://note.youdao.com/noteshare?id=658c32dde4ecf6c8525649914d0f8560&sub=FF09583558E14D2BA25680647013CBA3)\n\n- [针对oj系统中的输入问题](http://note.youdao.com/noteshare?id=3dec994dd95a401eed7aabdfb1c5c15f&sub=CAB6771BB0F044F895A705B8AB7514BC)\n\n- [java IO之AutoCloseable接口](http://note.youdao.com/noteshare?id=1a496522d91fa47b4f3132aa97228ab7&sub=CD032B0A9E714FE9ABB2BE05B49CEE75)\n\n- [IO篇1-Java IO模型](http://note.youdao.com/noteshare?id=e496eb1243c65be077e6193400f6209d&sub=5594861B9BE845BFAFB4BD14D7DE49D4)\n\n- [IO篇2-Java NIO](http://note.youdao.com/noteshare?id=8ef12e2d0ce1d93b444eb430ba110fe3&sub=B6822523990E474D869C822BFCD5DFB2)\n\n- [IO篇3-Java NIO 零拷贝](http://note.youdao.com/noteshare?id=2e291882966fc1b4d7f3efafdd39d32e&sub=CE23D5FE57DC45709F74AFEB3A49F22E)\n\n- [IO篇4-Linux 内核的 select&epoll](http://note.youdao.com/noteshare?id=07cbfb2c33782cd85f62e05ff298740d&sub=CC14B7D2EBB64930A3E7E8C4241EBD83)\n\n#### 多线程与并发\n\n- [synchronized 锁的JVM中实现原理-偏向](http://note.youdao.com/noteshare?id=b7407e24b468fd58df564afcbf749183&sub=954EE84618B44B6FAFE4931E4F691873)\n\n- [线程的创建](http://note.youdao.com/noteshare?id=0f69c79fd2c666de113882fd3ac72abf&sub=61118765FB1F4B85B048C652460A5768)\n\n- [线程间的通信](http://note.youdao.com/noteshare?id=49735f35157748a107270cb85fbb867c&sub=0D34816A0AA24981B0B61EB87A64C8D4)\n\n- [线程的生命周期](http://note.youdao.com/noteshare?id=12aac80f35ab764277a810af76852cb2&sub=4A4D685F065F46B9B60D9703CEE04D29)\n\n- [对象和变量的并发访问（可见性，原子性)](http://note.youdao.com/noteshare?id=8d401fdafcc6c5712042fa06f6e3850b&sub=96CD2BBFE5914F089493A803A5B7D020)\n\n- [java.util.concurrent.locks包 ](http://note.youdao.com/noteshare?id=ed1aa8d1cf7688f52c1598735165a2dc&sub=15233B8FCFFB4E11AC6167CE4BF4077E)\n\n- [J.U.C多线程1-Executor 框架的梳理](http://note.youdao.com/noteshare?id=291668d9a729451d6c913b3137c9640f&sub=B28DDF08EC1F4457BFF740A9D8869FE5)\n\n- [J.U.C多线程2-ThreadPoolExecutor线程](http://note.youdao.com/noteshare?id=5b0658b7d6383586ef61f9c80ef3d249&sub=CE01D9FD424D45BCA78F88E1A0149C0D)\n\n- [实现BlockingQueue接口的阻塞队列](http://note.youdao.com/noteshare?id=cb9e9ac4838bfdbb7e23f67711f2a84a&sub=859FFFFB9E664A18BB2DBE355F094405)\n\n- [J.U.C多线程3-CAS比较和交换 ](http://note.youdao.com/noteshare?id=19714d2d692039c32ebba2ee3e4829e0&sub=2F7585F44D7E4DBE84E9487A24766668)\n\n- [J.U.C多线程3-AQS 同步器框架的梳理](http://note.youdao.com/noteshare?id=6a89441511d69a3bced7209ba47b736b&sub=4A1DC26FB09D4E0C9D6086E37FDEAD6B)\n\n- [J.U.C多线程4-AQS框架的应用](http://note.youdao.com/noteshare?id=4ef9100e71f2628636a4bff9b73fe882&sub=7998ABD160384F36A606B72FB7493232)\n\n\n\n#### 其他\n\n- [泛型（泛型接口、泛型类、泛型方法）](http://note.youdao.com/noteshare?id=d30458d5aac2da6b78824e51dbd982a5&sub=1C451DD2DB6F4481AB58D42E0AA63C44)\n\n- [字符串类型-String,StringBuilder](http://note.youdao.com/noteshare?id=d7092de3662bbf7b0d73b15313fbab0f&sub=95A433A8DC2A4E6FBCF8B54D4767BC40)\n\n- [java 编码规范- google](http://note.youdao.com/noteshare?id=9b7abb4a2896be59b9ed6629d028a5c6&sub=4C6D630F214D45DCA01450F1907C6266)\n\n- [Java8- Lambda 表达式](http://note.youdao.com/noteshare?id=a3af60be0ecf53e817c4954ab4b3f2dd&sub=80F0D1E1017E4522B63882A48BE17CF2)\n\n- [动手实现ArrayList](http://note.youdao.com/noteshare?id=29117a52793f44078077602c6f47252f&sub=9B5D88DF10A94DCD968EA4C8263241C9)\n\n- [java 知识点梳理](http://note.youdao.com/noteshare?id=893e0088e06c4e3cd1073a6abeb7bda4&sub=AE4EBC77232149368BEFD526D435B452)\n\n- [Java 刷题遇到的问题](http://note.youdao.com/noteshare?id=2b866c01ebed8c2f6594e3357ae349be&sub=AA305E3F95724374B5A3C5D96D654270)\n\n- [基本数据类型and 初始化](http://note.youdao.com/noteshare?id=7c544d8a0a428eb5c142c36e771c5fac&sub=1DE4594384FD444F9C705D73C3A26556)\n\n\n\n#### jvm 虚拟机\n\n- [jvm1-内存模型-运行时数据区](http://note.youdao.com/noteshare?id=4be4640b0d30a46e8e4936fca48fc4da&sub=E4ACF7E445F4469FB7C49A184325AA3A)\n\n- [jvm2-类加载机制](http://note.youdao.com/noteshare?id=044b5c8d572a50aa43f7476075feacd6&sub=CB5ACEE22D7C4B119E920A983456E348)\n\n- [jvm3-对象的创建过程](http://note.youdao.com/noteshare?id=38a77fc1b5541c7443a42bb8936ad699&sub=AC6273A6423A45D49DF9D7BA2C02D087)\n\n- [jvm4-垃圾回收机制 ](http://note.youdao.com/noteshare?id=85b9df0570061425d77cd09d542758a3&sub=C25619379B2547F5A492FB6900FA53F9)\n\n- [自定义类加载器实现热部署，热替换](http://note.youdao.com/noteshare?id=3f927397764ecb9a72e25d53d1a8447e&sub=DB8BF7AF904E4224A287A4B22D114460)\n\n\n\n#### 其他\n\n- [反射](http://note.youdao.com/noteshare?id=6f70c51df350a1da3b7353b5f0876ba1&sub=A890AA4181A64A17B14D21040C1A9724)\n\n- [Java 动态代理](http://note.youdao.com/noteshare?id=cfb346b9be695d57572367fd3143531e&sub=DE178E988586406F87227AC75BD725CE)\n\n\n\n\n### 1.2 数据库相关\n\n#### 数据库的安装\n\n- [windwos 环境中 mysql 数据库安装](http://note.youdao.com/noteshare?id=eec529b536dfe09cbbb2d2305a9cec2c&sub=DB98C14DBC15458ABE1B8461CD4C6988)\n\n- [ubuntu 环境中 mysql 安装](http://note.youdao.com/noteshare?id=32e1a61698644f735e5ae33a0d285bee&sub=WEB845b970c5cb400fcf42e04843dbd70af)\n\n#### 学习笔记\n\n- [JDBC 使用](http://note.youdao.com/noteshare?id=c98cc599b42b416ea2bd0aec7fd11fff&sub=833E6D40B97E4F2F98EFD56C010FE4C7)\n\n- [mysql必知必会](http://note.youdao.com/noteshare?id=71dd174ad72a6cca26ae011637d4a705&sub=E3BE9112006D4380953846BA1E446964)\n\n- [数据库-三大范式](http://note.youdao.com/noteshare?id=4d74a6536781f195ffb428a0aa74fabe&sub=9A407FE68AB54120B18950BEE5500BAF)\n\n- [数据库ER图基础](http://note.youdao.com/noteshare?id=78c16d370ba2bf4d06fd1d253072d582&sub=6B15DEFDC24B4353A5820B68A5FB2C05)\n\n- [mysql必知必会1-DDL数据定义语言](http://note.youdao.com/noteshare?id=f0c534778c8fde528be10f4ffdb2c03b&sub=336222838CDC4F249C1210E24D3701AD)\n\n- [mysql必知必会2-DML数据操作语句](http://note.youdao.com/noteshare?id=360395368205af6b9cd43b67c17200af&sub=3BAEE4ACEA0F4FC2A40AB4DC39965766)\n\n- [mysql必知必会3-TCL事务控制语言](http://note.youdao.com/noteshare?id=3a8535b5bdf8fbe6b46b85a8f6ab707e&sub=0C9D47245F604624A95E1982D45157F2)\n\n- [mysql必知必会4-数据类型和约束](http://note.youdao.com/noteshare?id=5a66c81500067c3bafc11fb31cc56cd6&sub=6ADA92683A36438EB254D18AE729A6FA)\n\n- [mysql必知必会5-视图](http://note.youdao.com/noteshare?id=8b1f73787548684951c21dea07576331&sub=E95C55AAF40F4378B7A14176911B4B81)\n\n- [mysql必知必会6-变量，存储过程，函数....](http://note.youdao.com/noteshare?id=d71e1773bdfb453b885ec8280980823e&sub=B0AFAE28DCC94DF09AE25F420927921E)\n\n- [mysql必知必会7](http://note.youdao.com/noteshare?id=71dd174ad72a6cca26ae011637d4a705&sub=E3BE9112006D4380953846BA1E446964)\n\n- [索引优化1-索引的概念 ](http://note.youdao.com/noteshare?id=003c0cce526f2a71945614993d250377&sub=56317DB968F04FE3BCC0D482D083C877)\n\n- [索引优化2-Mysql索引的底层实现 ](http://note.youdao.com/noteshare?id=a527e1fa83cc6b429814c2f8710b891c&sub=9B9BDA5A138144B5A5A5E5C4BE6CE1D1)\n\n- [索引优化3- explain 查看执行计划 ](http://note.youdao.com/noteshare?id=f35d29b727ca3a228bfad4aac0a9e9e6&sub=53F88FCDB69547E895DAD25A7D402035)\n\n- [Sql语句优化-查询截取分析 ](http://note.youdao.com/noteshare?id=a83b6505ac7dbb6b3c69afd1860b8ccb&sub=C419B2D7DA254E589E0F449A60544A1C)\n\n- [mysql-数据库锁的机制和原理 ](http://note.youdao.com/noteshare?id=f8935a502a43186c1c821ad33ccc2c6d&sub=5D286DE5F8304B8BA7290255DBF15C0C)\n\n\n\n\n\n### 1.3 计算机网络相关\n\n- [互联网协议入门1-模型分层](http://note.youdao.com/noteshare?id=92e3adba9198d367e976bcc3f772d149&sub=7F7B0D8B9F3E4D7996815384809C35EA)\n\n- [互联网协议入门2-访问网页的过程](http://note.youdao.com/noteshare?id=8c41ad2717d4deee47f83841e49d755b&sub=C0C042EE387F4A0096F427CE6F391887)\n\n- [互联网协议入门3-TCP协议详细内容](http://note.youdao.com/noteshare?id=e7f3f660c5df2335b7eccb7be89ce514&sub=A775AFCC161A4388859120A340BDC6CB)\n\n- [互联网协议入门4-Http协议（应用层)](http://note.youdao.com/noteshare?id=71031b3ed61c6e8bd302a8577f6c396f&sub=0F5DF1F408844E7184F3A6BB5F868F89)\n\n### 1.4 Python 相关\n\n- [Anaconda 使用](http://note.youdao.com/noteshare?id=398da3b52370f6976e9a67cb3be4cd24&sub=WEBf9be5147ccbf73c569b46bb2a5ffe942)\n\n- [python 性能优化](http://note.youdao.com/noteshare?id=a813207158a22cfa902dbeba640bdf87&sub=E61484FE7B0D4D999DF1A462FA780049)\n\n- [python 内存管理](http://note.youdao.com/noteshare?id=dde4ed2eb6eea6c45926d251689e3d4e&sub=4A1EA0D89E634DEC9DD294C13012EFCA)\n\n- [python 包管理](http://note.youdao.com/noteshare?id=9146e0886cac1bdaec8cce2e5081cfe0&sub=060F7616DF954602BB641EC52D0F6110)\n\n- [知识积累](http://note.youdao.com/noteshare?id=3724fe43398de6c5fbd75dd8c452987e&sub=7837405EB49045FF8C22156022261A94)\n\n- [python 数据模型](http://note.youdao.com/noteshare?id=bfbf2eb0c5bccf64974fe260e1bdf131&sub=A8906CE9DF0E47F19377CD49BF2DFA6F)\n\n- [Set 集合  交并差运算](http://note.youdao.com/noteshare?id=0f7309f661031855b1e257072ceab9b9&sub=E6CAEE5B6F7043779DF1F3A95923DC0F)\n\n#### pandas 包\n\n- [pandas](http://note.youdao.com/noteshare?id=f191fc11a263f303532d40c02c1f2161&sub=3F6F9858E4DA4B7A9245F66557B15AB4)\n\n- [pandas-1数据结构](http://note.youdao.com/noteshare?id=64c2febf14a2e0f96bcbc868375500b9&sub=0B21232330E442118F68ADFB44DECA6E)\n\n- [pandas-2索引和选择数据](http://note.youdao.com/noteshare?id=7b8a86d71c5321171292fa000666efc8&sub=A1102303D97F4E2D836A588F4882C5E2)\n\n- [pandas-分层和多级索引](http://note.youdao.com/noteshare?id=02c6e6a9916d2f600153fa5402395c29&sub=0CF2D73FB22140A29F3838CF6EF299B9)\n\n- [pandas-4分组与聚合](http://note.youdao.com/noteshare?id=b8d6c15c3d603261cee9b6771732c5a5&sub=WEB9f17e5d4ecb0520c9c27c8145f3450dc)\n\n- [pandas-5缺失值处理](http://note.youdao.com/noteshare?id=57496ba2051b12d778ac17612d871354&sub=62AE7AB578AF4B3A9D630676179C8CA0)\n\n- [pandas-6重复值处理](http://note.youdao.com/noteshare?id=f16646b876ddb2c5ec482e316ca881dd&sub=8024BDCE94B4455FA20514234C7233C0)\n\n- [pandas-7时间处理](http://note.youdao.com/noteshare?id=5210591266c5f2472eab6bdb0e1adc7e&sub=7B85239BB0C74343830F3EBBC34F43A0)\n\n\n### 1.5 数据结构与算法相关\n\n#### 链表\n\n- [链表入门-单链表](http://note.youdao.com/noteshare?id=77d45fd3df6dc9821a505972246afc67&sub=CBBC8BE4E72147248464A2C136D8A893)\n\n- [双向链表](http://note.youdao.com/noteshare?id=2038af6c36c144a0005d3f7cb7cbd6e1&sub=19BC0DEA04654C51970F77E363746D36)\n\n#### 树结构\n\n- [树结构1-二叉树的种类 ](http://note.youdao.com/noteshare?id=3d87798249099424c8f688932e054d34&sub=962de575938af485eb5896712a3fa88bhttp://note.youdao.com/noteshare?id=3d87798249099424c8f688932e054d34&sub=962de575938af485eb5896712a3fa88b)\n\n- [树结构2-二叉树的四种遍历](http://note.youdao.com/noteshare?id=a93bf51802eb22ed23e7f01baeecdfd9&sub=C2561C42F8354E2787F3F58DC19CC2F5)\n\n- [树结构3- 二叉排序树 ](http://note.youdao.com/noteshare?id=6595e3f3a04494d53c79ac4f14156b45&sub=36364C54AB334D5B85B1871D6758FFF7)\n\n- [树结构4- 完全二叉树-堆排序 ](http://note.youdao.com/noteshare?id=ff1c7f5f5c5439a5bcf29746bafacd8e&sub=524DD42459CF4A43AB7CD89A74D83BAB)\n\n- [树结构5-红黑树 ](http://note.youdao.com/noteshare?id=28a1554677d3108539d237ed2dbfb3a9&sub=6917ECACABFC4BE99B0840940E1492C3)\n\n\n#### 栈\n\n- [栈 - Stack](http://note.youdao.com/noteshare?id=32bb87989cc88c68f94b697a2309e577&sub=CB4F1BAE4B48482B895E4B334EC920B7)\n\n#### 动态规划\n\n- [动态规划-DP](http://note.youdao.com/noteshare?id=2bf63868f3e17320b15a68783a6f1d89&sub=35032594A3AB441EB7DB3344B71213EF)\n\n- [DFS和回溯算法- 暴力搜索的优化方案](http://note.youdao.com/noteshare?id=47da45a5509c7f21f5905c65ec87c12d&sub=E525698B083343B382EFC767181A2755)\n\n#### 一般算法\n\n- [二分查找](http://note.youdao.com/noteshare?id=6139197ff7cc443d83b73f578ced01d2&sub=3671B7672DA341359DF0C57DAA5114E3)\n\n- [最大公约数与最小公倍数](http://note.youdao.com/noteshare?id=417cd36012151f1465f6b179a68c2559&sub=39B0B9975CC34C589CCCF7A4A619E921)\n\n- [素数和合数](http://note.youdao.com/noteshare?id=b9bb5b1c7a7f968392ca087beb53a288&sub=7AC07884471A4FFBAC433400CC8DD668)\n\n- [排序算法-Java版](http://note.youdao.com/noteshare?id=900f90e3d481dcabbd5ce22df8452e4b&sub=2A9F48EDC9824721A63091F213AE84DF)\n\n- [蓄水池采样算法](http://note.youdao.com/noteshare?id=34e1f4c6bbc849e28017b14d1aa1ed3d&sub=04B030FDEA424189A387F2B149670138)\n\n\n### 1.6 设计模式\n\n- [单例模式](http://note.youdao.com/noteshare?id=9b725da8bd83d6d2fa6628449036fa76&sub=61D7D7C472CC4F6FA40978D2EEE3F253)\n\n- [汇总 ](http://note.youdao.com/noteshare?id=3258d6710e66d885a3a213d45eea14be&sub=9E8B81697FD248EDBAAB8B203ACDD4B9)\n\n\n\n## 第二章  计算机提高篇\n\n> 提高篇是一些具体的学习方向，我学的比较杂。\n\n### 2.1 机器学习与数据挖掘\n\n- [特征工程中的问题](http://note.youdao.com/noteshare?id=a2a581480ef2d48c22c8972e2c1289ea&sub=WEBe5a19e45418f24614a27d5c871dbeef6)\n\n#### 决策树\n\n- [决策树-1基本概念](http://note.youdao.com/noteshare?id=72d77f019bd4fc8cde5d77f1479213a3&sub=3A0C8DB3DE554ED5B70179B18DEBDB6F)\n\n- [决策树-2 ID3算法](http://note.youdao.com/noteshare?id=6b4b7d196688d64889da3563eb4b194d&sub=E48B826F34CB41769382CA5DD11DE54F)\n\n- [决策树-3 CART分类回归树](http://note.youdao.com/noteshare?id=51ba5d9d9611ae2284c2612d5f38b721&sub=C40D67A492D4428EB698D146897932F2)\n\n- [CART 分类回归树](http://note.youdao.com/noteshare?id=8fd42b53e1a611131199f17d399820c7&sub=F7FA6EBCE1CC4A95875DD83B2CF9C551)\n\n- [sklearn 决策树使用技巧](http://note.youdao.com/noteshare?id=d5d006e5d1680bb1b93f6cdc68973b60&sub=C12A5DC3350C49CA8862D51287908CE4)\n\n- [sklearn整理-决策树](http://note.youdao.com/noteshare?id=3a209c356ed655acacf08699cef27150&sub=E0880A97A8264449BD714025A98BFE52)\n\n#### 神经网络\n\n- [常见的神经网络](http://note.youdao.com/noteshare?id=d1d1a974ade3ab72cd8ff9fbab061e78&sub=6C8F11DB78FA417AA9F4D0DA30351077)\n\n#### 集成学习\n\n- [集成学习提升算法-Adaboost](http://note.youdao.com/noteshare?id=fb4b442794aac472bdd7663b026a2dab&sub=939B2AAEB6F94E32ABAD4A54B8AF1358)\n\n- [XGBoost -python package introduction](http://note.youdao.com/noteshare?id=eb03f9b12281363b052e0ed071833b13&sub=WEBb2a9d589fb05754f76c2b2af09a826c1)\n\n- [梯度提升树-GBDT](http://note.youdao.com/noteshare?id=2039180d0a9ad5b39339c93e8c70040d&sub=9C48D93E6A1E4C1186E6F37EF222F528)\n\n- [sklearn整理-集成学习-随机森林](http://note.youdao.com/noteshare?id=e4ac54bae64eb94641594ad5f4a2cd6d&sub=8232CAC65C0A4FDC9EDED033B6A4770F)\n\n#### 模型评价\n\n- [ROC与AUC](http://note.youdao.com/noteshare?id=c76dbbe346dbd32a62cd4303f7bf4864&sub=753D4CFE21084BA78B0506697A415A0C)\n\n- [机器学习的方差与偏差](http://note.youdao.com/noteshare?id=030f5d8884e6a0914891ebf2289318fa&sub=28D75EDB51044316AB154021B0EB6BEA)\n\n#### 参与的一些竞赛\n\n- [ali-新人实战赛o2o优惠券使用预测](http://note.youdao.com/noteshare?id=1d8176b82fc84b0a3906fbd53979041c&sub=305B25CE269F45DCA311DBE8C20DAF67)\n\n\n- [ccf-2019](http://note.youdao.com/noteshare?id=5b2fa1c8320743190649812b394b3ed5&sub=27291314B2C74B09ABF8619277EE8A5E)\n\n- [dc-2019-商品购买转化率预测](http://note.youdao.com/noteshare?id=52c517d38463d99b24672f0195ecabfe&sub=WEBf24a84a951b3b16a0685ed029a28b960)\n\n- [竞赛提升方法-tricks](http://note.youdao.com/noteshare?id=2fd9687a7cb8c10210bf738536dd8021&sub=AE7E1B49101546F093C7C2B993A736A3)\n\n\n- [sklearn 脑图](http://note.youdao.com/noteshare?id=f43a977d8705582da02c202f295dadcc&sub=74C22A94ABB74B309807A886F50A5863)\n\n### 2.2 大数据与Hadoop\n\n#### 多台机器的分布式环境安装\n\n- [1.hadoop分布式集群安装](http://note.youdao.com/noteshare?id=e284c332fb9766d6487d925c4381ae22&sub=E4980D34F8A347DC9C1E2C23C5A48D17)\n\n#### RPC\n\n- [Hadoop RPC](http://note.youdao.com/noteshare?id=773c4878eaec8cc266c5074691a3d780&sub=68CE094D754C46CDA96C8CFA00401DF2)\n\n#### mapreduce 实验\n\n- [实验1.  多表关联](http://note.youdao.com/noteshare?id=710757567d678841cb43e891531c63b9&sub=BA97FAC420754425A2FE07E67D6B6EAD)\n\n- [实验2.  最高温度统计](http://note.youdao.com/noteshare?id=7c251c3514764eb58fdad72de78bf6a5&sub=FF9F53C4D1A04E008FA61A85A9CE0F01)\n\n- [实验3.  单表关联](http://note.youdao.com/noteshare?id=226bf0abd5e44ed6eae69f5250024bcf&sub=5EE9A40650BB4AD2A661C65DFBC57FC5)\n\n\n### 2.3 VUE\n\n#### VUE 安装\n\n- [开发环境搭建](http://note.youdao.com/noteshare?id=c60a733187bef04fa0404429eb2d1f30&sub=3F4FE35DF8E349A395F8C4C19AA7BBE4)\n\n### 2.4 Spring 框架\n\n- [Spring-1控制反转（IOC）和依赖注入](http://note.youdao.com/noteshare?id=7181c4a539cade23a864c8e970b05833&sub=771654DC28474896BAB711DD289A052C)\n\n- [Spring-2AOP 面向切面编程-基于动态代](http://note.youdao.com/noteshare?id=32da7b7e487b45fd4fde7906fb9436a1&sub=BAF8F0AE43DB42B399AC14B01FE74689)\n\n- [Spring-3事务管理Transaction Manager](http://note.youdao.com/noteshare?id=2caa6adcf719adaba44ad57fcad131e4&sub=8E30EF145E8A4972867B5476DF2DD607)\n\n\n## 第三章  工具使用\n\n- [vscode 使用记录](http://note.youdao.com/noteshare?id=82f292615812b23fec6c7ce9fcc35ec4&sub=6FC7D088767948388F03769F13A2C971)\n\n\n\n## 第四章  收藏的书籍\n\n- [书籍收藏](http://note.youdao.com/noteshare?id=57e1d26f1f078dc70a5b18392b29a841)\n\n","slug":"计算机基础学习笔记","published":1,"updated":"2020-04-21T02:41:32.215Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephgw002ot8plgunjaasz","content":"<h1 id=\"Computer-Basics-Notes-Links\"><a href=\"#Computer-Basics-Notes-Links\" class=\"headerlink\" title=\"Computer-Basics-Notes-Links\"></a>Computer-Basics-Notes-Links</h1><p><a href=\"https://github.com/elgong/Computer-Basics-Notes-Links\" target=\"_blank\" rel=\"noopener\">github地址</a></p>\n<h1 id=\"学习笔记\"><a href=\"#学习笔记\" class=\"headerlink\" title=\"学习笔记\"></a>学习笔记</h1><blockquote>\n<p>我在学习计算机基础的过程中整理了一部分笔记，但都比较零散，有些稍微连贯的内容已经整理为博客，而大部分还没来得及整理成md格式，我先整理出链接。为了尽可能的清晰展示笔记脉络，下文将分门别类的列出，有需要请自取。<br>笔记内容大部分都是参考了网上的博客以及书籍，整理笔记的习惯也是刚刚养成的，从开始整理笔记后，发现自己对于做过的东西，能够随着笔记很快的回忆起来，遇到一些问题能够快速从笔记里找到答案也是比较舒服的。笔记是用有道云分享的，我未来仍然会继续梳理这些笔记，如果有任何的错误或者意见，麻烦您联系我哈。</p>\n</blockquote>\n<h2 id=\"第一章-计算机基础篇\"><a href=\"#第一章-计算机基础篇\" class=\"headerlink\" title=\"第一章  计算机基础篇\"></a>第一章  计算机基础篇</h2><blockquote>\n<p>基础部分是一些语言相关的知识点。</p>\n</blockquote>\n<h3 id=\"1-1-Java-相关\"><a href=\"#1-1-Java-相关\" class=\"headerlink\" title=\"1.1 Java 相关\"></a>1.1 Java 相关</h3><h4 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h4><ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=f869167b77cb73b67478290ffdcf45bc&amp;sub=06694CB1F00B45CBA1D4BD1A4B62320C\" target=\"_blank\" rel=\"noopener\">Java面向对象-多态</a></li>\n</ul>\n<h4 id=\"部分源码分析\"><a href=\"#部分源码分析\" class=\"headerlink\" title=\"部分源码分析\"></a>部分源码分析</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=def11ef6e833a11434137d6fec1c834a&amp;sub=DD0083BFCFE14839A721700413B41F38\" target=\"_blank\" rel=\"noopener\">java.lang.Object 类</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=fb941f5b4a01adf474496df328542a91&amp;sub=02C7EDC387984E3BADE744B9280EA1E6\" target=\"_blank\" rel=\"noopener\">java.lang.Integer等基本类型包装类</a></p>\n</li>\n</ul>\n<h4 id=\"接口和抽象类\"><a href=\"#接口和抽象类\" class=\"headerlink\" title=\"接口和抽象类\"></a>接口和抽象类</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=7bdd684a91766f6b448e5328f1fed251&amp;sub=0DEE02584D22485EACF337D5F846ACCE0\" target=\"_blank\" rel=\"noopener\">接口和抽象类的概念</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=eb3b5e1f37828c301015c1fcc48b2ee9&amp;sub=B77DF9D467AE48948C63CEE6D7B51FB5\" target=\"_blank\" rel=\"noopener\">java.io.Serializable接口</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=af26732dc5f501e490a3f57c6b46333c&amp;sub=1E9132AF928342728B68D66845201D05\" target=\"_blank\" rel=\"noopener\">java.lang.AbstractStringBuilder</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=62429dcbeb51676d855b0c46d89ea67b&amp;sub=7D9CC78E517B46A19C567A567DDA0C1E\" target=\"_blank\" rel=\"noopener\">java.lang.CharSequence接口</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=4309c54f9e557075dc953a25a1e9aea4&amp;sub=4AF6A4102AD6494F884069B5F75DB663\" target=\"_blank\" rel=\"noopener\">java.lang.Comparable 接口</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=d7525d979bbcfac0ad602e0f90124a39&amp;sub=9B8E20EC1E924C988EB9DEC3C059FE4F\" target=\"_blank\" rel=\"noopener\">java.lang.Iterable 接口</a></p>\n</li>\n</ul>\n<h4 id=\"集合类\"><a href=\"#集合类\" class=\"headerlink\" title=\"集合类\"></a>集合类</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=3f13ce83c60473cb2d03ac7d500b3771&amp;sub=77608E57EC404A3D925D5BADFABA9F0C\" target=\"_blank\" rel=\"noopener\">Java集合的结构</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=8d5718ecf80ea7c1cd144c848afb556f&amp;sub=D12BF9FEA9B54873871F5BDC532FB46A\" target=\"_blank\" rel=\"noopener\">java.util.Arrays工具类</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=55f2b8f2004cc365aa3200283f918642&amp;sub=373C38673F3D4233869F2FA181CF6C77\" target=\"_blank\" rel=\"noopener\">java.util.Collections 工具类</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=2d1b0ca8f6ee80acab26bac64e65752b&amp;sub=BC00717F11EC48DBAA3187C99E27FB67\" target=\"_blank\" rel=\"noopener\">集合类之间的转换</a></p>\n</li>\n</ul>\n<h5 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h5><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=cf4402932c37eeda65d2cb48b771fa85&amp;sub=38A358238D644B009E8D35E85BC3958A\" target=\"_blank\" rel=\"noopener\">java.util.Collection 接口</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=35066dabdc8838cbf4a81a6064d3a278&amp;sub=B08F3371DAF94E0A8577E14A355948F7\" target=\"_blank\" rel=\"noopener\">java.util.List 接口</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=ac00534071924ed6812c3087ff89522d&amp;sub=7CF204D01C2846469F874ABE719F122E\" target=\"_blank\" rel=\"noopener\">java.util.ArrayList 类</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=24e53ad8811d97e37ae725caef30e87c&amp;sub=3580B9F523B14B9A8346594FAB7428B7\" target=\"_blank\" rel=\"noopener\">java.util.LinkedList 类</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=3fefcc71bac40f731582cda7de9680a9&amp;sub=FD48F85901CA48C2A1FDBFB356072932\" target=\"_blank\" rel=\"noopener\">java.util.Vector类-线程安全</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=7ca967ab85ba51315d576614e4debb88&amp;sub=D7FB8F63F9524697A2B6C92EBC997759\" target=\"_blank\" rel=\"noopener\">java.util.Stack类-线程安全</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=e69b12c5f34e8999a63f901e66cf6349&amp;sub=378BBC5185DD4901949BA8D6CC586117\" target=\"_blank\" rel=\"noopener\">java.util.Queue 接口</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=70bcfde9362d131a6cc9769df7c6a195&amp;sub=4CCDF46A03F64701B726C3B5B17EE5C7\" target=\"_blank\" rel=\"noopener\">java.util.Deque 接口</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=a8e52263383bbff56bba83c4437e62a5&amp;sub=273730F39B6345348B400731471932CD\" target=\"_blank\" rel=\"noopener\">java.util.ArrayDeque 类</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=d5807c6cbb3dfcd1c6a6fa2587f2a53a&amp;sub=8DB19EF833FF477C8241702AB6C728D4\" target=\"_blank\" rel=\"noopener\">java.util.PriorityQueue 类</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=78367406564a757c47fbb5fd74ab4118&amp;sub=CD2FAD0FE2EE433EAFEB76285A06D389\" target=\"_blank\" rel=\"noopener\">java.util.Set 接口</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=473ccb760a498a837a6fca3373b1f6d1&amp;sub=EF96DCB65AD1431BBCFBB52F21896643\" target=\"_blank\" rel=\"noopener\">java.util.HashSet 类</a></p>\n</li>\n</ul>\n<h5 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h5><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=8066dded44e4cba4a621fe78ed94c4a9&amp;sub=B9652D8B6D7940FFB5C92A5106BCC277\" target=\"_blank\" rel=\"noopener\">java.util.Map 接口</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=de517d176afdc4e3d0c9887c437bee17&amp;sub=459B4CAF65FF4D67BFBE91DCED6E050E\" target=\"_blank\" rel=\"noopener\">java.util.TreeMap 类</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=791e29ca757ab1dedb8f80d872c940b1&amp;sub=70D9B6BA82AF4889ACAD0A52F18C456D\" target=\"_blank\" rel=\"noopener\">java.util.HashMap 类</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=473ccb760a498a837a6fca3373b1f6d1&amp;sub=EF96DCB65AD1431BBCFBB52F21896643\" target=\"_blank\" rel=\"noopener\">java.util.HashSet 类</a></p>\n</li>\n</ul>\n<h4 id=\"IO-模型与IO流\"><a href=\"#IO-模型与IO流\" class=\"headerlink\" title=\"IO 模型与IO流\"></a>IO 模型与IO流</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=658c32dde4ecf6c8525649914d0f8560&amp;sub=FF09583558E14D2BA25680647013CBA3\" target=\"_blank\" rel=\"noopener\">标准步骤：</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=3dec994dd95a401eed7aabdfb1c5c15f&amp;sub=CAB6771BB0F044F895A705B8AB7514BC\" target=\"_blank\" rel=\"noopener\">针对oj系统中的输入问题</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=1a496522d91fa47b4f3132aa97228ab7&amp;sub=CD032B0A9E714FE9ABB2BE05B49CEE75\" target=\"_blank\" rel=\"noopener\">java IO之AutoCloseable接口</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=e496eb1243c65be077e6193400f6209d&amp;sub=5594861B9BE845BFAFB4BD14D7DE49D4\" target=\"_blank\" rel=\"noopener\">IO篇1-Java IO模型</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=8ef12e2d0ce1d93b444eb430ba110fe3&amp;sub=B6822523990E474D869C822BFCD5DFB2\" target=\"_blank\" rel=\"noopener\">IO篇2-Java NIO</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=2e291882966fc1b4d7f3efafdd39d32e&amp;sub=CE23D5FE57DC45709F74AFEB3A49F22E\" target=\"_blank\" rel=\"noopener\">IO篇3-Java NIO 零拷贝</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=07cbfb2c33782cd85f62e05ff298740d&amp;sub=CC14B7D2EBB64930A3E7E8C4241EBD83\" target=\"_blank\" rel=\"noopener\">IO篇4-Linux 内核的 select&amp;epoll</a></p>\n</li>\n</ul>\n<h4 id=\"多线程与并发\"><a href=\"#多线程与并发\" class=\"headerlink\" title=\"多线程与并发\"></a>多线程与并发</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=b7407e24b468fd58df564afcbf749183&amp;sub=954EE84618B44B6FAFE4931E4F691873\" target=\"_blank\" rel=\"noopener\">synchronized 锁的JVM中实现原理-偏向</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=0f69c79fd2c666de113882fd3ac72abf&amp;sub=61118765FB1F4B85B048C652460A5768\" target=\"_blank\" rel=\"noopener\">线程的创建</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=49735f35157748a107270cb85fbb867c&amp;sub=0D34816A0AA24981B0B61EB87A64C8D4\" target=\"_blank\" rel=\"noopener\">线程间的通信</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=12aac80f35ab764277a810af76852cb2&amp;sub=4A4D685F065F46B9B60D9703CEE04D29\" target=\"_blank\" rel=\"noopener\">线程的生命周期</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=8d401fdafcc6c5712042fa06f6e3850b&amp;sub=96CD2BBFE5914F089493A803A5B7D020\" target=\"_blank\" rel=\"noopener\">对象和变量的并发访问（可见性，原子性)</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=ed1aa8d1cf7688f52c1598735165a2dc&amp;sub=15233B8FCFFB4E11AC6167CE4BF4077E\" target=\"_blank\" rel=\"noopener\">java.util.concurrent.locks包 </a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=291668d9a729451d6c913b3137c9640f&amp;sub=B28DDF08EC1F4457BFF740A9D8869FE5\" target=\"_blank\" rel=\"noopener\">J.U.C多线程1-Executor 框架的梳理</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=5b0658b7d6383586ef61f9c80ef3d249&amp;sub=CE01D9FD424D45BCA78F88E1A0149C0D\" target=\"_blank\" rel=\"noopener\">J.U.C多线程2-ThreadPoolExecutor线程</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=cb9e9ac4838bfdbb7e23f67711f2a84a&amp;sub=859FFFFB9E664A18BB2DBE355F094405\" target=\"_blank\" rel=\"noopener\">实现BlockingQueue接口的阻塞队列</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=19714d2d692039c32ebba2ee3e4829e0&amp;sub=2F7585F44D7E4DBE84E9487A24766668\" target=\"_blank\" rel=\"noopener\">J.U.C多线程3-CAS比较和交换 </a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=6a89441511d69a3bced7209ba47b736b&amp;sub=4A1DC26FB09D4E0C9D6086E37FDEAD6B\" target=\"_blank\" rel=\"noopener\">J.U.C多线程3-AQS 同步器框架的梳理</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=4ef9100e71f2628636a4bff9b73fe882&amp;sub=7998ABD160384F36A606B72FB7493232\" target=\"_blank\" rel=\"noopener\">J.U.C多线程4-AQS框架的应用</a></p>\n</li>\n</ul>\n<h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=d30458d5aac2da6b78824e51dbd982a5&amp;sub=1C451DD2DB6F4481AB58D42E0AA63C44\" target=\"_blank\" rel=\"noopener\">泛型（泛型接口、泛型类、泛型方法）</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=d7092de3662bbf7b0d73b15313fbab0f&amp;sub=95A433A8DC2A4E6FBCF8B54D4767BC40\" target=\"_blank\" rel=\"noopener\">字符串类型-String,StringBuilder</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=9b7abb4a2896be59b9ed6629d028a5c6&amp;sub=4C6D630F214D45DCA01450F1907C6266\" target=\"_blank\" rel=\"noopener\">java 编码规范- google</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=a3af60be0ecf53e817c4954ab4b3f2dd&amp;sub=80F0D1E1017E4522B63882A48BE17CF2\" target=\"_blank\" rel=\"noopener\">Java8- Lambda 表达式</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=29117a52793f44078077602c6f47252f&amp;sub=9B5D88DF10A94DCD968EA4C8263241C9\" target=\"_blank\" rel=\"noopener\">动手实现ArrayList</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=893e0088e06c4e3cd1073a6abeb7bda4&amp;sub=AE4EBC77232149368BEFD526D435B452\" target=\"_blank\" rel=\"noopener\">java 知识点梳理</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=2b866c01ebed8c2f6594e3357ae349be&amp;sub=AA305E3F95724374B5A3C5D96D654270\" target=\"_blank\" rel=\"noopener\">Java 刷题遇到的问题</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=7c544d8a0a428eb5c142c36e771c5fac&amp;sub=1DE4594384FD444F9C705D73C3A26556\" target=\"_blank\" rel=\"noopener\">基本数据类型and 初始化</a></p>\n</li>\n</ul>\n<h4 id=\"jvm-虚拟机\"><a href=\"#jvm-虚拟机\" class=\"headerlink\" title=\"jvm 虚拟机\"></a>jvm 虚拟机</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=4be4640b0d30a46e8e4936fca48fc4da&amp;sub=E4ACF7E445F4469FB7C49A184325AA3A\" target=\"_blank\" rel=\"noopener\">jvm1-内存模型-运行时数据区</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=044b5c8d572a50aa43f7476075feacd6&amp;sub=CB5ACEE22D7C4B119E920A983456E348\" target=\"_blank\" rel=\"noopener\">jvm2-类加载机制</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=38a77fc1b5541c7443a42bb8936ad699&amp;sub=AC6273A6423A45D49DF9D7BA2C02D087\" target=\"_blank\" rel=\"noopener\">jvm3-对象的创建过程</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=85b9df0570061425d77cd09d542758a3&amp;sub=C25619379B2547F5A492FB6900FA53F9\" target=\"_blank\" rel=\"noopener\">jvm4-垃圾回收机制 </a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=3f927397764ecb9a72e25d53d1a8447e&amp;sub=DB8BF7AF904E4224A287A4B22D114460\" target=\"_blank\" rel=\"noopener\">自定义类加载器实现热部署，热替换</a></p>\n</li>\n</ul>\n<h4 id=\"其他-1\"><a href=\"#其他-1\" class=\"headerlink\" title=\"其他\"></a>其他</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=6f70c51df350a1da3b7353b5f0876ba1&amp;sub=A890AA4181A64A17B14D21040C1A9724\" target=\"_blank\" rel=\"noopener\">反射</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=cfb346b9be695d57572367fd3143531e&amp;sub=DE178E988586406F87227AC75BD725CE\" target=\"_blank\" rel=\"noopener\">Java 动态代理</a></p>\n</li>\n</ul>\n<h3 id=\"1-2-数据库相关\"><a href=\"#1-2-数据库相关\" class=\"headerlink\" title=\"1.2 数据库相关\"></a>1.2 数据库相关</h3><h4 id=\"数据库的安装\"><a href=\"#数据库的安装\" class=\"headerlink\" title=\"数据库的安装\"></a>数据库的安装</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=eec529b536dfe09cbbb2d2305a9cec2c&amp;sub=DB98C14DBC15458ABE1B8461CD4C6988\" target=\"_blank\" rel=\"noopener\">windwos 环境中 mysql 数据库安装</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=32e1a61698644f735e5ae33a0d285bee&amp;sub=WEB845b970c5cb400fcf42e04843dbd70af\" target=\"_blank\" rel=\"noopener\">ubuntu 环境中 mysql 安装</a></p>\n</li>\n</ul>\n<h4 id=\"学习笔记-1\"><a href=\"#学习笔记-1\" class=\"headerlink\" title=\"学习笔记\"></a>学习笔记</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=c98cc599b42b416ea2bd0aec7fd11fff&amp;sub=833E6D40B97E4F2F98EFD56C010FE4C7\" target=\"_blank\" rel=\"noopener\">JDBC 使用</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=71dd174ad72a6cca26ae011637d4a705&amp;sub=E3BE9112006D4380953846BA1E446964\" target=\"_blank\" rel=\"noopener\">mysql必知必会</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=4d74a6536781f195ffb428a0aa74fabe&amp;sub=9A407FE68AB54120B18950BEE5500BAF\" target=\"_blank\" rel=\"noopener\">数据库-三大范式</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=78c16d370ba2bf4d06fd1d253072d582&amp;sub=6B15DEFDC24B4353A5820B68A5FB2C05\" target=\"_blank\" rel=\"noopener\">数据库ER图基础</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=f0c534778c8fde528be10f4ffdb2c03b&amp;sub=336222838CDC4F249C1210E24D3701AD\" target=\"_blank\" rel=\"noopener\">mysql必知必会1-DDL数据定义语言</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=360395368205af6b9cd43b67c17200af&amp;sub=3BAEE4ACEA0F4FC2A40AB4DC39965766\" target=\"_blank\" rel=\"noopener\">mysql必知必会2-DML数据操作语句</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=3a8535b5bdf8fbe6b46b85a8f6ab707e&amp;sub=0C9D47245F604624A95E1982D45157F2\" target=\"_blank\" rel=\"noopener\">mysql必知必会3-TCL事务控制语言</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=5a66c81500067c3bafc11fb31cc56cd6&amp;sub=6ADA92683A36438EB254D18AE729A6FA\" target=\"_blank\" rel=\"noopener\">mysql必知必会4-数据类型和约束</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=8b1f73787548684951c21dea07576331&amp;sub=E95C55AAF40F4378B7A14176911B4B81\" target=\"_blank\" rel=\"noopener\">mysql必知必会5-视图</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=d71e1773bdfb453b885ec8280980823e&amp;sub=B0AFAE28DCC94DF09AE25F420927921E\" target=\"_blank\" rel=\"noopener\">mysql必知必会6-变量，存储过程，函数….</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=71dd174ad72a6cca26ae011637d4a705&amp;sub=E3BE9112006D4380953846BA1E446964\" target=\"_blank\" rel=\"noopener\">mysql必知必会7</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=003c0cce526f2a71945614993d250377&amp;sub=56317DB968F04FE3BCC0D482D083C877\" target=\"_blank\" rel=\"noopener\">索引优化1-索引的概念 </a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=a527e1fa83cc6b429814c2f8710b891c&amp;sub=9B9BDA5A138144B5A5A5E5C4BE6CE1D1\" target=\"_blank\" rel=\"noopener\">索引优化2-Mysql索引的底层实现 </a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=f35d29b727ca3a228bfad4aac0a9e9e6&amp;sub=53F88FCDB69547E895DAD25A7D402035\" target=\"_blank\" rel=\"noopener\">索引优化3- explain 查看执行计划 </a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=a83b6505ac7dbb6b3c69afd1860b8ccb&amp;sub=C419B2D7DA254E589E0F449A60544A1C\" target=\"_blank\" rel=\"noopener\">Sql语句优化-查询截取分析 </a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=f8935a502a43186c1c821ad33ccc2c6d&amp;sub=5D286DE5F8304B8BA7290255DBF15C0C\" target=\"_blank\" rel=\"noopener\">mysql-数据库锁的机制和原理 </a></p>\n</li>\n</ul>\n<h3 id=\"1-3-计算机网络相关\"><a href=\"#1-3-计算机网络相关\" class=\"headerlink\" title=\"1.3 计算机网络相关\"></a>1.3 计算机网络相关</h3><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=92e3adba9198d367e976bcc3f772d149&amp;sub=7F7B0D8B9F3E4D7996815384809C35EA\" target=\"_blank\" rel=\"noopener\">互联网协议入门1-模型分层</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=8c41ad2717d4deee47f83841e49d755b&amp;sub=C0C042EE387F4A0096F427CE6F391887\" target=\"_blank\" rel=\"noopener\">互联网协议入门2-访问网页的过程</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=e7f3f660c5df2335b7eccb7be89ce514&amp;sub=A775AFCC161A4388859120A340BDC6CB\" target=\"_blank\" rel=\"noopener\">互联网协议入门3-TCP协议详细内容</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=71031b3ed61c6e8bd302a8577f6c396f&amp;sub=0F5DF1F408844E7184F3A6BB5F868F89\" target=\"_blank\" rel=\"noopener\">互联网协议入门4-Http协议（应用层)</a></p>\n</li>\n</ul>\n<h3 id=\"1-4-Python-相关\"><a href=\"#1-4-Python-相关\" class=\"headerlink\" title=\"1.4 Python 相关\"></a>1.4 Python 相关</h3><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=398da3b52370f6976e9a67cb3be4cd24&amp;sub=WEBf9be5147ccbf73c569b46bb2a5ffe942\" target=\"_blank\" rel=\"noopener\">Anaconda 使用</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=a813207158a22cfa902dbeba640bdf87&amp;sub=E61484FE7B0D4D999DF1A462FA780049\" target=\"_blank\" rel=\"noopener\">python 性能优化</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=dde4ed2eb6eea6c45926d251689e3d4e&amp;sub=4A1EA0D89E634DEC9DD294C13012EFCA\" target=\"_blank\" rel=\"noopener\">python 内存管理</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=9146e0886cac1bdaec8cce2e5081cfe0&amp;sub=060F7616DF954602BB641EC52D0F6110\" target=\"_blank\" rel=\"noopener\">python 包管理</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=3724fe43398de6c5fbd75dd8c452987e&amp;sub=7837405EB49045FF8C22156022261A94\" target=\"_blank\" rel=\"noopener\">知识积累</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=bfbf2eb0c5bccf64974fe260e1bdf131&amp;sub=A8906CE9DF0E47F19377CD49BF2DFA6F\" target=\"_blank\" rel=\"noopener\">python 数据模型</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=0f7309f661031855b1e257072ceab9b9&amp;sub=E6CAEE5B6F7043779DF1F3A95923DC0F\" target=\"_blank\" rel=\"noopener\">Set 集合  交并差运算</a></p>\n</li>\n</ul>\n<h4 id=\"pandas-包\"><a href=\"#pandas-包\" class=\"headerlink\" title=\"pandas 包\"></a>pandas 包</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=f191fc11a263f303532d40c02c1f2161&amp;sub=3F6F9858E4DA4B7A9245F66557B15AB4\" target=\"_blank\" rel=\"noopener\">pandas</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=64c2febf14a2e0f96bcbc868375500b9&amp;sub=0B21232330E442118F68ADFB44DECA6E\" target=\"_blank\" rel=\"noopener\">pandas-1数据结构</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=7b8a86d71c5321171292fa000666efc8&amp;sub=A1102303D97F4E2D836A588F4882C5E2\" target=\"_blank\" rel=\"noopener\">pandas-2索引和选择数据</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=02c6e6a9916d2f600153fa5402395c29&amp;sub=0CF2D73FB22140A29F3838CF6EF299B9\" target=\"_blank\" rel=\"noopener\">pandas-分层和多级索引</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=b8d6c15c3d603261cee9b6771732c5a5&amp;sub=WEB9f17e5d4ecb0520c9c27c8145f3450dc\" target=\"_blank\" rel=\"noopener\">pandas-4分组与聚合</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=57496ba2051b12d778ac17612d871354&amp;sub=62AE7AB578AF4B3A9D630676179C8CA0\" target=\"_blank\" rel=\"noopener\">pandas-5缺失值处理</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=f16646b876ddb2c5ec482e316ca881dd&amp;sub=8024BDCE94B4455FA20514234C7233C0\" target=\"_blank\" rel=\"noopener\">pandas-6重复值处理</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=5210591266c5f2472eab6bdb0e1adc7e&amp;sub=7B85239BB0C74343830F3EBBC34F43A0\" target=\"_blank\" rel=\"noopener\">pandas-7时间处理</a></p>\n</li>\n</ul>\n<h3 id=\"1-5-数据结构与算法相关\"><a href=\"#1-5-数据结构与算法相关\" class=\"headerlink\" title=\"1.5 数据结构与算法相关\"></a>1.5 数据结构与算法相关</h3><h4 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=77d45fd3df6dc9821a505972246afc67&amp;sub=CBBC8BE4E72147248464A2C136D8A893\" target=\"_blank\" rel=\"noopener\">链表入门-单链表</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=2038af6c36c144a0005d3f7cb7cbd6e1&amp;sub=19BC0DEA04654C51970F77E363746D36\" target=\"_blank\" rel=\"noopener\">双向链表</a></p>\n</li>\n</ul>\n<h4 id=\"树结构\"><a href=\"#树结构\" class=\"headerlink\" title=\"树结构\"></a>树结构</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=3d87798249099424c8f688932e054d34&amp;sub=962de575938af485eb5896712a3fa88bhttp://note.youdao.com/noteshare?id=3d87798249099424c8f688932e054d34&amp;sub=962de575938af485eb5896712a3fa88b\" target=\"_blank\" rel=\"noopener\">树结构1-二叉树的种类 </a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=a93bf51802eb22ed23e7f01baeecdfd9&amp;sub=C2561C42F8354E2787F3F58DC19CC2F5\" target=\"_blank\" rel=\"noopener\">树结构2-二叉树的四种遍历</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=6595e3f3a04494d53c79ac4f14156b45&amp;sub=36364C54AB334D5B85B1871D6758FFF7\" target=\"_blank\" rel=\"noopener\">树结构3- 二叉排序树 </a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=ff1c7f5f5c5439a5bcf29746bafacd8e&amp;sub=524DD42459CF4A43AB7CD89A74D83BAB\" target=\"_blank\" rel=\"noopener\">树结构4- 完全二叉树-堆排序 </a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=28a1554677d3108539d237ed2dbfb3a9&amp;sub=6917ECACABFC4BE99B0840940E1492C3\" target=\"_blank\" rel=\"noopener\">树结构5-红黑树 </a></p>\n</li>\n</ul>\n<h4 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h4><ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=32bb87989cc88c68f94b697a2309e577&amp;sub=CB4F1BAE4B48482B895E4B334EC920B7\" target=\"_blank\" rel=\"noopener\">栈 - Stack</a></li>\n</ul>\n<h4 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=2bf63868f3e17320b15a68783a6f1d89&amp;sub=35032594A3AB441EB7DB3344B71213EF\" target=\"_blank\" rel=\"noopener\">动态规划-DP</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=47da45a5509c7f21f5905c65ec87c12d&amp;sub=E525698B083343B382EFC767181A2755\" target=\"_blank\" rel=\"noopener\">DFS和回溯算法- 暴力搜索的优化方案</a></p>\n</li>\n</ul>\n<h4 id=\"一般算法\"><a href=\"#一般算法\" class=\"headerlink\" title=\"一般算法\"></a>一般算法</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=6139197ff7cc443d83b73f578ced01d2&amp;sub=3671B7672DA341359DF0C57DAA5114E3\" target=\"_blank\" rel=\"noopener\">二分查找</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=417cd36012151f1465f6b179a68c2559&amp;sub=39B0B9975CC34C589CCCF7A4A619E921\" target=\"_blank\" rel=\"noopener\">最大公约数与最小公倍数</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=b9bb5b1c7a7f968392ca087beb53a288&amp;sub=7AC07884471A4FFBAC433400CC8DD668\" target=\"_blank\" rel=\"noopener\">素数和合数</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=900f90e3d481dcabbd5ce22df8452e4b&amp;sub=2A9F48EDC9824721A63091F213AE84DF\" target=\"_blank\" rel=\"noopener\">排序算法-Java版</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=34e1f4c6bbc849e28017b14d1aa1ed3d&amp;sub=04B030FDEA424189A387F2B149670138\" target=\"_blank\" rel=\"noopener\">蓄水池采样算法</a></p>\n</li>\n</ul>\n<h3 id=\"1-6-设计模式\"><a href=\"#1-6-设计模式\" class=\"headerlink\" title=\"1.6 设计模式\"></a>1.6 设计模式</h3><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=9b725da8bd83d6d2fa6628449036fa76&amp;sub=61D7D7C472CC4F6FA40978D2EEE3F253\" target=\"_blank\" rel=\"noopener\">单例模式</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=3258d6710e66d885a3a213d45eea14be&amp;sub=9E8B81697FD248EDBAAB8B203ACDD4B9\" target=\"_blank\" rel=\"noopener\">汇总 </a></p>\n</li>\n</ul>\n<h2 id=\"第二章-计算机提高篇\"><a href=\"#第二章-计算机提高篇\" class=\"headerlink\" title=\"第二章  计算机提高篇\"></a>第二章  计算机提高篇</h2><blockquote>\n<p>提高篇是一些具体的学习方向，我学的比较杂。</p>\n</blockquote>\n<h3 id=\"2-1-机器学习与数据挖掘\"><a href=\"#2-1-机器学习与数据挖掘\" class=\"headerlink\" title=\"2.1 机器学习与数据挖掘\"></a>2.1 机器学习与数据挖掘</h3><ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=a2a581480ef2d48c22c8972e2c1289ea&amp;sub=WEBe5a19e45418f24614a27d5c871dbeef6\" target=\"_blank\" rel=\"noopener\">特征工程中的问题</a></li>\n</ul>\n<h4 id=\"决策树\"><a href=\"#决策树\" class=\"headerlink\" title=\"决策树\"></a>决策树</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=72d77f019bd4fc8cde5d77f1479213a3&amp;sub=3A0C8DB3DE554ED5B70179B18DEBDB6F\" target=\"_blank\" rel=\"noopener\">决策树-1基本概念</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=6b4b7d196688d64889da3563eb4b194d&amp;sub=E48B826F34CB41769382CA5DD11DE54F\" target=\"_blank\" rel=\"noopener\">决策树-2 ID3算法</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=51ba5d9d9611ae2284c2612d5f38b721&amp;sub=C40D67A492D4428EB698D146897932F2\" target=\"_blank\" rel=\"noopener\">决策树-3 CART分类回归树</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=8fd42b53e1a611131199f17d399820c7&amp;sub=F7FA6EBCE1CC4A95875DD83B2CF9C551\" target=\"_blank\" rel=\"noopener\">CART 分类回归树</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=d5d006e5d1680bb1b93f6cdc68973b60&amp;sub=C12A5DC3350C49CA8862D51287908CE4\" target=\"_blank\" rel=\"noopener\">sklearn 决策树使用技巧</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=3a209c356ed655acacf08699cef27150&amp;sub=E0880A97A8264449BD714025A98BFE52\" target=\"_blank\" rel=\"noopener\">sklearn整理-决策树</a></p>\n</li>\n</ul>\n<h4 id=\"神经网络\"><a href=\"#神经网络\" class=\"headerlink\" title=\"神经网络\"></a>神经网络</h4><ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=d1d1a974ade3ab72cd8ff9fbab061e78&amp;sub=6C8F11DB78FA417AA9F4D0DA30351077\" target=\"_blank\" rel=\"noopener\">常见的神经网络</a></li>\n</ul>\n<h4 id=\"集成学习\"><a href=\"#集成学习\" class=\"headerlink\" title=\"集成学习\"></a>集成学习</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=fb4b442794aac472bdd7663b026a2dab&amp;sub=939B2AAEB6F94E32ABAD4A54B8AF1358\" target=\"_blank\" rel=\"noopener\">集成学习提升算法-Adaboost</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=eb03f9b12281363b052e0ed071833b13&amp;sub=WEBb2a9d589fb05754f76c2b2af09a826c1\" target=\"_blank\" rel=\"noopener\">XGBoost -python package introduction</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=2039180d0a9ad5b39339c93e8c70040d&amp;sub=9C48D93E6A1E4C1186E6F37EF222F528\" target=\"_blank\" rel=\"noopener\">梯度提升树-GBDT</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=e4ac54bae64eb94641594ad5f4a2cd6d&amp;sub=8232CAC65C0A4FDC9EDED033B6A4770F\" target=\"_blank\" rel=\"noopener\">sklearn整理-集成学习-随机森林</a></p>\n</li>\n</ul>\n<h4 id=\"模型评价\"><a href=\"#模型评价\" class=\"headerlink\" title=\"模型评价\"></a>模型评价</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=c76dbbe346dbd32a62cd4303f7bf4864&amp;sub=753D4CFE21084BA78B0506697A415A0C\" target=\"_blank\" rel=\"noopener\">ROC与AUC</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=030f5d8884e6a0914891ebf2289318fa&amp;sub=28D75EDB51044316AB154021B0EB6BEA\" target=\"_blank\" rel=\"noopener\">机器学习的方差与偏差</a></p>\n</li>\n</ul>\n<h4 id=\"参与的一些竞赛\"><a href=\"#参与的一些竞赛\" class=\"headerlink\" title=\"参与的一些竞赛\"></a>参与的一些竞赛</h4><ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=1d8176b82fc84b0a3906fbd53979041c&amp;sub=305B25CE269F45DCA311DBE8C20DAF67\" target=\"_blank\" rel=\"noopener\">ali-新人实战赛o2o优惠券使用预测</a></li>\n</ul>\n<ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=5b2fa1c8320743190649812b394b3ed5&amp;sub=27291314B2C74B09ABF8619277EE8A5E\" target=\"_blank\" rel=\"noopener\">ccf-2019</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=52c517d38463d99b24672f0195ecabfe&amp;sub=WEBf24a84a951b3b16a0685ed029a28b960\" target=\"_blank\" rel=\"noopener\">dc-2019-商品购买转化率预测</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=2fd9687a7cb8c10210bf738536dd8021&amp;sub=AE7E1B49101546F093C7C2B993A736A3\" target=\"_blank\" rel=\"noopener\">竞赛提升方法-tricks</a></p>\n</li>\n</ul>\n<ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=f43a977d8705582da02c202f295dadcc&amp;sub=74C22A94ABB74B309807A886F50A5863\" target=\"_blank\" rel=\"noopener\">sklearn 脑图</a></li>\n</ul>\n<h3 id=\"2-2-大数据与Hadoop\"><a href=\"#2-2-大数据与Hadoop\" class=\"headerlink\" title=\"2.2 大数据与Hadoop\"></a>2.2 大数据与Hadoop</h3><h4 id=\"多台机器的分布式环境安装\"><a href=\"#多台机器的分布式环境安装\" class=\"headerlink\" title=\"多台机器的分布式环境安装\"></a>多台机器的分布式环境安装</h4><ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=e284c332fb9766d6487d925c4381ae22&amp;sub=E4980D34F8A347DC9C1E2C23C5A48D17\" target=\"_blank\" rel=\"noopener\">1.hadoop分布式集群安装</a></li>\n</ul>\n<h4 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h4><ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=773c4878eaec8cc266c5074691a3d780&amp;sub=68CE094D754C46CDA96C8CFA00401DF2\" target=\"_blank\" rel=\"noopener\">Hadoop RPC</a></li>\n</ul>\n<h4 id=\"mapreduce-实验\"><a href=\"#mapreduce-实验\" class=\"headerlink\" title=\"mapreduce 实验\"></a>mapreduce 实验</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=710757567d678841cb43e891531c63b9&amp;sub=BA97FAC420754425A2FE07E67D6B6EAD\" target=\"_blank\" rel=\"noopener\">实验1.  多表关联</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=7c251c3514764eb58fdad72de78bf6a5&amp;sub=FF9F53C4D1A04E008FA61A85A9CE0F01\" target=\"_blank\" rel=\"noopener\">实验2.  最高温度统计</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=226bf0abd5e44ed6eae69f5250024bcf&amp;sub=5EE9A40650BB4AD2A661C65DFBC57FC5\" target=\"_blank\" rel=\"noopener\">实验3.  单表关联</a></p>\n</li>\n</ul>\n<h3 id=\"2-3-VUE\"><a href=\"#2-3-VUE\" class=\"headerlink\" title=\"2.3 VUE\"></a>2.3 VUE</h3><h4 id=\"VUE-安装\"><a href=\"#VUE-安装\" class=\"headerlink\" title=\"VUE 安装\"></a>VUE 安装</h4><ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=c60a733187bef04fa0404429eb2d1f30&amp;sub=3F4FE35DF8E349A395F8C4C19AA7BBE4\" target=\"_blank\" rel=\"noopener\">开发环境搭建</a></li>\n</ul>\n<h3 id=\"2-4-Spring-框架\"><a href=\"#2-4-Spring-框架\" class=\"headerlink\" title=\"2.4 Spring 框架\"></a>2.4 Spring 框架</h3><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=7181c4a539cade23a864c8e970b05833&amp;sub=771654DC28474896BAB711DD289A052C\" target=\"_blank\" rel=\"noopener\">Spring-1控制反转（IOC）和依赖注入</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=32da7b7e487b45fd4fde7906fb9436a1&amp;sub=BAF8F0AE43DB42B399AC14B01FE74689\" target=\"_blank\" rel=\"noopener\">Spring-2AOP 面向切面编程-基于动态代</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=2caa6adcf719adaba44ad57fcad131e4&amp;sub=8E30EF145E8A4972867B5476DF2DD607\" target=\"_blank\" rel=\"noopener\">Spring-3事务管理Transaction Manager</a></p>\n</li>\n</ul>\n<h2 id=\"第三章-工具使用\"><a href=\"#第三章-工具使用\" class=\"headerlink\" title=\"第三章  工具使用\"></a>第三章  工具使用</h2><ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=82f292615812b23fec6c7ce9fcc35ec4&amp;sub=6FC7D088767948388F03769F13A2C971\" target=\"_blank\" rel=\"noopener\">vscode 使用记录</a></li>\n</ul>\n<h2 id=\"第四章-收藏的书籍\"><a href=\"#第四章-收藏的书籍\" class=\"headerlink\" title=\"第四章  收藏的书籍\"></a>第四章  收藏的书籍</h2><ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=57e1d26f1f078dc70a5b18392b29a841\" target=\"_blank\" rel=\"noopener\">书籍收藏</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Computer-Basics-Notes-Links\"><a href=\"#Computer-Basics-Notes-Links\" class=\"headerlink\" title=\"Computer-Basics-Notes-Links\"></a>Computer-Basics-Notes-Links</h1><p><a href=\"https://github.com/elgong/Computer-Basics-Notes-Links\" target=\"_blank\" rel=\"noopener\">github地址</a></p>\n<h1 id=\"学习笔记\"><a href=\"#学习笔记\" class=\"headerlink\" title=\"学习笔记\"></a>学习笔记</h1><blockquote>\n<p>我在学习计算机基础的过程中整理了一部分笔记，但都比较零散，有些稍微连贯的内容已经整理为博客，而大部分还没来得及整理成md格式，我先整理出链接。为了尽可能的清晰展示笔记脉络，下文将分门别类的列出，有需要请自取。<br>笔记内容大部分都是参考了网上的博客以及书籍，整理笔记的习惯也是刚刚养成的，从开始整理笔记后，发现自己对于做过的东西，能够随着笔记很快的回忆起来，遇到一些问题能够快速从笔记里找到答案也是比较舒服的。笔记是用有道云分享的，我未来仍然会继续梳理这些笔记，如果有任何的错误或者意见，麻烦您联系我哈。</p>\n</blockquote>\n<h2 id=\"第一章-计算机基础篇\"><a href=\"#第一章-计算机基础篇\" class=\"headerlink\" title=\"第一章  计算机基础篇\"></a>第一章  计算机基础篇</h2><blockquote>\n<p>基础部分是一些语言相关的知识点。</p>\n</blockquote>\n<h3 id=\"1-1-Java-相关\"><a href=\"#1-1-Java-相关\" class=\"headerlink\" title=\"1.1 Java 相关\"></a>1.1 Java 相关</h3><h4 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h4><ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=f869167b77cb73b67478290ffdcf45bc&amp;sub=06694CB1F00B45CBA1D4BD1A4B62320C\" target=\"_blank\" rel=\"noopener\">Java面向对象-多态</a></li>\n</ul>\n<h4 id=\"部分源码分析\"><a href=\"#部分源码分析\" class=\"headerlink\" title=\"部分源码分析\"></a>部分源码分析</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=def11ef6e833a11434137d6fec1c834a&amp;sub=DD0083BFCFE14839A721700413B41F38\" target=\"_blank\" rel=\"noopener\">java.lang.Object 类</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=fb941f5b4a01adf474496df328542a91&amp;sub=02C7EDC387984E3BADE744B9280EA1E6\" target=\"_blank\" rel=\"noopener\">java.lang.Integer等基本类型包装类</a></p>\n</li>\n</ul>\n<h4 id=\"接口和抽象类\"><a href=\"#接口和抽象类\" class=\"headerlink\" title=\"接口和抽象类\"></a>接口和抽象类</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=7bdd684a91766f6b448e5328f1fed251&amp;sub=0DEE02584D22485EACF337D5F846ACCE0\" target=\"_blank\" rel=\"noopener\">接口和抽象类的概念</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=eb3b5e1f37828c301015c1fcc48b2ee9&amp;sub=B77DF9D467AE48948C63CEE6D7B51FB5\" target=\"_blank\" rel=\"noopener\">java.io.Serializable接口</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=af26732dc5f501e490a3f57c6b46333c&amp;sub=1E9132AF928342728B68D66845201D05\" target=\"_blank\" rel=\"noopener\">java.lang.AbstractStringBuilder</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=62429dcbeb51676d855b0c46d89ea67b&amp;sub=7D9CC78E517B46A19C567A567DDA0C1E\" target=\"_blank\" rel=\"noopener\">java.lang.CharSequence接口</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=4309c54f9e557075dc953a25a1e9aea4&amp;sub=4AF6A4102AD6494F884069B5F75DB663\" target=\"_blank\" rel=\"noopener\">java.lang.Comparable 接口</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=d7525d979bbcfac0ad602e0f90124a39&amp;sub=9B8E20EC1E924C988EB9DEC3C059FE4F\" target=\"_blank\" rel=\"noopener\">java.lang.Iterable 接口</a></p>\n</li>\n</ul>\n<h4 id=\"集合类\"><a href=\"#集合类\" class=\"headerlink\" title=\"集合类\"></a>集合类</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=3f13ce83c60473cb2d03ac7d500b3771&amp;sub=77608E57EC404A3D925D5BADFABA9F0C\" target=\"_blank\" rel=\"noopener\">Java集合的结构</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=8d5718ecf80ea7c1cd144c848afb556f&amp;sub=D12BF9FEA9B54873871F5BDC532FB46A\" target=\"_blank\" rel=\"noopener\">java.util.Arrays工具类</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=55f2b8f2004cc365aa3200283f918642&amp;sub=373C38673F3D4233869F2FA181CF6C77\" target=\"_blank\" rel=\"noopener\">java.util.Collections 工具类</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=2d1b0ca8f6ee80acab26bac64e65752b&amp;sub=BC00717F11EC48DBAA3187C99E27FB67\" target=\"_blank\" rel=\"noopener\">集合类之间的转换</a></p>\n</li>\n</ul>\n<h5 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h5><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=cf4402932c37eeda65d2cb48b771fa85&amp;sub=38A358238D644B009E8D35E85BC3958A\" target=\"_blank\" rel=\"noopener\">java.util.Collection 接口</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=35066dabdc8838cbf4a81a6064d3a278&amp;sub=B08F3371DAF94E0A8577E14A355948F7\" target=\"_blank\" rel=\"noopener\">java.util.List 接口</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=ac00534071924ed6812c3087ff89522d&amp;sub=7CF204D01C2846469F874ABE719F122E\" target=\"_blank\" rel=\"noopener\">java.util.ArrayList 类</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=24e53ad8811d97e37ae725caef30e87c&amp;sub=3580B9F523B14B9A8346594FAB7428B7\" target=\"_blank\" rel=\"noopener\">java.util.LinkedList 类</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=3fefcc71bac40f731582cda7de9680a9&amp;sub=FD48F85901CA48C2A1FDBFB356072932\" target=\"_blank\" rel=\"noopener\">java.util.Vector类-线程安全</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=7ca967ab85ba51315d576614e4debb88&amp;sub=D7FB8F63F9524697A2B6C92EBC997759\" target=\"_blank\" rel=\"noopener\">java.util.Stack类-线程安全</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=e69b12c5f34e8999a63f901e66cf6349&amp;sub=378BBC5185DD4901949BA8D6CC586117\" target=\"_blank\" rel=\"noopener\">java.util.Queue 接口</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=70bcfde9362d131a6cc9769df7c6a195&amp;sub=4CCDF46A03F64701B726C3B5B17EE5C7\" target=\"_blank\" rel=\"noopener\">java.util.Deque 接口</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=a8e52263383bbff56bba83c4437e62a5&amp;sub=273730F39B6345348B400731471932CD\" target=\"_blank\" rel=\"noopener\">java.util.ArrayDeque 类</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=d5807c6cbb3dfcd1c6a6fa2587f2a53a&amp;sub=8DB19EF833FF477C8241702AB6C728D4\" target=\"_blank\" rel=\"noopener\">java.util.PriorityQueue 类</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=78367406564a757c47fbb5fd74ab4118&amp;sub=CD2FAD0FE2EE433EAFEB76285A06D389\" target=\"_blank\" rel=\"noopener\">java.util.Set 接口</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=473ccb760a498a837a6fca3373b1f6d1&amp;sub=EF96DCB65AD1431BBCFBB52F21896643\" target=\"_blank\" rel=\"noopener\">java.util.HashSet 类</a></p>\n</li>\n</ul>\n<h5 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h5><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=8066dded44e4cba4a621fe78ed94c4a9&amp;sub=B9652D8B6D7940FFB5C92A5106BCC277\" target=\"_blank\" rel=\"noopener\">java.util.Map 接口</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=de517d176afdc4e3d0c9887c437bee17&amp;sub=459B4CAF65FF4D67BFBE91DCED6E050E\" target=\"_blank\" rel=\"noopener\">java.util.TreeMap 类</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=791e29ca757ab1dedb8f80d872c940b1&amp;sub=70D9B6BA82AF4889ACAD0A52F18C456D\" target=\"_blank\" rel=\"noopener\">java.util.HashMap 类</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=473ccb760a498a837a6fca3373b1f6d1&amp;sub=EF96DCB65AD1431BBCFBB52F21896643\" target=\"_blank\" rel=\"noopener\">java.util.HashSet 类</a></p>\n</li>\n</ul>\n<h4 id=\"IO-模型与IO流\"><a href=\"#IO-模型与IO流\" class=\"headerlink\" title=\"IO 模型与IO流\"></a>IO 模型与IO流</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=658c32dde4ecf6c8525649914d0f8560&amp;sub=FF09583558E14D2BA25680647013CBA3\" target=\"_blank\" rel=\"noopener\">标准步骤：</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=3dec994dd95a401eed7aabdfb1c5c15f&amp;sub=CAB6771BB0F044F895A705B8AB7514BC\" target=\"_blank\" rel=\"noopener\">针对oj系统中的输入问题</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=1a496522d91fa47b4f3132aa97228ab7&amp;sub=CD032B0A9E714FE9ABB2BE05B49CEE75\" target=\"_blank\" rel=\"noopener\">java IO之AutoCloseable接口</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=e496eb1243c65be077e6193400f6209d&amp;sub=5594861B9BE845BFAFB4BD14D7DE49D4\" target=\"_blank\" rel=\"noopener\">IO篇1-Java IO模型</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=8ef12e2d0ce1d93b444eb430ba110fe3&amp;sub=B6822523990E474D869C822BFCD5DFB2\" target=\"_blank\" rel=\"noopener\">IO篇2-Java NIO</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=2e291882966fc1b4d7f3efafdd39d32e&amp;sub=CE23D5FE57DC45709F74AFEB3A49F22E\" target=\"_blank\" rel=\"noopener\">IO篇3-Java NIO 零拷贝</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=07cbfb2c33782cd85f62e05ff298740d&amp;sub=CC14B7D2EBB64930A3E7E8C4241EBD83\" target=\"_blank\" rel=\"noopener\">IO篇4-Linux 内核的 select&amp;epoll</a></p>\n</li>\n</ul>\n<h4 id=\"多线程与并发\"><a href=\"#多线程与并发\" class=\"headerlink\" title=\"多线程与并发\"></a>多线程与并发</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=b7407e24b468fd58df564afcbf749183&amp;sub=954EE84618B44B6FAFE4931E4F691873\" target=\"_blank\" rel=\"noopener\">synchronized 锁的JVM中实现原理-偏向</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=0f69c79fd2c666de113882fd3ac72abf&amp;sub=61118765FB1F4B85B048C652460A5768\" target=\"_blank\" rel=\"noopener\">线程的创建</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=49735f35157748a107270cb85fbb867c&amp;sub=0D34816A0AA24981B0B61EB87A64C8D4\" target=\"_blank\" rel=\"noopener\">线程间的通信</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=12aac80f35ab764277a810af76852cb2&amp;sub=4A4D685F065F46B9B60D9703CEE04D29\" target=\"_blank\" rel=\"noopener\">线程的生命周期</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=8d401fdafcc6c5712042fa06f6e3850b&amp;sub=96CD2BBFE5914F089493A803A5B7D020\" target=\"_blank\" rel=\"noopener\">对象和变量的并发访问（可见性，原子性)</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=ed1aa8d1cf7688f52c1598735165a2dc&amp;sub=15233B8FCFFB4E11AC6167CE4BF4077E\" target=\"_blank\" rel=\"noopener\">java.util.concurrent.locks包 </a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=291668d9a729451d6c913b3137c9640f&amp;sub=B28DDF08EC1F4457BFF740A9D8869FE5\" target=\"_blank\" rel=\"noopener\">J.U.C多线程1-Executor 框架的梳理</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=5b0658b7d6383586ef61f9c80ef3d249&amp;sub=CE01D9FD424D45BCA78F88E1A0149C0D\" target=\"_blank\" rel=\"noopener\">J.U.C多线程2-ThreadPoolExecutor线程</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=cb9e9ac4838bfdbb7e23f67711f2a84a&amp;sub=859FFFFB9E664A18BB2DBE355F094405\" target=\"_blank\" rel=\"noopener\">实现BlockingQueue接口的阻塞队列</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=19714d2d692039c32ebba2ee3e4829e0&amp;sub=2F7585F44D7E4DBE84E9487A24766668\" target=\"_blank\" rel=\"noopener\">J.U.C多线程3-CAS比较和交换 </a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=6a89441511d69a3bced7209ba47b736b&amp;sub=4A1DC26FB09D4E0C9D6086E37FDEAD6B\" target=\"_blank\" rel=\"noopener\">J.U.C多线程3-AQS 同步器框架的梳理</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=4ef9100e71f2628636a4bff9b73fe882&amp;sub=7998ABD160384F36A606B72FB7493232\" target=\"_blank\" rel=\"noopener\">J.U.C多线程4-AQS框架的应用</a></p>\n</li>\n</ul>\n<h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=d30458d5aac2da6b78824e51dbd982a5&amp;sub=1C451DD2DB6F4481AB58D42E0AA63C44\" target=\"_blank\" rel=\"noopener\">泛型（泛型接口、泛型类、泛型方法）</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=d7092de3662bbf7b0d73b15313fbab0f&amp;sub=95A433A8DC2A4E6FBCF8B54D4767BC40\" target=\"_blank\" rel=\"noopener\">字符串类型-String,StringBuilder</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=9b7abb4a2896be59b9ed6629d028a5c6&amp;sub=4C6D630F214D45DCA01450F1907C6266\" target=\"_blank\" rel=\"noopener\">java 编码规范- google</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=a3af60be0ecf53e817c4954ab4b3f2dd&amp;sub=80F0D1E1017E4522B63882A48BE17CF2\" target=\"_blank\" rel=\"noopener\">Java8- Lambda 表达式</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=29117a52793f44078077602c6f47252f&amp;sub=9B5D88DF10A94DCD968EA4C8263241C9\" target=\"_blank\" rel=\"noopener\">动手实现ArrayList</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=893e0088e06c4e3cd1073a6abeb7bda4&amp;sub=AE4EBC77232149368BEFD526D435B452\" target=\"_blank\" rel=\"noopener\">java 知识点梳理</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=2b866c01ebed8c2f6594e3357ae349be&amp;sub=AA305E3F95724374B5A3C5D96D654270\" target=\"_blank\" rel=\"noopener\">Java 刷题遇到的问题</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=7c544d8a0a428eb5c142c36e771c5fac&amp;sub=1DE4594384FD444F9C705D73C3A26556\" target=\"_blank\" rel=\"noopener\">基本数据类型and 初始化</a></p>\n</li>\n</ul>\n<h4 id=\"jvm-虚拟机\"><a href=\"#jvm-虚拟机\" class=\"headerlink\" title=\"jvm 虚拟机\"></a>jvm 虚拟机</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=4be4640b0d30a46e8e4936fca48fc4da&amp;sub=E4ACF7E445F4469FB7C49A184325AA3A\" target=\"_blank\" rel=\"noopener\">jvm1-内存模型-运行时数据区</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=044b5c8d572a50aa43f7476075feacd6&amp;sub=CB5ACEE22D7C4B119E920A983456E348\" target=\"_blank\" rel=\"noopener\">jvm2-类加载机制</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=38a77fc1b5541c7443a42bb8936ad699&amp;sub=AC6273A6423A45D49DF9D7BA2C02D087\" target=\"_blank\" rel=\"noopener\">jvm3-对象的创建过程</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=85b9df0570061425d77cd09d542758a3&amp;sub=C25619379B2547F5A492FB6900FA53F9\" target=\"_blank\" rel=\"noopener\">jvm4-垃圾回收机制 </a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=3f927397764ecb9a72e25d53d1a8447e&amp;sub=DB8BF7AF904E4224A287A4B22D114460\" target=\"_blank\" rel=\"noopener\">自定义类加载器实现热部署，热替换</a></p>\n</li>\n</ul>\n<h4 id=\"其他-1\"><a href=\"#其他-1\" class=\"headerlink\" title=\"其他\"></a>其他</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=6f70c51df350a1da3b7353b5f0876ba1&amp;sub=A890AA4181A64A17B14D21040C1A9724\" target=\"_blank\" rel=\"noopener\">反射</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=cfb346b9be695d57572367fd3143531e&amp;sub=DE178E988586406F87227AC75BD725CE\" target=\"_blank\" rel=\"noopener\">Java 动态代理</a></p>\n</li>\n</ul>\n<h3 id=\"1-2-数据库相关\"><a href=\"#1-2-数据库相关\" class=\"headerlink\" title=\"1.2 数据库相关\"></a>1.2 数据库相关</h3><h4 id=\"数据库的安装\"><a href=\"#数据库的安装\" class=\"headerlink\" title=\"数据库的安装\"></a>数据库的安装</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=eec529b536dfe09cbbb2d2305a9cec2c&amp;sub=DB98C14DBC15458ABE1B8461CD4C6988\" target=\"_blank\" rel=\"noopener\">windwos 环境中 mysql 数据库安装</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=32e1a61698644f735e5ae33a0d285bee&amp;sub=WEB845b970c5cb400fcf42e04843dbd70af\" target=\"_blank\" rel=\"noopener\">ubuntu 环境中 mysql 安装</a></p>\n</li>\n</ul>\n<h4 id=\"学习笔记-1\"><a href=\"#学习笔记-1\" class=\"headerlink\" title=\"学习笔记\"></a>学习笔记</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=c98cc599b42b416ea2bd0aec7fd11fff&amp;sub=833E6D40B97E4F2F98EFD56C010FE4C7\" target=\"_blank\" rel=\"noopener\">JDBC 使用</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=71dd174ad72a6cca26ae011637d4a705&amp;sub=E3BE9112006D4380953846BA1E446964\" target=\"_blank\" rel=\"noopener\">mysql必知必会</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=4d74a6536781f195ffb428a0aa74fabe&amp;sub=9A407FE68AB54120B18950BEE5500BAF\" target=\"_blank\" rel=\"noopener\">数据库-三大范式</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=78c16d370ba2bf4d06fd1d253072d582&amp;sub=6B15DEFDC24B4353A5820B68A5FB2C05\" target=\"_blank\" rel=\"noopener\">数据库ER图基础</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=f0c534778c8fde528be10f4ffdb2c03b&amp;sub=336222838CDC4F249C1210E24D3701AD\" target=\"_blank\" rel=\"noopener\">mysql必知必会1-DDL数据定义语言</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=360395368205af6b9cd43b67c17200af&amp;sub=3BAEE4ACEA0F4FC2A40AB4DC39965766\" target=\"_blank\" rel=\"noopener\">mysql必知必会2-DML数据操作语句</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=3a8535b5bdf8fbe6b46b85a8f6ab707e&amp;sub=0C9D47245F604624A95E1982D45157F2\" target=\"_blank\" rel=\"noopener\">mysql必知必会3-TCL事务控制语言</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=5a66c81500067c3bafc11fb31cc56cd6&amp;sub=6ADA92683A36438EB254D18AE729A6FA\" target=\"_blank\" rel=\"noopener\">mysql必知必会4-数据类型和约束</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=8b1f73787548684951c21dea07576331&amp;sub=E95C55AAF40F4378B7A14176911B4B81\" target=\"_blank\" rel=\"noopener\">mysql必知必会5-视图</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=d71e1773bdfb453b885ec8280980823e&amp;sub=B0AFAE28DCC94DF09AE25F420927921E\" target=\"_blank\" rel=\"noopener\">mysql必知必会6-变量，存储过程，函数….</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=71dd174ad72a6cca26ae011637d4a705&amp;sub=E3BE9112006D4380953846BA1E446964\" target=\"_blank\" rel=\"noopener\">mysql必知必会7</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=003c0cce526f2a71945614993d250377&amp;sub=56317DB968F04FE3BCC0D482D083C877\" target=\"_blank\" rel=\"noopener\">索引优化1-索引的概念 </a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=a527e1fa83cc6b429814c2f8710b891c&amp;sub=9B9BDA5A138144B5A5A5E5C4BE6CE1D1\" target=\"_blank\" rel=\"noopener\">索引优化2-Mysql索引的底层实现 </a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=f35d29b727ca3a228bfad4aac0a9e9e6&amp;sub=53F88FCDB69547E895DAD25A7D402035\" target=\"_blank\" rel=\"noopener\">索引优化3- explain 查看执行计划 </a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=a83b6505ac7dbb6b3c69afd1860b8ccb&amp;sub=C419B2D7DA254E589E0F449A60544A1C\" target=\"_blank\" rel=\"noopener\">Sql语句优化-查询截取分析 </a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=f8935a502a43186c1c821ad33ccc2c6d&amp;sub=5D286DE5F8304B8BA7290255DBF15C0C\" target=\"_blank\" rel=\"noopener\">mysql-数据库锁的机制和原理 </a></p>\n</li>\n</ul>\n<h3 id=\"1-3-计算机网络相关\"><a href=\"#1-3-计算机网络相关\" class=\"headerlink\" title=\"1.3 计算机网络相关\"></a>1.3 计算机网络相关</h3><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=92e3adba9198d367e976bcc3f772d149&amp;sub=7F7B0D8B9F3E4D7996815384809C35EA\" target=\"_blank\" rel=\"noopener\">互联网协议入门1-模型分层</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=8c41ad2717d4deee47f83841e49d755b&amp;sub=C0C042EE387F4A0096F427CE6F391887\" target=\"_blank\" rel=\"noopener\">互联网协议入门2-访问网页的过程</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=e7f3f660c5df2335b7eccb7be89ce514&amp;sub=A775AFCC161A4388859120A340BDC6CB\" target=\"_blank\" rel=\"noopener\">互联网协议入门3-TCP协议详细内容</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=71031b3ed61c6e8bd302a8577f6c396f&amp;sub=0F5DF1F408844E7184F3A6BB5F868F89\" target=\"_blank\" rel=\"noopener\">互联网协议入门4-Http协议（应用层)</a></p>\n</li>\n</ul>\n<h3 id=\"1-4-Python-相关\"><a href=\"#1-4-Python-相关\" class=\"headerlink\" title=\"1.4 Python 相关\"></a>1.4 Python 相关</h3><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=398da3b52370f6976e9a67cb3be4cd24&amp;sub=WEBf9be5147ccbf73c569b46bb2a5ffe942\" target=\"_blank\" rel=\"noopener\">Anaconda 使用</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=a813207158a22cfa902dbeba640bdf87&amp;sub=E61484FE7B0D4D999DF1A462FA780049\" target=\"_blank\" rel=\"noopener\">python 性能优化</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=dde4ed2eb6eea6c45926d251689e3d4e&amp;sub=4A1EA0D89E634DEC9DD294C13012EFCA\" target=\"_blank\" rel=\"noopener\">python 内存管理</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=9146e0886cac1bdaec8cce2e5081cfe0&amp;sub=060F7616DF954602BB641EC52D0F6110\" target=\"_blank\" rel=\"noopener\">python 包管理</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=3724fe43398de6c5fbd75dd8c452987e&amp;sub=7837405EB49045FF8C22156022261A94\" target=\"_blank\" rel=\"noopener\">知识积累</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=bfbf2eb0c5bccf64974fe260e1bdf131&amp;sub=A8906CE9DF0E47F19377CD49BF2DFA6F\" target=\"_blank\" rel=\"noopener\">python 数据模型</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=0f7309f661031855b1e257072ceab9b9&amp;sub=E6CAEE5B6F7043779DF1F3A95923DC0F\" target=\"_blank\" rel=\"noopener\">Set 集合  交并差运算</a></p>\n</li>\n</ul>\n<h4 id=\"pandas-包\"><a href=\"#pandas-包\" class=\"headerlink\" title=\"pandas 包\"></a>pandas 包</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=f191fc11a263f303532d40c02c1f2161&amp;sub=3F6F9858E4DA4B7A9245F66557B15AB4\" target=\"_blank\" rel=\"noopener\">pandas</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=64c2febf14a2e0f96bcbc868375500b9&amp;sub=0B21232330E442118F68ADFB44DECA6E\" target=\"_blank\" rel=\"noopener\">pandas-1数据结构</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=7b8a86d71c5321171292fa000666efc8&amp;sub=A1102303D97F4E2D836A588F4882C5E2\" target=\"_blank\" rel=\"noopener\">pandas-2索引和选择数据</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=02c6e6a9916d2f600153fa5402395c29&amp;sub=0CF2D73FB22140A29F3838CF6EF299B9\" target=\"_blank\" rel=\"noopener\">pandas-分层和多级索引</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=b8d6c15c3d603261cee9b6771732c5a5&amp;sub=WEB9f17e5d4ecb0520c9c27c8145f3450dc\" target=\"_blank\" rel=\"noopener\">pandas-4分组与聚合</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=57496ba2051b12d778ac17612d871354&amp;sub=62AE7AB578AF4B3A9D630676179C8CA0\" target=\"_blank\" rel=\"noopener\">pandas-5缺失值处理</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=f16646b876ddb2c5ec482e316ca881dd&amp;sub=8024BDCE94B4455FA20514234C7233C0\" target=\"_blank\" rel=\"noopener\">pandas-6重复值处理</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=5210591266c5f2472eab6bdb0e1adc7e&amp;sub=7B85239BB0C74343830F3EBBC34F43A0\" target=\"_blank\" rel=\"noopener\">pandas-7时间处理</a></p>\n</li>\n</ul>\n<h3 id=\"1-5-数据结构与算法相关\"><a href=\"#1-5-数据结构与算法相关\" class=\"headerlink\" title=\"1.5 数据结构与算法相关\"></a>1.5 数据结构与算法相关</h3><h4 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=77d45fd3df6dc9821a505972246afc67&amp;sub=CBBC8BE4E72147248464A2C136D8A893\" target=\"_blank\" rel=\"noopener\">链表入门-单链表</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=2038af6c36c144a0005d3f7cb7cbd6e1&amp;sub=19BC0DEA04654C51970F77E363746D36\" target=\"_blank\" rel=\"noopener\">双向链表</a></p>\n</li>\n</ul>\n<h4 id=\"树结构\"><a href=\"#树结构\" class=\"headerlink\" title=\"树结构\"></a>树结构</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=3d87798249099424c8f688932e054d34&amp;sub=962de575938af485eb5896712a3fa88bhttp://note.youdao.com/noteshare?id=3d87798249099424c8f688932e054d34&amp;sub=962de575938af485eb5896712a3fa88b\" target=\"_blank\" rel=\"noopener\">树结构1-二叉树的种类 </a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=a93bf51802eb22ed23e7f01baeecdfd9&amp;sub=C2561C42F8354E2787F3F58DC19CC2F5\" target=\"_blank\" rel=\"noopener\">树结构2-二叉树的四种遍历</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=6595e3f3a04494d53c79ac4f14156b45&amp;sub=36364C54AB334D5B85B1871D6758FFF7\" target=\"_blank\" rel=\"noopener\">树结构3- 二叉排序树 </a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=ff1c7f5f5c5439a5bcf29746bafacd8e&amp;sub=524DD42459CF4A43AB7CD89A74D83BAB\" target=\"_blank\" rel=\"noopener\">树结构4- 完全二叉树-堆排序 </a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=28a1554677d3108539d237ed2dbfb3a9&amp;sub=6917ECACABFC4BE99B0840940E1492C3\" target=\"_blank\" rel=\"noopener\">树结构5-红黑树 </a></p>\n</li>\n</ul>\n<h4 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h4><ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=32bb87989cc88c68f94b697a2309e577&amp;sub=CB4F1BAE4B48482B895E4B334EC920B7\" target=\"_blank\" rel=\"noopener\">栈 - Stack</a></li>\n</ul>\n<h4 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=2bf63868f3e17320b15a68783a6f1d89&amp;sub=35032594A3AB441EB7DB3344B71213EF\" target=\"_blank\" rel=\"noopener\">动态规划-DP</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=47da45a5509c7f21f5905c65ec87c12d&amp;sub=E525698B083343B382EFC767181A2755\" target=\"_blank\" rel=\"noopener\">DFS和回溯算法- 暴力搜索的优化方案</a></p>\n</li>\n</ul>\n<h4 id=\"一般算法\"><a href=\"#一般算法\" class=\"headerlink\" title=\"一般算法\"></a>一般算法</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=6139197ff7cc443d83b73f578ced01d2&amp;sub=3671B7672DA341359DF0C57DAA5114E3\" target=\"_blank\" rel=\"noopener\">二分查找</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=417cd36012151f1465f6b179a68c2559&amp;sub=39B0B9975CC34C589CCCF7A4A619E921\" target=\"_blank\" rel=\"noopener\">最大公约数与最小公倍数</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=b9bb5b1c7a7f968392ca087beb53a288&amp;sub=7AC07884471A4FFBAC433400CC8DD668\" target=\"_blank\" rel=\"noopener\">素数和合数</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=900f90e3d481dcabbd5ce22df8452e4b&amp;sub=2A9F48EDC9824721A63091F213AE84DF\" target=\"_blank\" rel=\"noopener\">排序算法-Java版</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=34e1f4c6bbc849e28017b14d1aa1ed3d&amp;sub=04B030FDEA424189A387F2B149670138\" target=\"_blank\" rel=\"noopener\">蓄水池采样算法</a></p>\n</li>\n</ul>\n<h3 id=\"1-6-设计模式\"><a href=\"#1-6-设计模式\" class=\"headerlink\" title=\"1.6 设计模式\"></a>1.6 设计模式</h3><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=9b725da8bd83d6d2fa6628449036fa76&amp;sub=61D7D7C472CC4F6FA40978D2EEE3F253\" target=\"_blank\" rel=\"noopener\">单例模式</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=3258d6710e66d885a3a213d45eea14be&amp;sub=9E8B81697FD248EDBAAB8B203ACDD4B9\" target=\"_blank\" rel=\"noopener\">汇总 </a></p>\n</li>\n</ul>\n<h2 id=\"第二章-计算机提高篇\"><a href=\"#第二章-计算机提高篇\" class=\"headerlink\" title=\"第二章  计算机提高篇\"></a>第二章  计算机提高篇</h2><blockquote>\n<p>提高篇是一些具体的学习方向，我学的比较杂。</p>\n</blockquote>\n<h3 id=\"2-1-机器学习与数据挖掘\"><a href=\"#2-1-机器学习与数据挖掘\" class=\"headerlink\" title=\"2.1 机器学习与数据挖掘\"></a>2.1 机器学习与数据挖掘</h3><ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=a2a581480ef2d48c22c8972e2c1289ea&amp;sub=WEBe5a19e45418f24614a27d5c871dbeef6\" target=\"_blank\" rel=\"noopener\">特征工程中的问题</a></li>\n</ul>\n<h4 id=\"决策树\"><a href=\"#决策树\" class=\"headerlink\" title=\"决策树\"></a>决策树</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=72d77f019bd4fc8cde5d77f1479213a3&amp;sub=3A0C8DB3DE554ED5B70179B18DEBDB6F\" target=\"_blank\" rel=\"noopener\">决策树-1基本概念</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=6b4b7d196688d64889da3563eb4b194d&amp;sub=E48B826F34CB41769382CA5DD11DE54F\" target=\"_blank\" rel=\"noopener\">决策树-2 ID3算法</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=51ba5d9d9611ae2284c2612d5f38b721&amp;sub=C40D67A492D4428EB698D146897932F2\" target=\"_blank\" rel=\"noopener\">决策树-3 CART分类回归树</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=8fd42b53e1a611131199f17d399820c7&amp;sub=F7FA6EBCE1CC4A95875DD83B2CF9C551\" target=\"_blank\" rel=\"noopener\">CART 分类回归树</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=d5d006e5d1680bb1b93f6cdc68973b60&amp;sub=C12A5DC3350C49CA8862D51287908CE4\" target=\"_blank\" rel=\"noopener\">sklearn 决策树使用技巧</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=3a209c356ed655acacf08699cef27150&amp;sub=E0880A97A8264449BD714025A98BFE52\" target=\"_blank\" rel=\"noopener\">sklearn整理-决策树</a></p>\n</li>\n</ul>\n<h4 id=\"神经网络\"><a href=\"#神经网络\" class=\"headerlink\" title=\"神经网络\"></a>神经网络</h4><ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=d1d1a974ade3ab72cd8ff9fbab061e78&amp;sub=6C8F11DB78FA417AA9F4D0DA30351077\" target=\"_blank\" rel=\"noopener\">常见的神经网络</a></li>\n</ul>\n<h4 id=\"集成学习\"><a href=\"#集成学习\" class=\"headerlink\" title=\"集成学习\"></a>集成学习</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=fb4b442794aac472bdd7663b026a2dab&amp;sub=939B2AAEB6F94E32ABAD4A54B8AF1358\" target=\"_blank\" rel=\"noopener\">集成学习提升算法-Adaboost</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=eb03f9b12281363b052e0ed071833b13&amp;sub=WEBb2a9d589fb05754f76c2b2af09a826c1\" target=\"_blank\" rel=\"noopener\">XGBoost -python package introduction</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=2039180d0a9ad5b39339c93e8c70040d&amp;sub=9C48D93E6A1E4C1186E6F37EF222F528\" target=\"_blank\" rel=\"noopener\">梯度提升树-GBDT</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=e4ac54bae64eb94641594ad5f4a2cd6d&amp;sub=8232CAC65C0A4FDC9EDED033B6A4770F\" target=\"_blank\" rel=\"noopener\">sklearn整理-集成学习-随机森林</a></p>\n</li>\n</ul>\n<h4 id=\"模型评价\"><a href=\"#模型评价\" class=\"headerlink\" title=\"模型评价\"></a>模型评价</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=c76dbbe346dbd32a62cd4303f7bf4864&amp;sub=753D4CFE21084BA78B0506697A415A0C\" target=\"_blank\" rel=\"noopener\">ROC与AUC</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=030f5d8884e6a0914891ebf2289318fa&amp;sub=28D75EDB51044316AB154021B0EB6BEA\" target=\"_blank\" rel=\"noopener\">机器学习的方差与偏差</a></p>\n</li>\n</ul>\n<h4 id=\"参与的一些竞赛\"><a href=\"#参与的一些竞赛\" class=\"headerlink\" title=\"参与的一些竞赛\"></a>参与的一些竞赛</h4><ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=1d8176b82fc84b0a3906fbd53979041c&amp;sub=305B25CE269F45DCA311DBE8C20DAF67\" target=\"_blank\" rel=\"noopener\">ali-新人实战赛o2o优惠券使用预测</a></li>\n</ul>\n<ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=5b2fa1c8320743190649812b394b3ed5&amp;sub=27291314B2C74B09ABF8619277EE8A5E\" target=\"_blank\" rel=\"noopener\">ccf-2019</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=52c517d38463d99b24672f0195ecabfe&amp;sub=WEBf24a84a951b3b16a0685ed029a28b960\" target=\"_blank\" rel=\"noopener\">dc-2019-商品购买转化率预测</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=2fd9687a7cb8c10210bf738536dd8021&amp;sub=AE7E1B49101546F093C7C2B993A736A3\" target=\"_blank\" rel=\"noopener\">竞赛提升方法-tricks</a></p>\n</li>\n</ul>\n<ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=f43a977d8705582da02c202f295dadcc&amp;sub=74C22A94ABB74B309807A886F50A5863\" target=\"_blank\" rel=\"noopener\">sklearn 脑图</a></li>\n</ul>\n<h3 id=\"2-2-大数据与Hadoop\"><a href=\"#2-2-大数据与Hadoop\" class=\"headerlink\" title=\"2.2 大数据与Hadoop\"></a>2.2 大数据与Hadoop</h3><h4 id=\"多台机器的分布式环境安装\"><a href=\"#多台机器的分布式环境安装\" class=\"headerlink\" title=\"多台机器的分布式环境安装\"></a>多台机器的分布式环境安装</h4><ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=e284c332fb9766d6487d925c4381ae22&amp;sub=E4980D34F8A347DC9C1E2C23C5A48D17\" target=\"_blank\" rel=\"noopener\">1.hadoop分布式集群安装</a></li>\n</ul>\n<h4 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h4><ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=773c4878eaec8cc266c5074691a3d780&amp;sub=68CE094D754C46CDA96C8CFA00401DF2\" target=\"_blank\" rel=\"noopener\">Hadoop RPC</a></li>\n</ul>\n<h4 id=\"mapreduce-实验\"><a href=\"#mapreduce-实验\" class=\"headerlink\" title=\"mapreduce 实验\"></a>mapreduce 实验</h4><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=710757567d678841cb43e891531c63b9&amp;sub=BA97FAC420754425A2FE07E67D6B6EAD\" target=\"_blank\" rel=\"noopener\">实验1.  多表关联</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=7c251c3514764eb58fdad72de78bf6a5&amp;sub=FF9F53C4D1A04E008FA61A85A9CE0F01\" target=\"_blank\" rel=\"noopener\">实验2.  最高温度统计</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=226bf0abd5e44ed6eae69f5250024bcf&amp;sub=5EE9A40650BB4AD2A661C65DFBC57FC5\" target=\"_blank\" rel=\"noopener\">实验3.  单表关联</a></p>\n</li>\n</ul>\n<h3 id=\"2-3-VUE\"><a href=\"#2-3-VUE\" class=\"headerlink\" title=\"2.3 VUE\"></a>2.3 VUE</h3><h4 id=\"VUE-安装\"><a href=\"#VUE-安装\" class=\"headerlink\" title=\"VUE 安装\"></a>VUE 安装</h4><ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=c60a733187bef04fa0404429eb2d1f30&amp;sub=3F4FE35DF8E349A395F8C4C19AA7BBE4\" target=\"_blank\" rel=\"noopener\">开发环境搭建</a></li>\n</ul>\n<h3 id=\"2-4-Spring-框架\"><a href=\"#2-4-Spring-框架\" class=\"headerlink\" title=\"2.4 Spring 框架\"></a>2.4 Spring 框架</h3><ul>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=7181c4a539cade23a864c8e970b05833&amp;sub=771654DC28474896BAB711DD289A052C\" target=\"_blank\" rel=\"noopener\">Spring-1控制反转（IOC）和依赖注入</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=32da7b7e487b45fd4fde7906fb9436a1&amp;sub=BAF8F0AE43DB42B399AC14B01FE74689\" target=\"_blank\" rel=\"noopener\">Spring-2AOP 面向切面编程-基于动态代</a></p>\n</li>\n<li><p><a href=\"http://note.youdao.com/noteshare?id=2caa6adcf719adaba44ad57fcad131e4&amp;sub=8E30EF145E8A4972867B5476DF2DD607\" target=\"_blank\" rel=\"noopener\">Spring-3事务管理Transaction Manager</a></p>\n</li>\n</ul>\n<h2 id=\"第三章-工具使用\"><a href=\"#第三章-工具使用\" class=\"headerlink\" title=\"第三章  工具使用\"></a>第三章  工具使用</h2><ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=82f292615812b23fec6c7ce9fcc35ec4&amp;sub=6FC7D088767948388F03769F13A2C971\" target=\"_blank\" rel=\"noopener\">vscode 使用记录</a></li>\n</ul>\n<h2 id=\"第四章-收藏的书籍\"><a href=\"#第四章-收藏的书籍\" class=\"headerlink\" title=\"第四章  收藏的书籍\"></a>第四章  收藏的书籍</h2><ul>\n<li><a href=\"http://note.youdao.com/noteshare?id=57e1d26f1f078dc70a5b18392b29a841\" target=\"_blank\" rel=\"noopener\">书籍收藏</a></li>\n</ul>\n"},{"title":"集成学习提升算法-Adaboost","date":"2019-06-25T10:57:01.000Z","_content":"# Adaboost 算法原理及推导\n\n> Adaboost 是Boosting算法的代表。Boosting可将许多弱学习器组合达到强学习器的效果。\n\n> Adaboost 是通过提升错分数据的权重值来改善模型的不足。\n其主要的流程是：\n\n> 1. 先训练一个基学习器；\n> 2. 根据基学习器的表现，改变样本的分布，使得错误分类的样本得到更多的关注；\n> 3. 改变分布后的样本再训练新的基学习器，如此迭代；\n> 4. 加权组合这些基学习器。\n\n## 一、Adaboost算法原理\n\n> \"Adaptive Boosting\"（自适应增强）\n\nAdaboost算法中，每个样本有对应的权重D,每个基分类器也有对应的权重α，然后是下边的三步骤：\n\n    Step1：初始化训练集的权重；\n> 如果有N个样本，则每一个训练样本最开始时都被赋予相同的权重：1/N。\n\n    迭代：Step2： 改变样本分布，训练基学习器；\n> 错分的样本权重D会增加；准确率高的分类器的权重α会更大；\n\n    Step3: 加权组合弱学习器。\n\n## 二、Adaboost算法推导\n\n给定训练集\n$$\nT=\\{(x 1, y 1),(x 2, y 2) \\ldots(\\mathrm{xN}, y \\mathrm{N})\\}\n$$\n其中，\n$$\ny_{i} \\in\\{-1,1\\}\n$$\n\n步骤1：初始化训练集的权重D。每个训练样本的初始权重w相同，均为1/N,\n\n$$\nD_{1}=\\left(w_{11}, w_{12} \\cdots w_{1 i} \\cdots, w_{1 N}\\right)\n$$\n\n$$\nw_{1 i}=\\frac{1}{N}, i=1,2, \\cdots, N\n$$\n\n步骤2：训练基学习器，改变训练样本分布，迭代训练新的学习器。\n用m=1,2...M 代表迭代的轮数，每轮产生的学习器为 $$h_{m}(x)$$\n\n- 计算学习器 $$h_{m}(x)$$ 在训练数据集上的分类错误率 $$E_{t}$$ (误差的权值和):\n\n\n $$E_{t}=P\\left(G_{m}(x) \\neq y_{i}\\right)$$\n\n\n $$=\\sum_{i=1}^{N} w_{m i} I\\left(G_{m}\\left(x_{i}\\right) \\neq y_{i}\\right)$$\n\n\n- 计算学习器 $$h_{m}(x)$$ 的权重α：\n\n $$\\alpha_{m}=\\frac{1}{2} \\ln \\frac{\\left(1-E_{m}\\right)}{E_{m}}$$\n\n- 更新训练集样本权重。\n\n$$D_{m+1}=\\left(w_{m+1,1}, w_{m+1,2} \\cdots w_{m+1, i} \\cdots, w_{m+1, N}\\right)$$\n\n$$w_{m+1, i}=\\frac{w_{m i}}{Z_{m}} \\exp \\left(-\\alpha_{m} y_{i} G_{m}\\left(x_{i}\\right)\\right), i=1,2, \\cdots, N$$\n\n这里的 $$Z_{m}$$ 时规范化因子:\n\n$$Z_{m}=\\sum_{i=1}^{N} w_{m i} \\exp \\left(-\\alpha_{m} y_{i} G_{m}\\left(x_{i}\\right)\\right)$$\n\n- 迭代训练学习器\n\n步骤3：加权组合弱学习器。\n\n$$f(x)=\\sum_{m=1}^{M} \\alpha_{m} h_{m}(x)$$\n\n$$H(x)=\\operatorname{sign}(f(x))=\\operatorname{sign}\\left(\\sum_{m=1}^{M} \\alpha_{m} h_{m}(x)\\right)$$\n\n\n## 三、Adaboost算法解释\n\n> 模型为加法模型(基函数的线性组合),损失函数为指数函数,学习算法是前想分布算法的二类分类学习法.\n\n\n","source":"_posts/集成学习-Adaboost.md","raw":"---\ntitle: 集成学习提升算法-Adaboost\ndate: 2019-06-25 18:57:01\ntags: 集成学习\ncategories: 机器学习方法\n---\n# Adaboost 算法原理及推导\n\n> Adaboost 是Boosting算法的代表。Boosting可将许多弱学习器组合达到强学习器的效果。\n\n> Adaboost 是通过提升错分数据的权重值来改善模型的不足。\n其主要的流程是：\n\n> 1. 先训练一个基学习器；\n> 2. 根据基学习器的表现，改变样本的分布，使得错误分类的样本得到更多的关注；\n> 3. 改变分布后的样本再训练新的基学习器，如此迭代；\n> 4. 加权组合这些基学习器。\n\n## 一、Adaboost算法原理\n\n> \"Adaptive Boosting\"（自适应增强）\n\nAdaboost算法中，每个样本有对应的权重D,每个基分类器也有对应的权重α，然后是下边的三步骤：\n\n    Step1：初始化训练集的权重；\n> 如果有N个样本，则每一个训练样本最开始时都被赋予相同的权重：1/N。\n\n    迭代：Step2： 改变样本分布，训练基学习器；\n> 错分的样本权重D会增加；准确率高的分类器的权重α会更大；\n\n    Step3: 加权组合弱学习器。\n\n## 二、Adaboost算法推导\n\n给定训练集\n$$\nT=\\{(x 1, y 1),(x 2, y 2) \\ldots(\\mathrm{xN}, y \\mathrm{N})\\}\n$$\n其中，\n$$\ny_{i} \\in\\{-1,1\\}\n$$\n\n步骤1：初始化训练集的权重D。每个训练样本的初始权重w相同，均为1/N,\n\n$$\nD_{1}=\\left(w_{11}, w_{12} \\cdots w_{1 i} \\cdots, w_{1 N}\\right)\n$$\n\n$$\nw_{1 i}=\\frac{1}{N}, i=1,2, \\cdots, N\n$$\n\n步骤2：训练基学习器，改变训练样本分布，迭代训练新的学习器。\n用m=1,2...M 代表迭代的轮数，每轮产生的学习器为 $$h_{m}(x)$$\n\n- 计算学习器 $$h_{m}(x)$$ 在训练数据集上的分类错误率 $$E_{t}$$ (误差的权值和):\n\n\n $$E_{t}=P\\left(G_{m}(x) \\neq y_{i}\\right)$$\n\n\n $$=\\sum_{i=1}^{N} w_{m i} I\\left(G_{m}\\left(x_{i}\\right) \\neq y_{i}\\right)$$\n\n\n- 计算学习器 $$h_{m}(x)$$ 的权重α：\n\n $$\\alpha_{m}=\\frac{1}{2} \\ln \\frac{\\left(1-E_{m}\\right)}{E_{m}}$$\n\n- 更新训练集样本权重。\n\n$$D_{m+1}=\\left(w_{m+1,1}, w_{m+1,2} \\cdots w_{m+1, i} \\cdots, w_{m+1, N}\\right)$$\n\n$$w_{m+1, i}=\\frac{w_{m i}}{Z_{m}} \\exp \\left(-\\alpha_{m} y_{i} G_{m}\\left(x_{i}\\right)\\right), i=1,2, \\cdots, N$$\n\n这里的 $$Z_{m}$$ 时规范化因子:\n\n$$Z_{m}=\\sum_{i=1}^{N} w_{m i} \\exp \\left(-\\alpha_{m} y_{i} G_{m}\\left(x_{i}\\right)\\right)$$\n\n- 迭代训练学习器\n\n步骤3：加权组合弱学习器。\n\n$$f(x)=\\sum_{m=1}^{M} \\alpha_{m} h_{m}(x)$$\n\n$$H(x)=\\operatorname{sign}(f(x))=\\operatorname{sign}\\left(\\sum_{m=1}^{M} \\alpha_{m} h_{m}(x)\\right)$$\n\n\n## 三、Adaboost算法解释\n\n> 模型为加法模型(基函数的线性组合),损失函数为指数函数,学习算法是前想分布算法的二类分类学习法.\n\n\n","slug":"集成学习-Adaboost","published":1,"updated":"2020-02-20T06:39:10.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephh0002rt8plu4k6ec4c","content":"<h1 id=\"Adaboost-算法原理及推导\"><a href=\"#Adaboost-算法原理及推导\" class=\"headerlink\" title=\"Adaboost 算法原理及推导\"></a>Adaboost 算法原理及推导</h1><blockquote>\n<p>Adaboost 是Boosting算法的代表。Boosting可将许多弱学习器组合达到强学习器的效果。</p>\n<p>Adaboost 是通过提升错分数据的权重值来改善模型的不足。<br>其主要的流程是：</p>\n<ol>\n<li>先训练一个基学习器；</li>\n<li>根据基学习器的表现，改变样本的分布，使得错误分类的样本得到更多的关注；</li>\n<li>改变分布后的样本再训练新的基学习器，如此迭代；</li>\n<li>加权组合这些基学习器。</li>\n</ol>\n</blockquote>\n<h2 id=\"一、Adaboost算法原理\"><a href=\"#一、Adaboost算法原理\" class=\"headerlink\" title=\"一、Adaboost算法原理\"></a>一、Adaboost算法原理</h2><blockquote>\n<p>“Adaptive Boosting”（自适应增强）</p>\n</blockquote>\n<p>Adaboost算法中，每个样本有对应的权重D,每个基分类器也有对应的权重α，然后是下边的三步骤：</p>\n<pre><code>Step1：初始化训练集的权重；\n</code></pre><blockquote>\n<p>如果有N个样本，则每一个训练样本最开始时都被赋予相同的权重：1/N。</p>\n</blockquote>\n<pre><code>迭代：Step2： 改变样本分布，训练基学习器；\n</code></pre><blockquote>\n<p>错分的样本权重D会增加；准确率高的分类器的权重α会更大；</p>\n</blockquote>\n<pre><code>Step3: 加权组合弱学习器。\n</code></pre><h2 id=\"二、Adaboost算法推导\"><a href=\"#二、Adaboost算法推导\" class=\"headerlink\" title=\"二、Adaboost算法推导\"></a>二、Adaboost算法推导</h2><p>给定训练集</p>\n<script type=\"math/tex; mode=display\">\nT=\\{(x 1, y 1),(x 2, y 2) \\ldots(\\mathrm{xN}, y \\mathrm{N})\\}</script><p>其中，</p>\n<script type=\"math/tex; mode=display\">\ny_{i} \\in\\{-1,1\\}</script><p>步骤1：初始化训练集的权重D。每个训练样本的初始权重w相同，均为1/N,</p>\n<script type=\"math/tex; mode=display\">\nD_{1}=\\left(w_{11}, w_{12} \\cdots w_{1 i} \\cdots, w_{1 N}\\right)</script><script type=\"math/tex; mode=display\">\nw_{1 i}=\\frac{1}{N}, i=1,2, \\cdots, N</script><p>步骤2：训练基学习器，改变训练样本分布，迭代训练新的学习器。<br>用m=1,2…M 代表迭代的轮数，每轮产生的学习器为 <script type=\"math/tex\">h_{m}(x)</script></p>\n<ul>\n<li>计算学习器 <script type=\"math/tex\">h_{m}(x)</script> 在训练数据集上的分类错误率 <script type=\"math/tex\">E_{t}</script> (误差的权值和):</li>\n</ul>\n<script type=\"math/tex; mode=display\">E_{t}=P\\left(G_{m}(x) \\neq y_{i}\\right)</script><script type=\"math/tex; mode=display\">=\\sum_{i=1}^{N} w_{m i} I\\left(G_{m}\\left(x_{i}\\right) \\neq y_{i}\\right)</script><ul>\n<li><p>计算学习器 <script type=\"math/tex\">h_{m}(x)</script> 的权重α：</p>\n<script type=\"math/tex; mode=display\">\\alpha_{m}=\\frac{1}{2} \\ln \\frac{\\left(1-E_{m}\\right)}{E_{m}}</script></li>\n<li><p>更新训练集样本权重。</p>\n</li>\n</ul>\n<script type=\"math/tex; mode=display\">D_{m+1}=\\left(w_{m+1,1}, w_{m+1,2} \\cdots w_{m+1, i} \\cdots, w_{m+1, N}\\right)</script><script type=\"math/tex; mode=display\">w_{m+1, i}=\\frac{w_{m i}}{Z_{m}} \\exp \\left(-\\alpha_{m} y_{i} G_{m}\\left(x_{i}\\right)\\right), i=1,2, \\cdots, N</script><p>这里的 <script type=\"math/tex\">Z_{m}</script> 时规范化因子:</p>\n<script type=\"math/tex; mode=display\">Z_{m}=\\sum_{i=1}^{N} w_{m i} \\exp \\left(-\\alpha_{m} y_{i} G_{m}\\left(x_{i}\\right)\\right)</script><ul>\n<li>迭代训练学习器</li>\n</ul>\n<p>步骤3：加权组合弱学习器。</p>\n<script type=\"math/tex; mode=display\">f(x)=\\sum_{m=1}^{M} \\alpha_{m} h_{m}(x)</script><script type=\"math/tex; mode=display\">H(x)=\\operatorname{sign}(f(x))=\\operatorname{sign}\\left(\\sum_{m=1}^{M} \\alpha_{m} h_{m}(x)\\right)</script><h2 id=\"三、Adaboost算法解释\"><a href=\"#三、Adaboost算法解释\" class=\"headerlink\" title=\"三、Adaboost算法解释\"></a>三、Adaboost算法解释</h2><blockquote>\n<p>模型为加法模型(基函数的线性组合),损失函数为指数函数,学习算法是前想分布算法的二类分类学习法.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Adaboost-算法原理及推导\"><a href=\"#Adaboost-算法原理及推导\" class=\"headerlink\" title=\"Adaboost 算法原理及推导\"></a>Adaboost 算法原理及推导</h1><blockquote>\n<p>Adaboost 是Boosting算法的代表。Boosting可将许多弱学习器组合达到强学习器的效果。</p>\n<p>Adaboost 是通过提升错分数据的权重值来改善模型的不足。<br>其主要的流程是：</p>\n<ol>\n<li>先训练一个基学习器；</li>\n<li>根据基学习器的表现，改变样本的分布，使得错误分类的样本得到更多的关注；</li>\n<li>改变分布后的样本再训练新的基学习器，如此迭代；</li>\n<li>加权组合这些基学习器。</li>\n</ol>\n</blockquote>\n<h2 id=\"一、Adaboost算法原理\"><a href=\"#一、Adaboost算法原理\" class=\"headerlink\" title=\"一、Adaboost算法原理\"></a>一、Adaboost算法原理</h2><blockquote>\n<p>“Adaptive Boosting”（自适应增强）</p>\n</blockquote>\n<p>Adaboost算法中，每个样本有对应的权重D,每个基分类器也有对应的权重α，然后是下边的三步骤：</p>\n<pre><code>Step1：初始化训练集的权重；\n</code></pre><blockquote>\n<p>如果有N个样本，则每一个训练样本最开始时都被赋予相同的权重：1/N。</p>\n</blockquote>\n<pre><code>迭代：Step2： 改变样本分布，训练基学习器；\n</code></pre><blockquote>\n<p>错分的样本权重D会增加；准确率高的分类器的权重α会更大；</p>\n</blockquote>\n<pre><code>Step3: 加权组合弱学习器。\n</code></pre><h2 id=\"二、Adaboost算法推导\"><a href=\"#二、Adaboost算法推导\" class=\"headerlink\" title=\"二、Adaboost算法推导\"></a>二、Adaboost算法推导</h2><p>给定训练集</p>\n<script type=\"math/tex; mode=display\">\nT=\\{(x 1, y 1),(x 2, y 2) \\ldots(\\mathrm{xN}, y \\mathrm{N})\\}</script><p>其中，</p>\n<script type=\"math/tex; mode=display\">\ny_{i} \\in\\{-1,1\\}</script><p>步骤1：初始化训练集的权重D。每个训练样本的初始权重w相同，均为1/N,</p>\n<script type=\"math/tex; mode=display\">\nD_{1}=\\left(w_{11}, w_{12} \\cdots w_{1 i} \\cdots, w_{1 N}\\right)</script><script type=\"math/tex; mode=display\">\nw_{1 i}=\\frac{1}{N}, i=1,2, \\cdots, N</script><p>步骤2：训练基学习器，改变训练样本分布，迭代训练新的学习器。<br>用m=1,2…M 代表迭代的轮数，每轮产生的学习器为 <script type=\"math/tex\">h_{m}(x)</script></p>\n<ul>\n<li>计算学习器 <script type=\"math/tex\">h_{m}(x)</script> 在训练数据集上的分类错误率 <script type=\"math/tex\">E_{t}</script> (误差的权值和):</li>\n</ul>\n<script type=\"math/tex; mode=display\">E_{t}=P\\left(G_{m}(x) \\neq y_{i}\\right)</script><script type=\"math/tex; mode=display\">=\\sum_{i=1}^{N} w_{m i} I\\left(G_{m}\\left(x_{i}\\right) \\neq y_{i}\\right)</script><ul>\n<li><p>计算学习器 <script type=\"math/tex\">h_{m}(x)</script> 的权重α：</p>\n<script type=\"math/tex; mode=display\">\\alpha_{m}=\\frac{1}{2} \\ln \\frac{\\left(1-E_{m}\\right)}{E_{m}}</script></li>\n<li><p>更新训练集样本权重。</p>\n</li>\n</ul>\n<script type=\"math/tex; mode=display\">D_{m+1}=\\left(w_{m+1,1}, w_{m+1,2} \\cdots w_{m+1, i} \\cdots, w_{m+1, N}\\right)</script><script type=\"math/tex; mode=display\">w_{m+1, i}=\\frac{w_{m i}}{Z_{m}} \\exp \\left(-\\alpha_{m} y_{i} G_{m}\\left(x_{i}\\right)\\right), i=1,2, \\cdots, N</script><p>这里的 <script type=\"math/tex\">Z_{m}</script> 时规范化因子:</p>\n<script type=\"math/tex; mode=display\">Z_{m}=\\sum_{i=1}^{N} w_{m i} \\exp \\left(-\\alpha_{m} y_{i} G_{m}\\left(x_{i}\\right)\\right)</script><ul>\n<li>迭代训练学习器</li>\n</ul>\n<p>步骤3：加权组合弱学习器。</p>\n<script type=\"math/tex; mode=display\">f(x)=\\sum_{m=1}^{M} \\alpha_{m} h_{m}(x)</script><script type=\"math/tex; mode=display\">H(x)=\\operatorname{sign}(f(x))=\\operatorname{sign}\\left(\\sum_{m=1}^{M} \\alpha_{m} h_{m}(x)\\right)</script><h2 id=\"三、Adaboost算法解释\"><a href=\"#三、Adaboost算法解释\" class=\"headerlink\" title=\"三、Adaboost算法解释\"></a>三、Adaboost算法解释</h2><blockquote>\n<p>模型为加法模型(基函数的线性组合),损失函数为指数函数,学习算法是前想分布算法的二类分类学习法.</p>\n</blockquote>\n"},{"title":"版本控制-git","date":"2020-03-28T04:17:11.000Z","_content":"\n# 1. git 的作用\n\n- 版本控制\n- 协同开发\n\n# 2. 文件的状态\n\n- untracked  (新建的文件)\n- unmodified  （提交后进入仓库的文件与当前文件相同，即没修过）\n- modified  (commit 之前)\n- staged  （commit 之后）\n\n# 3. 一般使用流程\n\n#### 初始化仓库\n- `git init`\n\n#### 变更的文件加入暂存区\n- `git add .`\n\n#### 提交变更\n- `git commit -m`\n\n#### 查看commit日志, 并返回某一次提交的版本\n- `git log`   (### 弹出commit id)\n- `git reset 7hdadsu2qe21e921821e --hard`\n- 如果想恢复最新的   ` git  relog`\n\n#### 从暂存区 移除某些文件（add 的文件有多余）\n- `git reset <fileName>`\n\n# 4. 分支合作管理\n\n- 创建分支\n    - `git checkout -b <分支name> <template继承的commit,默认当前> `\n- 切换分支\n    - `git checkout master`\n- 查看所有分支\n    - `git branch `\n- 合并分支的变更（合并到当前master）\n    - `git meger  branch-2  `\n    - 有冲突时，会提示======\n\n# 5. remote 仓库的使用\n\n- 下载远端仓库到本地\n  \n    - `git clone  ......git`\n    \n- 创建本地的分支\n  \n    - `git checkout -b local-A`\n    \n- 在远端仓库设置分支(第一次需要)\n  \n    - `git push -set-upstream origin local-A`\n    \n- 提交本地分支到远端\n  \n    - `git push `\n    \n- 第一次拉取远端仓库的分支，到本地\n    - `git fetch`    \n    - `git checkout -b <name> `origin` <template继承的commit,默认当前> `\n    \n- 以后再从远端更新本地\n  \n    - `git pull ` （自动fetch + merge）  \n    \n    \n\n# 其他命令\n\n- `git merge`\n- `git pull`\n- `git fetch`\n- `git rebase` （版本合并时。。）\n\n \n\n","source":"_posts/版本控制-git.md","raw":"---\ntitle: 版本控制-git\ndate: 2020-03-28 12:17:11\ncategories: git\ntags: 版本控制\n---\n\n# 1. git 的作用\n\n- 版本控制\n- 协同开发\n\n# 2. 文件的状态\n\n- untracked  (新建的文件)\n- unmodified  （提交后进入仓库的文件与当前文件相同，即没修过）\n- modified  (commit 之前)\n- staged  （commit 之后）\n\n# 3. 一般使用流程\n\n#### 初始化仓库\n- `git init`\n\n#### 变更的文件加入暂存区\n- `git add .`\n\n#### 提交变更\n- `git commit -m`\n\n#### 查看commit日志, 并返回某一次提交的版本\n- `git log`   (### 弹出commit id)\n- `git reset 7hdadsu2qe21e921821e --hard`\n- 如果想恢复最新的   ` git  relog`\n\n#### 从暂存区 移除某些文件（add 的文件有多余）\n- `git reset <fileName>`\n\n# 4. 分支合作管理\n\n- 创建分支\n    - `git checkout -b <分支name> <template继承的commit,默认当前> `\n- 切换分支\n    - `git checkout master`\n- 查看所有分支\n    - `git branch `\n- 合并分支的变更（合并到当前master）\n    - `git meger  branch-2  `\n    - 有冲突时，会提示======\n\n# 5. remote 仓库的使用\n\n- 下载远端仓库到本地\n  \n    - `git clone  ......git`\n    \n- 创建本地的分支\n  \n    - `git checkout -b local-A`\n    \n- 在远端仓库设置分支(第一次需要)\n  \n    - `git push -set-upstream origin local-A`\n    \n- 提交本地分支到远端\n  \n    - `git push `\n    \n- 第一次拉取远端仓库的分支，到本地\n    - `git fetch`    \n    - `git checkout -b <name> `origin` <template继承的commit,默认当前> `\n    \n- 以后再从远端更新本地\n  \n    - `git pull ` （自动fetch + merge）  \n    \n    \n\n# 其他命令\n\n- `git merge`\n- `git pull`\n- `git fetch`\n- `git rebase` （版本合并时。。）\n\n \n\n","slug":"版本控制-git","published":1,"updated":"2020-03-28T04:24:01.401Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephh6002vt8pl6j39obbu","content":"<h1 id=\"1-git-的作用\"><a href=\"#1-git-的作用\" class=\"headerlink\" title=\"1. git 的作用\"></a>1. git 的作用</h1><ul>\n<li>版本控制</li>\n<li>协同开发</li>\n</ul>\n<h1 id=\"2-文件的状态\"><a href=\"#2-文件的状态\" class=\"headerlink\" title=\"2. 文件的状态\"></a>2. 文件的状态</h1><ul>\n<li>untracked  (新建的文件)</li>\n<li>unmodified  （提交后进入仓库的文件与当前文件相同，即没修过）</li>\n<li>modified  (commit 之前)</li>\n<li>staged  （commit 之后）</li>\n</ul>\n<h1 id=\"3-一般使用流程\"><a href=\"#3-一般使用流程\" class=\"headerlink\" title=\"3. 一般使用流程\"></a>3. 一般使用流程</h1><h4 id=\"初始化仓库\"><a href=\"#初始化仓库\" class=\"headerlink\" title=\"初始化仓库\"></a>初始化仓库</h4><ul>\n<li><code>git init</code></li>\n</ul>\n<h4 id=\"变更的文件加入暂存区\"><a href=\"#变更的文件加入暂存区\" class=\"headerlink\" title=\"变更的文件加入暂存区\"></a>变更的文件加入暂存区</h4><ul>\n<li><code>git add .</code></li>\n</ul>\n<h4 id=\"提交变更\"><a href=\"#提交变更\" class=\"headerlink\" title=\"提交变更\"></a>提交变更</h4><ul>\n<li><code>git commit -m</code></li>\n</ul>\n<h4 id=\"查看commit日志-并返回某一次提交的版本\"><a href=\"#查看commit日志-并返回某一次提交的版本\" class=\"headerlink\" title=\"查看commit日志, 并返回某一次提交的版本\"></a>查看commit日志, 并返回某一次提交的版本</h4><ul>\n<li><code>git log</code>   (### 弹出commit id)</li>\n<li><code>git reset 7hdadsu2qe21e921821e --hard</code></li>\n<li>如果想恢复最新的   <code>git  relog</code></li>\n</ul>\n<h4 id=\"从暂存区-移除某些文件（add-的文件有多余）\"><a href=\"#从暂存区-移除某些文件（add-的文件有多余）\" class=\"headerlink\" title=\"从暂存区 移除某些文件（add 的文件有多余）\"></a>从暂存区 移除某些文件（add 的文件有多余）</h4><ul>\n<li><code>git reset &lt;fileName&gt;</code></li>\n</ul>\n<h1 id=\"4-分支合作管理\"><a href=\"#4-分支合作管理\" class=\"headerlink\" title=\"4. 分支合作管理\"></a>4. 分支合作管理</h1><ul>\n<li>创建分支<ul>\n<li><code>git checkout -b &lt;分支name&gt; &lt;template继承的commit,默认当前&gt;</code></li>\n</ul>\n</li>\n<li>切换分支<ul>\n<li><code>git checkout master</code></li>\n</ul>\n</li>\n<li>查看所有分支<ul>\n<li><code>git branch</code></li>\n</ul>\n</li>\n<li>合并分支的变更（合并到当前master）<ul>\n<li><code>git meger  branch-2</code></li>\n<li>有冲突时，会提示======</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"5-remote-仓库的使用\"><a href=\"#5-remote-仓库的使用\" class=\"headerlink\" title=\"5. remote 仓库的使用\"></a>5. remote 仓库的使用</h1><ul>\n<li><p>下载远端仓库到本地</p>\n<ul>\n<li><code>git clone  ......git</code></li>\n</ul>\n</li>\n<li><p>创建本地的分支</p>\n<ul>\n<li><code>git checkout -b local-A</code></li>\n</ul>\n</li>\n<li><p>在远端仓库设置分支(第一次需要)</p>\n<ul>\n<li><code>git push -set-upstream origin local-A</code></li>\n</ul>\n</li>\n<li><p>提交本地分支到远端</p>\n<ul>\n<li><code>git push</code></li>\n</ul>\n</li>\n<li><p>第一次拉取远端仓库的分支，到本地</p>\n<ul>\n<li><code>git fetch</code>    </li>\n<li><code>git checkout -b &lt;name&gt;</code>origin<code>&lt;template继承的commit,默认当前&gt;</code></li>\n</ul>\n</li>\n<li><p>以后再从远端更新本地</p>\n<ul>\n<li><code>git pull</code> （自动fetch + merge）  </li>\n</ul>\n</li>\n</ul>\n<h1 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h1><ul>\n<li><code>git merge</code></li>\n<li><code>git pull</code></li>\n<li><code>git fetch</code></li>\n<li><code>git rebase</code> （版本合并时。。）</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-git-的作用\"><a href=\"#1-git-的作用\" class=\"headerlink\" title=\"1. git 的作用\"></a>1. git 的作用</h1><ul>\n<li>版本控制</li>\n<li>协同开发</li>\n</ul>\n<h1 id=\"2-文件的状态\"><a href=\"#2-文件的状态\" class=\"headerlink\" title=\"2. 文件的状态\"></a>2. 文件的状态</h1><ul>\n<li>untracked  (新建的文件)</li>\n<li>unmodified  （提交后进入仓库的文件与当前文件相同，即没修过）</li>\n<li>modified  (commit 之前)</li>\n<li>staged  （commit 之后）</li>\n</ul>\n<h1 id=\"3-一般使用流程\"><a href=\"#3-一般使用流程\" class=\"headerlink\" title=\"3. 一般使用流程\"></a>3. 一般使用流程</h1><h4 id=\"初始化仓库\"><a href=\"#初始化仓库\" class=\"headerlink\" title=\"初始化仓库\"></a>初始化仓库</h4><ul>\n<li><code>git init</code></li>\n</ul>\n<h4 id=\"变更的文件加入暂存区\"><a href=\"#变更的文件加入暂存区\" class=\"headerlink\" title=\"变更的文件加入暂存区\"></a>变更的文件加入暂存区</h4><ul>\n<li><code>git add .</code></li>\n</ul>\n<h4 id=\"提交变更\"><a href=\"#提交变更\" class=\"headerlink\" title=\"提交变更\"></a>提交变更</h4><ul>\n<li><code>git commit -m</code></li>\n</ul>\n<h4 id=\"查看commit日志-并返回某一次提交的版本\"><a href=\"#查看commit日志-并返回某一次提交的版本\" class=\"headerlink\" title=\"查看commit日志, 并返回某一次提交的版本\"></a>查看commit日志, 并返回某一次提交的版本</h4><ul>\n<li><code>git log</code>   (### 弹出commit id)</li>\n<li><code>git reset 7hdadsu2qe21e921821e --hard</code></li>\n<li>如果想恢复最新的   <code>git  relog</code></li>\n</ul>\n<h4 id=\"从暂存区-移除某些文件（add-的文件有多余）\"><a href=\"#从暂存区-移除某些文件（add-的文件有多余）\" class=\"headerlink\" title=\"从暂存区 移除某些文件（add 的文件有多余）\"></a>从暂存区 移除某些文件（add 的文件有多余）</h4><ul>\n<li><code>git reset &lt;fileName&gt;</code></li>\n</ul>\n<h1 id=\"4-分支合作管理\"><a href=\"#4-分支合作管理\" class=\"headerlink\" title=\"4. 分支合作管理\"></a>4. 分支合作管理</h1><ul>\n<li>创建分支<ul>\n<li><code>git checkout -b &lt;分支name&gt; &lt;template继承的commit,默认当前&gt;</code></li>\n</ul>\n</li>\n<li>切换分支<ul>\n<li><code>git checkout master</code></li>\n</ul>\n</li>\n<li>查看所有分支<ul>\n<li><code>git branch</code></li>\n</ul>\n</li>\n<li>合并分支的变更（合并到当前master）<ul>\n<li><code>git meger  branch-2</code></li>\n<li>有冲突时，会提示======</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"5-remote-仓库的使用\"><a href=\"#5-remote-仓库的使用\" class=\"headerlink\" title=\"5. remote 仓库的使用\"></a>5. remote 仓库的使用</h1><ul>\n<li><p>下载远端仓库到本地</p>\n<ul>\n<li><code>git clone  ......git</code></li>\n</ul>\n</li>\n<li><p>创建本地的分支</p>\n<ul>\n<li><code>git checkout -b local-A</code></li>\n</ul>\n</li>\n<li><p>在远端仓库设置分支(第一次需要)</p>\n<ul>\n<li><code>git push -set-upstream origin local-A</code></li>\n</ul>\n</li>\n<li><p>提交本地分支到远端</p>\n<ul>\n<li><code>git push</code></li>\n</ul>\n</li>\n<li><p>第一次拉取远端仓库的分支，到本地</p>\n<ul>\n<li><code>git fetch</code>    </li>\n<li><code>git checkout -b &lt;name&gt;</code>origin<code>&lt;template继承的commit,默认当前&gt;</code></li>\n</ul>\n</li>\n<li><p>以后再从远端更新本地</p>\n<ul>\n<li><code>git pull</code> （自动fetch + merge）  </li>\n</ul>\n</li>\n</ul>\n<h1 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h1><ul>\n<li><code>git merge</code></li>\n<li><code>git pull</code></li>\n<li><code>git fetch</code></li>\n<li><code>git rebase</code> （版本合并时。。）</li>\n</ul>\n"},{"title":"逻辑回归","mathjax":true,"date":"2019-04-27T05:01:43.000Z","_content":"\n> 逻辑回归就是西瓜书里的对数几率回归，名为回归，实际则是分类算法。其实质是利用线性回归模型的预测结果来逼近真实标记的对数几率。\n> \n一句话概括就是:\n<font color=\"red\"> \n逻辑回归假设数据服从 **伯努利分布** ,通过 **极大化似然函数** 的方法，运用 **梯度下降** 来求解参数，来达到将数据二分类的目的。</font>\n\n## 线性模型如何处理二分类问题？\n\n> 在处理二分类任务时，我们希望模型能预测样本属于某类别的概率[0, 1]，或者直接输出类别的标签{0, 1}。 线性模型不能直接来完成这项任务，因为其输出是一个实际值，范围也不一定在0~1之间，无法体现我们所想要的概率或者标签。\n\n$$\ny=\\boldsymbol{w}^{\\mathrm{T}} \\boldsymbol{x}+b\n$$\n\n因此，我们需要找到一种能把线性模型输出映射到 **概率** 或者 **标签** 的方法；\n\n- 如何转化为标签？\n\n\t单位阶跃函数\n\n- 如何转化为概率？\n\n\tsigmoid函数 (二分类): 将无穷范围的值限制在(0, 1)之间\n\n\tsoftmax函数（多分类）: 所有类别概率和为1\n\n![logo](逻辑回归/sigmoid.png)\n\n由于单位阶跃函数存在跳跃点，在跳跃点不可导，想选择梯度下降法来优化时，只能选择sigmoid函数了。\n\n## 逻辑回归模型\n\n> 逻辑回归就是这样的一个过程：面对一个分类问题，建立代价函数，然后通过优化方\n法迭代求解出最优的模型参数，然后测试验证我们这个求解的模型的好坏。\n\n### 逻辑回归的优缺点\n\n- 优点 \n\n\t- 速度快，适合二分类问题\n\t\n\t- 简单易于理解，直接看到各个特征的权重\n\n\t- 能容易地更新模型吸收新的数据\n\n\n- 缺点\n\n\t- 对数据和场景的适应能力有局限性，不如决策树算法适应性那么强\n\n### 逻辑回归的用途\n\n- **寻找主要影响因素**：  通过学习到的权重值，得到不同因素对结果的影响力大小\n\n\n- **预测**：  预测事件发生的概率\n\n\n### 建模常规步骤\n\n- 寻找 `h 函数`（预测函数）\n\n\n- 构造 `J 函数` (损失函数)\n\n\n- 利用梯度下降等方法最小化  `J 函数`，并求取参数\n\n### LR基本模型\n\n以下就是逻辑回归的基本模型：\n\n$$\ny=\\frac{1}{1+e^{-z}}\n$$\n\n$$\nz=w^{\\top} x+b\n$$\n\n取倒数\n\n$$\n\\frac{1}{y}=1+e^{-z}\n$$\n\n取对数\n\n$$\n\\ln \\left(\\frac{1}{y}-1\\right)=-z\n$$\n\n$$\n\\ln \\frac{y}{1-y}=\\boldsymbol{w}^{\\mathrm{T}} \\boldsymbol{x}+b\n$$\n\n\nln(y/(1-y)) 就是对数几率\n\n## 代价函数\n\n线性模型常用的目标函数 `均方误差` 用在逻辑回归模型是非凸函数，非凸函数通过梯度下降法容易陷入局部最小值，因此需要想办法找到代价函数，且代价函数为凸函数。\n\n### 极大似然法定义代价函数\n这里通过极大似然估计的方法来定义目标函数：\n\n> **极大似然估计**： 这里想了很久才算有点理解，之前就一直卡在这里。。极大似然估计就是可以利用已知数据来推测出产生这些数据的最可能的环境条件。\n\n\n> 举个栗子，当我们扔硬币时，出现的可能性有两个，要么正面朝上（事件A），要么反面朝上(事件B)，假设出现某事件的可能性只与硬币的 `质量分布θ` 有关系，假设我们做了n组实验（A出现m次），这样能得到两种情况的概率 P(A), P(B),我们要推测出 `质量分布θ` 是多少，也就是 `参数估计` ,即 `质量分布θ` 是多少时，才最可能出现当前实验的结果。抛硬币的事件服从二项分布，那么给定了一组实验的情况下，似然函数是(似然函数与概率值相等)：\n> $$\nL\\left(\\theta ; x_{1}, \\ldots, x_{n}\\right)=f\\left(x_{1}, \\ldots, x_{n} ; \\theta\\right)=\\prod_{i=1}^{n} P\\left(X=x_{i}\\right)=\\theta^{m}(1-\\theta)^{n-m}\n$$\n假设一个数据集`Cn`,标签`y∈{0,1}`，预测值`Θ`,模型参数为`w`则似然函数可以写作:\n$$\nP\\left( \\theta _{\\left( x_i \\right)}|w \\right) =\\prod_{n=1}^N{\\theta}_{xi}^{yi}\\cdot \\left( 1-\\theta _{\\left( x_i \\right)} \\right) ^{1-y_i}\n$$\n\n取对数简化运算:\n$$\n\\mathrm{L}(\\mathrm{w}, \\mathrm{b})=\\sum_{i=1}^{N}\\left[y_{i} \\log \\left(\\emptyset\\left(x_{i}\\right)\\right)+\\left(1-y_{i}\\right) \\log \\left(1-\\emptyset\\left(x_{i}\\right)\\right)\\right]\n$$\n实际代价函数的样子:\n$$\n\\mathrm{J}(\\mathrm{w}, \\mathrm{b})=-\\frac{1}{N} \\mathrm{L}(\\mathrm{w}, \\mathrm{b})=-\\frac{1}{N} \\sum_{i=1}^{N}\\left[y_{i} \\log \\left(\\emptyset\\left(x_{i}\\right)\\right)+\\left(1-y_{i}\\right) \\log \\left(1-\\emptyset\\left(x_{i}\\right)\\right)\\right]\n$$\n取对数之后的公式很符合理想的代价函数，当实际标签与预测结果相同，则代价为0，而相反时，会随着差值越大，损失越大。\n\n因为\n$$\n\\operatorname{logit}(\\mathrm{p})=\\log \\frac{p}{1-p}\n$$\n\n$$\n\\log \\frac{P(Y=1 | X)}{1-P(Y=1 | X)}=w \\cdot x+b\n$$\n带入后继续化简\n$$\n\\mathrm{L}(\\mathrm{w}, \\mathrm{b})=\\sum_{i=1}^{N}\\left[y_{i}\\left(\\mathrm{w} \\cdot x_{i}+\\mathrm{b}\\right)-\\log \\left(1+e^{\\mathrm{w} \\cdot x_{i}+b}\\right)\\right]\n$$\n### 直观解释\n\n直观上理解，代价函数就是分类错误的惩罚，那么当y=1时，prediction 越小时，损失应越大；y=0时prediction 越大时，损失应越小。\n$$\n\\operatorname{cost}=\\left\\{\\begin{aligned}-\\log (\\hat{p}), & \\text { if } y=1 \\\\-\\log (1-\\hat{p}), & \\text { if } y=0 \\end{aligned}\\right.\n$$\n## 通过梯度下降来最小化代价函数\n\n因为我们找到的代价函数是凸函数，所以可以尝试用梯度下降来找到合适的参数w，b：\n$$\n\\mathrm{w} :=\\mathrm{w}-\\alpha \\frac{\\partial J(w, b)}{\\partial w}\n$$\n\n$$\n\\mathrm{b} :=\\mathrm{b}-\\alpha \\frac{\\partial J(w, b)}{\\partial b}\n$$\n偏导求解过程：\n\n对w求偏导\n$$\n\\frac{\\partial J(w, b)}{\\partial w}=-\\frac{1}{N} \\sum_{i=1}^{N}\\left[y_{i} \\frac{1}{\\partial\\left(x_{i}\\right)}-\\left(1-y_{i}\\right) \\frac{1}{1-\\emptyset\\left(x_{i}\\right)}\\right] \\frac{\\partial \\emptyset\\left(x_{i}\\right)}{\\partial w}\n$$\n\n$$\n=-\\frac{1}{N} \\sum_{i=1}^{N}\\left[y_{i} \\frac{1}{\\emptyset\\left(x_{i}\\right)}-\\left(1-y_{i}\\right) \\frac{1}{1-\\emptyset\\left(x_{i}\\right)}\\right] \\sigma\\left(x_{i}\\right)\\left(1-\\emptyset\\left(x_{i}\\right)\\right) \\cdot x_{i}\n$$\n\n$$\n=-\\frac{1}{N} \\Sigma_{i=1}^{N}\\left(y_{i}-\\emptyset\\left(x_{i}\\right)\\right) \\cdot x_{i^{*}}\n$$\n对b求偏导\n$$\n\\frac{\\partial J(w, b)}{\\partial b}=-\\frac{1}{N} \\sum_{i=1}^{N}\\left[y_{i} \\frac{1}{\\emptyset\\left(x_{i}\\right)}-\\left(1-y_{i}\\right) \\frac{1}{1-\\emptyset\\left(x_{i}\\right)}\\right] \\frac{\\partial \\emptyset\\left(x_{i}\\right)}{\\partial b}\n$$\n\n$$\n=-\\frac{1}{N} \\sum_{i=1}^{N}\\left[y_{i} \\frac{1}{\\emptyset\\left(x_{i}\\right)}-\\left(1-y_{i}\\right) \\frac{1}{1-\\emptyset\\left(x_{i}\\right)}\\right] \\wp\\left(x_{i}\\right)\\left(1-\\emptyset\\left(x_{i}\\right)\\right)\n$$\n\n$$\n=-\\frac{1}{N} \\Sigma_{i=1}^{N}\\left(y_{i}-\\emptyset\\left(x_{i}\\right)\\right)\n$$\n\n带入公式后，得到最终推导的结果：\n$$\n\\mathrm{w} :=\\mathrm{w}+\\alpha \\frac{1}{N} \\sum_{i=1}^{N}\\left(y_{i}-\\emptyset\\left(x_{i}\\right)\\right) \\cdot x_{i}\n$$\n\n$$\n\\mathrm{b} :=\\mathrm{b}+\\alpha \\frac{1}{N} \\sum_{i=1}^{N}\\left(y_{i}-\\emptyset\\left(x_{i}\\right)\\right)\n$$\n<font color=\"red\"> \n通过以上公式可以看出，逻辑回归的梯度与 `sigmoid` 本身无关，只与 `y` 和`x`和 `w` 有关系。</font>\n\n## 进一步提高泛化能力\n\n> 影响模型泛化能力的主因素是 `过拟合`, 过拟合问题比较容易理解，这里就不贴图了。下面分析一下产生过拟合的原因和解决办法。\n\n### 过拟合产生的原因有哪些？\n\n**过多的特征**\n\n### 怎么解决过拟合？\n\n1. 减少特征数量\n\n\t减少特征数量会导致部分信息丢失。\n\n2. 正则化\n\n\t保留所有的特征，并且减小参数的大小。\n\n### 正则化方法\n\n**在代价函数上增加一个惩罚项**，<font color=red>惩罚项应该是模型复杂度的单调递增函数，模型越复杂，惩罚项越大。 </font>\n\n回归问题中，取**平方损失**（L2 范数），或者L1范数\n$$\nJ(\\theta)=\\frac{1}{2 m} \\sum_{i=1}^{n}\\left(\\mathrm{h}_{\\theta}\\left(\\mathrm{x}_{i}\\right)-y_{i}\\right)^{2}+\\lambda \\sum_{j=1}^{n} \\theta_{j}^{2}\n$$\n这里的lambda 系数：\n\n 如果它的值很大，说明对模型的复杂度惩罚大，对拟合数据的损失惩罚小，这样它就不会过分拟合数据，在训练数据上的偏差较大，在未知数据上的方差较小，但是可能出现欠拟合的现象；\n\n 如果它的值很小，说明比较注重对训练数据的拟合，在训练数据上的偏差会小，但是可能会导致过拟合。\n\n加入正则化后的参数更新：\n$$\n\\theta_{j} :=\\theta_{j}-\\frac{\\alpha}{m} \\sum_{i=1}^{m}\\left(h_{\\theta}\\left(x_{i}\\right)-y_{i}\\right) x_{i}^{j}-\\frac{\\lambda}{m} \\theta_{j}\n$$\n\n\n## python 实现\n\n空\n\n## 参考资料\n\n[极大似然估计](https://irwenqiang.iteye.com/blog/1552680\"该部分参考这里\")","source":"_posts/逻辑回归.md","raw":"---\ntitle: 逻辑回归\nmathjax: true\ndate: 2019-04-27 13:01:43\ncategories: 机器学习方法\ntags: 逻辑回归\n---\n\n> 逻辑回归就是西瓜书里的对数几率回归，名为回归，实际则是分类算法。其实质是利用线性回归模型的预测结果来逼近真实标记的对数几率。\n> \n一句话概括就是:\n<font color=\"red\"> \n逻辑回归假设数据服从 **伯努利分布** ,通过 **极大化似然函数** 的方法，运用 **梯度下降** 来求解参数，来达到将数据二分类的目的。</font>\n\n## 线性模型如何处理二分类问题？\n\n> 在处理二分类任务时，我们希望模型能预测样本属于某类别的概率[0, 1]，或者直接输出类别的标签{0, 1}。 线性模型不能直接来完成这项任务，因为其输出是一个实际值，范围也不一定在0~1之间，无法体现我们所想要的概率或者标签。\n\n$$\ny=\\boldsymbol{w}^{\\mathrm{T}} \\boldsymbol{x}+b\n$$\n\n因此，我们需要找到一种能把线性模型输出映射到 **概率** 或者 **标签** 的方法；\n\n- 如何转化为标签？\n\n\t单位阶跃函数\n\n- 如何转化为概率？\n\n\tsigmoid函数 (二分类): 将无穷范围的值限制在(0, 1)之间\n\n\tsoftmax函数（多分类）: 所有类别概率和为1\n\n![logo](逻辑回归/sigmoid.png)\n\n由于单位阶跃函数存在跳跃点，在跳跃点不可导，想选择梯度下降法来优化时，只能选择sigmoid函数了。\n\n## 逻辑回归模型\n\n> 逻辑回归就是这样的一个过程：面对一个分类问题，建立代价函数，然后通过优化方\n法迭代求解出最优的模型参数，然后测试验证我们这个求解的模型的好坏。\n\n### 逻辑回归的优缺点\n\n- 优点 \n\n\t- 速度快，适合二分类问题\n\t\n\t- 简单易于理解，直接看到各个特征的权重\n\n\t- 能容易地更新模型吸收新的数据\n\n\n- 缺点\n\n\t- 对数据和场景的适应能力有局限性，不如决策树算法适应性那么强\n\n### 逻辑回归的用途\n\n- **寻找主要影响因素**：  通过学习到的权重值，得到不同因素对结果的影响力大小\n\n\n- **预测**：  预测事件发生的概率\n\n\n### 建模常规步骤\n\n- 寻找 `h 函数`（预测函数）\n\n\n- 构造 `J 函数` (损失函数)\n\n\n- 利用梯度下降等方法最小化  `J 函数`，并求取参数\n\n### LR基本模型\n\n以下就是逻辑回归的基本模型：\n\n$$\ny=\\frac{1}{1+e^{-z}}\n$$\n\n$$\nz=w^{\\top} x+b\n$$\n\n取倒数\n\n$$\n\\frac{1}{y}=1+e^{-z}\n$$\n\n取对数\n\n$$\n\\ln \\left(\\frac{1}{y}-1\\right)=-z\n$$\n\n$$\n\\ln \\frac{y}{1-y}=\\boldsymbol{w}^{\\mathrm{T}} \\boldsymbol{x}+b\n$$\n\n\nln(y/(1-y)) 就是对数几率\n\n## 代价函数\n\n线性模型常用的目标函数 `均方误差` 用在逻辑回归模型是非凸函数，非凸函数通过梯度下降法容易陷入局部最小值，因此需要想办法找到代价函数，且代价函数为凸函数。\n\n### 极大似然法定义代价函数\n这里通过极大似然估计的方法来定义目标函数：\n\n> **极大似然估计**： 这里想了很久才算有点理解，之前就一直卡在这里。。极大似然估计就是可以利用已知数据来推测出产生这些数据的最可能的环境条件。\n\n\n> 举个栗子，当我们扔硬币时，出现的可能性有两个，要么正面朝上（事件A），要么反面朝上(事件B)，假设出现某事件的可能性只与硬币的 `质量分布θ` 有关系，假设我们做了n组实验（A出现m次），这样能得到两种情况的概率 P(A), P(B),我们要推测出 `质量分布θ` 是多少，也就是 `参数估计` ,即 `质量分布θ` 是多少时，才最可能出现当前实验的结果。抛硬币的事件服从二项分布，那么给定了一组实验的情况下，似然函数是(似然函数与概率值相等)：\n> $$\nL\\left(\\theta ; x_{1}, \\ldots, x_{n}\\right)=f\\left(x_{1}, \\ldots, x_{n} ; \\theta\\right)=\\prod_{i=1}^{n} P\\left(X=x_{i}\\right)=\\theta^{m}(1-\\theta)^{n-m}\n$$\n假设一个数据集`Cn`,标签`y∈{0,1}`，预测值`Θ`,模型参数为`w`则似然函数可以写作:\n$$\nP\\left( \\theta _{\\left( x_i \\right)}|w \\right) =\\prod_{n=1}^N{\\theta}_{xi}^{yi}\\cdot \\left( 1-\\theta _{\\left( x_i \\right)} \\right) ^{1-y_i}\n$$\n\n取对数简化运算:\n$$\n\\mathrm{L}(\\mathrm{w}, \\mathrm{b})=\\sum_{i=1}^{N}\\left[y_{i} \\log \\left(\\emptyset\\left(x_{i}\\right)\\right)+\\left(1-y_{i}\\right) \\log \\left(1-\\emptyset\\left(x_{i}\\right)\\right)\\right]\n$$\n实际代价函数的样子:\n$$\n\\mathrm{J}(\\mathrm{w}, \\mathrm{b})=-\\frac{1}{N} \\mathrm{L}(\\mathrm{w}, \\mathrm{b})=-\\frac{1}{N} \\sum_{i=1}^{N}\\left[y_{i} \\log \\left(\\emptyset\\left(x_{i}\\right)\\right)+\\left(1-y_{i}\\right) \\log \\left(1-\\emptyset\\left(x_{i}\\right)\\right)\\right]\n$$\n取对数之后的公式很符合理想的代价函数，当实际标签与预测结果相同，则代价为0，而相反时，会随着差值越大，损失越大。\n\n因为\n$$\n\\operatorname{logit}(\\mathrm{p})=\\log \\frac{p}{1-p}\n$$\n\n$$\n\\log \\frac{P(Y=1 | X)}{1-P(Y=1 | X)}=w \\cdot x+b\n$$\n带入后继续化简\n$$\n\\mathrm{L}(\\mathrm{w}, \\mathrm{b})=\\sum_{i=1}^{N}\\left[y_{i}\\left(\\mathrm{w} \\cdot x_{i}+\\mathrm{b}\\right)-\\log \\left(1+e^{\\mathrm{w} \\cdot x_{i}+b}\\right)\\right]\n$$\n### 直观解释\n\n直观上理解，代价函数就是分类错误的惩罚，那么当y=1时，prediction 越小时，损失应越大；y=0时prediction 越大时，损失应越小。\n$$\n\\operatorname{cost}=\\left\\{\\begin{aligned}-\\log (\\hat{p}), & \\text { if } y=1 \\\\-\\log (1-\\hat{p}), & \\text { if } y=0 \\end{aligned}\\right.\n$$\n## 通过梯度下降来最小化代价函数\n\n因为我们找到的代价函数是凸函数，所以可以尝试用梯度下降来找到合适的参数w，b：\n$$\n\\mathrm{w} :=\\mathrm{w}-\\alpha \\frac{\\partial J(w, b)}{\\partial w}\n$$\n\n$$\n\\mathrm{b} :=\\mathrm{b}-\\alpha \\frac{\\partial J(w, b)}{\\partial b}\n$$\n偏导求解过程：\n\n对w求偏导\n$$\n\\frac{\\partial J(w, b)}{\\partial w}=-\\frac{1}{N} \\sum_{i=1}^{N}\\left[y_{i} \\frac{1}{\\partial\\left(x_{i}\\right)}-\\left(1-y_{i}\\right) \\frac{1}{1-\\emptyset\\left(x_{i}\\right)}\\right] \\frac{\\partial \\emptyset\\left(x_{i}\\right)}{\\partial w}\n$$\n\n$$\n=-\\frac{1}{N} \\sum_{i=1}^{N}\\left[y_{i} \\frac{1}{\\emptyset\\left(x_{i}\\right)}-\\left(1-y_{i}\\right) \\frac{1}{1-\\emptyset\\left(x_{i}\\right)}\\right] \\sigma\\left(x_{i}\\right)\\left(1-\\emptyset\\left(x_{i}\\right)\\right) \\cdot x_{i}\n$$\n\n$$\n=-\\frac{1}{N} \\Sigma_{i=1}^{N}\\left(y_{i}-\\emptyset\\left(x_{i}\\right)\\right) \\cdot x_{i^{*}}\n$$\n对b求偏导\n$$\n\\frac{\\partial J(w, b)}{\\partial b}=-\\frac{1}{N} \\sum_{i=1}^{N}\\left[y_{i} \\frac{1}{\\emptyset\\left(x_{i}\\right)}-\\left(1-y_{i}\\right) \\frac{1}{1-\\emptyset\\left(x_{i}\\right)}\\right] \\frac{\\partial \\emptyset\\left(x_{i}\\right)}{\\partial b}\n$$\n\n$$\n=-\\frac{1}{N} \\sum_{i=1}^{N}\\left[y_{i} \\frac{1}{\\emptyset\\left(x_{i}\\right)}-\\left(1-y_{i}\\right) \\frac{1}{1-\\emptyset\\left(x_{i}\\right)}\\right] \\wp\\left(x_{i}\\right)\\left(1-\\emptyset\\left(x_{i}\\right)\\right)\n$$\n\n$$\n=-\\frac{1}{N} \\Sigma_{i=1}^{N}\\left(y_{i}-\\emptyset\\left(x_{i}\\right)\\right)\n$$\n\n带入公式后，得到最终推导的结果：\n$$\n\\mathrm{w} :=\\mathrm{w}+\\alpha \\frac{1}{N} \\sum_{i=1}^{N}\\left(y_{i}-\\emptyset\\left(x_{i}\\right)\\right) \\cdot x_{i}\n$$\n\n$$\n\\mathrm{b} :=\\mathrm{b}+\\alpha \\frac{1}{N} \\sum_{i=1}^{N}\\left(y_{i}-\\emptyset\\left(x_{i}\\right)\\right)\n$$\n<font color=\"red\"> \n通过以上公式可以看出，逻辑回归的梯度与 `sigmoid` 本身无关，只与 `y` 和`x`和 `w` 有关系。</font>\n\n## 进一步提高泛化能力\n\n> 影响模型泛化能力的主因素是 `过拟合`, 过拟合问题比较容易理解，这里就不贴图了。下面分析一下产生过拟合的原因和解决办法。\n\n### 过拟合产生的原因有哪些？\n\n**过多的特征**\n\n### 怎么解决过拟合？\n\n1. 减少特征数量\n\n\t减少特征数量会导致部分信息丢失。\n\n2. 正则化\n\n\t保留所有的特征，并且减小参数的大小。\n\n### 正则化方法\n\n**在代价函数上增加一个惩罚项**，<font color=red>惩罚项应该是模型复杂度的单调递增函数，模型越复杂，惩罚项越大。 </font>\n\n回归问题中，取**平方损失**（L2 范数），或者L1范数\n$$\nJ(\\theta)=\\frac{1}{2 m} \\sum_{i=1}^{n}\\left(\\mathrm{h}_{\\theta}\\left(\\mathrm{x}_{i}\\right)-y_{i}\\right)^{2}+\\lambda \\sum_{j=1}^{n} \\theta_{j}^{2}\n$$\n这里的lambda 系数：\n\n 如果它的值很大，说明对模型的复杂度惩罚大，对拟合数据的损失惩罚小，这样它就不会过分拟合数据，在训练数据上的偏差较大，在未知数据上的方差较小，但是可能出现欠拟合的现象；\n\n 如果它的值很小，说明比较注重对训练数据的拟合，在训练数据上的偏差会小，但是可能会导致过拟合。\n\n加入正则化后的参数更新：\n$$\n\\theta_{j} :=\\theta_{j}-\\frac{\\alpha}{m} \\sum_{i=1}^{m}\\left(h_{\\theta}\\left(x_{i}\\right)-y_{i}\\right) x_{i}^{j}-\\frac{\\lambda}{m} \\theta_{j}\n$$\n\n\n## python 实现\n\n空\n\n## 参考资料\n\n[极大似然估计](https://irwenqiang.iteye.com/blog/1552680\"该部分参考这里\")","slug":"逻辑回归","published":1,"updated":"2020-02-20T06:39:32.963Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka8ephhb002xt8pl7scmj30r","content":"<blockquote>\n<p>逻辑回归就是西瓜书里的对数几率回归，名为回归，实际则是分类算法。其实质是利用线性回归模型的预测结果来逼近真实标记的对数几率。</p>\n<p>一句话概括就是:</p>\n<font color=\"red\"> \n逻辑回归假设数据服从 **伯努利分布** ,通过 **极大化似然函数** 的方法，运用 **梯度下降** 来求解参数，来达到将数据二分类的目的。</font>\n\n</blockquote>\n<h2 id=\"线性模型如何处理二分类问题？\"><a href=\"#线性模型如何处理二分类问题？\" class=\"headerlink\" title=\"线性模型如何处理二分类问题？\"></a>线性模型如何处理二分类问题？</h2><blockquote>\n<p>在处理二分类任务时，我们希望模型能预测样本属于某类别的概率[0, 1]，或者直接输出类别的标签{0, 1}。 线性模型不能直接来完成这项任务，因为其输出是一个实际值，范围也不一定在0~1之间，无法体现我们所想要的概率或者标签。</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">\ny=\\boldsymbol{w}^{\\mathrm{T}} \\boldsymbol{x}+b</script><p>因此，我们需要找到一种能把线性模型输出映射到 <strong>概率</strong> 或者 <strong>标签</strong> 的方法；</p>\n<ul>\n<li><p>如何转化为标签？</p>\n<p>  单位阶跃函数</p>\n</li>\n<li><p>如何转化为概率？</p>\n<p>  sigmoid函数 (二分类): 将无穷范围的值限制在(0, 1)之间</p>\n<p>  softmax函数（多分类）: 所有类别概率和为1</p>\n</li>\n</ul>\n<p><img src=\"/2019/04/27/逻辑回归/sigmoid.png\" alt=\"logo\"></p>\n<p>由于单位阶跃函数存在跳跃点，在跳跃点不可导，想选择梯度下降法来优化时，只能选择sigmoid函数了。</p>\n<h2 id=\"逻辑回归模型\"><a href=\"#逻辑回归模型\" class=\"headerlink\" title=\"逻辑回归模型\"></a>逻辑回归模型</h2><blockquote>\n<p>逻辑回归就是这样的一个过程：面对一个分类问题，建立代价函数，然后通过优化方<br>法迭代求解出最优的模型参数，然后测试验证我们这个求解的模型的好坏。</p>\n</blockquote>\n<h3 id=\"逻辑回归的优缺点\"><a href=\"#逻辑回归的优缺点\" class=\"headerlink\" title=\"逻辑回归的优缺点\"></a>逻辑回归的优缺点</h3><ul>\n<li><p>优点 </p>\n<ul>\n<li><p>速度快，适合二分类问题</p>\n</li>\n<li><p>简单易于理解，直接看到各个特征的权重</p>\n</li>\n<li><p>能容易地更新模型吸收新的数据</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>缺点</p>\n<ul>\n<li>对数据和场景的适应能力有局限性，不如决策树算法适应性那么强</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"逻辑回归的用途\"><a href=\"#逻辑回归的用途\" class=\"headerlink\" title=\"逻辑回归的用途\"></a>逻辑回归的用途</h3><ul>\n<li><strong>寻找主要影响因素</strong>：  通过学习到的权重值，得到不同因素对结果的影响力大小</li>\n</ul>\n<ul>\n<li><strong>预测</strong>：  预测事件发生的概率</li>\n</ul>\n<h3 id=\"建模常规步骤\"><a href=\"#建模常规步骤\" class=\"headerlink\" title=\"建模常规步骤\"></a>建模常规步骤</h3><ul>\n<li>寻找 <code>h 函数</code>（预测函数）</li>\n</ul>\n<ul>\n<li>构造 <code>J 函数</code> (损失函数)</li>\n</ul>\n<ul>\n<li>利用梯度下降等方法最小化  <code>J 函数</code>，并求取参数</li>\n</ul>\n<h3 id=\"LR基本模型\"><a href=\"#LR基本模型\" class=\"headerlink\" title=\"LR基本模型\"></a>LR基本模型</h3><p>以下就是逻辑回归的基本模型：</p>\n<script type=\"math/tex; mode=display\">\ny=\\frac{1}{1+e^{-z}}</script><script type=\"math/tex; mode=display\">\nz=w^{\\top} x+b</script><p>取倒数</p>\n<script type=\"math/tex; mode=display\">\n\\frac{1}{y}=1+e^{-z}</script><p>取对数</p>\n<script type=\"math/tex; mode=display\">\n\\ln \\left(\\frac{1}{y}-1\\right)=-z</script><script type=\"math/tex; mode=display\">\n\\ln \\frac{y}{1-y}=\\boldsymbol{w}^{\\mathrm{T}} \\boldsymbol{x}+b</script><p>ln(y/(1-y)) 就是对数几率</p>\n<h2 id=\"代价函数\"><a href=\"#代价函数\" class=\"headerlink\" title=\"代价函数\"></a>代价函数</h2><p>线性模型常用的目标函数 <code>均方误差</code> 用在逻辑回归模型是非凸函数，非凸函数通过梯度下降法容易陷入局部最小值，因此需要想办法找到代价函数，且代价函数为凸函数。</p>\n<h3 id=\"极大似然法定义代价函数\"><a href=\"#极大似然法定义代价函数\" class=\"headerlink\" title=\"极大似然法定义代价函数\"></a>极大似然法定义代价函数</h3><p>这里通过极大似然估计的方法来定义目标函数：</p>\n<blockquote>\n<p><strong>极大似然估计</strong>： 这里想了很久才算有点理解，之前就一直卡在这里。。极大似然估计就是可以利用已知数据来推测出产生这些数据的最可能的环境条件。</p>\n<p>举个栗子，当我们扔硬币时，出现的可能性有两个，要么正面朝上（事件A），要么反面朝上(事件B)，假设出现某事件的可能性只与硬币的 <code>质量分布θ</code> 有关系，假设我们做了n组实验（A出现m次），这样能得到两种情况的概率 P(A), P(B),我们要推测出 <code>质量分布θ</code> 是多少，也就是 <code>参数估计</code> ,即 <code>质量分布θ</code> 是多少时，才最可能出现当前实验的结果。抛硬币的事件服从二项分布，那么给定了一组实验的情况下，似然函数是(似然函数与概率值相等)：</p>\n<script type=\"math/tex; mode=display\">\nL\\left(\\theta ; x_{1}, \\ldots, x_{n}\\right)=f\\left(x_{1}, \\ldots, x_{n} ; \\theta\\right)=\\prod_{i=1}^{n} P\\left(X=x_{i}\\right)=\\theta^{m}(1-\\theta)^{n-m}</script><p>假设一个数据集<code>Cn</code>,标签<code>y∈{0,1}</code>，预测值<code>Θ</code>,模型参数为<code>w</code>则似然函数可以写作:</p>\n<script type=\"math/tex; mode=display\">\nP\\left( \\theta _{\\left( x_i \\right)}|w \\right) =\\prod_{n=1}^N{\\theta}_{xi}^{yi}\\cdot \\left( 1-\\theta _{\\left( x_i \\right)} \\right) ^{1-y_i}</script></blockquote>\n<p>取对数简化运算:</p>\n<script type=\"math/tex; mode=display\">\n\\mathrm{L}(\\mathrm{w}, \\mathrm{b})=\\sum_{i=1}^{N}\\left[y_{i} \\log \\left(\\emptyset\\left(x_{i}\\right)\\right)+\\left(1-y_{i}\\right) \\log \\left(1-\\emptyset\\left(x_{i}\\right)\\right)\\right]</script><p>实际代价函数的样子:</p>\n<script type=\"math/tex; mode=display\">\n\\mathrm{J}(\\mathrm{w}, \\mathrm{b})=-\\frac{1}{N} \\mathrm{L}(\\mathrm{w}, \\mathrm{b})=-\\frac{1}{N} \\sum_{i=1}^{N}\\left[y_{i} \\log \\left(\\emptyset\\left(x_{i}\\right)\\right)+\\left(1-y_{i}\\right) \\log \\left(1-\\emptyset\\left(x_{i}\\right)\\right)\\right]</script><p>取对数之后的公式很符合理想的代价函数，当实际标签与预测结果相同，则代价为0，而相反时，会随着差值越大，损失越大。</p>\n<p>因为</p>\n<script type=\"math/tex; mode=display\">\n\\operatorname{logit}(\\mathrm{p})=\\log \\frac{p}{1-p}</script><script type=\"math/tex; mode=display\">\n\\log \\frac{P(Y=1 | X)}{1-P(Y=1 | X)}=w \\cdot x+b</script><p>带入后继续化简</p>\n<script type=\"math/tex; mode=display\">\n\\mathrm{L}(\\mathrm{w}, \\mathrm{b})=\\sum_{i=1}^{N}\\left[y_{i}\\left(\\mathrm{w} \\cdot x_{i}+\\mathrm{b}\\right)-\\log \\left(1+e^{\\mathrm{w} \\cdot x_{i}+b}\\right)\\right]</script><h3 id=\"直观解释\"><a href=\"#直观解释\" class=\"headerlink\" title=\"直观解释\"></a>直观解释</h3><p>直观上理解，代价函数就是分类错误的惩罚，那么当y=1时，prediction 越小时，损失应越大；y=0时prediction 越大时，损失应越小。</p>\n<script type=\"math/tex; mode=display\">\n\\operatorname{cost}=\\left\\{\\begin{aligned}-\\log (\\hat{p}), & \\text { if } y=1 \\\\-\\log (1-\\hat{p}), & \\text { if } y=0 \\end{aligned}\\right.</script><h2 id=\"通过梯度下降来最小化代价函数\"><a href=\"#通过梯度下降来最小化代价函数\" class=\"headerlink\" title=\"通过梯度下降来最小化代价函数\"></a>通过梯度下降来最小化代价函数</h2><p>因为我们找到的代价函数是凸函数，所以可以尝试用梯度下降来找到合适的参数w，b：</p>\n<script type=\"math/tex; mode=display\">\n\\mathrm{w} :=\\mathrm{w}-\\alpha \\frac{\\partial J(w, b)}{\\partial w}</script><script type=\"math/tex; mode=display\">\n\\mathrm{b} :=\\mathrm{b}-\\alpha \\frac{\\partial J(w, b)}{\\partial b}</script><p>偏导求解过程：</p>\n<p>对w求偏导</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\partial J(w, b)}{\\partial w}=-\\frac{1}{N} \\sum_{i=1}^{N}\\left[y_{i} \\frac{1}{\\partial\\left(x_{i}\\right)}-\\left(1-y_{i}\\right) \\frac{1}{1-\\emptyset\\left(x_{i}\\right)}\\right] \\frac{\\partial \\emptyset\\left(x_{i}\\right)}{\\partial w}</script><script type=\"math/tex; mode=display\">\n=-\\frac{1}{N} \\sum_{i=1}^{N}\\left[y_{i} \\frac{1}{\\emptyset\\left(x_{i}\\right)}-\\left(1-y_{i}\\right) \\frac{1}{1-\\emptyset\\left(x_{i}\\right)}\\right] \\sigma\\left(x_{i}\\right)\\left(1-\\emptyset\\left(x_{i}\\right)\\right) \\cdot x_{i}</script><script type=\"math/tex; mode=display\">\n=-\\frac{1}{N} \\Sigma_{i=1}^{N}\\left(y_{i}-\\emptyset\\left(x_{i}\\right)\\right) \\cdot x_{i^{*}}</script><p>对b求偏导</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\partial J(w, b)}{\\partial b}=-\\frac{1}{N} \\sum_{i=1}^{N}\\left[y_{i} \\frac{1}{\\emptyset\\left(x_{i}\\right)}-\\left(1-y_{i}\\right) \\frac{1}{1-\\emptyset\\left(x_{i}\\right)}\\right] \\frac{\\partial \\emptyset\\left(x_{i}\\right)}{\\partial b}</script><script type=\"math/tex; mode=display\">\n=-\\frac{1}{N} \\sum_{i=1}^{N}\\left[y_{i} \\frac{1}{\\emptyset\\left(x_{i}\\right)}-\\left(1-y_{i}\\right) \\frac{1}{1-\\emptyset\\left(x_{i}\\right)}\\right] \\wp\\left(x_{i}\\right)\\left(1-\\emptyset\\left(x_{i}\\right)\\right)</script><script type=\"math/tex; mode=display\">\n=-\\frac{1}{N} \\Sigma_{i=1}^{N}\\left(y_{i}-\\emptyset\\left(x_{i}\\right)\\right)</script><p>带入公式后，得到最终推导的结果：</p>\n<script type=\"math/tex; mode=display\">\n\\mathrm{w} :=\\mathrm{w}+\\alpha \\frac{1}{N} \\sum_{i=1}^{N}\\left(y_{i}-\\emptyset\\left(x_{i}\\right)\\right) \\cdot x_{i}</script><script type=\"math/tex; mode=display\">\n\\mathrm{b} :=\\mathrm{b}+\\alpha \\frac{1}{N} \\sum_{i=1}^{N}\\left(y_{i}-\\emptyset\\left(x_{i}\\right)\\right)</script><font color=\"red\"> \n通过以上公式可以看出，逻辑回归的梯度与 `sigmoid` 本身无关，只与 `y` 和`x`和 `w` 有关系。</font>\n\n<h2 id=\"进一步提高泛化能力\"><a href=\"#进一步提高泛化能力\" class=\"headerlink\" title=\"进一步提高泛化能力\"></a>进一步提高泛化能力</h2><blockquote>\n<p>影响模型泛化能力的主因素是 <code>过拟合</code>, 过拟合问题比较容易理解，这里就不贴图了。下面分析一下产生过拟合的原因和解决办法。</p>\n</blockquote>\n<h3 id=\"过拟合产生的原因有哪些？\"><a href=\"#过拟合产生的原因有哪些？\" class=\"headerlink\" title=\"过拟合产生的原因有哪些？\"></a>过拟合产生的原因有哪些？</h3><p><strong>过多的特征</strong></p>\n<h3 id=\"怎么解决过拟合？\"><a href=\"#怎么解决过拟合？\" class=\"headerlink\" title=\"怎么解决过拟合？\"></a>怎么解决过拟合？</h3><ol>\n<li><p>减少特征数量</p>\n<p> 减少特征数量会导致部分信息丢失。</p>\n</li>\n<li><p>正则化</p>\n<p> 保留所有的特征，并且减小参数的大小。</p>\n</li>\n</ol>\n<h3 id=\"正则化方法\"><a href=\"#正则化方法\" class=\"headerlink\" title=\"正则化方法\"></a>正则化方法</h3><p><strong>在代价函数上增加一个惩罚项</strong>，<font color=\"red\">惩罚项应该是模型复杂度的单调递增函数，模型越复杂，惩罚项越大。 </font></p>\n<p>回归问题中，取<strong>平方损失</strong>（L2 范数），或者L1范数</p>\n<script type=\"math/tex; mode=display\">\nJ(\\theta)=\\frac{1}{2 m} \\sum_{i=1}^{n}\\left(\\mathrm{h}_{\\theta}\\left(\\mathrm{x}_{i}\\right)-y_{i}\\right)^{2}+\\lambda \\sum_{j=1}^{n} \\theta_{j}^{2}</script><p>这里的lambda 系数：</p>\n<p> 如果它的值很大，说明对模型的复杂度惩罚大，对拟合数据的损失惩罚小，这样它就不会过分拟合数据，在训练数据上的偏差较大，在未知数据上的方差较小，但是可能出现欠拟合的现象；</p>\n<p> 如果它的值很小，说明比较注重对训练数据的拟合，在训练数据上的偏差会小，但是可能会导致过拟合。</p>\n<p>加入正则化后的参数更新：</p>\n<script type=\"math/tex; mode=display\">\n\\theta_{j} :=\\theta_{j}-\\frac{\\alpha}{m} \\sum_{i=1}^{m}\\left(h_{\\theta}\\left(x_{i}\\right)-y_{i}\\right) x_{i}^{j}-\\frac{\\lambda}{m} \\theta_{j}</script><h2 id=\"python-实现\"><a href=\"#python-实现\" class=\"headerlink\" title=\"python 实现\"></a>python 实现</h2><p>空</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://irwenqiang.iteye.com/blog/1552680&quot;该部分参考这里&quot;\" target=\"_blank\" rel=\"noopener\">极大似然估计</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>逻辑回归就是西瓜书里的对数几率回归，名为回归，实际则是分类算法。其实质是利用线性回归模型的预测结果来逼近真实标记的对数几率。</p>\n<p>一句话概括就是:</p>\n<font color=\"red\"> \n逻辑回归假设数据服从 **伯努利分布** ,通过 **极大化似然函数** 的方法，运用 **梯度下降** 来求解参数，来达到将数据二分类的目的。</font>\n\n</blockquote>\n<h2 id=\"线性模型如何处理二分类问题？\"><a href=\"#线性模型如何处理二分类问题？\" class=\"headerlink\" title=\"线性模型如何处理二分类问题？\"></a>线性模型如何处理二分类问题？</h2><blockquote>\n<p>在处理二分类任务时，我们希望模型能预测样本属于某类别的概率[0, 1]，或者直接输出类别的标签{0, 1}。 线性模型不能直接来完成这项任务，因为其输出是一个实际值，范围也不一定在0~1之间，无法体现我们所想要的概率或者标签。</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">\ny=\\boldsymbol{w}^{\\mathrm{T}} \\boldsymbol{x}+b</script><p>因此，我们需要找到一种能把线性模型输出映射到 <strong>概率</strong> 或者 <strong>标签</strong> 的方法；</p>\n<ul>\n<li><p>如何转化为标签？</p>\n<p>  单位阶跃函数</p>\n</li>\n<li><p>如何转化为概率？</p>\n<p>  sigmoid函数 (二分类): 将无穷范围的值限制在(0, 1)之间</p>\n<p>  softmax函数（多分类）: 所有类别概率和为1</p>\n</li>\n</ul>\n<p><img src=\"/2019/04/27/逻辑回归/sigmoid.png\" alt=\"logo\"></p>\n<p>由于单位阶跃函数存在跳跃点，在跳跃点不可导，想选择梯度下降法来优化时，只能选择sigmoid函数了。</p>\n<h2 id=\"逻辑回归模型\"><a href=\"#逻辑回归模型\" class=\"headerlink\" title=\"逻辑回归模型\"></a>逻辑回归模型</h2><blockquote>\n<p>逻辑回归就是这样的一个过程：面对一个分类问题，建立代价函数，然后通过优化方<br>法迭代求解出最优的模型参数，然后测试验证我们这个求解的模型的好坏。</p>\n</blockquote>\n<h3 id=\"逻辑回归的优缺点\"><a href=\"#逻辑回归的优缺点\" class=\"headerlink\" title=\"逻辑回归的优缺点\"></a>逻辑回归的优缺点</h3><ul>\n<li><p>优点 </p>\n<ul>\n<li><p>速度快，适合二分类问题</p>\n</li>\n<li><p>简单易于理解，直接看到各个特征的权重</p>\n</li>\n<li><p>能容易地更新模型吸收新的数据</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>缺点</p>\n<ul>\n<li>对数据和场景的适应能力有局限性，不如决策树算法适应性那么强</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"逻辑回归的用途\"><a href=\"#逻辑回归的用途\" class=\"headerlink\" title=\"逻辑回归的用途\"></a>逻辑回归的用途</h3><ul>\n<li><strong>寻找主要影响因素</strong>：  通过学习到的权重值，得到不同因素对结果的影响力大小</li>\n</ul>\n<ul>\n<li><strong>预测</strong>：  预测事件发生的概率</li>\n</ul>\n<h3 id=\"建模常规步骤\"><a href=\"#建模常规步骤\" class=\"headerlink\" title=\"建模常规步骤\"></a>建模常规步骤</h3><ul>\n<li>寻找 <code>h 函数</code>（预测函数）</li>\n</ul>\n<ul>\n<li>构造 <code>J 函数</code> (损失函数)</li>\n</ul>\n<ul>\n<li>利用梯度下降等方法最小化  <code>J 函数</code>，并求取参数</li>\n</ul>\n<h3 id=\"LR基本模型\"><a href=\"#LR基本模型\" class=\"headerlink\" title=\"LR基本模型\"></a>LR基本模型</h3><p>以下就是逻辑回归的基本模型：</p>\n<script type=\"math/tex; mode=display\">\ny=\\frac{1}{1+e^{-z}}</script><script type=\"math/tex; mode=display\">\nz=w^{\\top} x+b</script><p>取倒数</p>\n<script type=\"math/tex; mode=display\">\n\\frac{1}{y}=1+e^{-z}</script><p>取对数</p>\n<script type=\"math/tex; mode=display\">\n\\ln \\left(\\frac{1}{y}-1\\right)=-z</script><script type=\"math/tex; mode=display\">\n\\ln \\frac{y}{1-y}=\\boldsymbol{w}^{\\mathrm{T}} \\boldsymbol{x}+b</script><p>ln(y/(1-y)) 就是对数几率</p>\n<h2 id=\"代价函数\"><a href=\"#代价函数\" class=\"headerlink\" title=\"代价函数\"></a>代价函数</h2><p>线性模型常用的目标函数 <code>均方误差</code> 用在逻辑回归模型是非凸函数，非凸函数通过梯度下降法容易陷入局部最小值，因此需要想办法找到代价函数，且代价函数为凸函数。</p>\n<h3 id=\"极大似然法定义代价函数\"><a href=\"#极大似然法定义代价函数\" class=\"headerlink\" title=\"极大似然法定义代价函数\"></a>极大似然法定义代价函数</h3><p>这里通过极大似然估计的方法来定义目标函数：</p>\n<blockquote>\n<p><strong>极大似然估计</strong>： 这里想了很久才算有点理解，之前就一直卡在这里。。极大似然估计就是可以利用已知数据来推测出产生这些数据的最可能的环境条件。</p>\n<p>举个栗子，当我们扔硬币时，出现的可能性有两个，要么正面朝上（事件A），要么反面朝上(事件B)，假设出现某事件的可能性只与硬币的 <code>质量分布θ</code> 有关系，假设我们做了n组实验（A出现m次），这样能得到两种情况的概率 P(A), P(B),我们要推测出 <code>质量分布θ</code> 是多少，也就是 <code>参数估计</code> ,即 <code>质量分布θ</code> 是多少时，才最可能出现当前实验的结果。抛硬币的事件服从二项分布，那么给定了一组实验的情况下，似然函数是(似然函数与概率值相等)：</p>\n<script type=\"math/tex; mode=display\">\nL\\left(\\theta ; x_{1}, \\ldots, x_{n}\\right)=f\\left(x_{1}, \\ldots, x_{n} ; \\theta\\right)=\\prod_{i=1}^{n} P\\left(X=x_{i}\\right)=\\theta^{m}(1-\\theta)^{n-m}</script><p>假设一个数据集<code>Cn</code>,标签<code>y∈{0,1}</code>，预测值<code>Θ</code>,模型参数为<code>w</code>则似然函数可以写作:</p>\n<script type=\"math/tex; mode=display\">\nP\\left( \\theta _{\\left( x_i \\right)}|w \\right) =\\prod_{n=1}^N{\\theta}_{xi}^{yi}\\cdot \\left( 1-\\theta _{\\left( x_i \\right)} \\right) ^{1-y_i}</script></blockquote>\n<p>取对数简化运算:</p>\n<script type=\"math/tex; mode=display\">\n\\mathrm{L}(\\mathrm{w}, \\mathrm{b})=\\sum_{i=1}^{N}\\left[y_{i} \\log \\left(\\emptyset\\left(x_{i}\\right)\\right)+\\left(1-y_{i}\\right) \\log \\left(1-\\emptyset\\left(x_{i}\\right)\\right)\\right]</script><p>实际代价函数的样子:</p>\n<script type=\"math/tex; mode=display\">\n\\mathrm{J}(\\mathrm{w}, \\mathrm{b})=-\\frac{1}{N} \\mathrm{L}(\\mathrm{w}, \\mathrm{b})=-\\frac{1}{N} \\sum_{i=1}^{N}\\left[y_{i} \\log \\left(\\emptyset\\left(x_{i}\\right)\\right)+\\left(1-y_{i}\\right) \\log \\left(1-\\emptyset\\left(x_{i}\\right)\\right)\\right]</script><p>取对数之后的公式很符合理想的代价函数，当实际标签与预测结果相同，则代价为0，而相反时，会随着差值越大，损失越大。</p>\n<p>因为</p>\n<script type=\"math/tex; mode=display\">\n\\operatorname{logit}(\\mathrm{p})=\\log \\frac{p}{1-p}</script><script type=\"math/tex; mode=display\">\n\\log \\frac{P(Y=1 | X)}{1-P(Y=1 | X)}=w \\cdot x+b</script><p>带入后继续化简</p>\n<script type=\"math/tex; mode=display\">\n\\mathrm{L}(\\mathrm{w}, \\mathrm{b})=\\sum_{i=1}^{N}\\left[y_{i}\\left(\\mathrm{w} \\cdot x_{i}+\\mathrm{b}\\right)-\\log \\left(1+e^{\\mathrm{w} \\cdot x_{i}+b}\\right)\\right]</script><h3 id=\"直观解释\"><a href=\"#直观解释\" class=\"headerlink\" title=\"直观解释\"></a>直观解释</h3><p>直观上理解，代价函数就是分类错误的惩罚，那么当y=1时，prediction 越小时，损失应越大；y=0时prediction 越大时，损失应越小。</p>\n<script type=\"math/tex; mode=display\">\n\\operatorname{cost}=\\left\\{\\begin{aligned}-\\log (\\hat{p}), & \\text { if } y=1 \\\\-\\log (1-\\hat{p}), & \\text { if } y=0 \\end{aligned}\\right.</script><h2 id=\"通过梯度下降来最小化代价函数\"><a href=\"#通过梯度下降来最小化代价函数\" class=\"headerlink\" title=\"通过梯度下降来最小化代价函数\"></a>通过梯度下降来最小化代价函数</h2><p>因为我们找到的代价函数是凸函数，所以可以尝试用梯度下降来找到合适的参数w，b：</p>\n<script type=\"math/tex; mode=display\">\n\\mathrm{w} :=\\mathrm{w}-\\alpha \\frac{\\partial J(w, b)}{\\partial w}</script><script type=\"math/tex; mode=display\">\n\\mathrm{b} :=\\mathrm{b}-\\alpha \\frac{\\partial J(w, b)}{\\partial b}</script><p>偏导求解过程：</p>\n<p>对w求偏导</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\partial J(w, b)}{\\partial w}=-\\frac{1}{N} \\sum_{i=1}^{N}\\left[y_{i} \\frac{1}{\\partial\\left(x_{i}\\right)}-\\left(1-y_{i}\\right) \\frac{1}{1-\\emptyset\\left(x_{i}\\right)}\\right] \\frac{\\partial \\emptyset\\left(x_{i}\\right)}{\\partial w}</script><script type=\"math/tex; mode=display\">\n=-\\frac{1}{N} \\sum_{i=1}^{N}\\left[y_{i} \\frac{1}{\\emptyset\\left(x_{i}\\right)}-\\left(1-y_{i}\\right) \\frac{1}{1-\\emptyset\\left(x_{i}\\right)}\\right] \\sigma\\left(x_{i}\\right)\\left(1-\\emptyset\\left(x_{i}\\right)\\right) \\cdot x_{i}</script><script type=\"math/tex; mode=display\">\n=-\\frac{1}{N} \\Sigma_{i=1}^{N}\\left(y_{i}-\\emptyset\\left(x_{i}\\right)\\right) \\cdot x_{i^{*}}</script><p>对b求偏导</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\partial J(w, b)}{\\partial b}=-\\frac{1}{N} \\sum_{i=1}^{N}\\left[y_{i} \\frac{1}{\\emptyset\\left(x_{i}\\right)}-\\left(1-y_{i}\\right) \\frac{1}{1-\\emptyset\\left(x_{i}\\right)}\\right] \\frac{\\partial \\emptyset\\left(x_{i}\\right)}{\\partial b}</script><script type=\"math/tex; mode=display\">\n=-\\frac{1}{N} \\sum_{i=1}^{N}\\left[y_{i} \\frac{1}{\\emptyset\\left(x_{i}\\right)}-\\left(1-y_{i}\\right) \\frac{1}{1-\\emptyset\\left(x_{i}\\right)}\\right] \\wp\\left(x_{i}\\right)\\left(1-\\emptyset\\left(x_{i}\\right)\\right)</script><script type=\"math/tex; mode=display\">\n=-\\frac{1}{N} \\Sigma_{i=1}^{N}\\left(y_{i}-\\emptyset\\left(x_{i}\\right)\\right)</script><p>带入公式后，得到最终推导的结果：</p>\n<script type=\"math/tex; mode=display\">\n\\mathrm{w} :=\\mathrm{w}+\\alpha \\frac{1}{N} \\sum_{i=1}^{N}\\left(y_{i}-\\emptyset\\left(x_{i}\\right)\\right) \\cdot x_{i}</script><script type=\"math/tex; mode=display\">\n\\mathrm{b} :=\\mathrm{b}+\\alpha \\frac{1}{N} \\sum_{i=1}^{N}\\left(y_{i}-\\emptyset\\left(x_{i}\\right)\\right)</script><font color=\"red\"> \n通过以上公式可以看出，逻辑回归的梯度与 `sigmoid` 本身无关，只与 `y` 和`x`和 `w` 有关系。</font>\n\n<h2 id=\"进一步提高泛化能力\"><a href=\"#进一步提高泛化能力\" class=\"headerlink\" title=\"进一步提高泛化能力\"></a>进一步提高泛化能力</h2><blockquote>\n<p>影响模型泛化能力的主因素是 <code>过拟合</code>, 过拟合问题比较容易理解，这里就不贴图了。下面分析一下产生过拟合的原因和解决办法。</p>\n</blockquote>\n<h3 id=\"过拟合产生的原因有哪些？\"><a href=\"#过拟合产生的原因有哪些？\" class=\"headerlink\" title=\"过拟合产生的原因有哪些？\"></a>过拟合产生的原因有哪些？</h3><p><strong>过多的特征</strong></p>\n<h3 id=\"怎么解决过拟合？\"><a href=\"#怎么解决过拟合？\" class=\"headerlink\" title=\"怎么解决过拟合？\"></a>怎么解决过拟合？</h3><ol>\n<li><p>减少特征数量</p>\n<p> 减少特征数量会导致部分信息丢失。</p>\n</li>\n<li><p>正则化</p>\n<p> 保留所有的特征，并且减小参数的大小。</p>\n</li>\n</ol>\n<h3 id=\"正则化方法\"><a href=\"#正则化方法\" class=\"headerlink\" title=\"正则化方法\"></a>正则化方法</h3><p><strong>在代价函数上增加一个惩罚项</strong>，<font color=\"red\">惩罚项应该是模型复杂度的单调递增函数，模型越复杂，惩罚项越大。 </font></p>\n<p>回归问题中，取<strong>平方损失</strong>（L2 范数），或者L1范数</p>\n<script type=\"math/tex; mode=display\">\nJ(\\theta)=\\frac{1}{2 m} \\sum_{i=1}^{n}\\left(\\mathrm{h}_{\\theta}\\left(\\mathrm{x}_{i}\\right)-y_{i}\\right)^{2}+\\lambda \\sum_{j=1}^{n} \\theta_{j}^{2}</script><p>这里的lambda 系数：</p>\n<p> 如果它的值很大，说明对模型的复杂度惩罚大，对拟合数据的损失惩罚小，这样它就不会过分拟合数据，在训练数据上的偏差较大，在未知数据上的方差较小，但是可能出现欠拟合的现象；</p>\n<p> 如果它的值很小，说明比较注重对训练数据的拟合，在训练数据上的偏差会小，但是可能会导致过拟合。</p>\n<p>加入正则化后的参数更新：</p>\n<script type=\"math/tex; mode=display\">\n\\theta_{j} :=\\theta_{j}-\\frac{\\alpha}{m} \\sum_{i=1}^{m}\\left(h_{\\theta}\\left(x_{i}\\right)-y_{i}\\right) x_{i}^{j}-\\frac{\\lambda}{m} \\theta_{j}</script><h2 id=\"python-实现\"><a href=\"#python-实现\" class=\"headerlink\" title=\"python 实现\"></a>python 实现</h2><p>空</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://irwenqiang.iteye.com/blog/1552680&quot;该部分参考这里&quot;\" target=\"_blank\" rel=\"noopener\">极大似然估计</a></p>\n"}],"PostAsset":[{"_id":"source/_posts/Java-集合结构/集合.png","slug":"集合.png","post":"cka8ephdb000kt8plvisqu77f","modified":1,"renderable":0},{"_id":"source/_posts/决策树3-CART分类回归树/CART.png","post":"cka8ephfp001zt8plr6kb09rp","slug":"CART.png","modified":1,"renderable":1},{"_id":"source/_posts/机器学习模型的偏差与方差/biasvariance.png","post":"cka8ephfz0024t8ple85uc2uc","slug":"biasvariance.png","modified":1,"renderable":1},{"_id":"source/_posts/决策树-1基本概念/tree.png","post":"cka8ephg50027t8plqxez0dqn","slug":"tree.png","modified":1,"renderable":1},{"_id":"source/_posts/华为软挑/huawei.jpg","slug":"huawei.jpg","post":"cka8ephg9002at8plb17f3da8","modified":1,"renderable":0},{"_id":"source/_posts/Deep-Residual-Learning-for-Image-Recognition/resnet1.png","post":"cka8ephbn0004t8pl558v4eai","slug":"resnet1.png","modified":1,"renderable":1},{"_id":"source/_posts/Deep-Residual-Learning-for-Image-Recognition/resnet2.png","post":"cka8ephbn0004t8pl558v4eai","slug":"resnet2.png","modified":1,"renderable":1},{"_id":"source/_posts/Network-in-Network/nerworkInNetwork1.png","post":"cka8ephd4000gt8plxd4wqilb","slug":"nerworkInNetwork1.png","modified":1,"renderable":1},{"_id":"source/_posts/Network-in-Network/nerworkInNetwork2.png","post":"cka8ephd4000gt8plxd4wqilb","slug":"nerworkInNetwork2.png","modified":1,"renderable":1},{"_id":"source/_posts/逻辑回归/cost.png","post":"cka8ephhb002xt8pl7scmj30r","slug":"cost.png","modified":1,"renderable":1},{"_id":"source/_posts/逻辑回归/sigmoid.png","post":"cka8ephhb002xt8pl7scmj30r","slug":"sigmoid.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cka8ephb30002t8pl9ih83xod","category_id":"cka8ephbx0006t8plfq91dogj","_id":"cka8ephd7000ht8plr12mi1e6"},{"post_id":"cka8ephbn0004t8pl558v4eai","category_id":"cka8ephcs000ct8plb9jcy8lw","_id":"cka8ephdi000ot8pluqf89l1r"},{"post_id":"cka8ephd4000gt8plxd4wqilb","category_id":"cka8ephcs000ct8plb9jcy8lw","_id":"cka8ephdp000st8plwzm38z77"},{"post_id":"cka8ephc20008t8plgubam41z","category_id":"cka8ephd8000it8plqi64mcm1","_id":"cka8ephdt000vt8plhiqskjni"},{"post_id":"cka8ephcd000at8plsaydsupj","category_id":"cka8ephdj000pt8pljx2yotmg","_id":"cka8ephdz0011t8plsj3bh2e1"},{"post_id":"cka8ephck000bt8pl2iuoezo3","category_id":"cka8ephdt000wt8pldr1u1syu","_id":"cka8ephef0018t8pl5y5ibvzf"},{"post_id":"cka8ephcz000ft8pl24xzf93f","category_id":"cka8ephe10013t8pldtexa45a","_id":"cka8epheq001et8plh8p5xzq6"},{"post_id":"cka8ephdb000kt8plvisqu77f","category_id":"cka8epheg0019t8ple0z6oexy","_id":"cka8ephey001kt8plof2sq48o"},{"post_id":"cka8ephdf000mt8plzdw2a1pc","category_id":"cka8epher001ft8pleljtu0jc","_id":"cka8ephfd001rt8plfn40gqz9"},{"post_id":"cka8ephdm000rt8plr1zt4kn8","category_id":"cka8epher001ft8pleljtu0jc","_id":"cka8ephfo001xt8plgd8supgt"},{"post_id":"cka8ephdq000ut8plqcwxcigh","category_id":"cka8epher001ft8pleljtu0jc","_id":"cka8ephfy0023t8pl164569sw"},{"post_id":"cka8ephdu000yt8pl7mr6b2lj","category_id":"cka8epher001ft8pleljtu0jc","_id":"cka8ephg80029t8plinsfkizm"},{"post_id":"cka8ephdx0010t8plxhl82k1d","category_id":"cka8epher001ft8pleljtu0jc","_id":"cka8ephgg002et8pl6rf0wl0v"},{"post_id":"cka8ephgc002dt8pl6eirnbnw","category_id":"cka8ephdj000pt8pljx2yotmg","_id":"cka8ephgr002lt8pllkxt6r12"},{"post_id":"cka8ephdz0012t8plgf4czlz3","category_id":"cka8ephg70028t8pl5dhzxou0","_id":"cka8ephgy002pt8pl1xh257hi"},{"post_id":"cka8ephe70016t8pldz4y6skc","category_id":"cka8ephg70028t8pl5dhzxou0","_id":"cka8ephh3002tt8plglliquhc"},{"post_id":"cka8ephed0017t8plfffldjgh","category_id":"cka8ephg70028t8pl5dhzxou0","_id":"cka8ephhf002zt8plfbtxczn6"},{"post_id":"cka8ephh6002vt8pl6j39obbu","category_id":"cka8ephe10013t8pldtexa45a","_id":"cka8ephhk0032t8pl5akc9gz1"},{"post_id":"cka8ephek001bt8pltwi7ob2q","category_id":"cka8ephg70028t8pl5dhzxou0","_id":"cka8ephhm0035t8pldu3ejaar"},{"post_id":"cka8epheo001dt8plv6rpsqte","category_id":"cka8ephg70028t8pl5dhzxou0","_id":"cka8ephhn0037t8plu9q4safg"},{"post_id":"cka8ephes001ht8plrshu3hn4","category_id":"cka8ephhk0033t8plnrtbg82a","_id":"cka8ephhr003ct8plzkvp3mtj"},{"post_id":"cka8ephev001jt8pld32fzlt4","category_id":"cka8ephhk0033t8plnrtbg82a","_id":"cka8ephhx003gt8plkctgqywg"},{"post_id":"cka8ephf1001nt8pl8ijkhrqd","category_id":"cka8ephhk0033t8plnrtbg82a","_id":"cka8ephi1003kt8plmbg45ub5"},{"post_id":"cka8ephfa001pt8pl9lzm89al","category_id":"cka8ephhk0033t8plnrtbg82a","_id":"cka8ephi5003ot8plqa34v8yb"},{"post_id":"cka8ephfe001tt8plmtyukint","category_id":"cka8ephg70028t8pl5dhzxou0","_id":"cka8ephie003rt8plqu41sq44"},{"post_id":"cka8ephfk001vt8pl5va2i3xy","category_id":"cka8ephi4003nt8plan6o0prd","_id":"cka8ephik003wt8pl98efwy8y"},{"post_id":"cka8ephfp001zt8plr6kb09rp","category_id":"cka8ephi4003nt8plan6o0prd","_id":"cka8ephim003yt8plfdfcqh9m"},{"post_id":"cka8ephfu0021t8pl6i9oanlj","category_id":"cka8ephij003vt8pl0vkuwfgq","_id":"cka8ephiu0043t8pljh0r8ivb"},{"post_id":"cka8ephfz0024t8ple85uc2uc","category_id":"cka8ephi4003nt8plan6o0prd","_id":"cka8ephj50047t8plz4x6ebx9"},{"post_id":"cka8ephg50027t8plqxez0dqn","category_id":"cka8ephi4003nt8plan6o0prd","_id":"cka8ephjd004at8pll3p12d0m"},{"post_id":"cka8ephg9002at8plb17f3da8","category_id":"cka8ephj40046t8plybj6mtg5","_id":"cka8ephjh004ft8plbevn9tni"},{"post_id":"cka8ephgh002ft8pl40tbdy3q","category_id":"cka8ephij003vt8pl0vkuwfgq","_id":"cka8ephjj004ht8plfazja58f"},{"post_id":"cka8ephgm002it8pldfjfmmzf","category_id":"cka8ephjh004et8pl4cf9vs0h","_id":"cka8ephjr004nt8pldogwh2bv"},{"post_id":"cka8ephgp002kt8plh1z8mplo","category_id":"cka8ephi4003nt8plan6o0prd","_id":"cka8ephju004pt8plythf2o8k"},{"post_id":"cka8ephgw002ot8plgunjaasz","category_id":"cka8ephjq004mt8plhbv1l4t2","_id":"cka8ephjy004ut8plzedyadbe"},{"post_id":"cka8ephh0002rt8plu4k6ec4c","category_id":"cka8ephi4003nt8plan6o0prd","_id":"cka8ephk3004xt8plqe7d0un0"},{"post_id":"cka8ephhb002xt8pl7scmj30r","category_id":"cka8ephi4003nt8plan6o0prd","_id":"cka8ephk70050t8pl944ozuk3"}],"PostTag":[{"post_id":"cka8ephb30002t8pl9ih83xod","tag_id":"cka8ephc10007t8pl5r9dl3tc","_id":"cka8ephcy000et8plhj5y4dux"},{"post_id":"cka8ephbn0004t8pl558v4eai","tag_id":"cka8ephcv000dt8pltm7ix2bm","_id":"cka8ephdd000lt8plvz1g4qjr"},{"post_id":"cka8ephd4000gt8plxd4wqilb","tag_id":"cka8ephcv000dt8pltm7ix2bm","_id":"cka8ephdi000nt8plueo6b280"},{"post_id":"cka8ephc20008t8plgubam41z","tag_id":"cka8ephd9000jt8pla3wbmahx","_id":"cka8ephdp000tt8pl2mbwtps5"},{"post_id":"cka8ephcd000at8plsaydsupj","tag_id":"cka8ephdk000qt8pluj31nesa","_id":"cka8ephdw000zt8plv8qa7nao"},{"post_id":"cka8ephck000bt8pl2iuoezo3","tag_id":"cka8ephdu000xt8pl38j7bp1g","_id":"cka8ephe60015t8plyy7xbat7"},{"post_id":"cka8ephcz000ft8pl24xzf93f","tag_id":"cka8ephe30014t8plneq7tcxi","_id":"cka8ephen001ct8plu3b2rlnc"},{"post_id":"cka8ephdb000kt8plvisqu77f","tag_id":"cka8epheh001at8pli9a6gfkd","_id":"cka8epheu001it8plje7isccv"},{"post_id":"cka8ephdf000mt8plzdw2a1pc","tag_id":"cka8epher001gt8plifszqdgu","_id":"cka8ephf9001ot8plp8vhj8zz"},{"post_id":"cka8ephdm000rt8plr1zt4kn8","tag_id":"cka8epher001gt8plifszqdgu","_id":"cka8ephfj001ut8plaxrkg560"},{"post_id":"cka8ephdq000ut8plqcwxcigh","tag_id":"cka8epher001gt8plifszqdgu","_id":"cka8ephfs0020t8pls9cgmkcj"},{"post_id":"cka8ephdu000yt8pl7mr6b2lj","tag_id":"cka8ephfo001yt8pl4u46kipx","_id":"cka8ephg40026t8plek4zqobd"},{"post_id":"cka8ephdx0010t8plxhl82k1d","tag_id":"cka8ephfo001yt8pl4u46kipx","_id":"cka8ephgc002ct8plha967x2q"},{"post_id":"cka8ephdz0012t8plgf4czlz3","tag_id":"cka8ephga002bt8plqp5hyheh","_id":"cka8ephgo002jt8plhvc57157"},{"post_id":"cka8ephe70016t8pldz4y6skc","tag_id":"cka8ephgl002ht8pl2pvtivqn","_id":"cka8ephgz002qt8pl0oyv3033"},{"post_id":"cka8ephed0017t8plfffldjgh","tag_id":"cka8ephga002bt8plqp5hyheh","_id":"cka8ephh9002wt8pl21afjcie"},{"post_id":"cka8ephek001bt8pltwi7ob2q","tag_id":"cka8ephga002bt8plqp5hyheh","_id":"cka8ephhj0031t8plg2bzonfb"},{"post_id":"cka8epheo001dt8plv6rpsqte","tag_id":"cka8ephga002bt8plqp5hyheh","_id":"cka8ephhm0036t8plq4edw45l"},{"post_id":"cka8ephes001ht8plrshu3hn4","tag_id":"cka8ephhl0034t8plyr7dwtvx","_id":"cka8ephhp003at8plwd7duiht"},{"post_id":"cka8ephev001jt8pld32fzlt4","tag_id":"cka8ephho0039t8pl5y7wold6","_id":"cka8ephhv003et8pl58v0nll2"},{"post_id":"cka8ephf1001nt8pl8ijkhrqd","tag_id":"cka8ephht003dt8pljocw3est","_id":"cka8ephi0003it8pl7pwp1s6z"},{"post_id":"cka8ephfa001pt8pl9lzm89al","tag_id":"cka8ephhl0034t8plyr7dwtvx","_id":"cka8ephi4003mt8plg3f2q8xp"},{"post_id":"cka8ephfe001tt8plmtyukint","tag_id":"cka8ephga002bt8plqp5hyheh","_id":"cka8ephid003qt8pl9glvqqg1"},{"post_id":"cka8ephfk001vt8pl5va2i3xy","tag_id":"cka8ephib003pt8pl6s6crbbx","_id":"cka8ephii003ut8pl48je9mzn"},{"post_id":"cka8ephfp001zt8plr6kb09rp","tag_id":"cka8ephih003tt8pl5xszf14z","_id":"cka8ephin003zt8plnpktated"},{"post_id":"cka8ephfu0021t8pl6i9oanlj","tag_id":"cka8ephil003xt8plu3y01drv","_id":"cka8ephiv0044t8pl5k10ratw"},{"post_id":"cka8ephfz0024t8ple85uc2uc","tag_id":"cka8ephir0041t8plnl6tl7gg","_id":"cka8ephj70048t8pl2odeef2m"},{"post_id":"cka8ephg50027t8plqxez0dqn","tag_id":"cka8ephiy0045t8plk02oe9ne","_id":"cka8ephjf004ct8pl1kenihkl"},{"post_id":"cka8ephg9002at8plb17f3da8","tag_id":"cka8ephjc0049t8plbbiaxtpj","_id":"cka8ephji004gt8pl13rlubxx"},{"post_id":"cka8ephgc002dt8pl6eirnbnw","tag_id":"cka8ephjg004dt8plkyan337d","_id":"cka8ephjn004kt8plvoiigru5"},{"post_id":"cka8ephgh002ft8pl40tbdy3q","tag_id":"cka8ephil003xt8plu3y01drv","_id":"cka8ephjs004ot8pl5q0a2c08"},{"post_id":"cka8ephgm002it8pldfjfmmzf","tag_id":"cka8ephjp004lt8plaounn7ju","_id":"cka8ephjw004st8plpz97f9l6"},{"post_id":"cka8ephgp002kt8plh1z8mplo","tag_id":"cka8ephju004qt8pljrlaceqo","_id":"cka8ephk1004wt8pl5tlrycs1"},{"post_id":"cka8ephgw002ot8plgunjaasz","tag_id":"cka8ephjz004vt8pl1f6ipw3k","_id":"cka8ephk6004zt8plrgpx8m95"},{"post_id":"cka8ephh0002rt8plu4k6ec4c","tag_id":"cka8ephk4004yt8plhp2h8db5","_id":"cka8ephk90052t8pluox1ojna"},{"post_id":"cka8ephh6002vt8pl6j39obbu","tag_id":"cka8ephk80051t8plytz8xpt2","_id":"cka8ephkb0054t8plcoaibrbs"},{"post_id":"cka8ephhb002xt8pl7scmj30r","tag_id":"cka8ephka0053t8pld6cu7bc7","_id":"cka8ephkd0055t8pl3fnwo0nm"}],"Tag":[{"name":"C++","_id":"cka8ephc10007t8pl5r9dl3tc"},{"name":"深度学习论文","_id":"cka8ephcv000dt8pltm7ix2bm"},{"name":"向上转型&向下转型","_id":"cka8ephd9000jt8pla3wbmahx"},{"name":"布隆过滤器","_id":"cka8ephdk000qt8pluj31nesa"},{"name":"XGBoost","_id":"cka8ephdu000xt8pl38j7bp1g"},{"name":"git","_id":"cka8ephe30014t8plneq7tcxi"},{"name":"Java集合","_id":"cka8epheh001at8pli9a6gfkd"},{"name":"mysql-必知必会系列","_id":"cka8epher001gt8plifszqdgu"},{"name":"数据库索引","_id":"cka8ephfo001yt8pl4u46kipx"},{"name":"pandas","_id":"cka8ephga002bt8plqp5hyheh"},{"name":"pandas-MultiIndex","_id":"cka8ephgl002ht8pl2pvtivqn"},{"name":"redis","_id":"cka8ephhl0034t8plyr7dwtvx"},{"name":"redis, jedis","_id":"cka8ephho0039t8pl5y7wold6"},{"name":"redis, 缓存雪崩， 缓存穿透， 缓存击穿","_id":"cka8ephht003dt8pljocw3est"},{"name":"ID3","_id":"cka8ephib003pt8pl6s6crbbx"},{"name":"CART树","_id":"cka8ephih003tt8pl5xszf14z"},{"name":"闲聊","_id":"cka8ephil003xt8plu3y01drv"},{"name":"方差与偏差","_id":"cka8ephir0041t8plnl6tl7gg"},{"name":"决策树","_id":"cka8ephiy0045t8plk02oe9ne"},{"name":"华为软挑初赛","_id":"cka8ephjc0049t8plbbiaxtpj"},{"name":"蓄水池抽样算法 海量数据随机采样","_id":"cka8ephjg004dt8plkyan337d"},{"name":"Java类加载机制","_id":"cka8ephjp004lt8plaounn7ju"},{"name":"ROC","_id":"cka8ephju004qt8pljrlaceqo"},{"name":"学习笔记","_id":"cka8ephjz004vt8pl1f6ipw3k"},{"name":"集成学习","_id":"cka8ephk4004yt8plhp2h8db5"},{"name":"版本控制","_id":"cka8ephk80051t8plytz8xpt2"},{"name":"逻辑回归","_id":"cka8ephka0053t8pld6cu7bc7"}]}}