---
title: 虚拟机类加载机制
date: 2019-04-14 14:11:58
categories: 深入理解Java 虚拟机
tags: Java类加载机制
copyright: True
password:
top: True
---


# 虚拟机类加载机制

## 绑定
> 绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来。

- 静态绑定

	

> 前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现java当中的方法只有`final，static，private和构造方法` 是前期绑定的。

- 动态绑定

	

> 运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。




## 类加载机制
 

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：**加载、验证、准备、解析、初始化、使用和卸载** 七个阶段，前五个阶段属于类加载的过程。这是开始顺序，每个阶段可能交错。



### step1：加载

#### 加载阶段，虚拟机完成的任务：

- 通过一个类的全限定名来获取起定义的二进制字节流。

> 二进制字节流来源： Class文件，Jar包、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等；


- 将该字节流的静态存储结构转换为方法区的运行时数据结构。


- 在Java堆中声称一个代表这个类的 java.lang.Class对象，作为对方法区中这些对象的入口。

#### 三种主要的类加载器？

>  类加载机制采用了委托模式。 类加载器与类本身一同确定这个类在Java 虚拟机中的唯一性。

1. 启动类加载器 *Bootstrap ClassLoader*

> 该加载器由C++实现，不属于类，负责加载 ` /JDK/JRE/lib/rt.jar`，主要加载 JVM 工作需要的类；
 
2. 扩展类加载器 *Extension ClassLoader*
> Bootstrp loader 加载 ExtClassLoader,
	该加载器由sun.misc.Launcher$ExtClassLoader 实现，它负责加载`/JDK\JRE\lib\ext目录中的类，自己的类打包jar放入也可以；
3. 应用程序类加载器 *Application ClassLoader*
> Bootstrp loader加载完ExtClassLoader后，就会加载AppClassLoader,并且将AppClassLoader的父加载器指定为 ExtClassLoader， 负责加载classpath所指定的位置的类。

4. 自定义类加载器

> 如果要自定义类加载器，需要继承 `应用程序类加载器`

#### 三者如何协调工作？

类加载机制采用了委托模式。启动类加载器加载其他类加载器，当需要加载类时，**优先父类加载器工作**。

>   双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。


### step2：验证

#### 验证的目的？

保证`class 文件`的字节流符号JVM 虚拟机的要求，不危害虚拟机自身安全。虽然 Java 源码编译不会产生如数组越界之类的错误，但`class 文件`可以被编辑。

#### 都需要哪些验证？

- 文件格式验证

> **验证字节流是否符合 `class文件规范`**（如开头是否为魔数`0xCAFEBABE`， 主次版本号是否可以被当前虚拟机处理等）


- 元数据验证

> ** 验证字节码描述的信息是否符合Java 语言规范**（如类的继承实现是否符合语法规范）
- 字节码验证

> 该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。


- 符号引用验证

> 发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。

### step3： 准备

 准备阶段是正式为**类变量**（静态变量）分配内存并设置类变量初始值的阶段，**这些内存都将在方法区中分配**。注意的是：

1. 只为类变量分配内存；


2. static 类变量初始值为默认初始值，而不是程序中的值；


	public static int value = 3；  // 实际初始值为0
3. 同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值；

    public static final int value = 3；  // 实际初始值为3


### step4： 解析

> 解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。


>  解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。


### step5： 初始化

> 真正开始执行类中定义的Java程序代码,初始化阶段是执行类构造器<clinit>()方法的过程。

类构造器 `<clinit>()` 执行规则：

1. 按照在源文件中出现的顺序收集`类变量` 和 ` 静态语句块 static{ }`;
2. 静态语句块中只能访问定义在之前的变量，而在块后定义的变量只能被赋值，但不能被访问；
3. 优先构造父类；
4. 父类中的 ` 静态语句块 static{ }` 优先于子类中的变量赋值操作；
5. 不是必须的，当类或者接口中没有静态语句块或者没有变量赋值，则可以不生成`<clinit>()`；


## 双亲委派被破坏 3种情况下

- 第一次： JDK1.2之前还没有双亲委派，但是有用户自定义类加载器（通过`loadClass（）`加载），为了兼容老版本，设计者添加了 ` protected findClass()`，直接调用用户`loadClass（）`方法；


- 第二次：原则上 **越基础的类由越上层的加载器进行加载**,但是有些情况下基础类需要调用用户的代码。如**JNDI, JDBC，JCE,JAXB，JBI**,这时候引入了`线程上下文加载器`；

- 第三次：“代码热替换”和“模块热部署”出现，希望程序中的功能模块像键盘鼠标一样直接更换，而不是重启。**OSGi** 是这个标准化模块，具体还没看。。。
